# Bundle 9

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneLocalDayParser.d.cts

~~~cts
import type { Match } from "../../../locale/types.js";
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult, ParserOptions } from "../types.js";
export declare class StandAloneLocalDayParser extends Parser<number> {
  priority: number;
  parse(
    dateString: string,
    token: string,
    match: Match,
    options: ParserOptions,
  ): ParseResult<number>;
  validate<DateType extends Date>(_date: DateType, value: number): boolean;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
    options: ParserOptions,
  ): DateType;
  incompatibleTokens: string[];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneLocalDayParser.d.ts

~~~ts
import type { Match } from "../../../locale/types.js";
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult, ParserOptions } from "../types.js";
export declare class StandAloneLocalDayParser extends Parser<number> {
  priority: number;
  parse(
    dateString: string,
    token: string,
    match: Match,
    options: ParserOptions,
  ): ParseResult<number>;
  validate<DateType extends Date>(_date: DateType, value: number): boolean;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
    options: ParserOptions,
  ): DateType;
  incompatibleTokens: string[];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneLocalDayParser.js

~~~js
import { setDay } from "../../../setDay.js";
import { Parser } from "../Parser.js";

import { mapValue, parseNDigits } from "../utils.js";

// Stand-alone local day of week
export class StandAloneLocalDayParser extends Parser {
  priority = 90;

  parse(dateString, token, match, options) {
    const valueCallback = (value) => {
      // We want here floor instead of trunc, so we get -7 for value 0 instead of 0
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (
        ((value + options.weekStartsOn + 6 /* move sun -> sat */ + 1) % 7) +
        wholeWeekDays
      );
    };

    switch (token) {
      // 3
      case "c":
      case "cc": // 03
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      // 3rd
      case "co":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "day",
          }),
          valueCallback,
        );
      // Tue
      case "ccc":
        return (
          match.day(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );

      // T
      case "ccccc":
        return match.day(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // Tu
      case "cccccc":
        return (
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );

      // Tuesday
      case "cccc":
      default:
        return (
          match.day(dateString, { width: "wide", context: "standalone" }) ||
          match.day(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.day(dateString, { width: "short", context: "standalone" }) ||
          match.day(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 6;
  }

  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "y",
    "R",
    "u",
    "q",
    "Q",
    "M",
    "L",
    "I",
    "d",
    "D",
    "E",
    "i",
    "e",
    "t",
    "T",
  ];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneMonthParser.cjs

~~~cjs
"use strict";
exports.StandAloneMonthParser = void 0;
var _constants = require("../constants.cjs");
var _Parser = require("../Parser.cjs");

var _utils = require("../utils.cjs");

var _index = require("../../../_core/setMonth.cjs");

class StandAloneMonthParser extends _Parser.Parser {
  priority = 110;

  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;

    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return (0, _utils.mapValue)(
          (0, _utils.parseNumericPattern)(
            _constants.numericPatterns.month,
            dateString,
          ),
          valueCallback,
        );
      // 01, 02, ..., 12
      case "LL":
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(2, dateString),
          valueCallback,
        );
      // 1st, 2nd, ..., 12th
      case "Lo":
        return (0, _utils.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "month",
          }),
          valueCallback,
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return (
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );

      // J, F, ..., D
      case "LLLLL":
        return match.month(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return (
          match.month(dateString, { width: "wide", context: "standalone" }) ||
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    (0, _index.setMonth)(date, value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.StandAloneMonthParser = StandAloneMonthParser;

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneMonthParser.d.cts

~~~cts
import type { Match } from "../../../locale/types.js";
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export declare class StandAloneMonthParser extends Parser<number> {
  priority: number;
  parse(dateString: string, token: string, match: Match): ParseResult<number>;
  validate<DateType extends Date>(_date: DateType, value: number): boolean;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
  ): DateType;
  incompatibleTokens: string[];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneMonthParser.d.ts

~~~ts
import type { Match } from "../../../locale/types.js";
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export declare class StandAloneMonthParser extends Parser<number> {
  priority: number;
  parse(dateString: string, token: string, match: Match): ParseResult<number>;
  validate<DateType extends Date>(_date: DateType, value: number): boolean;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
  ): DateType;
  incompatibleTokens: string[];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneMonthParser.js

~~~js
import { numericPatterns } from "../constants.js";
import { Parser } from "../Parser.js";

import { mapValue, parseNDigits, parseNumericPattern } from "../utils.js";

import { setMonth as coreSetMonth } from "../../../_core/setMonth.js";

export class StandAloneMonthParser extends Parser {
  priority = 110;

  parse(dateString, token, match) {
    const valueCallback = (value) => value - 1;

    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback,
        );
      // 01, 02, ..., 12
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "month",
          }),
          valueCallback,
        );
      // Jan, Feb, ..., Dec
      case "LLL":
        return (
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );

      // J, F, ..., D
      case "LLLLL":
        return match.month(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return (
          match.month(dateString, { width: "wide", context: "standalone" }) ||
          match.month(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.month(dateString, { width: "narrow", context: "standalone" })
        );
    }
  }

  validate(_date, value) {
    return value >= 0 && value <= 11;
  }

  set(date, _flags, value) {
    coreSetMonth(date, value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "q",
    "Q",
    "M",
    "w",
    "I",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneQuarterParser.cjs

~~~cjs
"use strict";
exports.StandAloneQuarterParser = void 0;
var _Parser = require("../Parser.cjs");

var _utils = require("../utils.cjs");

var _index = require("../../../_core/setMonth.cjs");

class StandAloneQuarterParser extends _Parser.Parser {
  priority = 120;

  parse(dateString, token, match) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq": // 01, 02, 03, 04
        return (0, _utils.parseNDigits)(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return (
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );

      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match.quarter(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return (
          match.quarter(dateString, {
            width: "wide",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 4;
  }

  set(date, _flags, value) {
    (0, _index.setMonth)(date, (value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}
exports.StandAloneQuarterParser = StandAloneQuarterParser;

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneQuarterParser.d.cts

~~~cts
import type { Match } from "../../../locale/types.js";
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export declare class StandAloneQuarterParser extends Parser<number> {
  priority: number;
  parse(dateString: string, token: string, match: Match): ParseResult<number>;
  validate<DateType extends Date>(_date: DateType, value: number): boolean;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
  ): DateType;
  incompatibleTokens: string[];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneQuarterParser.d.ts

~~~ts
import type { Match } from "../../../locale/types.js";
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export declare class StandAloneQuarterParser extends Parser<number> {
  priority: number;
  parse(dateString: string, token: string, match: Match): ParseResult<number>;
  validate<DateType extends Date>(_date: DateType, value: number): boolean;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
  ): DateType;
  incompatibleTokens: string[];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\StandAloneQuarterParser.js

~~~js
import { Parser } from "../Parser.js";

import { parseNDigits } from "../utils.js";

import { setMonth as coreSetMonth } from "../../../_core/setMonth.js";

export class StandAloneQuarterParser extends Parser {
  priority = 120;

  parse(dateString, token, match) {
    switch (token) {
      // 1, 2, 3, 4
      case "q":
      case "qq": // 01, 02, 03, 04
        return parseNDigits(token.length, dateString);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return match.ordinalNumber(dateString, { unit: "quarter" });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return (
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );

      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return match.quarter(dateString, {
          width: "narrow",
          context: "standalone",
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return (
          match.quarter(dateString, {
            width: "wide",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "abbreviated",
            context: "standalone",
          }) ||
          match.quarter(dateString, {
            width: "narrow",
            context: "standalone",
          })
        );
    }
  }

  validate(_date, value) {
    return value >= 1 && value <= 4;
  }

  set(date, _flags, value) {
    coreSetMonth(date, (value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  incompatibleTokens = [
    "Y",
    "R",
    "Q",
    "M",
    "L",
    "w",
    "I",
    "d",
    "D",
    "i",
    "e",
    "c",
    "t",
    "T",
  ];
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\TimestampMillisecondsParser.cjs

~~~cjs
"use strict";
exports.TimestampMillisecondsParser = void 0;
var _index = require("../../../constructFrom.cjs");
var _Parser = require("../Parser.cjs");

var _utils = require("../utils.cjs");

class TimestampMillisecondsParser extends _Parser.Parser {
  priority = 20;

  parse(dateString) {
    return (0, _utils.parseAnyDigitsSigned)(dateString);
  }

  set(date, _flags, value) {
    return [(0, _index.constructFrom)(date, value), { timestampIsSet: true }];
  }

  incompatibleTokens = "*";
}
exports.TimestampMillisecondsParser = TimestampMillisecondsParser;

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\TimestampMillisecondsParser.d.cts

~~~cts
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export declare class TimestampMillisecondsParser extends Parser<number> {
  priority: number;
  parse(dateString: string): ParseResult<number>;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
  ): [DateType, ParseFlags];
  incompatibleTokens: "*";
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\TimestampMillisecondsParser.d.ts

~~~ts
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export declare class TimestampMillisecondsParser extends Parser<number> {
  priority: number;
  parse(dateString: string): ParseResult<number>;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
  ): [DateType, ParseFlags];
  incompatibleTokens: "*";
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\TimestampMillisecondsParser.js

~~~js
import { constructFrom } from "../../../constructFrom.js";
import { Parser } from "../Parser.js";

import { parseAnyDigitsSigned } from "../utils.js";

export class TimestampMillisecondsParser extends Parser {
  priority = 20;

  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }

  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }

  incompatibleTokens = "*";
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\TimestampSecondsParser.cjs

~~~cjs
"use strict";
exports.TimestampSecondsParser = void 0;
var _index = require("../../../constructFrom.cjs");
var _Parser = require("../Parser.cjs");

var _utils = require("../utils.cjs");

class TimestampSecondsParser extends _Parser.Parser {
  priority = 40;

  parse(dateString) {
    return (0, _utils.parseAnyDigitsSigned)(dateString);
  }

  set(date, _flags, value) {
    return [
      (0, _index.constructFrom)(date, value * 1000),
      { timestampIsSet: true },
    ];
  }

  incompatibleTokens = "*";
}
exports.TimestampSecondsParser = TimestampSecondsParser;

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\TimestampSecondsParser.d.cts

~~~cts
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export declare class TimestampSecondsParser extends Parser<number> {
  priority: number;
  parse(dateString: string): ParseResult<number>;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
  ): [DateType, ParseFlags];
  incompatibleTokens: "*";
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\TimestampSecondsParser.d.ts

~~~ts
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export declare class TimestampSecondsParser extends Parser<number> {
  priority: number;
  parse(dateString: string): ParseResult<number>;
  set<DateType extends Date>(
    date: DateType,
    _flags: ParseFlags,
    value: number,
  ): [DateType, ParseFlags];
  incompatibleTokens: "*";
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\TimestampSecondsParser.js

~~~js
import { constructFrom } from "../../../constructFrom.js";
import { Parser } from "../Parser.js";

import { parseAnyDigitsSigned } from "../utils.js";

export class TimestampSecondsParser extends Parser {
  priority = 40;

  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }

  set(date, _flags, value) {
    return [constructFrom(date, value * 1000), { timestampIsSet: true }];
  }

  incompatibleTokens = "*";
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\YearParser.cjs

~~~cjs
"use strict";
exports.YearParser = void 0;
var _Parser = require("../Parser.cjs");

var _utils = require("../utils.cjs");

var _index = require("../../../_core/getFullYear.cjs");
var _index2 = require("../../../_core/setFullYear.cjs");

// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
class YearParser extends _Parser.Parser {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];

  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy",
    });

    switch (token) {
      case "y":
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(4, dateString),
          valueCallback,
        );
      case "yo":
        return (0, _utils.mapValue)(
          match.ordinalNumber(dateString, {
            unit: "year",
          }),
          valueCallback,
        );
      default:
        return (0, _utils.mapValue)(
          (0, _utils.parseNDigits)(token.length, dateString),
          valueCallback,
        );
    }
  }

  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }

  set(date, flags, value) {
    const currentYear = (0, _index.getFullYear)(date);

    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(
        value.year,
        currentYear,
      );
      (0, _index2.setFullYear)(date, normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    const year =
      !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    (0, _index2.setFullYear)(date, year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}
exports.YearParser = YearParser;

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\YearParser.d.cts

~~~cts
import type { Match } from "../../../locale/types.js";
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export interface YearParserValue {
  year: number;
  isTwoDigitYear: boolean;
}
export declare class YearParser extends Parser<YearParserValue> {
  priority: number;
  incompatibleTokens: string[];
  parse(
    dateString: string,
    token: string,
    match: Match,
  ): ParseResult<YearParserValue>;
  validate<DateType extends Date>(
    _date: DateType,
    value: YearParserValue,
  ): boolean;
  set<DateType extends Date>(
    date: DateType,
    flags: ParseFlags,
    value: YearParserValue,
  ): DateType;
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\YearParser.d.ts

~~~ts
import type { Match } from "../../../locale/types.js";
import { Parser } from "../Parser.js";
import type { ParseFlags, ParseResult } from "../types.js";
export interface YearParserValue {
  year: number;
  isTwoDigitYear: boolean;
}
export declare class YearParser extends Parser<YearParserValue> {
  priority: number;
  incompatibleTokens: string[];
  parse(
    dateString: string,
    token: string,
    match: Match,
  ): ParseResult<YearParserValue>;
  validate<DateType extends Date>(
    _date: DateType,
    value: YearParserValue,
  ): boolean;
  set<DateType extends Date>(
    date: DateType,
    flags: ParseFlags,
    value: YearParserValue,
  ): DateType;
}

~~~

## node_modules\date-fns-jalali\parse\_lib\parsers\YearParser.js

~~~js
import { Parser } from "../Parser.js";

import { mapValue, normalizeTwoDigitYear, parseNDigits } from "../utils.js";

import { getFullYear as coreGetFullYear } from "../../../_core/getFullYear.js";
import { setFullYear as coreSetFullYear } from "../../../_core/setFullYear.js";

// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
export class YearParser extends Parser {
  priority = 130;
  incompatibleTokens = ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"];

  parse(dateString, token, match) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy",
    });

    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match.ordinalNumber(dateString, {
            unit: "year",
          }),
          valueCallback,
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }

  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }

  set(date, flags, value) {
    const currentYear = coreGetFullYear(date);

    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear,
      );
      coreSetFullYear(date, normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    const year =
      !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    coreSetFullYear(date, year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
}

~~~

## node_modules\date-fns-jalali\parse\_lib\Setter.cjs

~~~cjs
"use strict";
exports.ValueSetter = exports.Setter = exports.DateTimezoneSetter = void 0;
var _index = require("../../constructFrom.cjs");
var _index2 = require("../../transpose.cjs");

const TIMEZONE_UNIT_PRIORITY = 10;

class Setter {
  subPriority = 0;

  validate(_utcDate, _options) {
    return true;
  }
}
exports.Setter = Setter;

class ValueSetter extends Setter {
  constructor(
    value,

    validateValue,

    setValue,

    priority,
    subPriority,
  ) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }

  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }

  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
}
exports.ValueSetter = ValueSetter;

class DateTimezoneSetter extends Setter {
  priority = TIMEZONE_UNIT_PRIORITY;
  subPriority = -1;

  constructor(context, reference) {
    super();
    this.context =
      context || ((date) => (0, _index.constructFrom)(reference, date));
  }

  set(date, flags) {
    if (flags.timestampIsSet) return date;
    return (0, _index.constructFrom)(
      date,
      (0, _index2.transpose)(date, this.context),
    );
  }
}
exports.DateTimezoneSetter = DateTimezoneSetter;

~~~

## node_modules\date-fns-jalali\parse\_lib\Setter.d.cts

~~~cts
import type { ContextFn, DateArg } from "../../types.js";
import type { ParseFlags, ParserOptions } from "./types.js";
export declare abstract class Setter {
  abstract priority: number;
  subPriority: number;
  validate<DateType extends Date>(
    _utcDate: DateType,
    _options?: ParserOptions,
  ): boolean;
  abstract set<DateType extends Date>(
    date: DateType,
    flags: ParseFlags,
    options: ParserOptions,
  ): DateType | [DateType, ParseFlags];
}
export declare class ValueSetter<Value> extends Setter {
  private value;
  private validateValue;
  private setValue;
  priority: number;
  constructor(
    value: Value,
    validateValue: <DateType extends Date>(
      date: DateType,
      value: Value,
      options: ParserOptions,
    ) => boolean,
    setValue: <DateType extends Date>(
      date: DateType,
      flags: ParseFlags,
      value: Value,
      options: ParserOptions,
    ) => DateType | [DateType, ParseFlags],
    priority: number,
    subPriority?: number,
  );
  validate<DateType extends Date>(
    date: DateType,
    options: ParserOptions,
  ): boolean;
  set<DateType extends Date>(
    date: DateType,
    flags: ParseFlags,
    options: ParserOptions,
  ): DateType | [DateType, ParseFlags];
}
export declare class DateTimezoneSetter extends Setter {
  priority: number;
  subPriority: number;
  context: ContextFn<Date>;
  constructor(
    context: ContextFn<Date> | undefined,
    reference: DateArg<Date> & {},
  );
  set<DateType extends Date>(date: DateType, flags: ParseFlags): DateType;
}

~~~

## node_modules\date-fns-jalali\parse\_lib\Setter.d.ts

~~~ts
import type { ContextFn, DateArg } from "../../types.js";
import type { ParseFlags, ParserOptions } from "./types.js";
export declare abstract class Setter {
  abstract priority: number;
  subPriority: number;
  validate<DateType extends Date>(
    _utcDate: DateType,
    _options?: ParserOptions,
  ): boolean;
  abstract set<DateType extends Date>(
    date: DateType,
    flags: ParseFlags,
    options: ParserOptions,
  ): DateType | [DateType, ParseFlags];
}
export declare class ValueSetter<Value> extends Setter {
  private value;
  private validateValue;
  private setValue;
  priority: number;
  constructor(
    value: Value,
    validateValue: <DateType extends Date>(
      date: DateType,
      value: Value,
      options: ParserOptions,
    ) => boolean,
    setValue: <DateType extends Date>(
      date: DateType,
      flags: ParseFlags,
      value: Value,
      options: ParserOptions,
    ) => DateType | [DateType, ParseFlags],
    priority: number,
    subPriority?: number,
  );
  validate<DateType extends Date>(
    date: DateType,
    options: ParserOptions,
  ): boolean;
  set<DateType extends Date>(
    date: DateType,
    flags: ParseFlags,
    options: ParserOptions,
  ): DateType | [DateType, ParseFlags];
}
export declare class DateTimezoneSetter extends Setter {
  priority: number;
  subPriority: number;
  context: ContextFn<Date>;
  constructor(
    context: ContextFn<Date> | undefined,
    reference: DateArg<Date> & {},
  );
  set<DateType extends Date>(date: DateType, flags: ParseFlags): DateType;
}

~~~

## node_modules\date-fns-jalali\parse\_lib\Setter.js

~~~js
import { constructFrom } from "../../constructFrom.js";
import { transpose } from "../../transpose.js";

const TIMEZONE_UNIT_PRIORITY = 10;

export class Setter {
  subPriority = 0;

  validate(_utcDate, _options) {
    return true;
  }
}

export class ValueSetter extends Setter {
  constructor(
    value,

    validateValue,

    setValue,

    priority,
    subPriority,
  ) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }

  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }

  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
}

export class DateTimezoneSetter extends Setter {
  priority = TIMEZONE_UNIT_PRIORITY;
  subPriority = -1;

  constructor(context, reference) {
    super();
    this.context = context || ((date) => constructFrom(reference, date));
  }

  set(date, flags) {
    if (flags.timestampIsSet) return date;
    return constructFrom(date, transpose(date, this.context));
  }
}

~~~

## node_modules\date-fns-jalali\parse\_lib\types.cjs

~~~cjs
"use strict";

~~~

## node_modules\date-fns-jalali\parse\_lib\types.d.cts

~~~cts
import type {
  LocalizedOptions,
  FirstWeekContainsDateOptions,
  WeekOptions,
} from "../../types.js";
export interface ParseFlags {
  timestampIsSet?: boolean;
  era?: number;
}
export type ParserOptions = Required<
  LocalizedOptions<"options"> & FirstWeekContainsDateOptions & WeekOptions
>;
export type ParseResult<TValue> = {
  value: TValue;
  rest: string;
} | null;

~~~

## node_modules\date-fns-jalali\parse\_lib\types.d.ts

~~~ts
import type {
  LocalizedOptions,
  FirstWeekContainsDateOptions,
  WeekOptions,
} from "../../types.js";
export interface ParseFlags {
  timestampIsSet?: boolean;
  era?: number;
}
export type ParserOptions = Required<
  LocalizedOptions<"options"> & FirstWeekContainsDateOptions & WeekOptions
>;
export type ParseResult<TValue> = {
  value: TValue;
  rest: string;
} | null;

~~~

## node_modules\date-fns-jalali\parse\_lib\types.js

~~~js
export {};

~~~

## node_modules\date-fns-jalali\parse\_lib\utils.cjs

~~~cjs
"use strict";
exports.dayPeriodEnumToHours = dayPeriodEnumToHours;
exports.isLeapYearIndex = isLeapYearIndex;
exports.mapValue = mapValue;
exports.normalizeTwoDigitYear = normalizeTwoDigitYear;
exports.parseAnyDigitsSigned = parseAnyDigitsSigned;
exports.parseNDigits = parseNDigits;
exports.parseNDigitsSigned = parseNDigitsSigned;
exports.parseNumericPattern = parseNumericPattern;
exports.parseTimezonePattern = parseTimezonePattern;
var _index = require("../../constants.cjs");

var _constants = require("./constants.cjs");
var _index2 = require("../../isLeapYear.cjs");
var _index3 = require("../../_core/newDate.cjs");

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest,
  };
}

function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length),
  };
}

function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  // Input is 'Z'
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1),
    };
  }

  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;

  return {
    value:
      sign *
      (hours * _index.millisecondsInHour +
        minutes * _index.millisecondsInMinute +
        seconds * _index.millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length),
  };
}

function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(
    _constants.numericPatterns.anyDigitsSigned,
    dateString,
  );
}

function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(
        _constants.numericPatterns.singleDigit,
        dateString,
      );
    case 2:
      return parseNumericPattern(
        _constants.numericPatterns.twoDigits,
        dateString,
      );
    case 3:
      return parseNumericPattern(
        _constants.numericPatterns.threeDigits,
        dateString,
      );
    case 4:
      return parseNumericPattern(
        _constants.numericPatterns.fourDigits,
        dateString,
      );
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}

function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(
        _constants.numericPatterns.singleDigitSigned,
        dateString,
      );
    case 2:
      return parseNumericPattern(
        _constants.numericPatterns.twoDigitsSigned,
        dateString,
      );
    case 3:
      return parseNumericPattern(
        _constants.numericPatterns.threeDigitsSigned,
        dateString,
      );
    case 4:
      return parseNumericPattern(
        _constants.numericPatterns.fourDigitsSigned,
        dateString,
      );
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}

function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}

function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;

  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

function isLeapYearIndex(year) {
  return (0, _index2.isLeapYear)((0, _index3.newDate)(year, 0));
}

~~~

## node_modules\date-fns-jalali\parse\_lib\utils.d.cts

~~~cts
import type { LocaleDayPeriod } from "../../locale/types.js";
import type { ParseResult } from "./types.js";
export declare function mapValue<TInput, TResult>(
  parseFnResult: ParseResult<TInput>,
  mapFn: (value: TInput) => TResult,
): ParseResult<TResult>;
export declare function parseNumericPattern(
  pattern: RegExp,
  dateString: string,
): ParseResult<number>;
export declare function parseTimezonePattern(
  pattern: RegExp,
  dateString: string,
): ParseResult<number>;
export declare function parseAnyDigitsSigned(
  dateString: string,
): ParseResult<number>;
export declare function parseNDigits(
  n: number,
  dateString: string,
): ParseResult<number>;
export declare function parseNDigitsSigned(
  n: number,
  dateString: string,
): ParseResult<number>;
export declare function dayPeriodEnumToHours(
  dayPeriod: LocaleDayPeriod,
): number;
export declare function normalizeTwoDigitYear(
  twoDigitYear: number,
  currentYear: number,
): number;
export declare function isLeapYearIndex(year: number): boolean;

~~~

## node_modules\date-fns-jalali\parse\_lib\utils.d.ts

~~~ts
import type { LocaleDayPeriod } from "../../locale/types.js";
import type { ParseResult } from "./types.js";
export declare function mapValue<TInput, TResult>(
  parseFnResult: ParseResult<TInput>,
  mapFn: (value: TInput) => TResult,
): ParseResult<TResult>;
export declare function parseNumericPattern(
  pattern: RegExp,
  dateString: string,
): ParseResult<number>;
export declare function parseTimezonePattern(
  pattern: RegExp,
  dateString: string,
): ParseResult<number>;
export declare function parseAnyDigitsSigned(
  dateString: string,
): ParseResult<number>;
export declare function parseNDigits(
  n: number,
  dateString: string,
): ParseResult<number>;
export declare function parseNDigitsSigned(
  n: number,
  dateString: string,
): ParseResult<number>;
export declare function dayPeriodEnumToHours(
  dayPeriod: LocaleDayPeriod,
): number;
export declare function normalizeTwoDigitYear(
  twoDigitYear: number,
  currentYear: number,
): number;
export declare function isLeapYearIndex(year: number): boolean;

~~~

## node_modules\date-fns-jalali\parse\_lib\utils.js

~~~js
import {
  millisecondsInHour,
  millisecondsInMinute,
  millisecondsInSecond,
} from "../../constants.js";

import { numericPatterns } from "./constants.js";
import { isLeapYear } from "../../isLeapYear.js";
import { newDate as coreNewDate } from "../../_core/newDate.js";

export function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest,
  };
}

export function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length),
  };
}

export function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  // Input is 'Z'
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1),
    };
  }

  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;

  return {
    value:
      sign *
      (hours * millisecondsInHour +
        minutes * millisecondsInMinute +
        seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length),
  };
}

export function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}

export function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}

export function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}

export function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}

export function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;

  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}

export function isLeapYearIndex(year) {
  return isLeapYear(coreNewDate(year, 0));
}

~~~

## node_modules\date-fns-jalali\parseISO.cjs

~~~cjs
"use strict";
exports.parseISO = parseISO;
var _index = require("./constants.cjs");

var _index2 = require("./constructFrom.cjs");
var _index3 = require("./toDate.cjs");

/**
 * The {@link parseISO} function options.
 */

/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
function parseISO(argument, options) {
  const invalidDate = () => (0, _index2.constructFrom)(options?.in, NaN);

  const additionalDigits = options?.additionalDigits ?? 2;
  const dateStrings = splitDateString(argument);

  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (!date || isNaN(+date)) return invalidDate();

  const timestamp = +date;
  let time = 0;
  let offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) return invalidDate();
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) return invalidDate();
  } else {
    const tmpDate = new Date(timestamp + time);
    const result = (0, _index3.toDate)(0, options?.in);
    result.setFullYear(
      tmpDate.getUTCFullYear(),
      tmpDate.getUTCMonth(),
      tmpDate.getUTCDate(),
    );
    result.setHours(
      tmpDate.getUTCHours(),
      tmpDate.getUTCMinutes(),
      tmpDate.getUTCSeconds(),
      tmpDate.getUTCMilliseconds(),
    );
    return result;
  }

  return (0, _index3.toDate)(timestamp + time + offset, options?.in);
}

const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/,
};

const dateRegex =
  /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex =
  /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;

function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;

  // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].
  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length,
      );
    }
  }

  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" +
      (4 + additionalDigits) +
      "})|(\\d{2}|[+-]\\d{" +
      (2 + additionalDigits) +
      "})$)",
  );

  const captures = dateString.match(regex);
  // Invalid ISO-formatted year
  if (!captures) return { year: NaN, restDateString: "" };

  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;

  // either year or century is null, not both
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length),
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);

  const captures = dateString.match(dateRegex);
  // Invalid ISO-formatted string
  if (!captures) return new Date(NaN);

  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date = new Date(0);
    if (
      !validateDate(year, month, day) ||
      !validateDayOfYearDate(year, dayOfYear)
    ) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return (
    hours * _index.millisecondsInHour +
    minutes * _index.millisecondsInMinute +
    seconds * 1000
  );
}

function parseTimeUnit(value) {
  return (value && parseFloat(value.replace(",", "."))) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;

  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;

  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = (captures[3] && parseInt(captures[3])) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return (
    sign *
    (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute)
  );
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// Validation functions

// February is null to handle the leap year (using ||)
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

function validateDate(year, month, date) {
  return (
    month >= 0 &&
    month <= 11 &&
    date >= 1 &&
    date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28))
  );
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return (
    seconds >= 0 &&
    seconds < 60 &&
    minutes >= 0 &&
    minutes < 60 &&
    hours >= 0 &&
    hours < 25
  );
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

~~~

## node_modules\date-fns-jalali\parseISO.d.cts

~~~cts
import type { ContextOptions } from "./types.js";
/**
 * The {@link parseISO} function options.
 */
export interface ParseISOOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {
  /** The additional number of digits in the extended year format */
  additionalDigits?: 0 | 1 | 2;
}
/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
export declare function parseISO<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(argument: string, options?: ParseISOOptions<ResultDate>): ResultDate;

~~~

## node_modules\date-fns-jalali\parseISO.d.ts

~~~ts
import type { ContextOptions } from "./types.js";
/**
 * The {@link parseISO} function options.
 */
export interface ParseISOOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {
  /** The additional number of digits in the extended year format */
  additionalDigits?: 0 | 1 | 2;
}
/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
export declare function parseISO<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(argument: string, options?: ParseISOOptions<ResultDate>): ResultDate;

~~~

## node_modules\date-fns-jalali\parseISO.js

~~~js
import {
  millisecondsInHour,
  millisecondsInMinute,
} from "./constants.js";
import { constructFrom } from "./constructFrom.js";
import { toDate } from "./toDate.js";

/**
 * The {@link parseISO} function options.
 */

/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */
export function parseISO(argument, options) {
  const invalidDate = () => constructFrom(options?.in, NaN);

  const additionalDigits = options?.additionalDigits ?? 2;
  const dateStrings = splitDateString(argument);

  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (!date || isNaN(+date)) return invalidDate();

  const timestamp = +date;
  let time = 0;
  let offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) return invalidDate();
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) return invalidDate();
  } else {
    const tmpDate = new Date(timestamp + time);
    const result = toDate(0, options?.in);
    result.setFullYear(
      tmpDate.getUTCFullYear(),
      tmpDate.getUTCMonth(),
      tmpDate.getUTCDate(),
    );
    result.setHours(
      tmpDate.getUTCHours(),
      tmpDate.getUTCMinutes(),
      tmpDate.getUTCSeconds(),
      tmpDate.getUTCMilliseconds(),
    );
    return result;
  }

  return toDate(timestamp + time + offset, options?.in);
}

const patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/,
};

const dateRegex =
  /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
const timeRegex =
  /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;

function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;

  // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].
  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length,
      );
    }
  }

  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  const regex = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" +
      (4 + additionalDigits) +
      "})|(\\d{2}|[+-]\\d{" +
      (2 + additionalDigits) +
      "})$)",
  );

  const captures = dateString.match(regex);
  // Invalid ISO-formatted year
  if (!captures) return { year: NaN, restDateString: "" };

  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;

  // either year or century is null, not both
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length),
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);

  const captures = dateString.match(dateRegex);
  // Invalid ISO-formatted string
  if (!captures) return new Date(NaN);

  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date = new Date(0);
    if (
      !validateDate(year, month, day) ||
      !validateDayOfYearDate(year, dayOfYear)
    ) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return (
    hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000
  );
}

function parseTimeUnit(value) {
  return (value && parseFloat(value.replace(",", "."))) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;

  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;

  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = (captures[3] && parseInt(captures[3])) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

// Validation functions

// February is null to handle the leap year (using ||)
const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
}

function validateDate(year, month, date) {
  return (
    month >= 0 &&
    month <= 11 &&
    date >= 1 &&
    date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28))
  );
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return (
    seconds >= 0 &&
    seconds < 60 &&
    minutes >= 0 &&
    minutes < 60 &&
    hours >= 0 &&
    hours < 25
  );
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

// Fallback for modularized imports:
export default parseISO;

~~~

## node_modules\date-fns-jalali\parseJSON.cjs

~~~cjs
"use strict";
exports.parseJSON = parseJSON;
var _index = require("./toDate.cjs");

/**
 * The {@link parseJSON} function options.
 */

/**
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate](https://date-fns.org/docs/toDate):
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param dateStr - A fully formed ISO8601 date string to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 */
function parseJSON(dateStr, options) {
  const parts = dateStr.match(
    /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/,
  );

  if (!parts) return (0, _index.toDate)(NaN, options?.in);

  return (0, _index.toDate)(
    Date.UTC(
      +parts[1],
      +parts[2] - 1,
      +parts[3],
      +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1),
      +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1),
      +parts[6],
      +((parts[7] || "0") + "00").substring(0, 3),
    ),
    options?.in,
  );
}

~~~

## node_modules\date-fns-jalali\parseJSON.d.cts

~~~cts
import type { ContextOptions } from "./types.js";
/**
 * The {@link parseJSON} function options.
 */
export interface ParseJSONOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate](https://date-fns.org/docs/toDate):
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param dateStr - A fully formed ISO8601 date string to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 */
export declare function parseJSON<ResultDate extends Date = Date>(
  dateStr: string,
  options?: ParseJSONOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\parseJSON.d.ts

~~~ts
import type { ContextOptions } from "./types.js";
/**
 * The {@link parseJSON} function options.
 */
export interface ParseJSONOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate](https://date-fns.org/docs/toDate):
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param dateStr - A fully formed ISO8601 date string to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 */
export declare function parseJSON<ResultDate extends Date = Date>(
  dateStr: string,
  options?: ParseJSONOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\parseJSON.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link parseJSON} function options.
 */

/**
 * Converts a complete ISO date string in UTC time, the typical format for transmitting
 * a date in JSON, to a JavaScript `Date` instance.
 *
 * This is a minimal implementation for converting dates retrieved from a JSON API to
 * a `Date` instance which can be used with other functions in the `date-fns` library.
 * The following formats are supported:
 *
 * - `2000-03-15T05:20:10.123Z`: The output of `.toISOString()` and `JSON.stringify(new Date())`
 * - `2000-03-15T05:20:10Z`: Without milliseconds
 * - `2000-03-15T05:20:10+00:00`: With a zero offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+05:45`: With a positive or negative offset, the default JSON encoded format in some other languages
 * - `2000-03-15T05:20:10+0000`: With a zero offset without a colon
 * - `2000-03-15T05:20:10`: Without a trailing 'Z' symbol
 * - `2000-03-15T05:20:10.1234567`: Up to 7 digits in milliseconds field. Only first 3 are taken into account since JS does not allow fractional milliseconds
 * - `2000-03-15 05:20:10`: With a space instead of a 'T' separator for APIs returning a SQL date without reformatting
 *
 * For convenience and ease of use these other input types are also supported
 * via [toDate](https://date-fns.org/docs/toDate):
 *
 * - A `Date` instance will be cloned
 * - A `number` will be treated as a timestamp
 *
 * Any other input type or invalid date strings will return an `Invalid Date`.
 *
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param dateStr - A fully formed ISO8601 date string to convert
 * @param options - An object with options
 *
 * @returns The parsed date in the local time zone
 */
export function parseJSON(dateStr, options) {
  const parts = dateStr.match(
    /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/,
  );

  if (!parts) return toDate(NaN, options?.in);

  return toDate(
    Date.UTC(
      +parts[1],
      +parts[2] - 1,
      +parts[3],
      +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1),
      +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1),
      +parts[6],
      +((parts[7] || "0") + "00").substring(0, 3),
    ),
    options?.in,
  );
}

// Fallback for modularized imports:
export default parseJSON;

~~~

## node_modules\date-fns-jalali\previousDay.cjs

~~~cjs
"use strict";
exports.previousDay = previousDay;
var _index = require("./getDay.cjs");
var _index2 = require("./subDays.cjs");

/**
 * The {@link previousDay} function options.
 */

/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to check
 * @param day - The day of the week
 * @param options - An object with options
 *
 * @returns The date is the previous day of week
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */
function previousDay(date, day, options) {
  let delta = (0, _index.getDay)(date, options) - day;
  if (delta <= 0) delta += 7;

  return (0, _index2.subDays)(date, delta, options);
}

~~~

## node_modules\date-fns-jalali\previousDay.d.cts

~~~cts
import type { ContextOptions, DateArg, Day } from "./types.js";
/**
 * The {@link previousDay} function options.
 */
export interface PreviousDayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to check
 * @param day - The day of the week
 * @param options - An object with options
 *
 * @returns The date is the previous day of week
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */
export declare function previousDay<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  day: Day,
  options?: PreviousDayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousDay.d.ts

~~~ts
import type { ContextOptions, DateArg, Day } from "./types.js";
/**
 * The {@link previousDay} function options.
 */
export interface PreviousDayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to check
 * @param day - The day of the week
 * @param options - An object with options
 *
 * @returns The date is the previous day of week
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */
export declare function previousDay<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  day: Day,
  options?: PreviousDayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousDay.js

~~~js
import { getDay } from "./getDay.js";
import { subDays } from "./subDays.js";

/**
 * The {@link previousDay} function options.
 */

/**
 * @name previousDay
 * @category Weekday Helpers
 * @summary When is the previous day of the week?
 *
 * @description
 * When is the previous day of the week? 0-6 the day of the week, 0 represents Sunday.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to check
 * @param day - The day of the week
 * @param options - An object with options
 *
 * @returns The date is the previous day of week
 *
 * @example
 * // When is the previous Monday before Mar, 20, 2020?
 * const result = previousDay(new Date(2020, 2, 20), 1)
 * //=> Mon Mar 16 2020 00:00:00
 *
 * @example
 * // When is the previous Tuesday before Mar, 21, 2020?
 * const result = previousDay(new Date(2020, 2, 21), 2)
 * //=> Tue Mar 17 2020 00:00:00
 */
export function previousDay(date, day, options) {
  let delta = getDay(date, options) - day;
  if (delta <= 0) delta += 7;

  return subDays(date, delta, options);
}

// Fallback for modularized imports:
export default previousDay;

~~~

## node_modules\date-fns-jalali\previousFriday.cjs

~~~cjs
"use strict";
exports.previousFriday = previousFriday;
var _index = require("./previousDay.cjs");

/**
 * The {@link previousFriday} function options.
 */

/**
 * @name previousFriday
 * @category Weekday Helpers
 * @summary When is the previous Friday?
 *
 * @description
 * When is the previous Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Friday
 *
 * @example
 * // When is the previous Friday before Jun, 19, 2021?
 * const result = previousFriday(new Date(2021, 5, 19))
 * //=> Fri June 18 2021 00:00:00
 */
function previousFriday(date, options) {
  return (0, _index.previousDay)(date, 5, options);
}

~~~

## node_modules\date-fns-jalali\previousFriday.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousFriday} function options.
 */
export interface PreviousFridayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousFriday
 * @category Weekday Helpers
 * @summary When is the previous Friday?
 *
 * @description
 * When is the previous Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Friday
 *
 * @example
 * // When is the previous Friday before Jun, 19, 2021?
 * const result = previousFriday(new Date(2021, 5, 19))
 * //=> Fri June 18 2021 00:00:00
 */
export declare function previousFriday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousFridayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousFriday.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousFriday} function options.
 */
export interface PreviousFridayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousFriday
 * @category Weekday Helpers
 * @summary When is the previous Friday?
 *
 * @description
 * When is the previous Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Friday
 *
 * @example
 * // When is the previous Friday before Jun, 19, 2021?
 * const result = previousFriday(new Date(2021, 5, 19))
 * //=> Fri June 18 2021 00:00:00
 */
export declare function previousFriday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousFridayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousFriday.js

~~~js
import { previousDay } from "./previousDay.js";

/**
 * The {@link previousFriday} function options.
 */

/**
 * @name previousFriday
 * @category Weekday Helpers
 * @summary When is the previous Friday?
 *
 * @description
 * When is the previous Friday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Friday
 *
 * @example
 * // When is the previous Friday before Jun, 19, 2021?
 * const result = previousFriday(new Date(2021, 5, 19))
 * //=> Fri June 18 2021 00:00:00
 */
export function previousFriday(date, options) {
  return previousDay(date, 5, options);
}

// Fallback for modularized imports:
export default previousFriday;

~~~

## node_modules\date-fns-jalali\previousMonday.cjs

~~~cjs
"use strict";
exports.previousMonday = previousMonday;
var _index = require("./previousDay.cjs");

/**
 * The {@link previousMonday} function options.
 */

/**
 * @name previousMonday
 * @category Weekday Helpers
 * @summary When is the previous Monday?
 *
 * @description
 * When is the previous Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Monday
 *
 * @example
 * // When is the previous Monday before Jun, 18, 2021?
 * const result = previousMonday(new Date(2021, 5, 18))
 * //=> Mon June 14 2021 00:00:00
 */
function previousMonday(date, options) {
  return (0, _index.previousDay)(date, 1, options);
}

~~~

## node_modules\date-fns-jalali\previousMonday.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousMonday} function options.
 */
export interface PreviousMondayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousMonday
 * @category Weekday Helpers
 * @summary When is the previous Monday?
 *
 * @description
 * When is the previous Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Monday
 *
 * @example
 * // When is the previous Monday before Jun, 18, 2021?
 * const result = previousMonday(new Date(2021, 5, 18))
 * //=> Mon June 14 2021 00:00:00
 */
export declare function previousMonday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousMondayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousMonday.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousMonday} function options.
 */
export interface PreviousMondayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousMonday
 * @category Weekday Helpers
 * @summary When is the previous Monday?
 *
 * @description
 * When is the previous Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Monday
 *
 * @example
 * // When is the previous Monday before Jun, 18, 2021?
 * const result = previousMonday(new Date(2021, 5, 18))
 * //=> Mon June 14 2021 00:00:00
 */
export declare function previousMonday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousMondayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousMonday.js

~~~js
import { previousDay } from "./previousDay.js";

/**
 * The {@link previousMonday} function options.
 */

/**
 * @name previousMonday
 * @category Weekday Helpers
 * @summary When is the previous Monday?
 *
 * @description
 * When is the previous Monday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Monday
 *
 * @example
 * // When is the previous Monday before Jun, 18, 2021?
 * const result = previousMonday(new Date(2021, 5, 18))
 * //=> Mon June 14 2021 00:00:00
 */
export function previousMonday(date, options) {
  return previousDay(date, 1, options);
}

// Fallback for modularized imports:
export default previousMonday;

~~~

## node_modules\date-fns-jalali\previousSaturday.cjs

~~~cjs
"use strict";
exports.previousSaturday = previousSaturday;
var _index = require("./previousDay.cjs");

/**
 * The {@link previousSaturday} function options.
 */

/**
 * @name previousSaturday
 * @category Weekday Helpers
 * @summary When is the previous Saturday?
 *
 * @description
 * When is the previous Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Saturday
 *
 * @example
 * // When is the previous Saturday before Jun, 20, 2021?
 * const result = previousSaturday(new Date(2021, 5, 20))
 * //=> Sat June 19 2021 00:00:00
 */
function previousSaturday(date, options) {
  return (0, _index.previousDay)(date, 6, options);
}

~~~

## node_modules\date-fns-jalali\previousSaturday.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousSaturday} function options.
 */
export interface PreviousSaturdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousSaturday
 * @category Weekday Helpers
 * @summary When is the previous Saturday?
 *
 * @description
 * When is the previous Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Saturday
 *
 * @example
 * // When is the previous Saturday before Jun, 20, 2021?
 * const result = previousSaturday(new Date(2021, 5, 20))
 * //=> Sat June 19 2021 00:00:00
 */
export declare function previousSaturday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousSaturdayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousSaturday.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousSaturday} function options.
 */
export interface PreviousSaturdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousSaturday
 * @category Weekday Helpers
 * @summary When is the previous Saturday?
 *
 * @description
 * When is the previous Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Saturday
 *
 * @example
 * // When is the previous Saturday before Jun, 20, 2021?
 * const result = previousSaturday(new Date(2021, 5, 20))
 * //=> Sat June 19 2021 00:00:00
 */
export declare function previousSaturday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousSaturdayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousSaturday.js

~~~js
import { previousDay } from "./previousDay.js";

/**
 * The {@link previousSaturday} function options.
 */

/**
 * @name previousSaturday
 * @category Weekday Helpers
 * @summary When is the previous Saturday?
 *
 * @description
 * When is the previous Saturday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Saturday
 *
 * @example
 * // When is the previous Saturday before Jun, 20, 2021?
 * const result = previousSaturday(new Date(2021, 5, 20))
 * //=> Sat June 19 2021 00:00:00
 */
export function previousSaturday(date, options) {
  return previousDay(date, 6, options);
}

// Fallback for modularized imports:
export default previousSaturday;

~~~

## node_modules\date-fns-jalali\previousSunday.cjs

~~~cjs
"use strict";
exports.previousSunday = previousSunday;
var _index = require("./previousDay.cjs");

/**
 * The {@link previousSunday} function options.
 */

/**
 * @name previousSunday
 * @category Weekday Helpers
 * @summary When is the previous Sunday?
 *
 * @description
 * When is the previous Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Sunday
 *
 * @example
 * // When is the previous Sunday before Jun, 21, 2021?
 * const result = previousSunday(new Date(2021, 5, 21))
 * //=> Sun June 20 2021 00:00:00
 */
function previousSunday(date, options) {
  return (0, _index.previousDay)(date, 0, options);
}

~~~

## node_modules\date-fns-jalali\previousSunday.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousSunday} function options.
 */
export interface PreviousSundayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousSunday
 * @category Weekday Helpers
 * @summary When is the previous Sunday?
 *
 * @description
 * When is the previous Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Sunday
 *
 * @example
 * // When is the previous Sunday before Jun, 21, 2021?
 * const result = previousSunday(new Date(2021, 5, 21))
 * //=> Sun June 20 2021 00:00:00
 */
export declare function previousSunday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousSundayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousSunday.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousSunday} function options.
 */
export interface PreviousSundayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousSunday
 * @category Weekday Helpers
 * @summary When is the previous Sunday?
 *
 * @description
 * When is the previous Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Sunday
 *
 * @example
 * // When is the previous Sunday before Jun, 21, 2021?
 * const result = previousSunday(new Date(2021, 5, 21))
 * //=> Sun June 20 2021 00:00:00
 */
export declare function previousSunday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousSundayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousSunday.js

~~~js
import { previousDay } from "./previousDay.js";

/**
 * The {@link previousSunday} function options.
 */

/**
 * @name previousSunday
 * @category Weekday Helpers
 * @summary When is the previous Sunday?
 *
 * @description
 * When is the previous Sunday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - The options
 *
 * @returns The previous Sunday
 *
 * @example
 * // When is the previous Sunday before Jun, 21, 2021?
 * const result = previousSunday(new Date(2021, 5, 21))
 * //=> Sun June 20 2021 00:00:00
 */
export function previousSunday(date, options) {
  return previousDay(date, 0, options);
}

// Fallback for modularized imports:
export default previousSunday;

~~~

## node_modules\date-fns-jalali\previousThursday.cjs

~~~cjs
"use strict";
exports.previousThursday = previousThursday;
var _index = require("./previousDay.cjs");

/**
 * The {@link previousThursday} function options.
 */

/**
 * @name previousThursday
 * @category Weekday Helpers
 * @summary When is the previous Thursday?
 *
 * @description
 * When is the previous Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Thursday
 *
 * @example
 * // When is the previous Thursday before Jun, 18, 2021?
 * const result = previousThursday(new Date(2021, 5, 18))
 * //=> Thu June 17 2021 00:00:00
 */
function previousThursday(date, options) {
  return (0, _index.previousDay)(date, 4, options);
}

~~~

## node_modules\date-fns-jalali\previousThursday.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousThursday} function options.
 */
export interface PreviousThursdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousThursday
 * @category Weekday Helpers
 * @summary When is the previous Thursday?
 *
 * @description
 * When is the previous Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Thursday
 *
 * @example
 * // When is the previous Thursday before Jun, 18, 2021?
 * const result = previousThursday(new Date(2021, 5, 18))
 * //=> Thu June 17 2021 00:00:00
 */
export declare function previousThursday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousThursdayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousThursday.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousThursday} function options.
 */
export interface PreviousThursdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousThursday
 * @category Weekday Helpers
 * @summary When is the previous Thursday?
 *
 * @description
 * When is the previous Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Thursday
 *
 * @example
 * // When is the previous Thursday before Jun, 18, 2021?
 * const result = previousThursday(new Date(2021, 5, 18))
 * //=> Thu June 17 2021 00:00:00
 */
export declare function previousThursday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousThursdayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousThursday.js

~~~js
import { previousDay } from "./previousDay.js";

/**
 * The {@link previousThursday} function options.
 */

/**
 * @name previousThursday
 * @category Weekday Helpers
 * @summary When is the previous Thursday?
 *
 * @description
 * When is the previous Thursday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Thursday
 *
 * @example
 * // When is the previous Thursday before Jun, 18, 2021?
 * const result = previousThursday(new Date(2021, 5, 18))
 * //=> Thu June 17 2021 00:00:00
 */
export function previousThursday(date, options) {
  return previousDay(date, 4, options);
}

// Fallback for modularized imports:
export default previousThursday;

~~~

## node_modules\date-fns-jalali\previousTuesday.cjs

~~~cjs
"use strict";
exports.previousTuesday = previousTuesday;
var _index = require("./previousDay.cjs");

/**
 * The {@link previousTuesday} function options.
 */

/**
 * @name previousTuesday
 * @category Weekday Helpers
 * @summary When is the previous Tuesday?
 *
 * @description
 * When is the previous Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Tuesday
 *
 * @example
 * // When is the previous Tuesday before Jun, 18, 2021?
 * const result = previousTuesday(new Date(2021, 5, 18))
 * //=> Tue June 15 2021 00:00:00
 */
function previousTuesday(date, options) {
  return (0, _index.previousDay)(date, 2, options);
}

~~~

## node_modules\date-fns-jalali\previousTuesday.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousTuesday} function options.
 */
export interface PreviousTuesdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousTuesday
 * @category Weekday Helpers
 * @summary When is the previous Tuesday?
 *
 * @description
 * When is the previous Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Tuesday
 *
 * @example
 * // When is the previous Tuesday before Jun, 18, 2021?
 * const result = previousTuesday(new Date(2021, 5, 18))
 * //=> Tue June 15 2021 00:00:00
 */
export declare function previousTuesday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousTuesdayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousTuesday.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousTuesday} function options.
 */
export interface PreviousTuesdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousTuesday
 * @category Weekday Helpers
 * @summary When is the previous Tuesday?
 *
 * @description
 * When is the previous Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Tuesday
 *
 * @example
 * // When is the previous Tuesday before Jun, 18, 2021?
 * const result = previousTuesday(new Date(2021, 5, 18))
 * //=> Tue June 15 2021 00:00:00
 */
export declare function previousTuesday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousTuesdayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousTuesday.js

~~~js
import { previousDay } from "./previousDay.js";

/**
 * The {@link previousTuesday} function options.
 */

/**
 * @name previousTuesday
 * @category Weekday Helpers
 * @summary When is the previous Tuesday?
 *
 * @description
 * When is the previous Tuesday?
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Tuesday
 *
 * @example
 * // When is the previous Tuesday before Jun, 18, 2021?
 * const result = previousTuesday(new Date(2021, 5, 18))
 * //=> Tue June 15 2021 00:00:00
 */
export function previousTuesday(date, options) {
  return previousDay(date, 2, options);
}

// Fallback for modularized imports:
export default previousTuesday;

~~~

## node_modules\date-fns-jalali\previousWednesday.cjs

~~~cjs
"use strict";
exports.previousWednesday = previousWednesday;
var _index = require("./previousDay.cjs");

/**
 * The {@link previousWednesday} function options.
 */

/**
 * @name previousWednesday
 * @category Weekday Helpers
 * @summary When is the previous Wednesday?
 *
 * @description
 * When is the previous Wednesday?
 *
 * @typeParam DateType - The Date type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Wednesday
 *
 * @example
 * // When is the previous Wednesday before Jun, 18, 2021?
 * const result = previousWednesday(new Date(2021, 5, 18))
 * //=> Wed June 16 2021 00:00:00
 */
function previousWednesday(date, options) {
  return (0, _index.previousDay)(date, 3, options);
}

~~~

## node_modules\date-fns-jalali\previousWednesday.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousWednesday} function options.
 */
export interface PreviousWednesdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousWednesday
 * @category Weekday Helpers
 * @summary When is the previous Wednesday?
 *
 * @description
 * When is the previous Wednesday?
 *
 * @typeParam DateType - The Date type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Wednesday
 *
 * @example
 * // When is the previous Wednesday before Jun, 18, 2021?
 * const result = previousWednesday(new Date(2021, 5, 18))
 * //=> Wed June 16 2021 00:00:00
 */
export declare function previousWednesday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousWednesdayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousWednesday.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link previousWednesday} function options.
 */
export interface PreviousWednesdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name previousWednesday
 * @category Weekday Helpers
 * @summary When is the previous Wednesday?
 *
 * @description
 * When is the previous Wednesday?
 *
 * @typeParam DateType - The Date type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Wednesday
 *
 * @example
 * // When is the previous Wednesday before Jun, 18, 2021?
 * const result = previousWednesday(new Date(2021, 5, 18))
 * //=> Wed June 16 2021 00:00:00
 */
export declare function previousWednesday<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: PreviousWednesdayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\previousWednesday.js

~~~js
import { previousDay } from "./previousDay.js";

/**
 * The {@link previousWednesday} function options.
 */

/**
 * @name previousWednesday
 * @category Weekday Helpers
 * @summary When is the previous Wednesday?
 *
 * @description
 * When is the previous Wednesday?
 *
 * @typeParam DateType - The Date type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [UTCDate](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to start counting from
 * @param options - An object with options
 *
 * @returns The previous Wednesday
 *
 * @example
 * // When is the previous Wednesday before Jun, 18, 2021?
 * const result = previousWednesday(new Date(2021, 5, 18))
 * //=> Wed June 16 2021 00:00:00
 */
export function previousWednesday(date, options) {
  return previousDay(date, 3, options);
}

// Fallback for modularized imports:
export default previousWednesday;

~~~

## node_modules\date-fns-jalali\quartersToMonths.cjs

~~~cjs
"use strict";
exports.quartersToMonths = quartersToMonths;
var _index = require("./constants.cjs");

/**
 * @name quartersToMonths
 * @category Conversion Helpers
 * @summary Convert number of quarters to months.
 *
 * @description
 * Convert a number of quarters to a full number of months.
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in months
 *
 * @example
 * // Convert 2 quarters to months
 * const result = quartersToMonths(2)
 * //=> 6
 */
function quartersToMonths(quarters) {
  return Math.trunc(quarters * _index.monthsInQuarter);
}

~~~

## node_modules\date-fns-jalali\quartersToMonths.d.cts

~~~cts
/**
 * @name quartersToMonths
 * @category Conversion Helpers
 * @summary Convert number of quarters to months.
 *
 * @description
 * Convert a number of quarters to a full number of months.
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in months
 *
 * @example
 * // Convert 2 quarters to months
 * const result = quartersToMonths(2)
 * //=> 6
 */
export declare function quartersToMonths(quarters: number): number;

~~~

## node_modules\date-fns-jalali\quartersToMonths.d.ts

~~~ts
/**
 * @name quartersToMonths
 * @category Conversion Helpers
 * @summary Convert number of quarters to months.
 *
 * @description
 * Convert a number of quarters to a full number of months.
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in months
 *
 * @example
 * // Convert 2 quarters to months
 * const result = quartersToMonths(2)
 * //=> 6
 */
export declare function quartersToMonths(quarters: number): number;

~~~

## node_modules\date-fns-jalali\quartersToMonths.js

~~~js
import { monthsInQuarter } from "./constants.js";

/**
 * @name quartersToMonths
 * @category Conversion Helpers
 * @summary Convert number of quarters to months.
 *
 * @description
 * Convert a number of quarters to a full number of months.
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in months
 *
 * @example
 * // Convert 2 quarters to months
 * const result = quartersToMonths(2)
 * //=> 6
 */
export function quartersToMonths(quarters) {
  return Math.trunc(quarters * monthsInQuarter);
}

// Fallback for modularized imports:
export default quartersToMonths;

~~~

## node_modules\date-fns-jalali\quartersToYears.cjs

~~~cjs
"use strict";
exports.quartersToYears = quartersToYears;
var _index = require("./constants.cjs");

/**
 * @name quartersToYears
 * @category Conversion Helpers
 * @summary Convert number of quarters to years.
 *
 * @description
 * Convert a number of quarters to a full number of years.
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in years
 *
 * @example
 * // Convert 8 quarters to years
 * const result = quartersToYears(8)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = quartersToYears(11)
 * //=> 2
 */
function quartersToYears(quarters) {
  const years = quarters / _index.quartersInYear;
  return Math.trunc(years);
}

~~~

## node_modules\date-fns-jalali\quartersToYears.d.cts

~~~cts
/**
 * @name quartersToYears
 * @category Conversion Helpers
 * @summary Convert number of quarters to years.
 *
 * @description
 * Convert a number of quarters to a full number of years.
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in years
 *
 * @example
 * // Convert 8 quarters to years
 * const result = quartersToYears(8)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = quartersToYears(11)
 * //=> 2
 */
export declare function quartersToYears(quarters: number): number;

~~~

## node_modules\date-fns-jalali\quartersToYears.d.ts

~~~ts
/**
 * @name quartersToYears
 * @category Conversion Helpers
 * @summary Convert number of quarters to years.
 *
 * @description
 * Convert a number of quarters to a full number of years.
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in years
 *
 * @example
 * // Convert 8 quarters to years
 * const result = quartersToYears(8)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = quartersToYears(11)
 * //=> 2
 */
export declare function quartersToYears(quarters: number): number;

~~~

## node_modules\date-fns-jalali\quartersToYears.js

~~~js
import { quartersInYear } from "./constants.js";

/**
 * @name quartersToYears
 * @category Conversion Helpers
 * @summary Convert number of quarters to years.
 *
 * @description
 * Convert a number of quarters to a full number of years.
 *
 * @param quarters - The number of quarters to be converted
 *
 * @returns The number of quarters converted in years
 *
 * @example
 * // Convert 8 quarters to years
 * const result = quartersToYears(8)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = quartersToYears(11)
 * //=> 2
 */
export function quartersToYears(quarters) {
  const years = quarters / quartersInYear;
  return Math.trunc(years);
}

// Fallback for modularized imports:
export default quartersToYears;

~~~

## node_modules\date-fns-jalali\README.md

~~~md
[![date-fns-jalali](docs/logotype.svg)](https://date-fns.org/)

?뵦截?**NEW**: [date-fns v4.0 with first-class time zone support is out!](https://blog.date-fns.org/v40-with-time-zone-support/)

date-fns-jalali provides the most comprehensive, yet simple and consistent toolset for manipulating JavaScript dates in a browser & Node.js for jalali calendar.

?몛 [Documentation](https://date-fns.org/)

?몛 [Blog](https://blog.date-fns.org/)

<hr>

It's like [Lodash](https://lodash.com) for dates

- It has [**200+ functions** for all occasions](https://date-fns.org/docs/Getting-Started/).
- **Modular**: Pick what you need. Works with webpack, Browserify, or Rollup and also supports tree-shaking.
- **Native dates**: Uses existing native type. It doesn't extend core objects for safety's sake.
- **Immutable & Pure**: Built using pure functions and always returns a new date instance.
- **TypeScript**: The library is 100% TypeScript with brand-new handcrafted types.
- **I18n**: Dozens of locales. Include only what you need.
- [and many more benefits](https://date-fns.org/)

**date-fns-jalali** provides **date-fns** toolset for [jalali calendar](https://en.wikipedia.org/wiki/Jalali_calendar)

```js
import { compareAsc, format, newDate } from "date-fns-jalali";

format(new Date(2014, 1, 11), "yyyy-MM-dd");
//=> '1392-11-22'

newDate(1392, 10, 22);
// => Tue Feb 11 2014 00:00:00

format(newDate(1392, 10, 22), "yyyy MMMM d");
// 1392 磨??? 22

const dates = [
  new Date(1995, 6, 2),
  new Date(1987, 1, 11),
  new Date(1989, 6, 10),
];
dates.sort(compareAsc);
//=> [
//   Wed Feb 11 1987 00:00:00,
//   Mon Jul 10 1989 00:00:00,
//   Sun Jul 02 1995 00:00:00
// ]
```

The library is available as an [npm package](https://www.npmjs.com/package/date-fns-jalali).
To install the package run:

```bash
npm install date-fns-jalali --save
```

## Docs

[See date-fns.org](https://date-fns.org/) for more details, API,
and other docs.

<br />

## License

MIT

~~~

## node_modules\date-fns-jalali\roundToNearestHours.cjs

~~~cjs
"use strict";
exports.roundToNearestHours = roundToNearestHours;
var _index = require("./_lib/getRoundingMethod.cjs");
var _index2 = require("./constructFrom.cjs");
var _index3 = require("./toDate.cjs");

/**
 * The {@link roundToNearestHours} function options.
 */

/**
 * @name roundToNearestHours
 * @category Hour Helpers
 * @summary Rounds the given date to the nearest hour
 *
 * @description
 * Rounds the given date to the nearest hour (or number of hours).
 * Rounds up when the given date is exactly between the nearest round hours.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest hour
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56))
 * //=> Thu Jul 10 2014 13:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 6 })
 * //=> Thu Jul 10 2014 12:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 8 })
 * //=> Thu Jul 10 2014 16:00:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 1, 23, 45), { roundingMethod: 'ceil' })
 * //=> Thu Jul 10 2014 02:00:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:34:56 to nearest quarter hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { roundingMethod: 'floor', nearestTo: 8 })
 * //=> Thu Jul 10 2014 08:00:00
 */
function roundToNearestHours(date, options) {
  const nearestTo = options?.nearestTo ?? 1;

  if (nearestTo < 1 || nearestTo > 12)
    return (0, _index2.constructFrom)(options?.in || date, NaN);

  const date_ = (0, _index3.toDate)(date, options?.in);
  const fractionalMinutes = date_.getMinutes() / 60;
  const fractionalSeconds = date_.getSeconds() / 60 / 60;
  const fractionalMilliseconds = date_.getMilliseconds() / 1000 / 60 / 60;
  const hours =
    date_.getHours() +
    fractionalMinutes +
    fractionalSeconds +
    fractionalMilliseconds;

  const method = options?.roundingMethod ?? "round";
  const roundingMethod = (0, _index.getRoundingMethod)(method);

  const roundedHours = roundingMethod(hours / nearestTo) * nearestTo;

  date_.setHours(roundedHours, 0, 0, 0);
  return date_;
}

~~~

## node_modules\date-fns-jalali\roundToNearestHours.d.cts

~~~cts
import type {
  ContextOptions,
  DateArg,
  NearestHours,
  NearestToUnitOptions,
  RoundingOptions,
} from "./types.js";
/**
 * The {@link roundToNearestHours} function options.
 */
export interface RoundToNearestHoursOptions<DateType extends Date = Date>
  extends NearestToUnitOptions<NearestHours>,
    RoundingOptions,
    ContextOptions<DateType> {}
/**
 * @name roundToNearestHours
 * @category Hour Helpers
 * @summary Rounds the given date to the nearest hour
 *
 * @description
 * Rounds the given date to the nearest hour (or number of hours).
 * Rounds up when the given date is exactly between the nearest round hours.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest hour
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56))
 * //=> Thu Jul 10 2014 13:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 6 })
 * //=> Thu Jul 10 2014 12:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 8 })
 * //=> Thu Jul 10 2014 16:00:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 1, 23, 45), { roundingMethod: 'ceil' })
 * //=> Thu Jul 10 2014 02:00:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:34:56 to nearest quarter hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { roundingMethod: 'floor', nearestTo: 8 })
 * //=> Thu Jul 10 2014 08:00:00
 */
export declare function roundToNearestHours<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: RoundToNearestHoursOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\roundToNearestHours.d.ts

~~~ts
import type {
  ContextOptions,
  DateArg,
  NearestHours,
  NearestToUnitOptions,
  RoundingOptions,
} from "./types.js";
/**
 * The {@link roundToNearestHours} function options.
 */
export interface RoundToNearestHoursOptions<DateType extends Date = Date>
  extends NearestToUnitOptions<NearestHours>,
    RoundingOptions,
    ContextOptions<DateType> {}
/**
 * @name roundToNearestHours
 * @category Hour Helpers
 * @summary Rounds the given date to the nearest hour
 *
 * @description
 * Rounds the given date to the nearest hour (or number of hours).
 * Rounds up when the given date is exactly between the nearest round hours.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest hour
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56))
 * //=> Thu Jul 10 2014 13:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 6 })
 * //=> Thu Jul 10 2014 12:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 8 })
 * //=> Thu Jul 10 2014 16:00:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 1, 23, 45), { roundingMethod: 'ceil' })
 * //=> Thu Jul 10 2014 02:00:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:34:56 to nearest quarter hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { roundingMethod: 'floor', nearestTo: 8 })
 * //=> Thu Jul 10 2014 08:00:00
 */
export declare function roundToNearestHours<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: RoundToNearestHoursOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\roundToNearestHours.js

~~~js
import { getRoundingMethod } from "./_lib/getRoundingMethod.js";
import { constructFrom } from "./constructFrom.js";
import { toDate } from "./toDate.js";

/**
 * The {@link roundToNearestHours} function options.
 */

/**
 * @name roundToNearestHours
 * @category Hour Helpers
 * @summary Rounds the given date to the nearest hour
 *
 * @description
 * Rounds the given date to the nearest hour (or number of hours).
 * Rounds up when the given date is exactly between the nearest round hours.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest hour
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56))
 * //=> Thu Jul 10 2014 13:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 6 })
 * //=> Thu Jul 10 2014 12:00:00
 *
 * @example
 * // Round 10 July 2014 12:34:56 to nearest half hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { nearestTo: 8 })
 * //=> Thu Jul 10 2014 16:00:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:34:56 to nearest hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 1, 23, 45), { roundingMethod: 'ceil' })
 * //=> Thu Jul 10 2014 02:00:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:34:56 to nearest quarter hour:
 * const result = roundToNearestHours(new Date(2014, 6, 10, 12, 34, 56), { roundingMethod: 'floor', nearestTo: 8 })
 * //=> Thu Jul 10 2014 08:00:00
 */
export function roundToNearestHours(date, options) {
  const nearestTo = options?.nearestTo ?? 1;

  if (nearestTo < 1 || nearestTo > 12)
    return constructFrom(options?.in || date, NaN);

  const date_ = toDate(date, options?.in);
  const fractionalMinutes = date_.getMinutes() / 60;
  const fractionalSeconds = date_.getSeconds() / 60 / 60;
  const fractionalMilliseconds = date_.getMilliseconds() / 1000 / 60 / 60;
  const hours =
    date_.getHours() +
    fractionalMinutes +
    fractionalSeconds +
    fractionalMilliseconds;

  const method = options?.roundingMethod ?? "round";
  const roundingMethod = getRoundingMethod(method);

  const roundedHours = roundingMethod(hours / nearestTo) * nearestTo;

  date_.setHours(roundedHours, 0, 0, 0);
  return date_;
}

// Fallback for modularized imports:
export default roundToNearestHours;

~~~

## node_modules\date-fns-jalali\roundToNearestMinutes.cjs

~~~cjs
"use strict";
exports.roundToNearestMinutes = roundToNearestMinutes;
var _index = require("./_lib/getRoundingMethod.cjs");
var _index2 = require("./constructFrom.cjs");
var _index3 = require("./toDate.cjs");

/**
 * The {@link roundToNearestMinutes} function options.
 */

/**
 * @name roundToNearestMinutes
 * @category Minute Helpers
 * @summary Rounds the given date to the nearest minute
 *
 * @description
 * Rounds the given date to the nearest minute (or number of minutes).
 * Rounds up when the given date is exactly between the nearest round minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest minute
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
 * //=> Thu Jul 10 2014 12:13:00
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest quarter hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
 * //=> Thu Jul 10 2014 12:15:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'floor' })
 * //=> Thu Jul 10 2014 12:12:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:12:34 to nearest half hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })
 * //=> Thu Jul 10 2014 12:30:00
 */
function roundToNearestMinutes(date, options) {
  const nearestTo = options?.nearestTo ?? 1;

  if (nearestTo < 1 || nearestTo > 30)
    return (0, _index2.constructFrom)(date, NaN);

  const date_ = (0, _index3.toDate)(date, options?.in);
  const fractionalSeconds = date_.getSeconds() / 60;
  const fractionalMilliseconds = date_.getMilliseconds() / 1000 / 60;
  const minutes =
    date_.getMinutes() + fractionalSeconds + fractionalMilliseconds;

  const method = options?.roundingMethod ?? "round";
  const roundingMethod = (0, _index.getRoundingMethod)(method);

  const roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;

  date_.setMinutes(roundedMinutes, 0, 0);
  return date_;
}

~~~

## node_modules\date-fns-jalali\roundToNearestMinutes.d.cts

~~~cts
import type {
  ContextOptions,
  DateArg,
  NearestMinutes,
  NearestToUnitOptions,
  RoundingOptions,
} from "./types.js";
/**
 * The {@link roundToNearestMinutes} function options.
 */
export interface RoundToNearestMinutesOptions<DateType extends Date = Date>
  extends NearestToUnitOptions<NearestMinutes>,
    RoundingOptions,
    ContextOptions<DateType> {}
/**
 * @name roundToNearestMinutes
 * @category Minute Helpers
 * @summary Rounds the given date to the nearest minute
 *
 * @description
 * Rounds the given date to the nearest minute (or number of minutes).
 * Rounds up when the given date is exactly between the nearest round minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest minute
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
 * //=> Thu Jul 10 2014 12:13:00
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest quarter hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
 * //=> Thu Jul 10 2014 12:15:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'floor' })
 * //=> Thu Jul 10 2014 12:12:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:12:34 to nearest half hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })
 * //=> Thu Jul 10 2014 12:30:00
 */
export declare function roundToNearestMinutes<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: RoundToNearestMinutesOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\roundToNearestMinutes.d.ts

~~~ts
import type {
  ContextOptions,
  DateArg,
  NearestMinutes,
  NearestToUnitOptions,
  RoundingOptions,
} from "./types.js";
/**
 * The {@link roundToNearestMinutes} function options.
 */
export interface RoundToNearestMinutesOptions<DateType extends Date = Date>
  extends NearestToUnitOptions<NearestMinutes>,
    RoundingOptions,
    ContextOptions<DateType> {}
/**
 * @name roundToNearestMinutes
 * @category Minute Helpers
 * @summary Rounds the given date to the nearest minute
 *
 * @description
 * Rounds the given date to the nearest minute (or number of minutes).
 * Rounds up when the given date is exactly between the nearest round minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest minute
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
 * //=> Thu Jul 10 2014 12:13:00
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest quarter hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
 * //=> Thu Jul 10 2014 12:15:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'floor' })
 * //=> Thu Jul 10 2014 12:12:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:12:34 to nearest half hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })
 * //=> Thu Jul 10 2014 12:30:00
 */
export declare function roundToNearestMinutes<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: RoundToNearestMinutesOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\roundToNearestMinutes.js

~~~js
import { getRoundingMethod } from "./_lib/getRoundingMethod.js";
import { constructFrom } from "./constructFrom.js";
import { toDate } from "./toDate.js";

/**
 * The {@link roundToNearestMinutes} function options.
 */

/**
 * @name roundToNearestMinutes
 * @category Minute Helpers
 * @summary Rounds the given date to the nearest minute
 *
 * @description
 * Rounds the given date to the nearest minute (or number of minutes).
 * Rounds up when the given date is exactly between the nearest round minutes.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to round
 * @param options - An object with options.
 *
 * @returns The new date rounded to the closest minute
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34))
 * //=> Thu Jul 10 2014 12:13:00
 *
 * @example
 * // Round 10 July 2014 12:12:34 to nearest quarter hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { nearestTo: 15 })
 * //=> Thu Jul 10 2014 12:15:00
 *
 * @example
 * // Floor (rounds down) 10 July 2014 12:12:34 to nearest minute:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'floor' })
 * //=> Thu Jul 10 2014 12:12:00
 *
 * @example
 * // Ceil (rounds up) 10 July 2014 12:12:34 to nearest half hour:
 * const result = roundToNearestMinutes(new Date(2014, 6, 10, 12, 12, 34), { roundingMethod: 'ceil', nearestTo: 30 })
 * //=> Thu Jul 10 2014 12:30:00
 */
export function roundToNearestMinutes(date, options) {
  const nearestTo = options?.nearestTo ?? 1;

  if (nearestTo < 1 || nearestTo > 30) return constructFrom(date, NaN);

  const date_ = toDate(date, options?.in);
  const fractionalSeconds = date_.getSeconds() / 60;
  const fractionalMilliseconds = date_.getMilliseconds() / 1000 / 60;
  const minutes =
    date_.getMinutes() + fractionalSeconds + fractionalMilliseconds;

  const method = options?.roundingMethod ?? "round";
  const roundingMethod = getRoundingMethod(method);

  const roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;

  date_.setMinutes(roundedMinutes, 0, 0);
  return date_;
}

// Fallback for modularized imports:
export default roundToNearestMinutes;

~~~

## node_modules\date-fns-jalali\secondsToHours.cjs

~~~cjs
"use strict";
exports.secondsToHours = secondsToHours;
var _index = require("./constants.cjs");

/**
 * @name secondsToHours
 * @category Conversion Helpers
 * @summary Convert seconds to hours.
 *
 * @description
 * Convert a number of seconds to a full number of hours.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in hours
 *
 * @example
 * // Convert 7200 seconds into hours
 * const result = secondsToHours(7200)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToHours(7199)
 * //=> 1
 */
function secondsToHours(seconds) {
  const hours = seconds / _index.secondsInHour;
  return Math.trunc(hours);
}

~~~

## node_modules\date-fns-jalali\secondsToHours.d.cts

~~~cts
/**
 * @name secondsToHours
 * @category Conversion Helpers
 * @summary Convert seconds to hours.
 *
 * @description
 * Convert a number of seconds to a full number of hours.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in hours
 *
 * @example
 * // Convert 7200 seconds into hours
 * const result = secondsToHours(7200)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToHours(7199)
 * //=> 1
 */
export declare function secondsToHours(seconds: number): number;

~~~

## node_modules\date-fns-jalali\secondsToHours.d.ts

~~~ts
/**
 * @name secondsToHours
 * @category Conversion Helpers
 * @summary Convert seconds to hours.
 *
 * @description
 * Convert a number of seconds to a full number of hours.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in hours
 *
 * @example
 * // Convert 7200 seconds into hours
 * const result = secondsToHours(7200)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToHours(7199)
 * //=> 1
 */
export declare function secondsToHours(seconds: number): number;

~~~

## node_modules\date-fns-jalali\secondsToHours.js

~~~js
import { secondsInHour } from "./constants.js";

/**
 * @name secondsToHours
 * @category Conversion Helpers
 * @summary Convert seconds to hours.
 *
 * @description
 * Convert a number of seconds to a full number of hours.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in hours
 *
 * @example
 * // Convert 7200 seconds into hours
 * const result = secondsToHours(7200)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToHours(7199)
 * //=> 1
 */
export function secondsToHours(seconds) {
  const hours = seconds / secondsInHour;
  return Math.trunc(hours);
}

// Fallback for modularized imports:
export default secondsToHours;

~~~

## node_modules\date-fns-jalali\secondsToMilliseconds.cjs

~~~cjs
"use strict";
exports.secondsToMilliseconds = secondsToMilliseconds;
var _index = require("./constants.cjs");

/**
 * @name secondsToMilliseconds
 * @category Conversion Helpers
 * @summary Convert seconds to milliseconds.
 *
 * @description
 * Convert a number of seconds to a full number of milliseconds.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in milliseconds
 *
 * @example
 * // Convert 2 seconds into milliseconds
 * const result = secondsToMilliseconds(2)
 * //=> 2000
 */
function secondsToMilliseconds(seconds) {
  return seconds * _index.millisecondsInSecond;
}

~~~

## node_modules\date-fns-jalali\secondsToMilliseconds.d.cts

~~~cts
/**
 * @name secondsToMilliseconds
 * @category Conversion Helpers
 * @summary Convert seconds to milliseconds.
 *
 * @description
 * Convert a number of seconds to a full number of milliseconds.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in milliseconds
 *
 * @example
 * // Convert 2 seconds into milliseconds
 * const result = secondsToMilliseconds(2)
 * //=> 2000
 */
export declare function secondsToMilliseconds(seconds: number): number;

~~~

## node_modules\date-fns-jalali\secondsToMilliseconds.d.ts

~~~ts
/**
 * @name secondsToMilliseconds
 * @category Conversion Helpers
 * @summary Convert seconds to milliseconds.
 *
 * @description
 * Convert a number of seconds to a full number of milliseconds.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in milliseconds
 *
 * @example
 * // Convert 2 seconds into milliseconds
 * const result = secondsToMilliseconds(2)
 * //=> 2000
 */
export declare function secondsToMilliseconds(seconds: number): number;

~~~

## node_modules\date-fns-jalali\secondsToMilliseconds.js

~~~js
import { millisecondsInSecond } from "./constants.js";

/**
 * @name secondsToMilliseconds
 * @category Conversion Helpers
 * @summary Convert seconds to milliseconds.
 *
 * @description
 * Convert a number of seconds to a full number of milliseconds.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in milliseconds
 *
 * @example
 * // Convert 2 seconds into milliseconds
 * const result = secondsToMilliseconds(2)
 * //=> 2000
 */
export function secondsToMilliseconds(seconds) {
  return seconds * millisecondsInSecond;
}

// Fallback for modularized imports:
export default secondsToMilliseconds;

~~~

## node_modules\date-fns-jalali\secondsToMinutes.cjs

~~~cjs
"use strict";
exports.secondsToMinutes = secondsToMinutes;
var _index = require("./constants.cjs");

/**
 * @name secondsToMinutes
 * @category Conversion Helpers
 * @summary Convert seconds to minutes.
 *
 * @description
 * Convert a number of seconds to a full number of minutes.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in minutes
 *
 * @example
 * // Convert 120 seconds into minutes
 * const result = secondsToMinutes(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToMinutes(119)
 * //=> 1
 */
function secondsToMinutes(seconds) {
  const minutes = seconds / _index.secondsInMinute;
  return Math.trunc(minutes);
}

~~~

## node_modules\date-fns-jalali\secondsToMinutes.d.cts

~~~cts
/**
 * @name secondsToMinutes
 * @category Conversion Helpers
 * @summary Convert seconds to minutes.
 *
 * @description
 * Convert a number of seconds to a full number of minutes.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in minutes
 *
 * @example
 * // Convert 120 seconds into minutes
 * const result = secondsToMinutes(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToMinutes(119)
 * //=> 1
 */
export declare function secondsToMinutes(seconds: number): number;

~~~

## node_modules\date-fns-jalali\secondsToMinutes.d.ts

~~~ts
/**
 * @name secondsToMinutes
 * @category Conversion Helpers
 * @summary Convert seconds to minutes.
 *
 * @description
 * Convert a number of seconds to a full number of minutes.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in minutes
 *
 * @example
 * // Convert 120 seconds into minutes
 * const result = secondsToMinutes(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToMinutes(119)
 * //=> 1
 */
export declare function secondsToMinutes(seconds: number): number;

~~~

## node_modules\date-fns-jalali\secondsToMinutes.js

~~~js
import { secondsInMinute } from "./constants.js";

/**
 * @name secondsToMinutes
 * @category Conversion Helpers
 * @summary Convert seconds to minutes.
 *
 * @description
 * Convert a number of seconds to a full number of minutes.
 *
 * @param seconds - The number of seconds to be converted
 *
 * @returns The number of seconds converted in minutes
 *
 * @example
 * // Convert 120 seconds into minutes
 * const result = secondsToMinutes(120)
 * //=> 2
 *
 * @example
 * // It uses floor rounding:
 * const result = secondsToMinutes(119)
 * //=> 1
 */
export function secondsToMinutes(seconds) {
  const minutes = seconds / secondsInMinute;
  return Math.trunc(minutes);
}

// Fallback for modularized imports:
export default secondsToMinutes;

~~~

## node_modules\date-fns-jalali\SECURITY.md

~~~md
# Security Policy

## Supported Versions

Security updates are applied only to the latest release.

## Reporting a Vulnerability

If you have discovered a security vulnerability in this project, please report it privately. **Do not disclose it as a public issue.**
This gives us time to work with you to fix the issue before public exposure, reducing the chance that the exploit will be used before a patch is released.
Please disclose it to [Sasha Koss](mailto:koss@nocorp.me). This project is maintained by a team of volunteers
on a reasonable-effort basis. As such, please give us at least 90 days to work on a fix before public exposure.

~~~

## node_modules\date-fns-jalali\set.cjs

~~~cjs
"use strict";
exports.set = set;
var _index = require("./constructFrom.cjs");
var _index2 = require("./setMonth.cjs");
var _index3 = require("./toDate.cjs");

var _index4 = require("./_core/setDate.cjs");
var _index5 = require("./_core/setFullYear.cjs");

/**
 * The {@link set} function options.
 */

/**
 * @name set
 * @category Common Helpers
 * @summary Set date values to a given date.
 *
 * @description
 * Set date values to a given date.
 *
 * Sets time values to date from object `values`.
 * A value is not set if it is undefined or null or doesn't exist in `values`.
 *
 * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
 * to use native `Date#setX` methods. If you use this function, you may not want to include the
 * other `setX` functions that date-fns provides if you are concerned about the bundle size.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param values - The date values to be set
 * @param options - The options
 *
 * @returns The new date with options set
 *
 * @example
 * // Transform 1 September 2014 into 20 October 2015 in a single line:
 * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
 * //=> Tue Oct 20 2015 00:00:00
 *
 * @example
 * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
 * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
 * //=> Mon Sep 01 2014 12:23:45
 */
function set(date, values, options) {
  let _date = (0, _index3.toDate)(date, options?.in);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(+_date)) return (0, _index.constructFrom)(options?.in || date, NaN);

  if (values.year != null) (0, _index5.setFullYear)(_date, values.year);
  if (values.month != null) _date = (0, _index2.setMonth)(_date, values.month);
  if (values.date != null) (0, _index4.setDate)(_date, values.date);
  if (values.hours != null) _date.setHours(values.hours);
  if (values.minutes != null) _date.setMinutes(values.minutes);
  if (values.seconds != null) _date.setSeconds(values.seconds);
  if (values.milliseconds != null) _date.setMilliseconds(values.milliseconds);

  return _date;
}

~~~

## node_modules\date-fns-jalali\set.d.cts

~~~cts
import type { ContextOptions, DateArg, DateValues } from "./types.js";
/**
 * The {@link set} function options.
 */
export interface SetOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name set
 * @category Common Helpers
 * @summary Set date values to a given date.
 *
 * @description
 * Set date values to a given date.
 *
 * Sets time values to date from object `values`.
 * A value is not set if it is undefined or null or doesn't exist in `values`.
 *
 * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
 * to use native `Date#setX` methods. If you use this function, you may not want to include the
 * other `setX` functions that date-fns provides if you are concerned about the bundle size.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param values - The date values to be set
 * @param options - The options
 *
 * @returns The new date with options set
 *
 * @example
 * // Transform 1 September 2014 into 20 October 2015 in a single line:
 * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
 * //=> Tue Oct 20 2015 00:00:00
 *
 * @example
 * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
 * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
 * //=> Mon Sep 01 2014 12:23:45
 */
export declare function set<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  values: DateValues,
  options?: SetOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\set.d.ts

~~~ts
import type { ContextOptions, DateArg, DateValues } from "./types.js";
/**
 * The {@link set} function options.
 */
export interface SetOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name set
 * @category Common Helpers
 * @summary Set date values to a given date.
 *
 * @description
 * Set date values to a given date.
 *
 * Sets time values to date from object `values`.
 * A value is not set if it is undefined or null or doesn't exist in `values`.
 *
 * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
 * to use native `Date#setX` methods. If you use this function, you may not want to include the
 * other `setX` functions that date-fns provides if you are concerned about the bundle size.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param values - The date values to be set
 * @param options - The options
 *
 * @returns The new date with options set
 *
 * @example
 * // Transform 1 September 2014 into 20 October 2015 in a single line:
 * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
 * //=> Tue Oct 20 2015 00:00:00
 *
 * @example
 * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
 * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
 * //=> Mon Sep 01 2014 12:23:45
 */
export declare function set<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  values: DateValues,
  options?: SetOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\set.js

~~~js
import { constructFrom } from "./constructFrom.js";
import { setMonth } from "./setMonth.js";
import { toDate } from "./toDate.js";

import { setDate as coreSetDate } from "./_core/setDate.js";
import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link set} function options.
 */

/**
 * @name set
 * @category Common Helpers
 * @summary Set date values to a given date.
 *
 * @description
 * Set date values to a given date.
 *
 * Sets time values to date from object `values`.
 * A value is not set if it is undefined or null or doesn't exist in `values`.
 *
 * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
 * to use native `Date#setX` methods. If you use this function, you may not want to include the
 * other `setX` functions that date-fns provides if you are concerned about the bundle size.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param values - The date values to be set
 * @param options - The options
 *
 * @returns The new date with options set
 *
 * @example
 * // Transform 1 September 2014 into 20 October 2015 in a single line:
 * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
 * //=> Tue Oct 20 2015 00:00:00
 *
 * @example
 * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
 * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
 * //=> Mon Sep 01 2014 12:23:45
 */
export function set(date, values, options) {
  let _date = toDate(date, options?.in);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(+_date)) return constructFrom(options?.in || date, NaN);

  if (values.year != null) coreSetFullYear(_date, values.year);
  if (values.month != null) _date = setMonth(_date, values.month);
  if (values.date != null) coreSetDate(_date, values.date);
  if (values.hours != null) _date.setHours(values.hours);
  if (values.minutes != null) _date.setMinutes(values.minutes);
  if (values.seconds != null) _date.setSeconds(values.seconds);
  if (values.milliseconds != null) _date.setMilliseconds(values.milliseconds);

  return _date;
}

// Fallback for modularized imports:
export default set;

~~~

## node_modules\date-fns-jalali\setDate.cjs

~~~cjs
"use strict";
exports.setDate = setDate;
var _index = require("./toDate.cjs");

var _index2 = require("./_core/setDate.cjs");

/**
 * The {@link setDate} function options.
 */

/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param dayOfMonth - The day of the month of the new date
 * @param options - The options
 *
 * @returns The new date with the day of the month set
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */
function setDate(date, dayOfMonth, options) {
  const _date = (0, _index.toDate)(date, options?.in);
  (0, _index2.setDate)(_date, dayOfMonth);
  return _date;
}

~~~

## node_modules\date-fns-jalali\setDate.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setDate} function options.
 */
export interface SetDateOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param dayOfMonth - The day of the month of the new date
 * @param options - The options
 *
 * @returns The new date with the day of the month set
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */
export declare function setDate<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  dayOfMonth: number,
  options?: SetDateOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setDate.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setDate} function options.
 */
export interface SetDateOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param dayOfMonth - The day of the month of the new date
 * @param options - The options
 *
 * @returns The new date with the day of the month set
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */
export declare function setDate<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  dayOfMonth: number,
  options?: SetDateOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setDate.js

~~~js
import { toDate } from "./toDate.js";

import { setDate as coreSetDate } from "./_core/setDate.js";

/**
 * The {@link setDate} function options.
 */

/**
 * @name setDate
 * @category Day Helpers
 * @summary Set the day of the month to the given date.
 *
 * @description
 * Set the day of the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param dayOfMonth - The day of the month of the new date
 * @param options - The options
 *
 * @returns The new date with the day of the month set
 *
 * @example
 * // Set the 30th day of the month to 1 September 2014:
 * const result = setDate(new Date(2014, 8, 1), 30)
 * //=> Tue Sep 30 2014 00:00:00
 */
export function setDate(date, dayOfMonth, options) {
  const _date = toDate(date, options?.in);
  coreSetDate(_date, dayOfMonth);
  return _date;
}

// Fallback for modularized imports:
export default setDate;

~~~

## node_modules\date-fns-jalali\setDay.cjs

~~~cjs
"use strict";
exports.setDay = setDay;
var _index = require("./_lib/defaultOptions.cjs");
var _index2 = require("./addDays.cjs");
var _index3 = require("./toDate.cjs");

/**
 * The {@link setDay} function options.
 */

/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the week of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the day of the week set
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
function setDay(date, day, options) {
  const defaultOptions = (0, _index.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    6;

  const date_ = (0, _index3.toDate)(date, options?.in);
  const currentDay = date_.getDay();

  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;

  const delta = 7 - weekStartsOn;
  const diff =
    day < 0 || day > 6
      ? day - ((currentDay + delta) % 7)
      : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);
  return (0, _index2.addDays)(date_, diff, options);
}

~~~

## node_modules\date-fns-jalali\setDay.d.cts

~~~cts
import type {
  ContextOptions,
  DateArg,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link setDay} function options.
 */
export interface SetDayOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    WeekOptions,
    ContextOptions<DateType> {}
/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the week of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the day of the week set
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
export declare function setDay<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  day: number,
  options?: SetDayOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setDay.d.ts

~~~ts
import type {
  ContextOptions,
  DateArg,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link setDay} function options.
 */
export interface SetDayOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    WeekOptions,
    ContextOptions<DateType> {}
/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the week of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the day of the week set
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
export declare function setDay<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  day: number,
  options?: SetDayOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setDay.js

~~~js
import { getDefaultOptions } from "./_lib/defaultOptions.js";
import { addDays } from "./addDays.js";
import { toDate } from "./toDate.js";

/**
 * The {@link setDay} function options.
 */

/**
 * @name setDay
 * @category Weekday Helpers
 * @summary Set the day of the week to the given date.
 *
 * @description
 * Set the day of the week to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the week of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the day of the week set
 *
 * @example
 * // Set week day to Sunday, with the default weekStartsOn of Sunday:
 * const result = setDay(new Date(2014, 8, 1), 0)
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Set week day to Sunday, with a weekStartsOn of Monday:
 * const result = setDay(new Date(2014, 8, 1), 0, { weekStartsOn: 1 })
 * //=> Sun Sep 07 2014 00:00:00
 */
export function setDay(date, day, options) {
  const defaultOptions = getDefaultOptions();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    6;

  const date_ = toDate(date, options?.in);
  const currentDay = date_.getDay();

  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;

  const delta = 7 - weekStartsOn;
  const diff =
    day < 0 || day > 6
      ? day - ((currentDay + delta) % 7)
      : ((dayIndex + delta) % 7) - ((currentDay + delta) % 7);
  return addDays(date_, diff, options);
}

// Fallback for modularized imports:
export default setDay;

~~~

## node_modules\date-fns-jalali\setDayOfYear.cjs

~~~cjs
"use strict";
exports.setDayOfYear = setDayOfYear;
var _index = require("./toDate.cjs");

var _index2 = require("./_core/setMonth.cjs");
var _index3 = require("./_core/setDate.cjs");

/**
 * The {@link setDayOfYear} function options.
 */

/**
 * @name setDayOfYear
 * @category Day Helpers
 * @summary Set the day of the year to the given date.
 *
 * @description
 * Set the day of the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param dayOfYear - The day of the year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the year set
 *
 * @example
 * // Set the 2nd day of the year to 2 July 2014:
 * const result = setDayOfYear(new Date(2014, 6, 2), 2)
 * //=> Thu Jan 02 2014 00:00:00
 */
function setDayOfYear(date, dayOfYear, options) {
  const date_ = (0, _index.toDate)(date, options?.in);
  (0, _index2.setMonth)(date_, 0);
  (0, _index3.setDate)(date_, dayOfYear);
  return date_;
}

~~~

## node_modules\date-fns-jalali\setDayOfYear.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setDayOfYear} function options.
 */
export interface SetDayOfYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setDayOfYear
 * @category Day Helpers
 * @summary Set the day of the year to the given date.
 *
 * @description
 * Set the day of the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param dayOfYear - The day of the year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the year set
 *
 * @example
 * // Set the 2nd day of the year to 2 July 2014:
 * const result = setDayOfYear(new Date(2014, 6, 2), 2)
 * //=> Thu Jan 02 2014 00:00:00
 */
export declare function setDayOfYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  dayOfYear: number,
  options?: SetDayOfYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setDayOfYear.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setDayOfYear} function options.
 */
export interface SetDayOfYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setDayOfYear
 * @category Day Helpers
 * @summary Set the day of the year to the given date.
 *
 * @description
 * Set the day of the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param dayOfYear - The day of the year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the year set
 *
 * @example
 * // Set the 2nd day of the year to 2 July 2014:
 * const result = setDayOfYear(new Date(2014, 6, 2), 2)
 * //=> Thu Jan 02 2014 00:00:00
 */
export declare function setDayOfYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  dayOfYear: number,
  options?: SetDayOfYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setDayOfYear.js

~~~js
import { toDate } from "./toDate.js";

import { setMonth as coreSetMonth } from "./_core/setMonth.js";
import { setDate as coreSetDate } from "./_core/setDate.js";

/**
 * The {@link setDayOfYear} function options.
 */

/**
 * @name setDayOfYear
 * @category Day Helpers
 * @summary Set the day of the year to the given date.
 *
 * @description
 * Set the day of the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param dayOfYear - The day of the year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the year set
 *
 * @example
 * // Set the 2nd day of the year to 2 July 2014:
 * const result = setDayOfYear(new Date(2014, 6, 2), 2)
 * //=> Thu Jan 02 2014 00:00:00
 */
export function setDayOfYear(date, dayOfYear, options) {
  const date_ = toDate(date, options?.in);
  coreSetMonth(date_, 0);
  coreSetDate(date_, dayOfYear);
  return date_;
}

// Fallback for modularized imports:
export default setDayOfYear;

~~~

## node_modules\date-fns-jalali\setDefaultOptions.cjs

~~~cjs
"use strict";
exports.setDefaultOptions = setDefaultOptions;
var _index = require("./_lib/defaultOptions.cjs");

/**
 * @name setDefaultOptions
 * @category Common Helpers
 * @summary Set default options including locale.
 * @pure false
 *
 * @description
 * Sets the defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * @param options - An object with options
 *
 * @example
 * // Set global locale:
 * import { es } from 'date-fns/locale'
 * setDefaultOptions({ locale: es })
 * const result = format(new Date(2014, 8, 2), 'PPPP')
 * //=> 'martes, 2 de septiembre de 2014'
 *
 * @example
 * // Start of the week for 2 September 2014:
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Start of the week for 2 September 2014,
 * // when we set that week starts on Monday by default:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Mon Sep 01 2014 00:00:00
 *
 * @example
 * // Manually set options take priority over default options:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Remove the option by setting it to `undefined`:
 * setDefaultOptions({ weekStartsOn: 1 })
 * setDefaultOptions({ weekStartsOn: undefined })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 */
function setDefaultOptions(options) {
  const result = {};
  const defaultOptions = (0, _index.getDefaultOptions)();

  for (const property in defaultOptions) {
    if (Object.prototype.hasOwnProperty.call(defaultOptions, property)) {
      // [TODO] I challenge you to fix the type
      result[property] = defaultOptions[property];
    }
  }

  for (const property in options) {
    if (Object.prototype.hasOwnProperty.call(options, property)) {
      if (options[property] === undefined) {
        // [TODO] I challenge you to fix the type
        delete result[property];
      } else {
        // [TODO] I challenge you to fix the type
        result[property] = options[property];
      }
    }
  }

  (0, _index.setDefaultOptions)(result);
}

~~~

## node_modules\date-fns-jalali\setDefaultOptions.d.cts

~~~cts
import type { DefaultOptions } from "./_lib/defaultOptions.js";
/**
 * @name setDefaultOptions
 * @category Common Helpers
 * @summary Set default options including locale.
 * @pure false
 *
 * @description
 * Sets the defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * @param options - An object with options
 *
 * @example
 * // Set global locale:
 * import { es } from 'date-fns/locale'
 * setDefaultOptions({ locale: es })
 * const result = format(new Date(2014, 8, 2), 'PPPP')
 * //=> 'martes, 2 de septiembre de 2014'
 *
 * @example
 * // Start of the week for 2 September 2014:
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Start of the week for 2 September 2014,
 * // when we set that week starts on Monday by default:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Mon Sep 01 2014 00:00:00
 *
 * @example
 * // Manually set options take priority over default options:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Remove the option by setting it to `undefined`:
 * setDefaultOptions({ weekStartsOn: 1 })
 * setDefaultOptions({ weekStartsOn: undefined })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 */
export declare function setDefaultOptions(options: DefaultOptions): void;

~~~

## node_modules\date-fns-jalali\setDefaultOptions.d.ts

~~~ts
import type { DefaultOptions } from "./_lib/defaultOptions.js";
/**
 * @name setDefaultOptions
 * @category Common Helpers
 * @summary Set default options including locale.
 * @pure false
 *
 * @description
 * Sets the defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * @param options - An object with options
 *
 * @example
 * // Set global locale:
 * import { es } from 'date-fns/locale'
 * setDefaultOptions({ locale: es })
 * const result = format(new Date(2014, 8, 2), 'PPPP')
 * //=> 'martes, 2 de septiembre de 2014'
 *
 * @example
 * // Start of the week for 2 September 2014:
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Start of the week for 2 September 2014,
 * // when we set that week starts on Monday by default:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Mon Sep 01 2014 00:00:00
 *
 * @example
 * // Manually set options take priority over default options:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Remove the option by setting it to `undefined`:
 * setDefaultOptions({ weekStartsOn: 1 })
 * setDefaultOptions({ weekStartsOn: undefined })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 */
export declare function setDefaultOptions(options: DefaultOptions): void;

~~~

## node_modules\date-fns-jalali\setDefaultOptions.js

~~~js
import {
  getDefaultOptions,
  setDefaultOptions as setInternalDefaultOptions,
} from "./_lib/defaultOptions.js";

/**
 * @name setDefaultOptions
 * @category Common Helpers
 * @summary Set default options including locale.
 * @pure false
 *
 * @description
 * Sets the defaults for
 * `options.locale`, `options.weekStartsOn` and `options.firstWeekContainsDate`
 * arguments for all functions.
 *
 * @param options - An object with options
 *
 * @example
 * // Set global locale:
 * import { es } from 'date-fns/locale'
 * setDefaultOptions({ locale: es })
 * const result = format(new Date(2014, 8, 2), 'PPPP')
 * //=> 'martes, 2 de septiembre de 2014'
 *
 * @example
 * // Start of the week for 2 September 2014:
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Start of the week for 2 September 2014,
 * // when we set that week starts on Monday by default:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Mon Sep 01 2014 00:00:00
 *
 * @example
 * // Manually set options take priority over default options:
 * setDefaultOptions({ weekStartsOn: 1 })
 * const result = startOfWeek(new Date(2014, 8, 2), { weekStartsOn: 0 })
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // Remove the option by setting it to `undefined`:
 * setDefaultOptions({ weekStartsOn: 1 })
 * setDefaultOptions({ weekStartsOn: undefined })
 * const result = startOfWeek(new Date(2014, 8, 2))
 * //=> Sun Aug 31 2014 00:00:00
 */
export function setDefaultOptions(options) {
  const result = {};
  const defaultOptions = getDefaultOptions();

  for (const property in defaultOptions) {
    if (Object.prototype.hasOwnProperty.call(defaultOptions, property)) {
      // [TODO] I challenge you to fix the type
      result[property] = defaultOptions[property];
    }
  }

  for (const property in options) {
    if (Object.prototype.hasOwnProperty.call(options, property)) {
      if (options[property] === undefined) {
        // [TODO] I challenge you to fix the type
        delete result[property];
      } else {
        // [TODO] I challenge you to fix the type
        result[property] = options[property];
      }
    }
  }

  setInternalDefaultOptions(result);
}

// Fallback for modularized imports:
export default setDefaultOptions;

~~~

## node_modules\date-fns-jalali\setHours.cjs

~~~cjs
"use strict";
exports.setHours = setHours;
var _index = require("./toDate.cjs");

/**
 * The {@link setHours} function options.
 */

/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param hours - The hours of the new date
 * @param options - An object with options
 *
 * @returns The new date with the hours set
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */
function setHours(date, hours, options) {
  const _date = (0, _index.toDate)(date, options?.in);
  _date.setHours(hours);
  return _date;
}

~~~

## node_modules\date-fns-jalali\setHours.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setHours} function options.
 */
export interface SetHoursOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param hours - The hours of the new date
 * @param options - An object with options
 *
 * @returns The new date with the hours set
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */
export declare function setHours<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  hours: number,
  options?: SetHoursOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setHours.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setHours} function options.
 */
export interface SetHoursOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param hours - The hours of the new date
 * @param options - An object with options
 *
 * @returns The new date with the hours set
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */
export declare function setHours<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  hours: number,
  options?: SetHoursOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setHours.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link setHours} function options.
 */

/**
 * @name setHours
 * @category Hour Helpers
 * @summary Set the hours to the given date.
 *
 * @description
 * Set the hours to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param hours - The hours of the new date
 * @param options - An object with options
 *
 * @returns The new date with the hours set
 *
 * @example
 * // Set 4 hours to 1 September 2014 11:30:00:
 * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
 * //=> Mon Sep 01 2014 04:30:00
 */
export function setHours(date, hours, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(hours);
  return _date;
}

// Fallback for modularized imports:
export default setHours;

~~~

## node_modules\date-fns-jalali\setISODay.cjs

~~~cjs
"use strict";
exports.setISODay = setISODay;
var _index = require("./addDays.cjs");
var _index2 = require("./getISODay.cjs");
var _index3 = require("./toDate.cjs");

/**
 * The {@link setISODay} function options.
 */

/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday, etc.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the ISO week set
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */
function setISODay(date, day, options) {
  const date_ = (0, _index3.toDate)(date, options?.in);
  const currentDay = (0, _index2.getISODay)(date_, options);
  const diff = day - currentDay;
  return (0, _index.addDays)(date_, diff, options);
}

~~~

## node_modules\date-fns-jalali\setISODay.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setISODay} function options.
 */
export interface SetISODayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday, etc.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the ISO week set
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */
export declare function setISODay<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  day: number,
  options?: SetISODayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setISODay.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setISODay} function options.
 */
export interface SetISODayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday, etc.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the ISO week set
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */
export declare function setISODay<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  day: number,
  options?: SetISODayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setISODay.js

~~~js
import { addDays } from "./addDays.js";
import { getISODay } from "./getISODay.js";
import { toDate } from "./toDate.js";

/**
 * The {@link setISODay} function options.
 */

/**
 * @name setISODay
 * @category Weekday Helpers
 * @summary Set the day of the ISO week to the given date.
 *
 * @description
 * Set the day of the ISO week to the given date.
 * ISO week starts with Monday.
 * 7 is the index of Sunday, 1 is the index of Monday, etc.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param day - The day of the ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the day of the ISO week set
 *
 * @example
 * // Set Sunday to 1 September 2014:
 * const result = setISODay(new Date(2014, 8, 1), 7)
 * //=> Sun Sep 07 2014 00:00:00
 */
export function setISODay(date, day, options) {
  const date_ = toDate(date, options?.in);
  const currentDay = getISODay(date_, options);
  const diff = day - currentDay;
  return addDays(date_, diff, options);
}

// Fallback for modularized imports:
export default setISODay;

~~~

## node_modules\date-fns-jalali\setISOWeek.cjs

~~~cjs
"use strict";
exports.setISOWeek = setISOWeek;
var _index = require("./getISOWeek.cjs");
var _index2 = require("./toDate.cjs");

/**
 * The {@link setISOWeek} function options.
 */

/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The `Date` type of the context function.
 *
 * @param date - The date to be changed
 * @param week - The ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week set
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */
function setISOWeek(date, week, options) {
  const _date = (0, _index2.toDate)(date, options?.in);
  const diff = (0, _index.getISOWeek)(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

~~~

## node_modules\date-fns-jalali\setISOWeek.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setISOWeek} function options.
 */
export interface SetISOWeekOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The `Date` type of the context function.
 *
 * @param date - The date to be changed
 * @param week - The ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week set
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */
export declare function setISOWeek<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  week: number,
  options?: SetISOWeekOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setISOWeek.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setISOWeek} function options.
 */
export interface SetISOWeekOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The `Date` type of the context function.
 *
 * @param date - The date to be changed
 * @param week - The ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week set
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */
export declare function setISOWeek<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  week: number,
  options?: SetISOWeekOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setISOWeek.js

~~~js
import { getISOWeek } from "./getISOWeek.js";
import { toDate } from "./toDate.js";

/**
 * The {@link setISOWeek} function options.
 */

/**
 * @name setISOWeek
 * @category ISO Week Helpers
 * @summary Set the ISO week to the given date.
 *
 * @description
 * Set the ISO week to the given date, saving the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The `Date` type of the context function.
 *
 * @param date - The date to be changed
 * @param week - The ISO week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week set
 *
 * @example
 * // Set the 53rd ISO week to 7 August 2004:
 * const result = setISOWeek(new Date(2004, 7, 7), 53)
 * //=> Sat Jan 01 2005 00:00:00
 */
export function setISOWeek(date, week, options) {
  const _date = toDate(date, options?.in);
  const diff = getISOWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// Fallback for modularized imports:
export default setISOWeek;

~~~

## node_modules\date-fns-jalali\setISOWeekYear.cjs

~~~cjs
"use strict";
exports.setISOWeekYear = setISOWeekYear;
var _index = require("./constructFrom.cjs");
var _index2 = require("./differenceInCalendarDays.cjs");
var _index3 = require("./startOfISOWeekYear.cjs");
var _index4 = require("./toDate.cjs");

/**
 * The {@link setISOWeekYear} function options.
 */

/**
 * @name setISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Set the ISO week-numbering year to the given date.
 *
 * @description
 * Set the ISO week-numbering year to the given date,
 * saving the week number and the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param weekYear - The ISO week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week-numbering year set
 *
 * @example
 * // Set ISO week-numbering year 2007 to 29 December 2008:
 * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
 * //=> Mon Jan 01 2007 00:00:00
 */
function setISOWeekYear(date, weekYear, options) {
  let _date = (0, _index4.toDate)(date, options?.in);
  const diff = (0, _index2.differenceInCalendarDays)(
    _date,
    (0, _index3.startOfISOWeekYear)(_date, options),
  );
  const fourthOfJanuary = (0, _index.constructFrom)(options?.in || date, 0);
  fourthOfJanuary.setFullYear(weekYear, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  _date = (0, _index3.startOfISOWeekYear)(fourthOfJanuary);
  _date.setDate(_date.getDate() + diff);
  return _date;
}

~~~

## node_modules\date-fns-jalali\setISOWeekYear.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setISOWeekYear} function options.
 */
export interface SetISOWeekYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Set the ISO week-numbering year to the given date.
 *
 * @description
 * Set the ISO week-numbering year to the given date,
 * saving the week number and the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param weekYear - The ISO week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week-numbering year set
 *
 * @example
 * // Set ISO week-numbering year 2007 to 29 December 2008:
 * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
 * //=> Mon Jan 01 2007 00:00:00
 */
export declare function setISOWeekYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  weekYear: number,
  options?: SetISOWeekYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setISOWeekYear.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setISOWeekYear} function options.
 */
export interface SetISOWeekYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Set the ISO week-numbering year to the given date.
 *
 * @description
 * Set the ISO week-numbering year to the given date,
 * saving the week number and the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param weekYear - The ISO week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week-numbering year set
 *
 * @example
 * // Set ISO week-numbering year 2007 to 29 December 2008:
 * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
 * //=> Mon Jan 01 2007 00:00:00
 */
export declare function setISOWeekYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  weekYear: number,
  options?: SetISOWeekYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setISOWeekYear.js

~~~js
import { constructFrom } from "./constructFrom.js";
import { differenceInCalendarDays } from "./differenceInCalendarDays.js";
import { startOfISOWeekYear } from "./startOfISOWeekYear.js";
import { toDate } from "./toDate.js";

/**
 * The {@link setISOWeekYear} function options.
 */

/**
 * @name setISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Set the ISO week-numbering year to the given date.
 *
 * @description
 * Set the ISO week-numbering year to the given date,
 * saving the week number and the weekday number.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param weekYear - The ISO week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the ISO week-numbering year set
 *
 * @example
 * // Set ISO week-numbering year 2007 to 29 December 2008:
 * const result = setISOWeekYear(new Date(2008, 11, 29), 2007)
 * //=> Mon Jan 01 2007 00:00:00
 */
export function setISOWeekYear(date, weekYear, options) {
  let _date = toDate(date, options?.in);
  const diff = differenceInCalendarDays(
    _date,
    startOfISOWeekYear(_date, options),
  );
  const fourthOfJanuary = constructFrom(options?.in || date, 0);
  fourthOfJanuary.setFullYear(weekYear, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  _date = startOfISOWeekYear(fourthOfJanuary);
  _date.setDate(_date.getDate() + diff);
  return _date;
}

// Fallback for modularized imports:
export default setISOWeekYear;

~~~

## node_modules\date-fns-jalali\setMilliseconds.cjs

~~~cjs
"use strict";
exports.setMilliseconds = setMilliseconds;
var _index = require("./toDate.cjs");

/**
 * The {@link setMilliseconds} function options.
 */

/**
 * @name setMilliseconds
 * @category Millisecond Helpers
 * @summary Set the milliseconds to the given date.
 *
 * @description
 * Set the milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param milliseconds - The milliseconds of the new date
 * @param options - The options
 *
 * @returns The new date with the milliseconds set
 *
 * @example
 * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
 * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
 * //=> Mon Sep 01 2014 11:30:40.300
 */
function setMilliseconds(date, milliseconds, options) {
  const _date = (0, _index.toDate)(date, options?.in);
  _date.setMilliseconds(milliseconds);
  return _date;
}

~~~

## node_modules\date-fns-jalali\setMilliseconds.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setMilliseconds} function options.
 */
export interface SetMillisecondsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setMilliseconds
 * @category Millisecond Helpers
 * @summary Set the milliseconds to the given date.
 *
 * @description
 * Set the milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param milliseconds - The milliseconds of the new date
 * @param options - The options
 *
 * @returns The new date with the milliseconds set
 *
 * @example
 * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
 * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
 * //=> Mon Sep 01 2014 11:30:40.300
 */
export declare function setMilliseconds<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  milliseconds: number,
  options?: SetMillisecondsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setMilliseconds.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setMilliseconds} function options.
 */
export interface SetMillisecondsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setMilliseconds
 * @category Millisecond Helpers
 * @summary Set the milliseconds to the given date.
 *
 * @description
 * Set the milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param milliseconds - The milliseconds of the new date
 * @param options - The options
 *
 * @returns The new date with the milliseconds set
 *
 * @example
 * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
 * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
 * //=> Mon Sep 01 2014 11:30:40.300
 */
export declare function setMilliseconds<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  milliseconds: number,
  options?: SetMillisecondsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setMilliseconds.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link setMilliseconds} function options.
 */

/**
 * @name setMilliseconds
 * @category Millisecond Helpers
 * @summary Set the milliseconds to the given date.
 *
 * @description
 * Set the milliseconds to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param milliseconds - The milliseconds of the new date
 * @param options - The options
 *
 * @returns The new date with the milliseconds set
 *
 * @example
 * // Set 300 milliseconds to 1 September 2014 11:30:40.500:
 * const result = setMilliseconds(new Date(2014, 8, 1, 11, 30, 40, 500), 300)
 * //=> Mon Sep 01 2014 11:30:40.300
 */
export function setMilliseconds(date, milliseconds, options) {
  const _date = toDate(date, options?.in);
  _date.setMilliseconds(milliseconds);
  return _date;
}

// Fallback for modularized imports:
export default setMilliseconds;

~~~

## node_modules\date-fns-jalali\setMinutes.cjs

~~~cjs
"use strict";
exports.setMinutes = setMinutes;
var _index = require("./toDate.cjs");

/**
 * The {@link setMinutes} function options.
 */

/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, returned from the context function, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param minutes - The minutes of the new date
 * @param options - An object with options
 *
 * @returns The new date with the minutes set
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */
function setMinutes(date, minutes, options) {
  const date_ = (0, _index.toDate)(date, options?.in);
  date_.setMinutes(minutes);
  return date_;
}

~~~

## node_modules\date-fns-jalali\setMinutes.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setMinutes} function options.
 */
export interface SetMinutesOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, returned from the context function, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param minutes - The minutes of the new date
 * @param options - An object with options
 *
 * @returns The new date with the minutes set
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */
export declare function setMinutes<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  minutes: number,
  options?: SetMinutesOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setMinutes.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setMinutes} function options.
 */
export interface SetMinutesOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, returned from the context function, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param minutes - The minutes of the new date
 * @param options - An object with options
 *
 * @returns The new date with the minutes set
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */
export declare function setMinutes<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  minutes: number,
  options?: SetMinutesOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setMinutes.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link setMinutes} function options.
 */

/**
 * @name setMinutes
 * @category Minute Helpers
 * @summary Set the minutes to the given date.
 *
 * @description
 * Set the minutes to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows using extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, returned from the context function, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param minutes - The minutes of the new date
 * @param options - An object with options
 *
 * @returns The new date with the minutes set
 *
 * @example
 * // Set 45 minutes to 1 September 2014 11:30:40:
 * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:45:40
 */
export function setMinutes(date, minutes, options) {
  const date_ = toDate(date, options?.in);
  date_.setMinutes(minutes);
  return date_;
}

// Fallback for modularized imports:
export default setMinutes;

~~~

## node_modules\date-fns-jalali\setMonth.cjs

~~~cjs
"use strict";
exports.setMonth = setMonth;
var _index = require("./constructFrom.cjs");
var _index2 = require("./getDaysInMonth.cjs");
var _index3 = require("./toDate.cjs");

var _index4 = require("./_core/setMonth.cjs");
var _index5 = require("./_core/getDate.cjs");
var _index6 = require("./_core/getFullYear.cjs");
var _index7 = require("./_core/setFullYear.cjs");

/**
 * The {@link setMonth} function options.
 */

/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param month - The month index to set (0-11)
 * @param options - The options
 *
 * @returns The new date with the month set
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */
function setMonth(date, month, options) {
  const _date = (0, _index3.toDate)(date, options?.in);
  const year = (0, _index6.getFullYear)(_date);
  const day = (0, _index5.getDate)(_date);

  const midMonth = (0, _index.constructFrom)(options?.in || date, 0);
  (0, _index7.setFullYear)(midMonth, year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = (0, _index2.getDaysInMonth)(midMonth);

  // Set the earlier date, allows to wrap Jan 31 to Feb 28
  (0, _index4.setMonth)(_date, month, Math.min(day, daysInMonth));
  return _date;
}

~~~

## node_modules\date-fns-jalali\setMonth.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setMonth} function options.
 */
export interface SetMonthOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param month - The month index to set (0-11)
 * @param options - The options
 *
 * @returns The new date with the month set
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */
export declare function setMonth<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  month: number,
  options?: SetMonthOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setMonth.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setMonth} function options.
 */
export interface SetMonthOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param month - The month index to set (0-11)
 * @param options - The options
 *
 * @returns The new date with the month set
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */
export declare function setMonth<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  month: number,
  options?: SetMonthOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setMonth.js

~~~js
import { constructFrom } from "./constructFrom.js";
import { getDaysInMonth } from "./getDaysInMonth.js";
import { toDate } from "./toDate.js";

import { setMonth as coreSetMonth } from "./_core/setMonth.js";
import { getDate as coreGetDate } from "./_core/getDate.js";
import { getFullYear as coreGetFullYear } from "./_core/getFullYear.js";
import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link setMonth} function options.
 */

/**
 * @name setMonth
 * @category Month Helpers
 * @summary Set the month to the given date.
 *
 * @description
 * Set the month to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param month - The month index to set (0-11)
 * @param options - The options
 *
 * @returns The new date with the month set
 *
 * @example
 * // Set February to 1 September 2014:
 * const result = setMonth(new Date(2014, 8, 1), 1)
 * //=> Sat Feb 01 2014 00:00:00
 */
export function setMonth(date, month, options) {
  const _date = toDate(date, options?.in);
  const year = coreGetFullYear(_date);
  const day = coreGetDate(_date);

  const midMonth = constructFrom(options?.in || date, 0);
  coreSetFullYear(midMonth, year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(midMonth);

  // Set the earlier date, allows to wrap Jan 31 to Feb 28
  coreSetMonth(_date, month, Math.min(day, daysInMonth));
  return _date;
}

// Fallback for modularized imports:
export default setMonth;

~~~

## node_modules\date-fns-jalali\setQuarter.cjs

~~~cjs
"use strict";
exports.setQuarter = setQuarter;
var _index = require("./setMonth.cjs");
var _index2 = require("./toDate.cjs");

var _index3 = require("./_core/getMonth.cjs");

/**
 * The {@link setQuarter} function options.
 */

/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param quarter - The quarter of the new date
 * @param options - The options
 *
 * @returns The new date with the quarter set
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */
function setQuarter(date, quarter, options) {
  const date_ = (0, _index2.toDate)(date, options?.in);
  const oldQuarter = Math.trunc((0, _index3.getMonth)(date_) / 3) + 1;
  const diff = quarter - oldQuarter;
  return (0, _index.setMonth)(date_, (0, _index3.getMonth)(date_) + diff * 3);
}

~~~

## node_modules\date-fns-jalali\setQuarter.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setQuarter} function options.
 */
export interface SetQuarterOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param quarter - The quarter of the new date
 * @param options - The options
 *
 * @returns The new date with the quarter set
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */
export declare function setQuarter<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  quarter: number,
  options?: SetQuarterOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setQuarter.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setQuarter} function options.
 */
export interface SetQuarterOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param quarter - The quarter of the new date
 * @param options - The options
 *
 * @returns The new date with the quarter set
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */
export declare function setQuarter<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  quarter: number,
  options?: SetQuarterOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setQuarter.js

~~~js
import { setMonth } from "./setMonth.js";
import { toDate } from "./toDate.js";

import { getMonth as coreGetMonth } from "./_core/getMonth.js";

/**
 * The {@link setQuarter} function options.
 */

/**
 * @name setQuarter
 * @category Quarter Helpers
 * @summary Set the year quarter to the given date.
 *
 * @description
 * Set the year quarter to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param quarter - The quarter of the new date
 * @param options - The options
 *
 * @returns The new date with the quarter set
 *
 * @example
 * // Set the 2nd quarter to 2 July 2014:
 * const result = setQuarter(new Date(2014, 6, 2), 2)
 * //=> Wed Apr 02 2014 00:00:00
 */
export function setQuarter(date, quarter, options) {
  const date_ = toDate(date, options?.in);
  const oldQuarter = Math.trunc(coreGetMonth(date_) / 3) + 1;
  const diff = quarter - oldQuarter;
  return setMonth(date_, coreGetMonth(date_) + diff * 3);
}

// Fallback for modularized imports:
export default setQuarter;

~~~

## node_modules\date-fns-jalali\setSeconds.cjs

~~~cjs
"use strict";
exports.setSeconds = setSeconds;
var _index = require("./toDate.cjs");

/**
 * The {@link setSeconds} function options.
 */

/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date, with context support.
 *
 * @description
 * Set the seconds to the given date, with an optional context for time zone specification.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param seconds - The seconds of the new date
 * @param options - An object with options
 *
 * @returns The new date with the seconds set
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */
function setSeconds(date, seconds, options) {
  const _date = (0, _index.toDate)(date, options?.in);
  _date.setSeconds(seconds);
  return _date;
}

~~~

## node_modules\date-fns-jalali\setSeconds.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setSeconds} function options.
 */
export interface SetSecondsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date, with context support.
 *
 * @description
 * Set the seconds to the given date, with an optional context for time zone specification.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param seconds - The seconds of the new date
 * @param options - An object with options
 *
 * @returns The new date with the seconds set
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */
export declare function setSeconds<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  seconds: number,
  options?: SetSecondsOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setSeconds.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setSeconds} function options.
 */
export interface SetSecondsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date, with context support.
 *
 * @description
 * Set the seconds to the given date, with an optional context for time zone specification.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param seconds - The seconds of the new date
 * @param options - An object with options
 *
 * @returns The new date with the seconds set
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */
export declare function setSeconds<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  seconds: number,
  options?: SetSecondsOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setSeconds.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link setSeconds} function options.
 */

/**
 * @name setSeconds
 * @category Second Helpers
 * @summary Set the seconds to the given date, with context support.
 *
 * @description
 * Set the seconds to the given date, with an optional context for time zone specification.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param seconds - The seconds of the new date
 * @param options - An object with options
 *
 * @returns The new date with the seconds set
 *
 * @example
 * // Set 45 seconds to 1 September 2014 11:30:40:
 * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
 * //=> Mon Sep 01 2014 11:30:45
 */
export function setSeconds(date, seconds, options) {
  const _date = toDate(date, options?.in);
  _date.setSeconds(seconds);
  return _date;
}

// Fallback for modularized imports:
export default setSeconds;

~~~

## node_modules\date-fns-jalali\setWeek.cjs

~~~cjs
"use strict";
exports.setWeek = setWeek;
var _index = require("./getWeek.cjs");
var _index2 = require("./toDate.cjs");

var _index3 = require("./_core/getDate.cjs");
var _index4 = require("./_core/setDate.cjs");

/**
 * The {@link setWeek} function options.
 */

/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param week - The week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week set
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
function setWeek(date, week, options) {
  const date_ = (0, _index2.toDate)(date, options?.in);
  const diff = (0, _index.getWeek)(date_, options) - week;
  (0, _index4.setDate)(date_, (0, _index3.getDate)(date_) - diff * 7);
  return (0, _index2.toDate)(date_, options?.in);
}

~~~

## node_modules\date-fns-jalali\setWeek.d.cts

~~~cts
import type {
  ContextOptions,
  DateArg,
  FirstWeekContainsDateOptions,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link setWeek} function options.
 */
export interface SetWeekOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    WeekOptions,
    FirstWeekContainsDateOptions,
    ContextOptions<DateType> {}
/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param week - The week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week set
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
export declare function setWeek<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  week: number,
  options?: SetWeekOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setWeek.d.ts

~~~ts
import type {
  ContextOptions,
  DateArg,
  FirstWeekContainsDateOptions,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link setWeek} function options.
 */
export interface SetWeekOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    WeekOptions,
    FirstWeekContainsDateOptions,
    ContextOptions<DateType> {}
/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param week - The week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week set
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
export declare function setWeek<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  week: number,
  options?: SetWeekOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setWeek.js

~~~js
import { getWeek } from "./getWeek.js";
import { toDate } from "./toDate.js";

import { getDate as coreGetDate } from "./_core/getDate.js";
import { setDate as coreSetDate } from "./_core/setDate.js";

/**
 * The {@link setWeek} function options.
 */

/**
 * @name setWeek
 * @category Week Helpers
 * @summary Set the local week to the given date.
 *
 * @description
 * Set the local week to the given date, saving the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param week - The week of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week set
 *
 * @example
 * // Set the 1st week to 2 January 2005 with default options:
 * const result = setWeek(new Date(2005, 0, 2), 1)
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // Set the 1st week to 2 January 2005,
 * // if Monday is the first day of the week,
 * // and the first week of the year always contains 4 January:
 * const result = setWeek(new Date(2005, 0, 2), 1, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sun Jan 4 2004 00:00:00
 */
export function setWeek(date, week, options) {
  const date_ = toDate(date, options?.in);
  const diff = getWeek(date_, options) - week;
  coreSetDate(date_, coreGetDate(date_) - diff * 7);
  return toDate(date_, options?.in);
}

// Fallback for modularized imports:
export default setWeek;

~~~

## node_modules\date-fns-jalali\setWeekYear.cjs

~~~cjs
"use strict";
exports.setWeekYear = setWeekYear;
var _index = require("./_lib/defaultOptions.cjs");
var _index2 = require("./constructFrom.cjs");
var _index3 = require("./differenceInCalendarDays.cjs");
var _index4 = require("./startOfWeekYear.cjs");
var _index5 = require("./toDate.cjs");

var _index6 = require("./_core/getDate.cjs");
var _index7 = require("./_core/setDate.cjs");
var _index8 = require("./_core/setFullYear.cjs");

/**
 * The {@link setWeekYear} function options.
 */

/**
 * @name setWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Set the local week-numbering year to the given date.
 *
 * @description
 * Set the local week-numbering year to the given date,
 * saving the week number and the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param weekYear - The local week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week-numbering year set
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004)
 * //=> Sat Jan 03 2004 00:00:00
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010,
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sat Jan 01 2005 00:00:00
 */
function setWeekYear(date, weekYear, options) {
  const defaultOptions = (0, _index.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const diff = (0, _index3.differenceInCalendarDays)(
    (0, _index5.toDate)(date, options?.in),
    (0, _index4.startOfWeekYear)(date, options),
    options,
  );

  const firstWeek = (0, _index2.constructFrom)(options?.in || date, 0);
  (0, _index8.setFullYear)(firstWeek, weekYear, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);

  const date_ = (0, _index4.startOfWeekYear)(firstWeek, options);
  (0, _index7.setDate)(date_, (0, _index6.getDate)(date_) + diff);
  return date_;
}

~~~

## node_modules\date-fns-jalali\setWeekYear.d.cts

~~~cts
import type {
  ContextOptions,
  DateArg,
  FirstWeekContainsDateOptions,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link setWeekYear} function options.
 */
export interface SetWeekYearOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    WeekOptions,
    FirstWeekContainsDateOptions,
    ContextOptions<DateType> {}
/**
 * @name setWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Set the local week-numbering year to the given date.
 *
 * @description
 * Set the local week-numbering year to the given date,
 * saving the week number and the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param weekYear - The local week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week-numbering year set
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004)
 * //=> Sat Jan 03 2004 00:00:00
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010,
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sat Jan 01 2005 00:00:00
 */
export declare function setWeekYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  weekYear: number,
  options?: SetWeekYearOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setWeekYear.d.ts

~~~ts
import type {
  ContextOptions,
  DateArg,
  FirstWeekContainsDateOptions,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link setWeekYear} function options.
 */
export interface SetWeekYearOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    WeekOptions,
    FirstWeekContainsDateOptions,
    ContextOptions<DateType> {}
/**
 * @name setWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Set the local week-numbering year to the given date.
 *
 * @description
 * Set the local week-numbering year to the given date,
 * saving the week number and the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param weekYear - The local week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week-numbering year set
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004)
 * //=> Sat Jan 03 2004 00:00:00
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010,
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sat Jan 01 2005 00:00:00
 */
export declare function setWeekYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  weekYear: number,
  options?: SetWeekYearOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setWeekYear.js

~~~js
import { getDefaultOptions } from "./_lib/defaultOptions.js";
import { constructFrom } from "./constructFrom.js";
import { differenceInCalendarDays } from "./differenceInCalendarDays.js";
import { startOfWeekYear } from "./startOfWeekYear.js";
import { toDate } from "./toDate.js";

import { getDate as coreGetDate } from "./_core/getDate.js";
import { setDate as coreSetDate } from "./_core/setDate.js";
import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link setWeekYear} function options.
 */

/**
 * @name setWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Set the local week-numbering year to the given date.
 *
 * @description
 * Set the local week-numbering year to the given date,
 * saving the week number and the weekday number.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param weekYear - The local week-numbering year of the new date
 * @param options - An object with options
 *
 * @returns The new date with the local week-numbering year set
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010 with default options:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004)
 * //=> Sat Jan 03 2004 00:00:00
 *
 * @example
 * // Set the local week-numbering year 2004 to 2 January 2010,
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = setWeekYear(new Date(2010, 0, 2), 2004, {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Sat Jan 01 2005 00:00:00
 */
export function setWeekYear(date, weekYear, options) {
  const defaultOptions = getDefaultOptions();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const diff = differenceInCalendarDays(
    toDate(date, options?.in),
    startOfWeekYear(date, options),
    options,
  );

  const firstWeek = constructFrom(options?.in || date, 0);
  coreSetFullYear(firstWeek, weekYear, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);

  const date_ = startOfWeekYear(firstWeek, options);
  coreSetDate(date_, coreGetDate(date_) + diff);
  return date_;
}

// Fallback for modularized imports:
export default setWeekYear;

~~~

## node_modules\date-fns-jalali\setYear.cjs

~~~cjs
"use strict";
exports.setYear = setYear;
var _index = require("./constructFrom.cjs");
var _index2 = require("./toDate.cjs");

var _index3 = require("./_core/setFullYear.cjs");

/**
 * The {@link setYear} function options.
 */

/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param year - The year of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the year set
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */
function setYear(date, year, options) {
  const date_ = (0, _index2.toDate)(date, options?.in);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(+date_)) return (0, _index.constructFrom)(options?.in || date, NaN);

  (0, _index3.setFullYear)(date_, year);
  return date_;
}

~~~

## node_modules\date-fns-jalali\setYear.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setYear} function options.
 */
export interface SetYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param year - The year of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the year set
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */
export declare function setYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  year: number,
  options?: SetYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setYear.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link setYear} function options.
 */
export interface SetYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param year - The year of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the year set
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */
export declare function setYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  year: number,
  options?: SetYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\setYear.js

~~~js
import { constructFrom } from "./constructFrom.js";
import { toDate } from "./toDate.js";

import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link setYear} function options.
 */

/**
 * @name setYear
 * @category Year Helpers
 * @summary Set the year to the given date.
 *
 * @description
 * Set the year to the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param year - The year of the new date
 * @param options - An object with options.
 *
 * @returns The new date with the year set
 *
 * @example
 * // Set year 2013 to 1 September 2014:
 * const result = setYear(new Date(2014, 8, 1), 2013)
 * //=> Sun Sep 01 2013 00:00:00
 */
export function setYear(date, year, options) {
  const date_ = toDate(date, options?.in);

  // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
  if (isNaN(+date_)) return constructFrom(options?.in || date, NaN);

  coreSetFullYear(date_, year);
  return date_;
}

// Fallback for modularized imports:
export default setYear;

~~~

## node_modules\date-fns-jalali\startOfDay.cjs

~~~cjs
"use strict";
exports.startOfDay = startOfDay;
var _index = require("./toDate.cjs");

/**
 * The {@link startOfDay} function options.
 */

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
function startOfDay(date, options) {
  const _date = (0, _index.toDate)(date, options?.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

~~~

## node_modules\date-fns-jalali\startOfDay.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfDay} function options.
 */
export interface StartOfDayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
export declare function startOfDay<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfDayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfDay.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfDay} function options.
 */
export interface StartOfDayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
export declare function startOfDay<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfDayOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfDay.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link startOfDay} function options.
 */

/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a day
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */
export function startOfDay(date, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
export default startOfDay;

~~~

## node_modules\date-fns-jalali\startOfDecade.cjs

~~~cjs
"use strict";
exports.startOfDecade = startOfDecade;
var _index = require("./toDate.cjs");

var _index2 = require("./_core/getFullYear.cjs");
var _index3 = require("./_core/setFullYear.cjs");

/**
 * The {@link startOfDecade} options.
 */

/**
 * @name startOfDecade
 * @category Decade Helpers
 * @summary Return the start of a decade for the given date.
 *
 * @description
 * Return the start of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a decade
 *
 * @example
 * // The start of a decade for 21 October 2015 00:00:00:
 * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
 * //=> Jan 01 2010 00:00:00
 */
function startOfDecade(date, options) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = (0, _index.toDate)(date, options?.in);
  const year = (0, _index2.getFullYear)(_date);
  const decade = Math.floor(year / 10) * 10;
  (0, _index3.setFullYear)(_date, decade, 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

~~~

## node_modules\date-fns-jalali\startOfDecade.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfDecade} options.
 */
export interface StartOfDecadeOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfDecade
 * @category Decade Helpers
 * @summary Return the start of a decade for the given date.
 *
 * @description
 * Return the start of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a decade
 *
 * @example
 * // The start of a decade for 21 October 2015 00:00:00:
 * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
 * //=> Jan 01 2010 00:00:00
 */
export declare function startOfDecade<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfDecadeOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfDecade.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfDecade} options.
 */
export interface StartOfDecadeOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfDecade
 * @category Decade Helpers
 * @summary Return the start of a decade for the given date.
 *
 * @description
 * Return the start of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a decade
 *
 * @example
 * // The start of a decade for 21 October 2015 00:00:00:
 * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
 * //=> Jan 01 2010 00:00:00
 */
export declare function startOfDecade<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfDecadeOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfDecade.js

~~~js
import { toDate } from "./toDate.js";

import { getFullYear as coreGetFullYear } from "./_core/getFullYear.js";
import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link startOfDecade} options.
 */

/**
 * @name startOfDecade
 * @category Decade Helpers
 * @summary Return the start of a decade for the given date.
 *
 * @description
 * Return the start of a decade for the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a decade
 *
 * @example
 * // The start of a decade for 21 October 2015 00:00:00:
 * const result = startOfDecade(new Date(2015, 9, 21, 00, 00, 00))
 * //=> Jan 01 2010 00:00:00
 */
export function startOfDecade(date, options) {
  // TODO: Switch to more technical definition in of decades that start with 1
  // end with 0. I.e. 2001-2010 instead of current 2000-2009. It's a breaking
  // change, so it can only be done in 4.0.
  const _date = toDate(date, options?.in);
  const year = coreGetFullYear(_date);
  const decade = Math.floor(year / 10) * 10;
  coreSetFullYear(_date, decade, 0, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
export default startOfDecade;

~~~

## node_modules\date-fns-jalali\startOfHour.cjs

~~~cjs
"use strict";
exports.startOfHour = startOfHour;
var _index = require("./toDate.cjs");

/**
 * The {@link startOfHour} function options.
 */

/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an hour
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */
function startOfHour(date, options) {
  const _date = (0, _index.toDate)(date, options?.in);
  _date.setMinutes(0, 0, 0);
  return _date;
}

~~~

## node_modules\date-fns-jalali\startOfHour.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfHour} function options.
 */
export interface StartOfHourOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an hour
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */
export declare function startOfHour<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfHourOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfHour.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfHour} function options.
 */
export interface StartOfHourOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an hour
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */
export declare function startOfHour<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfHourOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfHour.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link startOfHour} function options.
 */

/**
 * @name startOfHour
 * @category Hour Helpers
 * @summary Return the start of an hour for the given date.
 *
 * @description
 * Return the start of an hour for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an hour
 *
 * @example
 * // The start of an hour for 2 September 2014 11:55:00:
 * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
 * //=> Tue Sep 02 2014 11:00:00
 */
export function startOfHour(date, options) {
  const _date = toDate(date, options?.in);
  _date.setMinutes(0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
export default startOfHour;

~~~

## node_modules\date-fns-jalali\startOfISOWeek.cjs

~~~cjs
"use strict";
exports.startOfISOWeek = startOfISOWeek;
var _index = require("./startOfWeek.cjs");

/**
 * The {@link startOfISOWeek} function options.
 */

/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfISOWeek(date, options) {
  return (0, _index.startOfWeek)(date, { ...options, weekStartsOn: 1 });
}

~~~

## node_modules\date-fns-jalali\startOfISOWeek.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfISOWeek} function options.
 */
export interface StartOfISOWeekOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
export declare function startOfISOWeek<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfISOWeekOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfISOWeek.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfISOWeek} function options.
 */
export interface StartOfISOWeekOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
export declare function startOfISOWeek<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfISOWeekOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfISOWeek.js

~~~js
import { startOfWeek } from "./startOfWeek.js";

/**
 * The {@link startOfISOWeek} function options.
 */

/**
 * @name startOfISOWeek
 * @category ISO Week Helpers
 * @summary Return the start of an ISO week for the given date.
 *
 * @description
 * Return the start of an ISO week for the given date.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week
 *
 * @example
 * // The start of an ISO week for 2 September 2014 11:55:00:
 * const result = startOfISOWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
export function startOfISOWeek(date, options) {
  return startOfWeek(date, { ...options, weekStartsOn: 1 });
}

// Fallback for modularized imports:
export default startOfISOWeek;

~~~

## node_modules\date-fns-jalali\startOfISOWeekYear.cjs

~~~cjs
"use strict";
exports.startOfISOWeekYear = startOfISOWeekYear;
var _index = require("./constructFrom.cjs");
var _index2 = require("./getISOWeekYear.cjs");
var _index3 = require("./startOfISOWeek.cjs");

/**
 * The {@link startOfISOWeekYear} function options.
 */

/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfISOWeekYear(date, options) {
  const year = (0, _index2.getISOWeekYear)(date, options);
  const fourthOfJanuary = (0, _index.constructFrom)(options?.in || date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return (0, _index3.startOfISOWeek)(fourthOfJanuary);
}

~~~

## node_modules\date-fns-jalali\startOfISOWeekYear.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfISOWeekYear} function options.
 */
export interface StartOfISOWeekYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
export declare function startOfISOWeekYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfISOWeekYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfISOWeekYear.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfISOWeekYear} function options.
 */
export interface StartOfISOWeekYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
export declare function startOfISOWeekYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfISOWeekYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfISOWeekYear.js

~~~js
import { constructFrom } from "./constructFrom.js";
import { getISOWeekYear } from "./getISOWeekYear.js";
import { startOfISOWeek } from "./startOfISOWeek.js";

/**
 * The {@link startOfISOWeekYear} function options.
 */

/**
 * @name startOfISOWeekYear
 * @category ISO Week-Numbering Year Helpers
 * @summary Return the start of an ISO week-numbering year for the given date.
 *
 * @description
 * Return the start of an ISO week-numbering year,
 * which always starts 3 days before the year's first Thursday.
 * The result will be in the local timezone.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of an ISO week-numbering year
 *
 * @example
 * // The start of an ISO week-numbering year for 2 July 2005:
 * const result = startOfISOWeekYear(new Date(2005, 6, 2))
 * //=> Mon Jan 03 2005 00:00:00
 */
export function startOfISOWeekYear(date, options) {
  const year = getISOWeekYear(date, options);
  const fourthOfJanuary = constructFrom(options?.in || date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// Fallback for modularized imports:
export default startOfISOWeekYear;

~~~

## node_modules\date-fns-jalali\startOfMinute.cjs

~~~cjs
"use strict";
exports.startOfMinute = startOfMinute;
var _index = require("./toDate.cjs");

/**
 * The {@link startOfMinute} function options.
 */

/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a minute
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */
function startOfMinute(date, options) {
  const date_ = (0, _index.toDate)(date, options?.in);
  date_.setSeconds(0, 0);
  return date_;
}

~~~

## node_modules\date-fns-jalali\startOfMinute.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfMinute} function options.
 */
export interface StartOfMinuteOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a minute
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */
export declare function startOfMinute<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfMinuteOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfMinute.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfMinute} function options.
 */
export interface StartOfMinuteOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a minute
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */
export declare function startOfMinute<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfMinuteOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfMinute.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link startOfMinute} function options.
 */

/**
 * @name startOfMinute
 * @category Minute Helpers
 * @summary Return the start of a minute for the given date.
 *
 * @description
 * Return the start of a minute for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a minute
 *
 * @example
 * // The start of a minute for 1 December 2014 22:15:45.400:
 * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:00
 */
export function startOfMinute(date, options) {
  const date_ = toDate(date, options?.in);
  date_.setSeconds(0, 0);
  return date_;
}

// Fallback for modularized imports:
export default startOfMinute;

~~~

## node_modules\date-fns-jalali\startOfMonth.cjs

~~~cjs
"use strict";
exports.startOfMonth = startOfMonth;
var _index = require("./toDate.cjs");

var _index2 = require("./_core/setDate.cjs");

/**
 * The {@link startOfMonth} function options.
 */

/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date. The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments.
 * Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed,
 * or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a month
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfMonth(date, options) {
  const _date = (0, _index.toDate)(date, options?.in);
  (0, _index2.setDate)(_date, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

~~~

## node_modules\date-fns-jalali\startOfMonth.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfMonth} function options.
 */
export interface StartOfMonthOptions<ResultDate extends Date>
  extends ContextOptions<ResultDate> {}
/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date. The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments.
 * Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed,
 * or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a month
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
export declare function startOfMonth<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfMonthOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfMonth.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfMonth} function options.
 */
export interface StartOfMonthOptions<ResultDate extends Date>
  extends ContextOptions<ResultDate> {}
/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date. The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments.
 * Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed,
 * or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a month
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
export declare function startOfMonth<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfMonthOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfMonth.js

~~~js
import { toDate } from "./toDate.js";

import { setDate as coreSetDate } from "./_core/setDate.js";

/**
 * The {@link startOfMonth} function options.
 */

/**
 * @name startOfMonth
 * @category Month Helpers
 * @summary Return the start of a month for the given date.
 *
 * @description
 * Return the start of a month for the given date. The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments.
 * Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed,
 * or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a month
 *
 * @example
 * // The start of a month for 2 September 2014 11:55:00:
 * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Mon Sep 01 2014 00:00:00
 */
export function startOfMonth(date, options) {
  const _date = toDate(date, options?.in);
  coreSetDate(_date, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
export default startOfMonth;

~~~

## node_modules\date-fns-jalali\startOfQuarter.cjs

~~~cjs
"use strict";
exports.startOfQuarter = startOfQuarter;
var _index = require("./toDate.cjs");

var _index2 = require("./_core/getMonth.cjs");
var _index3 = require("./_core/setMonth.cjs");

/**
 * The {@link startOfQuarter} function options.
 */

/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a quarter
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */
function startOfQuarter(date, options) {
  const _date = (0, _index.toDate)(date, options?.in);
  const currentMonth = (0, _index2.getMonth)(_date);
  const month = currentMonth - (currentMonth % 3);
  (0, _index3.setMonth)(_date, month, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

~~~

## node_modules\date-fns-jalali\startOfQuarter.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfQuarter} function options.
 */
export interface StartOfQuarterOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a quarter
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */
export declare function startOfQuarter<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfQuarterOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfQuarter.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfQuarter} function options.
 */
export interface StartOfQuarterOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a quarter
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */
export declare function startOfQuarter<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfQuarterOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfQuarter.js

~~~js
import { toDate } from "./toDate.js";

import { getMonth as coreGetMonth } from "./_core/getMonth.js";
import { setMonth as coreSetMonth } from "./_core/setMonth.js";

/**
 * The {@link startOfQuarter} function options.
 */

/**
 * @name startOfQuarter
 * @category Quarter Helpers
 * @summary Return the start of a year quarter for the given date.
 *
 * @description
 * Return the start of a year quarter for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a quarter
 *
 * @example
 * // The start of a quarter for 2 September 2014 11:55:00:
 * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Jul 01 2014 00:00:00
 */
export function startOfQuarter(date, options) {
  const _date = toDate(date, options?.in);
  const currentMonth = coreGetMonth(_date);
  const month = currentMonth - (currentMonth % 3);
  coreSetMonth(_date, month, 1);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
export default startOfQuarter;

~~~

## node_modules\date-fns-jalali\startOfSecond.cjs

~~~cjs
"use strict";
exports.startOfSecond = startOfSecond;
var _index = require("./toDate.cjs");

/**
 * The {@link startOfSecond} function options.
 */

/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a second
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */
function startOfSecond(date, options) {
  const date_ = (0, _index.toDate)(date, options?.in);
  date_.setMilliseconds(0);
  return date_;
}

~~~

## node_modules\date-fns-jalali\startOfSecond.d.cts

~~~cts
import type { DateArg, ContextOptions } from "./types.js";
/**
 * The {@link startOfSecond} function options.
 */
export interface StartOfSecondOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a second
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */
export declare function startOfSecond<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfSecondOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfSecond.d.ts

~~~ts
import type { DateArg, ContextOptions } from "./types.js";
/**
 * The {@link startOfSecond} function options.
 */
export interface StartOfSecondOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a second
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */
export declare function startOfSecond<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfSecondOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfSecond.js

~~~js
import { toDate } from "./toDate.js";

/**
 * The {@link startOfSecond} function options.
 */

/**
 * @name startOfSecond
 * @category Second Helpers
 * @summary Return the start of a second for the given date.
 *
 * @description
 * Return the start of a second for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a second
 *
 * @example
 * // The start of a second for 1 December 2014 22:15:45.400:
 * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
 * //=> Mon Dec 01 2014 22:15:45.000
 */
export function startOfSecond(date, options) {
  const date_ = toDate(date, options?.in);
  date_.setMilliseconds(0);
  return date_;
}

// Fallback for modularized imports:
export default startOfSecond;

~~~

## node_modules\date-fns-jalali\startOfToday.cjs

~~~cjs
"use strict";
exports.startOfToday = startOfToday;
var _index = require("./startOfDay.cjs");

/**
 * The {@link startOfToday} function options.
 */

/**
 * @name startOfToday
 * @category Day Helpers
 * @summary Return the start of today.
 * @pure false
 *
 * @description
 * Return the start of today.
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @returns The start of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfToday()
 * //=> Mon Oct 6 2014 00:00:00
 */
function startOfToday(options) {
  return (0, _index.startOfDay)(Date.now(), options);
}

~~~

## node_modules\date-fns-jalali\startOfToday.d.cts

~~~cts
import type { ContextOptions } from "./types.js";
/**
 * The {@link startOfToday} function options.
 */
export interface StartOfTodayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfToday
 * @category Day Helpers
 * @summary Return the start of today.
 * @pure false
 *
 * @description
 * Return the start of today.
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @returns The start of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfToday()
 * //=> Mon Oct 6 2014 00:00:00
 */
export declare function startOfToday<ContextDate extends Date>(
  options?: StartOfTodayOptions<ContextDate> | undefined,
): ContextDate;

~~~

## node_modules\date-fns-jalali\startOfToday.d.ts

~~~ts
import type { ContextOptions } from "./types.js";
/**
 * The {@link startOfToday} function options.
 */
export interface StartOfTodayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfToday
 * @category Day Helpers
 * @summary Return the start of today.
 * @pure false
 *
 * @description
 * Return the start of today.
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @returns The start of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfToday()
 * //=> Mon Oct 6 2014 00:00:00
 */
export declare function startOfToday<ContextDate extends Date>(
  options?: StartOfTodayOptions<ContextDate> | undefined,
): ContextDate;

~~~

## node_modules\date-fns-jalali\startOfToday.js

~~~js
import { startOfDay } from "./startOfDay.js";

/**
 * The {@link startOfToday} function options.
 */

/**
 * @name startOfToday
 * @category Day Helpers
 * @summary Return the start of today.
 * @pure false
 *
 * @description
 * Return the start of today.
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @returns The start of today
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfToday()
 * //=> Mon Oct 6 2014 00:00:00
 */
export function startOfToday(options) {
  return startOfDay(Date.now(), options);
}

// Fallback for modularized imports:
export default startOfToday;

~~~

## node_modules\date-fns-jalali\startOfTomorrow.cjs

~~~cjs
"use strict";
exports.startOfTomorrow = startOfTomorrow;
var _index = require("./constructFrom.cjs");
var _index2 = require("./constructNow.cjs");

var _index3 = require("./_core/getMonth.cjs");
var _index4 = require("./_core/getDate.cjs");
var _index5 = require("./_core/getFullYear.cjs");
var _index6 = require("./_core/setFullYear.cjs");

/**
 * The {@link startOfTomorrow} function options.
 */

/**
 * @name startOfTomorrow
 * @category Day Helpers
 * @summary Return the start of tomorrow.
 * @pure false
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @returns The start of tomorrow
 *
 * @description
 * Return the start of tomorrow.
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfTomorrow()
 * //=> Tue Oct 7 2014 00:00:00
 */
function startOfTomorrow(options) {
  const now = (0, _index2.constructNow)(options?.in);
  const year = (0, _index5.getFullYear)(now);
  const month = (0, _index3.getMonth)(now);
  const day = (0, _index4.getDate)(now);

  const date = (0, _index.constructFrom)(options?.in, 0);
  (0, _index6.setFullYear)(date, year, month, day + 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

~~~

## node_modules\date-fns-jalali\startOfTomorrow.d.cts

~~~cts
import type { ContextOptions } from "./types.js";
/**
 * The {@link startOfTomorrow} function options.
 */
export interface StartOfTomorrowOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfTomorrow
 * @category Day Helpers
 * @summary Return the start of tomorrow.
 * @pure false
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @returns The start of tomorrow
 *
 * @description
 * Return the start of tomorrow.
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfTomorrow()
 * //=> Tue Oct 7 2014 00:00:00
 */
export declare function startOfTomorrow<ContextDate extends Date>(
  options?: StartOfTomorrowOptions<ContextDate> | undefined,
): ContextDate;

~~~

## node_modules\date-fns-jalali\startOfTomorrow.d.ts

~~~ts
import type { ContextOptions } from "./types.js";
/**
 * The {@link startOfTomorrow} function options.
 */
export interface StartOfTomorrowOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfTomorrow
 * @category Day Helpers
 * @summary Return the start of tomorrow.
 * @pure false
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @returns The start of tomorrow
 *
 * @description
 * Return the start of tomorrow.
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfTomorrow()
 * //=> Tue Oct 7 2014 00:00:00
 */
export declare function startOfTomorrow<ContextDate extends Date>(
  options?: StartOfTomorrowOptions<ContextDate> | undefined,
): ContextDate;

~~~

## node_modules\date-fns-jalali\startOfTomorrow.js

~~~js
import { constructFrom } from "./constructFrom.js";
import { constructNow } from "./constructNow.js";

import { getMonth as coreGetMonth } from "./_core/getMonth.js";
import { getDate as coreGetDate } from "./_core/getDate.js";
import { getFullYear as coreGetFullYear } from "./_core/getFullYear.js";
import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link startOfTomorrow} function options.
 */

/**
 * @name startOfTomorrow
 * @category Day Helpers
 * @summary Return the start of tomorrow.
 * @pure false
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @returns The start of tomorrow
 *
 * @description
 * Return the start of tomorrow.
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfTomorrow()
 * //=> Tue Oct 7 2014 00:00:00
 */
export function startOfTomorrow(options) {
  const now = constructNow(options?.in);
  const year = coreGetFullYear(now);
  const month = coreGetMonth(now);
  const day = coreGetDate(now);

  const date = constructFrom(options?.in, 0);
  coreSetFullYear(date, year, month, day + 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

// Fallback for modularized imports:
export default startOfTomorrow;

~~~

## node_modules\date-fns-jalali\startOfWeek.cjs

~~~cjs
"use strict";
exports.startOfWeek = startOfWeek;
var _index = require("./_lib/defaultOptions.cjs");
var _index2 = require("./toDate.cjs");

var _index3 = require("./_core/getDate.cjs");
var _index4 = require("./_core/setDate.cjs");

/**
 * The {@link startOfWeek} function options.
 */

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
function startOfWeek(date, options) {
  const defaultOptions = (0, _index.getDefaultOptions)();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    6;

  const _date = (0, _index2.toDate)(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

  (0, _index4.setDate)(_date, (0, _index3.getDate)(_date) - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

~~~

## node_modules\date-fns-jalali\startOfWeek.d.cts

~~~cts
import type {
  ContextOptions,
  DateArg,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link startOfWeek} function options.
 */
export interface StartOfWeekOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    WeekOptions,
    ContextOptions<DateType> {}
/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
export declare function startOfWeek<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfWeekOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfWeek.d.ts

~~~ts
import type {
  ContextOptions,
  DateArg,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link startOfWeek} function options.
 */
export interface StartOfWeekOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    WeekOptions,
    ContextOptions<DateType> {}
/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
export declare function startOfWeek<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfWeekOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfWeek.js

~~~js
import { getDefaultOptions } from "./_lib/defaultOptions.js";
import { toDate } from "./toDate.js";

import { getDate as coreGetDate } from "./_core/getDate.js";
import { setDate as coreSetDate } from "./_core/setDate.js";

/**
 * The {@link startOfWeek} function options.
 */

/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */
export function startOfWeek(date, options) {
  const defaultOptions = getDefaultOptions();
  const weekStartsOn =
    options?.weekStartsOn ??
    options?.locale?.options?.weekStartsOn ??
    defaultOptions.weekStartsOn ??
    defaultOptions.locale?.options?.weekStartsOn ??
    6;

  const _date = toDate(date, options?.in);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;

  coreSetDate(_date, coreGetDate(_date) - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// Fallback for modularized imports:
export default startOfWeek;

~~~

## node_modules\date-fns-jalali\startOfWeekYear.cjs

~~~cjs
"use strict";
exports.startOfWeekYear = startOfWeekYear;
var _index = require("./_lib/defaultOptions.cjs");
var _index2 = require("./constructFrom.cjs");
var _index3 = require("./getWeekYear.cjs");
var _index4 = require("./startOfWeek.cjs");

var _index5 = require("./_core/setFullYear.cjs");

/**
 * The {@link startOfWeekYear} function options.
 */

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
function startOfWeekYear(date, options) {
  const defaultOptions = (0, _index.getDefaultOptions)();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const year = (0, _index3.getWeekYear)(date, options);
  const firstWeek = (0, _index2.constructFrom)(options?.in || date, 0);
  (0, _index5.setFullYear)(firstWeek, year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = (0, _index4.startOfWeek)(firstWeek, options);
  return _date;
}

~~~

## node_modules\date-fns-jalali\startOfWeekYear.d.cts

~~~cts
import type {
  ContextOptions,
  DateArg,
  FirstWeekContainsDateOptions,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link startOfWeekYear} function options.
 */
export interface StartOfWeekYearOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    FirstWeekContainsDateOptions,
    WeekOptions,
    ContextOptions<DateType> {}
/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
export declare function startOfWeekYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfWeekYearOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfWeekYear.d.ts

~~~ts
import type {
  ContextOptions,
  DateArg,
  FirstWeekContainsDateOptions,
  LocalizedOptions,
  WeekOptions,
} from "./types.js";
/**
 * The {@link startOfWeekYear} function options.
 */
export interface StartOfWeekYearOptions<DateType extends Date = Date>
  extends LocalizedOptions<"options">,
    FirstWeekContainsDateOptions,
    WeekOptions,
    ContextOptions<DateType> {}
/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
export declare function startOfWeekYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfWeekYearOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfWeekYear.js

~~~js
import { getDefaultOptions } from "./_lib/defaultOptions.js";
import { constructFrom } from "./constructFrom.js";
import { getWeekYear } from "./getWeekYear.js";
import { startOfWeek } from "./startOfWeek.js";

import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link startOfWeekYear} function options.
 */

/**
 * @name startOfWeekYear
 * @category Week-Numbering Year Helpers
 * @summary Return the start of a local week-numbering year for the given date.
 *
 * @description
 * Return the start of a local week-numbering year.
 * The exact calculation depends on the values of
 * `options.weekStartsOn` (which is the index of the first day of the week)
 * and `options.firstWeekContainsDate` (which is the day of January, which is always in
 * the first week of the week-numbering year)
 *
 * Week numbering: https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type.
 *
 * @param date - The original date
 * @param options - An object with options
 *
 * @returns The start of a week-numbering year
 *
 * @example
 * // The start of an a week-numbering year for 2 July 2005 with default settings:
 * const result = startOfWeekYear(new Date(2005, 6, 2))
 * //=> Sun Dec 26 2004 00:00:00
 *
 * @example
 * // The start of a week-numbering year for 2 July 2005
 * // if Monday is the first day of week
 * // and 4 January is always in the first week of the year:
 * const result = startOfWeekYear(new Date(2005, 6, 2), {
 *   weekStartsOn: 1,
 *   firstWeekContainsDate: 4
 * })
 * //=> Mon Jan 03 2005 00:00:00
 */
export function startOfWeekYear(date, options) {
  const defaultOptions = getDefaultOptions();
  const firstWeekContainsDate =
    options?.firstWeekContainsDate ??
    options?.locale?.options?.firstWeekContainsDate ??
    defaultOptions.firstWeekContainsDate ??
    defaultOptions.locale?.options?.firstWeekContainsDate ??
    1;

  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(options?.in || date, 0);
  coreSetFullYear(firstWeek, year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// Fallback for modularized imports:
export default startOfWeekYear;

~~~

## node_modules\date-fns-jalali\startOfYear.cjs

~~~cjs
"use strict";
exports.startOfYear = startOfYear;
var _index = require("./toDate.cjs");

var _index2 = require("./_core/getFullYear.cjs");
var _index3 = require("./_core/setFullYear.cjs");

/**
 * The {@link startOfYear} function options.
 */

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
function startOfYear(date, options) {
  const date_ = (0, _index.toDate)(date, options?.in);
  (0, _index3.setFullYear)(date_, (0, _index2.getFullYear)(date_), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}

~~~

## node_modules\date-fns-jalali\startOfYear.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfYear} function options.
 */
export interface StartOfYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
export declare function startOfYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfYear.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link startOfYear} function options.
 */
export interface StartOfYearOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
export declare function startOfYear<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  options?: StartOfYearOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\startOfYear.js

~~~js
import { toDate } from "./toDate.js";

import { getFullYear as coreGetFullYear } from "./_core/getFullYear.js";
import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link startOfYear} function options.
 */

/**
 * @name startOfYear
 * @category Year Helpers
 * @summary Return the start of a year for the given date.
 *
 * @description
 * Return the start of a year for the given date.
 * The result will be in the local timezone.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The original date
 * @param options - The options
 *
 * @returns The start of a year
 *
 * @example
 * // The start of a year for 2 September 2014 11:55:00:
 * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
 * //=> Wed Jan 01 2014 00:00:00
 */
export function startOfYear(date, options) {
  const date_ = toDate(date, options?.in);
  coreSetFullYear(date_, coreGetFullYear(date_), 0, 1);
  date_.setHours(0, 0, 0, 0);
  return date_;
}

// Fallback for modularized imports:
export default startOfYear;

~~~

## node_modules\date-fns-jalali\startOfYesterday.cjs

~~~cjs
"use strict";
exports.startOfYesterday = startOfYesterday;
var _index = require("./constructNow.cjs");

var _index2 = require("./_core/getMonth.cjs");
var _index3 = require("./_core/getDate.cjs");
var _index4 = require("./_core/getFullYear.cjs");
var _index5 = require("./_core/setFullYear.cjs");

/**
 * The {@link startOfYesterday} function options.
 */

/**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @description
 * Return the start of yesterday.
 *
 * @returns The start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */
function startOfYesterday(options) {
  const now = (0, _index.constructNow)(options?.in);
  const year = (0, _index4.getFullYear)(now);
  const month = (0, _index2.getMonth)(now);
  const day = (0, _index3.getDate)(now);

  const date = (0, _index.constructNow)(options?.in);
  (0, _index5.setFullYear)(date, year, month, day - 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

~~~

## node_modules\date-fns-jalali\startOfYesterday.d.cts

~~~cts
import type { ContextOptions } from "./types.js";
/**
 * The {@link startOfYesterday} function options.
 */
export interface StartOfYesterdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @description
 * Return the start of yesterday.
 *
 * @returns The start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */
export declare function startOfYesterday<ContextDate extends Date>(
  options?: StartOfYesterdayOptions<ContextDate> | undefined,
): ContextDate;

~~~

## node_modules\date-fns-jalali\startOfYesterday.d.ts

~~~ts
import type { ContextOptions } from "./types.js";
/**
 * The {@link startOfYesterday} function options.
 */
export interface StartOfYesterdayOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @description
 * Return the start of yesterday.
 *
 * @returns The start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */
export declare function startOfYesterday<ContextDate extends Date>(
  options?: StartOfYesterdayOptions<ContextDate> | undefined,
): ContextDate;

~~~

## node_modules\date-fns-jalali\startOfYesterday.js

~~~js
import { constructNow } from "./constructNow.js";

import { getMonth as coreGetMonth } from "./_core/getMonth.js";
import { getDate as coreGetDate } from "./_core/getDate.js";
import { getFullYear as coreGetFullYear } from "./_core/getFullYear.js";
import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * The {@link startOfYesterday} function options.
 */

/**
 * @name startOfYesterday
 * @category Day Helpers
 * @summary Return the start of yesterday.
 * @pure false
 *
 * @typeParam ContextDate - The `Date` type of the context function.
 *
 * @param options - An object with options
 *
 * @description
 * Return the start of yesterday.
 *
 * @returns The start of yesterday
 *
 * @example
 * // If today is 6 October 2014:
 * const result = startOfYesterday()
 * //=> Sun Oct 5 2014 00:00:00
 */
export function startOfYesterday(options) {
  const now = constructNow(options?.in);
  const year = coreGetFullYear(now);
  const month = coreGetMonth(now);
  const day = coreGetDate(now);

  const date = constructNow(options?.in);
  coreSetFullYear(date, year, month, day - 1);
  date.setHours(0, 0, 0, 0);
  return date;
}

// Fallback for modularized imports:
export default startOfYesterday;

~~~

## node_modules\date-fns-jalali\sub.cjs

~~~cjs
"use strict";
exports.sub = sub;
var _index = require("./constructFrom.cjs");
var _index2 = require("./subDays.cjs");
var _index3 = require("./subMonths.cjs");

/**
 * The {@link sub} function options.
 */

/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 * @param options - An object with options
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */
function sub(date, duration, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0,
  } = duration;

  const withoutMonths = (0, _index3.subMonths)(
    date,
    months + years * 12,
    options,
  );
  const withoutDays = (0, _index2.subDays)(
    withoutMonths,
    days + weeks * 7,
    options,
  );

  const minutesToSub = minutes + hours * 60;
  const secondsToSub = seconds + minutesToSub * 60;
  const msToSub = secondsToSub * 1000;

  return (0, _index.constructFrom)(options?.in || date, +withoutDays - msToSub);
}

~~~

## node_modules\date-fns-jalali\sub.d.cts

~~~cts
import type { ContextOptions, DateArg, Duration } from "./types.js";
/**
 * The {@link sub} function options.
 */
export interface SubOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 * @param options - An object with options
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */
export declare function sub<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  duration: Duration,
  options?: SubOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\sub.d.ts

~~~ts
import type { ContextOptions, DateArg, Duration } from "./types.js";
/**
 * The {@link sub} function options.
 */
export interface SubOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 * @param options - An object with options
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */
export declare function sub<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  duration: Duration,
  options?: SubOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\sub.js

~~~js
import { constructFrom } from "./constructFrom.js";
import { subDays } from "./subDays.js";
import { subMonths } from "./subMonths.js";

/**
 * The {@link sub} function options.
 */

/**
 * @name sub
 * @category Common Helpers
 * @summary Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @description
 * Subtract the specified years, months, weeks, days, hours, minutes and seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param duration - The object with years, months, weeks, days, hours, minutes and seconds to be subtracted
 * @param options - An object with options
 *
 * | Key     | Description                        |
 * |---------|------------------------------------|
 * | years   | Amount of years to be subtracted   |
 * | months  | Amount of months to be subtracted  |
 * | weeks   | Amount of weeks to be subtracted   |
 * | days    | Amount of days to be subtracted    |
 * | hours   | Amount of hours to be subtracted   |
 * | minutes | Amount of minutes to be subtracted |
 * | seconds | Amount of seconds to be subtracted |
 *
 * All values default to 0
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract the following duration from 15 June 2017 15:29:20
 * const result = sub(new Date(2017, 5, 15, 15, 29, 20), {
 *   years: 2,
 *   months: 9,
 *   weeks: 1,
 *   days: 7,
 *   hours: 5,
 *   minutes: 9,
 *   seconds: 30
 * })
 * //=> Mon Sep 1 2014 10:19:50
 */
export function sub(date, duration, options) {
  const {
    years = 0,
    months = 0,
    weeks = 0,
    days = 0,
    hours = 0,
    minutes = 0,
    seconds = 0,
  } = duration;

  const withoutMonths = subMonths(date, months + years * 12, options);
  const withoutDays = subDays(withoutMonths, days + weeks * 7, options);

  const minutesToSub = minutes + hours * 60;
  const secondsToSub = seconds + minutesToSub * 60;
  const msToSub = secondsToSub * 1000;

  return constructFrom(options?.in || date, +withoutDays - msToSub);
}

// Fallback for modularized imports:
export default sub;

~~~

## node_modules\date-fns-jalali\subBusinessDays.cjs

~~~cjs
"use strict";
exports.subBusinessDays = subBusinessDays;
var _index = require("./addBusinessDays.cjs");

/**
 * The {@link subBusinessDays} function options.
 */

/**
 * @name subBusinessDays
 * @category Day Helpers
 * @summary Subtract the specified number of business days (mon - fri) from the given date.
 *
 * @description
 * Subtract the specified number of business days (mon - fri) from the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the business days subtracted
 *
 * @example
 * // Subtract 10 business days from 1 September 2014:
 * const result = subBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
 */
function subBusinessDays(date, amount, options) {
  return (0, _index.addBusinessDays)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subBusinessDays.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subBusinessDays} function options.
 */
export interface SubBusinessDaysOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subBusinessDays
 * @category Day Helpers
 * @summary Subtract the specified number of business days (mon - fri) from the given date.
 *
 * @description
 * Subtract the specified number of business days (mon - fri) from the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the business days subtracted
 *
 * @example
 * // Subtract 10 business days from 1 September 2014:
 * const result = subBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
 */
export declare function subBusinessDays<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubBusinessDaysOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subBusinessDays.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subBusinessDays} function options.
 */
export interface SubBusinessDaysOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subBusinessDays
 * @category Day Helpers
 * @summary Subtract the specified number of business days (mon - fri) from the given date.
 *
 * @description
 * Subtract the specified number of business days (mon - fri) from the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the business days subtracted
 *
 * @example
 * // Subtract 10 business days from 1 September 2014:
 * const result = subBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
 */
export declare function subBusinessDays<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubBusinessDaysOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subBusinessDays.js

~~~js
import { addBusinessDays } from "./addBusinessDays.js";

/**
 * The {@link subBusinessDays} function options.
 */

/**
 * @name subBusinessDays
 * @category Day Helpers
 * @summary Subtract the specified number of business days (mon - fri) from the given date.
 *
 * @description
 * Subtract the specified number of business days (mon - fri) from the given date, ignoring weekends.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of business days to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the business days subtracted
 *
 * @example
 * // Subtract 10 business days from 1 September 2014:
 * const result = subBusinessDays(new Date(2014, 8, 1), 10)
 * //=> Mon Aug 18 2014 00:00:00 (skipped weekend days)
 */
export function subBusinessDays(date, amount, options) {
  return addBusinessDays(date, -amount, options);
}

// Fallback for modularized imports:
export default subBusinessDays;

~~~

## node_modules\date-fns-jalali\subDays.cjs

~~~cjs
"use strict";
exports.subDays = subDays;
var _index = require("./addDays.cjs");

/**
 * The {@link subDays} function options.
 */

/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the days subtracted
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */
function subDays(date, amount, options) {
  return (0, _index.addDays)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subDays.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subDays} function options.
 */
export interface SubDaysOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the days subtracted
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */
export declare function subDays<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubDaysOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subDays.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subDays} function options.
 */
export interface SubDaysOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the days subtracted
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */
export declare function subDays<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubDaysOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subDays.js

~~~js
import { addDays } from "./addDays.js";

/**
 * The {@link subDays} function options.
 */

/**
 * @name subDays
 * @category Day Helpers
 * @summary Subtract the specified number of days from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of days to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the days subtracted
 *
 * @example
 * // Subtract 10 days from 1 September 2014:
 * const result = subDays(new Date(2014, 8, 1), 10)
 * //=> Fri Aug 22 2014 00:00:00
 */
export function subDays(date, amount, options) {
  return addDays(date, -amount, options);
}

// Fallback for modularized imports:
export default subDays;

~~~

## node_modules\date-fns-jalali\subHours.cjs

~~~cjs
"use strict";
exports.subHours = subHours;
var _index = require("./addHours.cjs");

/**
 * The {@link subHours} function options.
 */

/**
 * @name subHours
 * @category Hour Helpers
 * @summary Subtract the specified number of hours from the given date.
 *
 * @description
 * Subtract the specified number of hours from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the hours subtracted
 *
 * @example
 * // Subtract 2 hours from 11 July 2014 01:00:00:
 * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
 * //=> Thu Jul 10 2014 23:00:00
 */
function subHours(date, amount, options) {
  return (0, _index.addHours)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subHours.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subHours} function options.
 */
export interface SubHoursOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subHours
 * @category Hour Helpers
 * @summary Subtract the specified number of hours from the given date.
 *
 * @description
 * Subtract the specified number of hours from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the hours subtracted
 *
 * @example
 * // Subtract 2 hours from 11 July 2014 01:00:00:
 * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
 * //=> Thu Jul 10 2014 23:00:00
 */
export declare function subHours<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubHoursOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subHours.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subHours} function options.
 */
export interface SubHoursOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subHours
 * @category Hour Helpers
 * @summary Subtract the specified number of hours from the given date.
 *
 * @description
 * Subtract the specified number of hours from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the hours subtracted
 *
 * @example
 * // Subtract 2 hours from 11 July 2014 01:00:00:
 * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
 * //=> Thu Jul 10 2014 23:00:00
 */
export declare function subHours<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubHoursOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subHours.js

~~~js
import { addHours } from "./addHours.js";

/**
 * The {@link subHours} function options.
 */

/**
 * @name subHours
 * @category Hour Helpers
 * @summary Subtract the specified number of hours from the given date.
 *
 * @description
 * Subtract the specified number of hours from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of hours to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the hours subtracted
 *
 * @example
 * // Subtract 2 hours from 11 July 2014 01:00:00:
 * const result = subHours(new Date(2014, 6, 11, 1, 0), 2)
 * //=> Thu Jul 10 2014 23:00:00
 */
export function subHours(date, amount, options) {
  return addHours(date, -amount, options);
}

// Fallback for modularized imports:
export default subHours;

~~~

## node_modules\date-fns-jalali\subISOWeekYears.cjs

~~~cjs
"use strict";
exports.subISOWeekYears = subISOWeekYears;
var _index = require("./addISOWeekYears.cjs");

/**
 * The {@link subISOWeekYears} function options.
 */

/**
 * @name subISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Subtract the specified number of ISO week-numbering years from the given date.
 *
 * @description
 * Subtract the specified number of ISO week-numbering years from the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the ISO week-numbering years subtracted
 *
 * @example
 * // Subtract 5 ISO week-numbering years from 1 September 2014:
 * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
 * //=> Mon Aug 31 2009 00:00:00
 */
function subISOWeekYears(date, amount, options) {
  return (0, _index.addISOWeekYears)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subISOWeekYears.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subISOWeekYears} function options.
 */
export interface SubISOWeekYearsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Subtract the specified number of ISO week-numbering years from the given date.
 *
 * @description
 * Subtract the specified number of ISO week-numbering years from the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the ISO week-numbering years subtracted
 *
 * @example
 * // Subtract 5 ISO week-numbering years from 1 September 2014:
 * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
 * //=> Mon Aug 31 2009 00:00:00
 */
export declare function subISOWeekYears<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubISOWeekYearsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subISOWeekYears.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subISOWeekYears} function options.
 */
export interface SubISOWeekYearsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Subtract the specified number of ISO week-numbering years from the given date.
 *
 * @description
 * Subtract the specified number of ISO week-numbering years from the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the ISO week-numbering years subtracted
 *
 * @example
 * // Subtract 5 ISO week-numbering years from 1 September 2014:
 * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
 * //=> Mon Aug 31 2009 00:00:00
 */
export declare function subISOWeekYears<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubISOWeekYearsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subISOWeekYears.js

~~~js
import { addISOWeekYears } from "./addISOWeekYears.js";

/**
 * The {@link subISOWeekYears} function options.
 */

/**
 * @name subISOWeekYears
 * @category ISO Week-Numbering Year Helpers
 * @summary Subtract the specified number of ISO week-numbering years from the given date.
 *
 * @description
 * Subtract the specified number of ISO week-numbering years from the given date.
 *
 * ISO week-numbering year: http://en.wikipedia.org/wiki/ISO_week_date
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of ISO week-numbering years to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the ISO week-numbering years subtracted
 *
 * @example
 * // Subtract 5 ISO week-numbering years from 1 September 2014:
 * const result = subISOWeekYears(new Date(2014, 8, 1), 5)
 * //=> Mon Aug 31 2009 00:00:00
 */
export function subISOWeekYears(date, amount, options) {
  return addISOWeekYears(date, -amount, options);
}

// Fallback for modularized imports:
export default subISOWeekYears;

~~~

## node_modules\date-fns-jalali\subMilliseconds.cjs

~~~cjs
"use strict";
exports.subMilliseconds = subMilliseconds;
var _index = require("./addMilliseconds.cjs");

/**
 * The {@link subMilliseconds} function options.
 */

/**
 * Subtract the specified number of milliseconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the milliseconds subtracted
 */
function subMilliseconds(date, amount, options) {
  return (0, _index.addMilliseconds)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subMilliseconds.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subMilliseconds} function options.
 */
export interface SubMillisecondsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * Subtract the specified number of milliseconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the milliseconds subtracted
 */
export declare function subMilliseconds<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubMillisecondsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subMilliseconds.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subMilliseconds} function options.
 */
export interface SubMillisecondsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * Subtract the specified number of milliseconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the milliseconds subtracted
 */
export declare function subMilliseconds<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubMillisecondsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subMilliseconds.js

~~~js
import { addMilliseconds } from "./addMilliseconds.js";

/**
 * The {@link subMilliseconds} function options.
 */

/**
 * Subtract the specified number of milliseconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of milliseconds to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the milliseconds subtracted
 */
export function subMilliseconds(date, amount, options) {
  return addMilliseconds(date, -amount, options);
}

// Fallback for modularized imports:
export default subMilliseconds;

~~~

## node_modules\date-fns-jalali\subMinutes.cjs

~~~cjs
"use strict";
exports.subMinutes = subMinutes;
var _index = require("./addMinutes.cjs");

/**
 * The {@link subMinutes} function options.
 */

/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the minutes subtracted
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */
function subMinutes(date, amount, options) {
  return (0, _index.addMinutes)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subMinutes.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subMinutes} function options.
 */
export interface SubMinutesOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the minutes subtracted
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */
export declare function subMinutes<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubMinutesOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subMinutes.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subMinutes} function options.
 */
export interface SubMinutesOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the minutes subtracted
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */
export declare function subMinutes<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubMinutesOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subMinutes.js

~~~js
import { addMinutes } from "./addMinutes.js";

/**
 * The {@link subMinutes} function options.
 */

/**
 * @name subMinutes
 * @category Minute Helpers
 * @summary Subtract the specified number of minutes from the given date.
 *
 * @description
 * Subtract the specified number of minutes from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of minutes to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the minutes subtracted
 *
 * @example
 * // Subtract 30 minutes from 10 July 2014 12:00:00:
 * const result = subMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 11:30:00
 */
export function subMinutes(date, amount, options) {
  return addMinutes(date, -amount, options);
}

// Fallback for modularized imports:
export default subMinutes;

~~~

## node_modules\date-fns-jalali\subMonths.cjs

~~~cjs
"use strict";
exports.subMonths = subMonths;
var _index = require("./addMonths.cjs");

/**
 * The subMonths function options.
 */

/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the months subtracted
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
function subMonths(date, amount, options) {
  return (0, _index.addMonths)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subMonths.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The subMonths function options.
 */
export interface SubMonthsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the months subtracted
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
export declare function subMonths<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubMonthsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subMonths.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The subMonths function options.
 */
export interface SubMonthsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the months subtracted
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
export declare function subMonths<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubMonthsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subMonths.js

~~~js
import { addMonths } from "./addMonths.js";

/**
 * The subMonths function options.
 */

/**
 * @name subMonths
 * @category Month Helpers
 * @summary Subtract the specified number of months from the given date.
 *
 * @description
 * Subtract the specified number of months from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of months to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the months subtracted
 *
 * @example
 * // Subtract 5 months from 1 February 2015:
 * const result = subMonths(new Date(2015, 1, 1), 5)
 * //=> Mon Sep 01 2014 00:00:00
 */
export function subMonths(date, amount, options) {
  return addMonths(date, -amount, options);
}

// Fallback for modularized imports:
export default subMonths;

~~~

## node_modules\date-fns-jalali\subQuarters.cjs

~~~cjs
"use strict";
exports.subQuarters = subQuarters;
var _index = require("./addQuarters.cjs");

/**
 * The {@link subQuarters} function options.
 */

/**
 * @name subQuarters
 * @category Quarter Helpers
 * @summary Subtract the specified number of year quarters from the given date.
 *
 * @description
 * Subtract the specified number of year quarters from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the quarters subtracted
 *
 * @example
 * // Subtract 3 quarters from 1 September 2014:
 * const result = subQuarters(new Date(2014, 8, 1), 3)
 * //=> Sun Dec 01 2013 00:00:00
 */
function subQuarters(date, amount, options) {
  return (0, _index.addQuarters)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subQuarters.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subQuarters} function options.
 */
export interface SubQuartersOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subQuarters
 * @category Quarter Helpers
 * @summary Subtract the specified number of year quarters from the given date.
 *
 * @description
 * Subtract the specified number of year quarters from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the quarters subtracted
 *
 * @example
 * // Subtract 3 quarters from 1 September 2014:
 * const result = subQuarters(new Date(2014, 8, 1), 3)
 * //=> Sun Dec 01 2013 00:00:00
 */
export declare function subQuarters<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubQuartersOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subQuarters.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subQuarters} function options.
 */
export interface SubQuartersOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subQuarters
 * @category Quarter Helpers
 * @summary Subtract the specified number of year quarters from the given date.
 *
 * @description
 * Subtract the specified number of year quarters from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the quarters subtracted
 *
 * @example
 * // Subtract 3 quarters from 1 September 2014:
 * const result = subQuarters(new Date(2014, 8, 1), 3)
 * //=> Sun Dec 01 2013 00:00:00
 */
export declare function subQuarters<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubQuartersOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subQuarters.js

~~~js
import { addQuarters } from "./addQuarters.js";

/**
 * The {@link subQuarters} function options.
 */

/**
 * @name subQuarters
 * @category Quarter Helpers
 * @summary Subtract the specified number of year quarters from the given date.
 *
 * @description
 * Subtract the specified number of year quarters from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of quarters to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the quarters subtracted
 *
 * @example
 * // Subtract 3 quarters from 1 September 2014:
 * const result = subQuarters(new Date(2014, 8, 1), 3)
 * //=> Sun Dec 01 2013 00:00:00
 */
export function subQuarters(date, amount, options) {
  return addQuarters(date, -amount, options);
}

// Fallback for modularized imports:
export default subQuarters;

~~~

## node_modules\date-fns-jalali\subSeconds.cjs

~~~cjs
"use strict";
exports.subSeconds = subSeconds;
var _index = require("./addSeconds.cjs");

/**
 * The {@link subSeconds} function options.
 */

/**
 * Subtract the specified number of seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract 30 seconds from 10 July 2014 12:45:00:
 * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:44:30
 */
function subSeconds(date, amount, options) {
  return (0, _index.addSeconds)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subSeconds.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subSeconds} function options.
 */
export interface SubSecondsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * Subtract the specified number of seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract 30 seconds from 10 July 2014 12:45:00:
 * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:44:30
 */
export declare function subSeconds<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubSecondsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subSeconds.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subSeconds} function options.
 */
export interface SubSecondsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * Subtract the specified number of seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract 30 seconds from 10 July 2014 12:45:00:
 * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:44:30
 */
export declare function subSeconds<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubSecondsOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subSeconds.js

~~~js
import { addSeconds } from "./addSeconds.js";

/**
 * The {@link subSeconds} function options.
 */

/**
 * Subtract the specified number of seconds from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of seconds to be subtracted.
 * @param options - The options
 *
 * @returns The new date with the seconds subtracted
 *
 * @example
 * // Subtract 30 seconds from 10 July 2014 12:45:00:
 * const result = subSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:44:30
 */
export function subSeconds(date, amount, options) {
  return addSeconds(date, -amount, options);
}

// Fallback for modularized imports:
export default subSeconds;

~~~

## node_modules\date-fns-jalali\subWeeks.cjs

~~~cjs
"use strict";
exports.subWeeks = subWeeks;
var _index = require("./addWeeks.cjs");

/**
 * The {@link subWeeks} function options.
 */

/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the weeks subtracted
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */
function subWeeks(date, amount, options) {
  return (0, _index.addWeeks)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subWeeks.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subWeeks} function options.
 */
export interface SubWeeksOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the weeks subtracted
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */
export declare function subWeeks<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubWeeksOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subWeeks.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subWeeks} function options.
 */
export interface SubWeeksOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the weeks subtracted
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */
export declare function subWeeks<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubWeeksOptions<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subWeeks.js

~~~js
import { addWeeks } from "./addWeeks.js";

/**
 * The {@link subWeeks} function options.
 */

/**
 * @name subWeeks
 * @category Week Helpers
 * @summary Subtract the specified number of weeks from the given date.
 *
 * @description
 * Subtract the specified number of weeks from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of weeks to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the weeks subtracted
 *
 * @example
 * // Subtract 4 weeks from 1 September 2014:
 * const result = subWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Aug 04 2014 00:00:00
 */
export function subWeeks(date, amount, options) {
  return addWeeks(date, -amount, options);
}

// Fallback for modularized imports:
export default subWeeks;

~~~

## node_modules\date-fns-jalali\subYears.cjs

~~~cjs
"use strict";
exports.subYears = subYears;
var _index = require("./addYears.cjs");

/**
 * The {@link subYears} function options.
 */

/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the years subtracted
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */
function subYears(date, amount, options) {
  return (0, _index.addYears)(date, -amount, options);
}

~~~

## node_modules\date-fns-jalali\subYears.d.cts

~~~cts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subYears} function options.
 */
export interface SubYearsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the years subtracted
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */
export declare function subYears<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubYearsOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subYears.d.ts

~~~ts
import type { ContextOptions, DateArg } from "./types.js";
/**
 * The {@link subYears} function options.
 */
export interface SubYearsOptions<DateType extends Date = Date>
  extends ContextOptions<DateType> {}
/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the years subtracted
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */
export declare function subYears<
  DateType extends Date,
  ResultDate extends Date = DateType,
>(
  date: DateArg<DateType>,
  amount: number,
  options?: SubYearsOptions<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\subYears.js

~~~js
import { addYears } from "./addYears.js";

/**
 * The {@link subYears} function options.
 */

/**
 * @name subYears
 * @category Year Helpers
 * @summary Subtract the specified number of years from the given date.
 *
 * @description
 * Subtract the specified number of years from the given date.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param date - The date to be changed
 * @param amount - The amount of years to be subtracted.
 * @param options - An object with options
 *
 * @returns The new date with the years subtracted
 *
 * @example
 * // Subtract 5 years from 1 September 2014:
 * const result = subYears(new Date(2014, 8, 1), 5)
 * //=> Tue Sep 01 2009 00:00:00
 */
export function subYears(date, amount, options) {
  return addYears(date, -amount, options);
}

// Fallback for modularized imports:
export default subYears;

~~~

## node_modules\date-fns-jalali\toDate.cjs

~~~cjs
"use strict";
exports.toDate = toDate;
var _index = require("./constructFrom.cjs");

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
function toDate(argument, context) {
  // [TODO] Get rid of `toDate` or `constructFrom`?
  return (0, _index.constructFrom)(context || argument, argument);
}

~~~

## node_modules\date-fns-jalali\toDate.d.cts

~~~cts
import type { ConstructableDate, ContextFn, DateArg } from "./types.js";
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
export declare function toDate<
  DateType extends Date | ConstructableDate,
  ResultDate extends Date = DateType,
>(
  argument: DateArg<DateType>,
  context?: ContextFn<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\toDate.d.ts

~~~ts
import type { ConstructableDate, ContextFn, DateArg } from "./types.js";
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
export declare function toDate<
  DateType extends Date | ConstructableDate,
  ResultDate extends Date = DateType,
>(
  argument: DateArg<DateType>,
  context?: ContextFn<ResultDate> | undefined,
): ResultDate;

~~~

## node_modules\date-fns-jalali\toDate.js

~~~js
import { constructFrom } from "./constructFrom.js";

/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * Starting from v3.7.0, it clones a date using `[Symbol.for("constructDateFrom")]`
 * enabling to transfer extra properties from the reference date to the new date.
 * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.
 *
 * @param argument - The value to convert
 *
 * @returns The parsed date in the local time zone
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */
export function toDate(argument, context) {
  // [TODO] Get rid of `toDate` or `constructFrom`?
  return constructFrom(context || argument, argument);
}

// Fallback for modularized imports:
export default toDate;

~~~

## node_modules\date-fns-jalali\transpose.cjs

~~~cjs
"use strict";
exports.transpose = transpose;
var _index = require("./constructFrom.cjs");

var _index2 = require("./_core/getMonth.cjs");
var _index3 = require("./_core/getDate.cjs");
var _index4 = require("./_core/getFullYear.cjs");
var _index5 = require("./_core/setFullYear.cjs");

/**
 * @name transpose
 * @category Generic Helpers
 * @summary Transpose the date to the given constructor.
 *
 * @description
 * The function transposes the date to the given constructor. It helps you
 * to transpose the date in the system time zone to say `UTCDate` or any other
 * date extension.
 *
 * @typeParam InputDate - The input `Date` type derived from the passed argument.
 * @typeParam ResultDate - The result `Date` type derived from the passed constructor.
 *
 * @param date - The date to use values from
 * @param constructor - The date constructor to use
 *
 * @returns Date transposed to the given constructor
 *
 * @example
 * // Create July 10, 2022 00:00 in locale time zone
 * const date = new Date(2022, 6, 10)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
 *
 * @example
 * // Transpose the date to July 10, 2022 00:00 in UTC
 * transpose(date, UTCDate)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
 */
function transpose(date, constructor) {
  const date_ = isConstructor(constructor)
    ? new constructor(0)
    : (0, _index.constructFrom)(constructor, 0);
  (0, _index5.setFullYear)(
    date_,
    (0, _index4.getFullYear)(date),
    (0, _index2.getMonth)(date),
    (0, _index3.getDate)(date),
  );
  date_.setHours(
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds(),
  );
  return date_;
}

function isConstructor(constructor) {
  return (
    typeof constructor === "function" &&
    constructor.prototype?.constructor === constructor
  );
}

~~~

## node_modules\date-fns-jalali\transpose.d.cts

~~~cts
import type { ContextFn, GenericDateConstructor } from "./types.js";
/**
 * @name transpose
 * @category Generic Helpers
 * @summary Transpose the date to the given constructor.
 *
 * @description
 * The function transposes the date to the given constructor. It helps you
 * to transpose the date in the system time zone to say `UTCDate` or any other
 * date extension.
 *
 * @typeParam InputDate - The input `Date` type derived from the passed argument.
 * @typeParam ResultDate - The result `Date` type derived from the passed constructor.
 *
 * @param date - The date to use values from
 * @param constructor - The date constructor to use
 *
 * @returns Date transposed to the given constructor
 *
 * @example
 * // Create July 10, 2022 00:00 in locale time zone
 * const date = new Date(2022, 6, 10)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
 *
 * @example
 * // Transpose the date to July 10, 2022 00:00 in UTC
 * transpose(date, UTCDate)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
 */
export declare function transpose<
  InputDate extends Date,
  ResultDate extends Date,
>(
  date: InputDate,
  constructor:
    | ResultDate
    | GenericDateConstructor<ResultDate>
    | ContextFn<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\transpose.d.ts

~~~ts
import type { ContextFn, GenericDateConstructor } from "./types.js";
/**
 * @name transpose
 * @category Generic Helpers
 * @summary Transpose the date to the given constructor.
 *
 * @description
 * The function transposes the date to the given constructor. It helps you
 * to transpose the date in the system time zone to say `UTCDate` or any other
 * date extension.
 *
 * @typeParam InputDate - The input `Date` type derived from the passed argument.
 * @typeParam ResultDate - The result `Date` type derived from the passed constructor.
 *
 * @param date - The date to use values from
 * @param constructor - The date constructor to use
 *
 * @returns Date transposed to the given constructor
 *
 * @example
 * // Create July 10, 2022 00:00 in locale time zone
 * const date = new Date(2022, 6, 10)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
 *
 * @example
 * // Transpose the date to July 10, 2022 00:00 in UTC
 * transpose(date, UTCDate)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
 */
export declare function transpose<
  InputDate extends Date,
  ResultDate extends Date,
>(
  date: InputDate,
  constructor:
    | ResultDate
    | GenericDateConstructor<ResultDate>
    | ContextFn<ResultDate>,
): ResultDate;

~~~

## node_modules\date-fns-jalali\transpose.js

~~~js
import { constructFrom } from "./constructFrom.js";

import { getMonth as coreGetMonth } from "./_core/getMonth.js";
import { getDate as coreGetDate } from "./_core/getDate.js";
import { getFullYear as coreGetFullYear } from "./_core/getFullYear.js";
import { setFullYear as coreSetFullYear } from "./_core/setFullYear.js";

/**
 * @name transpose
 * @category Generic Helpers
 * @summary Transpose the date to the given constructor.
 *
 * @description
 * The function transposes the date to the given constructor. It helps you
 * to transpose the date in the system time zone to say `UTCDate` or any other
 * date extension.
 *
 * @typeParam InputDate - The input `Date` type derived from the passed argument.
 * @typeParam ResultDate - The result `Date` type derived from the passed constructor.
 *
 * @param date - The date to use values from
 * @param constructor - The date constructor to use
 *
 * @returns Date transposed to the given constructor
 *
 * @example
 * // Create July 10, 2022 00:00 in locale time zone
 * const date = new Date(2022, 6, 10)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0800 (Singapore Standard Time)'
 *
 * @example
 * // Transpose the date to July 10, 2022 00:00 in UTC
 * transpose(date, UTCDate)
 * //=> 'Sun Jul 10 2022 00:00:00 GMT+0000 (Coordinated Universal Time)'
 */
export function transpose(date, constructor) {
  const date_ = isConstructor(constructor)
    ? new constructor(0)
    : constructFrom(constructor, 0);
  coreSetFullYear(
    date_,
    coreGetFullYear(date),
    coreGetMonth(date),
    coreGetDate(date),
  );
  date_.setHours(
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds(),
  );
  return date_;
}

function isConstructor(constructor) {
  return (
    typeof constructor === "function" &&
    constructor.prototype?.constructor === constructor
  );
}

// Fallback for modularized imports:
export default transpose;

~~~

## node_modules\date-fns-jalali\types.cjs

~~~cjs
"use strict";

~~~

## node_modules\date-fns-jalali\types.d.cts

~~~cts
import { type constructFromSymbol } from "./constants.js";
import type { Locale } from "./locale/types.js";
export type * from "./fp/types.js";
export type * from "./locale/types.js";
/**
 * The argument type.
 */
export type DateArg<DateType extends Date> = DateType | number | string;
/**
 * Date extension interface that allows to transfer extra properties from
 * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 */
export interface ConstructableDate extends Date {
  [constructFromSymbol]: <DateType extends Date = Date>(
    value: DateArg<Date> & {},
  ) => DateType;
}
/**
 * The generic date constructor. Replicates the Date constructor. Used to build
 * generic functions.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 */
export interface GenericDateConstructor<DateType extends Date = Date> {
  /**
   * The date constructor. Creates date with the current date and time.
   *
   * @returns The date instance
   */
  new (): DateType;
  /**
   * The date constructor. Creates date with the passed date, number of
   * milliseconds or string to parse.
   *
   * @param value - The date, number of milliseconds or string to parse
   *
   * @returns The date instance
   */
  new (value: DateArg<Date> & {}): DateType;
  /**
   * The date constructor. Creates date with the passed date values (year,
   * month, etc.) Note that the month is 0-indexed.
   *
   * @param year - The year
   * @param month - The month. Note that the month is 0-indexed.
   * @param date - The day of the month
   * @param hours - The hours
   * @param minutes - The minutes
   * @param seconds - The seconds
   * @param ms - The milliseconds
   *
   * @returns The date instance
   */
  new (
    year: number,
    month: number,
    date?: number,
    hours?: number,
    minutes?: number,
    seconds?: number,
    ms?: number,
  ): DateType;
}
/**
 * The duration object. Contains the duration in the units specified by the
 * object.
 */
export interface Duration {
  /** The number of years in the duration */
  years?: number;
  /** The number of months in the duration */
  months?: number;
  /** The number of weeks in the duration */
  weeks?: number;
  /** The number of days in the duration */
  days?: number;
  /** The number of hours in the duration */
  hours?: number;
  /** The number of minutes in the duration */
  minutes?: number;
  /** The number of seconds in the duration */
  seconds?: number;
}
/**
 * The duration unit type alias.
 */
export type DurationUnit = keyof Duration;
/**
 * An object that combines two dates to represent the time interval.
 *
 * @typeParam StartDate - The start `Date` type.
 * @typeParam EndDate - The end `Date` type.
 */
export interface Interval<
  StartType extends DateArg<Date> = DateArg<Date>,
  EndType extends DateArg<Date> = DateArg<Date>,
> {
  /** The start of the interval. */
  start: StartType;
  /** The end of the interval. */
  end: EndType;
}
/**
 * A version of {@link Interval} that has both start and end resolved to Date.
 */
export type NormalizedInterval<DateType extends Date = Date> = Interval<
  DateType,
  DateType
>;
/**
 * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).
 */
export type Era = 0 | 1;
/**
 * The year quarter. Goes from 1 to 4.
 */
export type Quarter = 1 | 2 | 3 | 4;
/**
 * The day of the week type alias. Unlike the date (the number of days since
 * the beginning of the month), which begins with 1 and is dynamic (can go up to
 * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at
 * it as an index in an array where Sunday is the first element and Saturday
 * is the last.
 */
export type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;
/**
 * The month type alias. Goes from 0 to 11, where 0 is January and 11 is
 * December.
 */
export type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
/**
 * FirstWeekContainsDate is used to determine which week is the first week of
 * the year, based on what day the January, 1 is in that week.
 *
 * The day in that week can only be 1 (Monday) or 4 (Thursday).
 *
 * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.
 */
export type FirstWeekContainsDate = 1 | 4;
/**
 * The date values, used to set or get date object values.
 */
export interface DateValues {
  /** The year */
  year?: number;
  /** The month */
  month?: number;
  /** The day of the month */
  date?: number;
  /** The hours */
  hours?: number;
  /** The minutes */
  minutes?: number;
  /** The seconds */
  seconds?: number;
  /** The milliseconds */
  milliseconds?: number;
}
/**
 * The number rounding method.
 */
export type RoundingMethod = "ceil" | "floor" | "round" | "trunc";
/**
 * The ISO string format.
 *
 * - basic: Minimal number of separators
 * - extended: With separators added to enhance human readability
 */
export type ISOStringFormat = "extended" | "basic";
/**
 * The ISO date representation. Represents which component the string includes,
 * date, time or both.
 */
export type ISOStringRepresentation = "complete" | "date" | "time";
/**
 * The step function options. Used to build function options.
 */
export interface StepOptions {
  /** The step to use when iterating */
  step?: number;
}
/**
 * The week function options. Used to build function options.
 */
export interface WeekOptions {
  /** Which day the week starts on. */
  weekStartsOn?: Day;
}
/**
 * The first week contains date options. Used to build function options.
 */
export interface FirstWeekContainsDateOptions {
  /** See {@link FirstWeekContainsDate} for more details. */
  firstWeekContainsDate?: FirstWeekContainsDate;
}
/**
 * The localized function options. Used to build function options.
 *
 * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.
 */
export interface LocalizedOptions<LocaleFields extends keyof Locale> {
  /** The locale to use in the function. */
  locale?: Pick<Locale, LocaleFields>;
}
/**
 * The ISO format function options. Used to build function options.
 */
export interface ISOFormatOptions {
  /** The format to use: basic with minimal number of separators or extended
   * with separators added to enhance human readability */
  format?: ISOStringFormat;
  /** The date representation - what component to format: date, time\
   * or both (complete) */
  representation?: ISOStringRepresentation;
}
/**
 * The rounding options. Used to build function options.
 */
export interface RoundingOptions {
  /** The rounding method to use */
  roundingMethod?: RoundingMethod;
}
/**
 * Additional tokens options. Used to build function options.
 */
export interface AdditionalTokensOptions {
  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.
   * See: https://date-fns.org/docs/Unicode-Tokens */
  useAdditionalWeekYearTokens?: boolean;
  /** If true, allows usage of the day of year tokens `D` and `DD`.
   * See: https://date-fns.org/docs/Unicode-Tokens */
  useAdditionalDayOfYearTokens?: boolean;
}
/**
 * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30
 * is nearest half an hour.
 */
export type NearestMinutes =
  | 1
  | 2
  | 3
  | 4
  | 5
  | 6
  | 7
  | 8
  | 9
  | 10
  | 11
  | 12
  | 13
  | 14
  | 15
  | 16
  | 17
  | 18
  | 19
  | 20
  | 21
  | 22
  | 23
  | 24
  | 25
  | 26
  | 27
  | 28
  | 29
  | 30;
/**
 * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12
 * is nearest half a day.
 */
export type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;
/**
 * The nearest minutes function options. Used to build function options.
 *
 * @deprecated Use {@link NearestToUnitOptions} instead.
 */
export type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;
/**
 * The nearest unit function options. Used to build function options.
 */
export interface NearestToUnitOptions<Unit extends number> {
  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter
   * hours. */
  nearestTo?: Unit;
}
/**
 * The context options. Used to build function options.
 */
export interface ContextOptions<DateType extends Date> {
  /**
   * The context to use in the function. It allows to normalize the arguments
   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).
   */
  in?: ContextFn<DateType> | undefined;
}
/**
  /**
   * The context function type. It's used to normalize the input arguments to
   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).
   */
export type ContextFn<DateType extends Date> = (
  value: DateArg<Date> & {},
) => DateType;
/**
 * Resolves passed type or array of types.
 */
export type MaybeArray<Type> = Type | Type[];

~~~

## node_modules\date-fns-jalali\types.d.ts

~~~ts
import { type constructFromSymbol } from "./constants.js";
import type { Locale } from "./locale/types.js";
export type * from "./fp/types.js";
export type * from "./locale/types.js";
/**
 * The argument type.
 */
export type DateArg<DateType extends Date> = DateType | number | string;
/**
 * Date extension interface that allows to transfer extra properties from
 * the reference date to the new date. It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)
 * that accept a time zone as a constructor argument.
 */
export interface ConstructableDate extends Date {
  [constructFromSymbol]: <DateType extends Date = Date>(
    value: DateArg<Date> & {},
  ) => DateType;
}
/**
 * The generic date constructor. Replicates the Date constructor. Used to build
 * generic functions.
 *
 * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).
 */
export interface GenericDateConstructor<DateType extends Date = Date> {
  /**
   * The date constructor. Creates date with the current date and time.
   *
   * @returns The date instance
   */
  new (): DateType;
  /**
   * The date constructor. Creates date with the passed date, number of
   * milliseconds or string to parse.
   *
   * @param value - The date, number of milliseconds or string to parse
   *
   * @returns The date instance
   */
  new (value: DateArg<Date> & {}): DateType;
  /**
   * The date constructor. Creates date with the passed date values (year,
   * month, etc.) Note that the month is 0-indexed.
   *
   * @param year - The year
   * @param month - The month. Note that the month is 0-indexed.
   * @param date - The day of the month
   * @param hours - The hours
   * @param minutes - The minutes
   * @param seconds - The seconds
   * @param ms - The milliseconds
   *
   * @returns The date instance
   */
  new (
    year: number,
    month: number,
    date?: number,
    hours?: number,
    minutes?: number,
    seconds?: number,
    ms?: number,
  ): DateType;
}
/**
 * The duration object. Contains the duration in the units specified by the
 * object.
 */
export interface Duration {
  /** The number of years in the duration */
  years?: number;
  /** The number of months in the duration */
  months?: number;
  /** The number of weeks in the duration */
  weeks?: number;
  /** The number of days in the duration */
  days?: number;
  /** The number of hours in the duration */
  hours?: number;
  /** The number of minutes in the duration */
  minutes?: number;
  /** The number of seconds in the duration */
  seconds?: number;
}
/**
 * The duration unit type alias.
 */
export type DurationUnit = keyof Duration;
/**
 * An object that combines two dates to represent the time interval.
 *
 * @typeParam StartDate - The start `Date` type.
 * @typeParam EndDate - The end `Date` type.
 */
export interface Interval<
  StartType extends DateArg<Date> = DateArg<Date>,
  EndType extends DateArg<Date> = DateArg<Date>,
> {
  /** The start of the interval. */
  start: StartType;
  /** The end of the interval. */
  end: EndType;
}
/**
 * A version of {@link Interval} that has both start and end resolved to Date.
 */
export type NormalizedInterval<DateType extends Date = Date> = Interval<
  DateType,
  DateType
>;
/**
 * The era. Can be either 0 (AD - Anno Domini) or 1 (BC - Before Christ).
 */
export type Era = 0 | 1;
/**
 * The year quarter. Goes from 1 to 4.
 */
export type Quarter = 1 | 2 | 3 | 4;
/**
 * The day of the week type alias. Unlike the date (the number of days since
 * the beginning of the month), which begins with 1 and is dynamic (can go up to
 * 28, 30, or 31), the day starts with 0 and static (always ends at 6). Look at
 * it as an index in an array where Sunday is the first element and Saturday
 * is the last.
 */
export type Day = 0 | 1 | 2 | 3 | 4 | 5 | 6;
/**
 * The month type alias. Goes from 0 to 11, where 0 is January and 11 is
 * December.
 */
export type Month = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
/**
 * FirstWeekContainsDate is used to determine which week is the first week of
 * the year, based on what day the January, 1 is in that week.
 *
 * The day in that week can only be 1 (Monday) or 4 (Thursday).
 *
 * Please see https://en.wikipedia.org/wiki/Week#The_ISO_week_date_system for more information.
 */
export type FirstWeekContainsDate = 1 | 4;
/**
 * The date values, used to set or get date object values.
 */
export interface DateValues {
  /** The year */
  year?: number;
  /** The month */
  month?: number;
  /** The day of the month */
  date?: number;
  /** The hours */
  hours?: number;
  /** The minutes */
  minutes?: number;
  /** The seconds */
  seconds?: number;
  /** The milliseconds */
  milliseconds?: number;
}
/**
 * The number rounding method.
 */
export type RoundingMethod = "ceil" | "floor" | "round" | "trunc";
/**
 * The ISO string format.
 *
 * - basic: Minimal number of separators
 * - extended: With separators added to enhance human readability
 */
export type ISOStringFormat = "extended" | "basic";
/**
 * The ISO date representation. Represents which component the string includes,
 * date, time or both.
 */
export type ISOStringRepresentation = "complete" | "date" | "time";
/**
 * The step function options. Used to build function options.
 */
export interface StepOptions {
  /** The step to use when iterating */
  step?: number;
}
/**
 * The week function options. Used to build function options.
 */
export interface WeekOptions {
  /** Which day the week starts on. */
  weekStartsOn?: Day;
}
/**
 * The first week contains date options. Used to build function options.
 */
export interface FirstWeekContainsDateOptions {
  /** See {@link FirstWeekContainsDate} for more details. */
  firstWeekContainsDate?: FirstWeekContainsDate;
}
/**
 * The localized function options. Used to build function options.
 *
 * @typeParam LocaleFields - The locale fields used in the relevant function. Defines the minimum set of locale fields that must be provided.
 */
export interface LocalizedOptions<LocaleFields extends keyof Locale> {
  /** The locale to use in the function. */
  locale?: Pick<Locale, LocaleFields>;
}
/**
 * The ISO format function options. Used to build function options.
 */
export interface ISOFormatOptions {
  /** The format to use: basic with minimal number of separators or extended
   * with separators added to enhance human readability */
  format?: ISOStringFormat;
  /** The date representation - what component to format: date, time\
   * or both (complete) */
  representation?: ISOStringRepresentation;
}
/**
 * The rounding options. Used to build function options.
 */
export interface RoundingOptions {
  /** The rounding method to use */
  roundingMethod?: RoundingMethod;
}
/**
 * Additional tokens options. Used to build function options.
 */
export interface AdditionalTokensOptions {
  /** If true, allows usage of the week-numbering year tokens `YY` and `YYYY`.
   * See: https://date-fns.org/docs/Unicode-Tokens */
  useAdditionalWeekYearTokens?: boolean;
  /** If true, allows usage of the day of year tokens `D` and `DD`.
   * See: https://date-fns.org/docs/Unicode-Tokens */
  useAdditionalDayOfYearTokens?: boolean;
}
/**
 * Nearest minute type. Goes from 1 to 30, where 1 is the nearest minute and 30
 * is nearest half an hour.
 */
export type NearestMinutes =
  | 1
  | 2
  | 3
  | 4
  | 5
  | 6
  | 7
  | 8
  | 9
  | 10
  | 11
  | 12
  | 13
  | 14
  | 15
  | 16
  | 17
  | 18
  | 19
  | 20
  | 21
  | 22
  | 23
  | 24
  | 25
  | 26
  | 27
  | 28
  | 29
  | 30;
/**
 * Nearest hour type. Goes from 1 to 12, where 1 is the nearest hour and 12
 * is nearest half a day.
 */
export type NearestHours = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;
/**
 * The nearest minutes function options. Used to build function options.
 *
 * @deprecated Use {@link NearestToUnitOptions} instead.
 */
export type NearestMinutesOptions = NearestToUnitOptions<NearestMinutes>;
/**
 * The nearest unit function options. Used to build function options.
 */
export interface NearestToUnitOptions<Unit extends number> {
  /** The nearest unit to round to. E.g. for minutes `15` to round to quarter
   * hours. */
  nearestTo?: Unit;
}
/**
 * The context options. Used to build function options.
 */
export interface ContextOptions<DateType extends Date> {
  /**
   * The context to use in the function. It allows to normalize the arguments
   * to a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).
   */
  in?: ContextFn<DateType> | undefined;
}
/**
  /**
   * The context function type. It's used to normalize the input arguments to
   * a specific date instance, which is useful for extensions like [`TZDate`](https://github.com/date-fns/tz).
   */
export type ContextFn<DateType extends Date> = (
  value: DateArg<Date> & {},
) => DateType;
/**
 * Resolves passed type or array of types.
 */
export type MaybeArray<Type> = Type | Type[];

~~~

## node_modules\date-fns-jalali\types.js

~~~js
export {};

~~~

## node_modules\date-fns-jalali\weeksToDays.cjs

~~~cjs
"use strict";
exports.weeksToDays = weeksToDays;
var _index = require("./constants.cjs");

/**
 * @name weeksToDays
 * @category Conversion Helpers
 * @summary Convert weeks to days.
 *
 * @description
 * Convert a number of weeks to a full number of days.
 *
 * @param weeks - The number of weeks to be converted
 *
 * @returns The number of weeks converted in days
 *
 * @example
 * // Convert 2 weeks into days
 * const result = weeksToDays(2)
 * //=> 14
 */
function weeksToDays(weeks) {
  return Math.trunc(weeks * _index.daysInWeek);
}

~~~

## node_modules\date-fns-jalali\weeksToDays.d.cts

~~~cts
/**
 * @name weeksToDays
 * @category Conversion Helpers
 * @summary Convert weeks to days.
 *
 * @description
 * Convert a number of weeks to a full number of days.
 *
 * @param weeks - The number of weeks to be converted
 *
 * @returns The number of weeks converted in days
 *
 * @example
 * // Convert 2 weeks into days
 * const result = weeksToDays(2)
 * //=> 14
 */
export declare function weeksToDays(weeks: number): number;

~~~

## node_modules\date-fns-jalali\weeksToDays.d.ts

~~~ts
/**
 * @name weeksToDays
 * @category Conversion Helpers
 * @summary Convert weeks to days.
 *
 * @description
 * Convert a number of weeks to a full number of days.
 *
 * @param weeks - The number of weeks to be converted
 *
 * @returns The number of weeks converted in days
 *
 * @example
 * // Convert 2 weeks into days
 * const result = weeksToDays(2)
 * //=> 14
 */
export declare function weeksToDays(weeks: number): number;

~~~

## node_modules\date-fns-jalali\weeksToDays.js

~~~js
import { daysInWeek } from "./constants.js";

/**
 * @name weeksToDays
 * @category Conversion Helpers
 * @summary Convert weeks to days.
 *
 * @description
 * Convert a number of weeks to a full number of days.
 *
 * @param weeks - The number of weeks to be converted
 *
 * @returns The number of weeks converted in days
 *
 * @example
 * // Convert 2 weeks into days
 * const result = weeksToDays(2)
 * //=> 14
 */
export function weeksToDays(weeks) {
  return Math.trunc(weeks * daysInWeek);
}

// Fallback for modularized imports:
export default weeksToDays;

~~~

## node_modules\date-fns-jalali\yearsToDays.cjs

~~~cjs
"use strict";
exports.yearsToDays = yearsToDays;
var _index = require("./constants.cjs");

/**
 * @name yearsToDays
 * @category Conversion Helpers
 * @summary Convert years to days.
 *
 * @description
 * Convert a number of years to a full number of days.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in days
 *
 * @example
 * // Convert 2 years into days
 * const result = yearsToDays(2)
 * //=> 730
 */
function yearsToDays(years) {
  return Math.trunc(years * _index.daysInYear);
}

~~~

## node_modules\date-fns-jalali\yearsToDays.d.cts

~~~cts
/**
 * @name yearsToDays
 * @category Conversion Helpers
 * @summary Convert years to days.
 *
 * @description
 * Convert a number of years to a full number of days.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in days
 *
 * @example
 * // Convert 2 years into days
 * const result = yearsToDays(2)
 * //=> 730
 */
export declare function yearsToDays(years: number): number;

~~~

## node_modules\date-fns-jalali\yearsToDays.d.ts

~~~ts
/**
 * @name yearsToDays
 * @category Conversion Helpers
 * @summary Convert years to days.
 *
 * @description
 * Convert a number of years to a full number of days.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in days
 *
 * @example
 * // Convert 2 years into days
 * const result = yearsToDays(2)
 * //=> 730
 */
export declare function yearsToDays(years: number): number;

~~~

## node_modules\date-fns-jalali\yearsToDays.js

~~~js
import { daysInYear } from "./constants.js";

/**
 * @name yearsToDays
 * @category Conversion Helpers
 * @summary Convert years to days.
 *
 * @description
 * Convert a number of years to a full number of days.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in days
 *
 * @example
 * // Convert 2 years into days
 * const result = yearsToDays(2)
 * //=> 730
 */
export function yearsToDays(years) {
  return Math.trunc(years * daysInYear);
}

// Fallback for modularized imports:
export default yearsToDays;

~~~

## node_modules\date-fns-jalali\yearsToMonths.cjs

~~~cjs
"use strict";
exports.yearsToMonths = yearsToMonths;
var _index = require("./constants.cjs");

/**
 * @name yearsToMonths
 * @category Conversion Helpers
 * @summary Convert years to months.
 *
 * @description
 * Convert a number of years to a full number of months.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in months
 *
 * @example
 * // Convert 2 years into months
 * const result = yearsToMonths(2)
 * //=> 24
 */
function yearsToMonths(years) {
  return Math.trunc(years * _index.monthsInYear);
}

~~~

## node_modules\date-fns-jalali\yearsToMonths.d.cts

~~~cts
/**
 * @name yearsToMonths
 * @category Conversion Helpers
 * @summary Convert years to months.
 *
 * @description
 * Convert a number of years to a full number of months.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in months
 *
 * @example
 * // Convert 2 years into months
 * const result = yearsToMonths(2)
 * //=> 24
 */
export declare function yearsToMonths(years: number): number;

~~~

## node_modules\date-fns-jalali\yearsToMonths.d.ts

~~~ts
/**
 * @name yearsToMonths
 * @category Conversion Helpers
 * @summary Convert years to months.
 *
 * @description
 * Convert a number of years to a full number of months.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in months
 *
 * @example
 * // Convert 2 years into months
 * const result = yearsToMonths(2)
 * //=> 24
 */
export declare function yearsToMonths(years: number): number;

~~~

## node_modules\date-fns-jalali\yearsToMonths.js

~~~js
import { monthsInYear } from "./constants.js";

/**
 * @name yearsToMonths
 * @category Conversion Helpers
 * @summary Convert years to months.
 *
 * @description
 * Convert a number of years to a full number of months.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in months
 *
 * @example
 * // Convert 2 years into months
 * const result = yearsToMonths(2)
 * //=> 24
 */
export function yearsToMonths(years) {
  return Math.trunc(years * monthsInYear);
}

// Fallback for modularized imports:
export default yearsToMonths;

~~~

## node_modules\date-fns-jalali\yearsToQuarters.cjs

~~~cjs
"use strict";
exports.yearsToQuarters = yearsToQuarters;
var _index = require("./constants.cjs");

/**
 * @name yearsToQuarters
 * @category Conversion Helpers
 * @summary Convert years to quarters.
 *
 * @description
 * Convert a number of years to a full number of quarters.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in quarters
 *
 * @example
 * // Convert 2 years to quarters
 * const result = yearsToQuarters(2)
 * //=> 8
 */
function yearsToQuarters(years) {
  return Math.trunc(years * _index.quartersInYear);
}

~~~

## node_modules\date-fns-jalali\yearsToQuarters.d.cts

~~~cts
/**
 * @name yearsToQuarters
 * @category Conversion Helpers
 * @summary Convert years to quarters.
 *
 * @description
 * Convert a number of years to a full number of quarters.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in quarters
 *
 * @example
 * // Convert 2 years to quarters
 * const result = yearsToQuarters(2)
 * //=> 8
 */
export declare function yearsToQuarters(years: number): number;

~~~

## node_modules\date-fns-jalali\yearsToQuarters.d.ts

~~~ts
/**
 * @name yearsToQuarters
 * @category Conversion Helpers
 * @summary Convert years to quarters.
 *
 * @description
 * Convert a number of years to a full number of quarters.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in quarters
 *
 * @example
 * // Convert 2 years to quarters
 * const result = yearsToQuarters(2)
 * //=> 8
 */
export declare function yearsToQuarters(years: number): number;

~~~

## node_modules\date-fns-jalali\yearsToQuarters.js

~~~js
import { quartersInYear } from "./constants.js";

/**
 * @name yearsToQuarters
 * @category Conversion Helpers
 * @summary Convert years to quarters.
 *
 * @description
 * Convert a number of years to a full number of quarters.
 *
 * @param years - The number of years to be converted
 *
 * @returns The number of years converted in quarters
 *
 * @example
 * // Convert 2 years to quarters
 * const result = yearsToQuarters(2)
 * //=> 8
 */
export function yearsToQuarters(years) {
  return Math.trunc(years * quartersInYear);
}

// Fallback for modularized imports:
export default yearsToQuarters;

~~~

## node_modules\detect-node-es\es5\browser.js

~~~js
module.exports.isNode = false;


~~~

## node_modules\detect-node-es\es5\node.d.ts

~~~ts
/**
 * returns true if the current environment is NodeJS
 */
export declare const isNode: boolean;
~~~

## node_modules\detect-node-es\es5\node.js

~~~js
// Only Node.JS has a process variable that is of [[Class]] process
module.exports.isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

~~~

## node_modules\detect-node-es\esm\browser.js

~~~js
export const isNode = false;


~~~

## node_modules\detect-node-es\esm\node.js

~~~js
// Only Node.JS has a process variable that is of [[Class]] process
export const isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

~~~

## node_modules\detect-node-es\LICENSE

~~~text
MIT License

Copyright (c) 2017 Ilya Kantor

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

~~~

## node_modules\detect-node-es\package.json

~~~json
{
  "name": "detect-node-es",
  "version": "1.1.0",
  "description": "Detect Node.JS (as opposite to browser environment). ESM modification",
  "main": "es5/node.js",
  "module": "esm/node.js",
  "browser": {
    "./es5/node.js": "./es5/browser.js",
    "./esm/node.js": "./esm/browser.js"
  },
  "types": "es5/node.d.ts",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/thekashey/detect-node"
  },
  "keywords": [
    "detect",
    "node"
  ],
  "author": "Ilya Kantor",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/thekashey/detect-node/issues"
  },
  "homepage": "https://github.com/thekashey/detect-node"
}

~~~

## node_modules\detect-node-es\Readme.md

~~~md
## detect-node
> This is a fork of `detect-node`.

Differences:
- uses named export {isNode}
- has d.ts integrated
- supports ESM

### Install

```shell
npm install --save detect-node-es
```

### Usage:

```diff
-var isNode = require('detect-node');
+var {isNode} = require('detect-node-es');

if (isNode) {
  console.log("Running under Node.JS");
} else {
  alert("Hello from browser (or whatever not-a-node env)");
}
```

The check is performed as:
```js
module.exports = false;

// Only Node.JS has a process variable that is of [[Class]] process
try {
 module.exports = Object.prototype.toString.call(global.process) === '[object process]' 
} catch(e) {}

```

Thanks to Ingvar Stepanyan for the initial idea. This check is both **the most reliable I could find** and it does not use `process` env directly, which would cause browserify to include it into the build.

~~~

## node_modules\embla-carousel\cjs\components\Alignment.d.ts

~~~ts
export type AlignmentOptionType = 'start' | 'center' | 'end' | ((viewSize: number, snapSize: number, index: number) => number);
export type AlignmentType = {
    measure: (n: number, index: number) => number;
};
export declare function Alignment(align: AlignmentOptionType, viewSize: number): AlignmentType;

~~~

## node_modules\embla-carousel\cjs\components\Animations.d.ts

~~~ts
import { EngineType } from './Engine';
import { WindowType } from './utils';
export type AnimationsUpdateType = (engine: EngineType) => void;
export type AnimationsRenderType = (engine: EngineType, alpha: number) => void;
export type AnimationsType = {
    init: () => void;
    destroy: () => void;
    start: () => void;
    stop: () => void;
    update: () => void;
    render: (alpha: number) => void;
};
export declare function Animations(ownerDocument: Document, ownerWindow: WindowType, update: () => void, render: (alpha: number) => void): AnimationsType;

~~~

## node_modules\embla-carousel\cjs\components\Axis.d.ts

~~~ts
import { NodeRectType } from './NodeRects';
export type AxisOptionType = 'x' | 'y';
export type AxisDirectionOptionType = 'ltr' | 'rtl';
type AxisEdgeType = 'top' | 'right' | 'bottom' | 'left';
export type AxisType = {
    scroll: AxisOptionType;
    cross: AxisOptionType;
    startEdge: AxisEdgeType;
    endEdge: AxisEdgeType;
    measureSize: (nodeRect: NodeRectType) => number;
    direction: (n: number) => number;
};
export declare function Axis(axis: AxisOptionType, contentDirection: AxisDirectionOptionType): AxisType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\Counter.d.ts

~~~ts
export type CounterType = {
    get: () => number;
    set: (n: number) => CounterType;
    add: (n: number) => CounterType;
    clone: () => CounterType;
};
export declare function Counter(max: number, start: number, loop: boolean): CounterType;

~~~

## node_modules\embla-carousel\cjs\components\DragHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
import { AnimationsType } from './Animations';
import { CounterType } from './Counter';
import { DragTrackerType, PointerEventType } from './DragTracker';
import { EventHandlerType } from './EventHandler';
import { AxisType } from './Axis';
import { ScrollBodyType } from './ScrollBody';
import { ScrollTargetType } from './ScrollTarget';
import { ScrollToType } from './ScrollTo';
import { Vector1DType } from './Vector1d';
import { PercentOfViewType } from './PercentOfView';
import { WindowType } from './utils';
type DragHandlerCallbackType = (emblaApi: EmblaCarouselType, evt: PointerEventType) => boolean | void;
export type DragHandlerOptionType = boolean | DragHandlerCallbackType;
export type DragHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
    pointerDown: () => boolean;
};
export declare function DragHandler(axis: AxisType, rootNode: HTMLElement, ownerDocument: Document, ownerWindow: WindowType, target: Vector1DType, dragTracker: DragTrackerType, location: Vector1DType, animation: AnimationsType, scrollTo: ScrollToType, scrollBody: ScrollBodyType, scrollTarget: ScrollTargetType, index: CounterType, eventHandler: EventHandlerType, percentOfView: PercentOfViewType, dragFree: boolean, dragThreshold: number, skipSnaps: boolean, baseFriction: number, watchDrag: DragHandlerOptionType): DragHandlerType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\DragTracker.d.ts

~~~ts
import { AxisOptionType, AxisType } from './Axis';
import { WindowType } from './utils';
export type PointerEventType = TouchEvent | MouseEvent;
export type DragTrackerType = {
    pointerDown: (evt: PointerEventType) => number;
    pointerMove: (evt: PointerEventType) => number;
    pointerUp: (evt: PointerEventType) => number;
    readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number;
};
export declare function DragTracker(axis: AxisType, ownerWindow: WindowType): DragTrackerType;

~~~

## node_modules\embla-carousel\cjs\components\EmblaCarousel.d.ts

~~~ts
import { EngineType } from './Engine';
import { EventHandlerType } from './EventHandler';
import { EmblaOptionsType } from './Options';
import { EmblaPluginsType, EmblaPluginType } from './Plugins';
export type EmblaCarouselType = {
    canScrollNext: () => boolean;
    canScrollPrev: () => boolean;
    containerNode: () => HTMLElement;
    internalEngine: () => EngineType;
    destroy: () => void;
    off: EventHandlerType['off'];
    on: EventHandlerType['on'];
    emit: EventHandlerType['emit'];
    plugins: () => EmblaPluginsType;
    previousScrollSnap: () => number;
    reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void;
    rootNode: () => HTMLElement;
    scrollNext: (jump?: boolean) => void;
    scrollPrev: (jump?: boolean) => void;
    scrollProgress: () => number;
    scrollSnapList: () => number[];
    scrollTo: (index: number, jump?: boolean) => void;
    selectedScrollSnap: () => number;
    slideNodes: () => HTMLElement[];
    slidesInView: () => number[];
    slidesNotInView: () => number[];
};
declare function EmblaCarousel(root: HTMLElement, userOptions?: EmblaOptionsType, userPlugins?: EmblaPluginType[]): EmblaCarouselType;
declare namespace EmblaCarousel {
    let globalOptions: EmblaOptionsType | undefined;
}
export default EmblaCarousel;

~~~

## node_modules\embla-carousel\cjs\components\Engine.d.ts

~~~ts
import { AnimationsType } from './Animations';
import { AxisType } from './Axis';
import { CounterType } from './Counter';
import { DragHandlerType } from './DragHandler';
import { EventHandlerType } from './EventHandler';
import { EventStoreType } from './EventStore';
import { LimitType } from './Limit';
import { NodeRectType } from './NodeRects';
import { OptionsType } from './Options';
import { PercentOfViewType } from './PercentOfView';
import { ResizeHandlerType } from './ResizeHandler';
import { ScrollBodyType } from './ScrollBody';
import { ScrollBoundsType } from './ScrollBounds';
import { ScrollLooperType } from './ScrollLooper';
import { ScrollProgressType } from './ScrollProgress';
import { SlideRegistryType } from './SlideRegistry';
import { ScrollTargetType } from './ScrollTarget';
import { ScrollToType } from './ScrollTo';
import { SlideFocusType } from './SlideFocus';
import { SlideLooperType } from './SlideLooper';
import { SlidesHandlerType } from './SlidesHandler';
import { SlidesInViewType } from './SlidesInView';
import { SlidesToScrollType } from './SlidesToScroll';
import { TranslateType } from './Translate';
import { WindowType } from './utils';
import { Vector1DType } from './Vector1d';
export type EngineType = {
    ownerDocument: Document;
    ownerWindow: WindowType;
    eventHandler: EventHandlerType;
    axis: AxisType;
    animation: AnimationsType;
    scrollBounds: ScrollBoundsType;
    scrollLooper: ScrollLooperType;
    scrollProgress: ScrollProgressType;
    index: CounterType;
    indexPrevious: CounterType;
    limit: LimitType;
    location: Vector1DType;
    offsetLocation: Vector1DType;
    previousLocation: Vector1DType;
    options: OptionsType;
    percentOfView: PercentOfViewType;
    scrollBody: ScrollBodyType;
    dragHandler: DragHandlerType;
    eventStore: EventStoreType;
    slideLooper: SlideLooperType;
    slidesInView: SlidesInViewType;
    slidesToScroll: SlidesToScrollType;
    target: Vector1DType;
    translate: TranslateType;
    resizeHandler: ResizeHandlerType;
    slidesHandler: SlidesHandlerType;
    scrollTo: ScrollToType;
    scrollTarget: ScrollTargetType;
    scrollSnapList: number[];
    scrollSnaps: number[];
    slideIndexes: number[];
    slideFocus: SlideFocusType;
    slideRegistry: SlideRegistryType['slideRegistry'];
    containerRect: NodeRectType;
    slideRects: NodeRectType[];
};
export declare function Engine(root: HTMLElement, container: HTMLElement, slides: HTMLElement[], ownerDocument: Document, ownerWindow: WindowType, options: OptionsType, eventHandler: EventHandlerType): EngineType;

~~~

## node_modules\embla-carousel\cjs\components\EventHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
type CallbackType = (emblaApi: EmblaCarouselType, evt: EmblaEventType) => void;
export type EmblaEventType = EmblaEventListType[keyof EmblaEventListType];
export interface EmblaEventListType {
    init: 'init';
    pointerDown: 'pointerDown';
    pointerUp: 'pointerUp';
    slidesChanged: 'slidesChanged';
    slidesInView: 'slidesInView';
    scroll: 'scroll';
    select: 'select';
    settle: 'settle';
    destroy: 'destroy';
    reInit: 'reInit';
    resize: 'resize';
    slideFocusStart: 'slideFocusStart';
    slideFocus: 'slideFocus';
}
export type EventHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    emit: (evt: EmblaEventType) => EventHandlerType;
    on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType;
    off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType;
    clear: () => void;
};
export declare function EventHandler(): EventHandlerType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\EventStore.d.ts

~~~ts
type EventNameType = keyof DocumentEventMap | keyof WindowEventMap;
type EventHandlerType = (evt: any) => void;
type EventOptionsType = boolean | AddEventListenerOptions | undefined;
export type EventStoreType = {
    add: (node: EventTarget, type: EventNameType, handler: EventHandlerType, options?: EventOptionsType) => EventStoreType;
    clear: () => void;
};
export declare function EventStore(): EventStoreType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\Limit.d.ts

~~~ts
export type LimitType = {
    min: number;
    max: number;
    length: number;
    constrain: (n: number) => number;
    reachedAny: (n: number) => boolean;
    reachedMax: (n: number) => boolean;
    reachedMin: (n: number) => boolean;
    removeOffset: (n: number) => number;
};
export declare function Limit(min?: number, max?: number): LimitType;

~~~

## node_modules\embla-carousel\cjs\components\NodeRects.d.ts

~~~ts
export type NodeRectType = {
    top: number;
    right: number;
    bottom: number;
    left: number;
    width: number;
    height: number;
};
export type NodeRectsType = {
    measure: (node: HTMLElement) => NodeRectType;
};
export declare function NodeRects(): NodeRectsType;

~~~

## node_modules\embla-carousel\cjs\components\Options.d.ts

~~~ts
import { AlignmentOptionType } from './Alignment';
import { AxisDirectionOptionType, AxisOptionType } from './Axis';
import { SlidesToScrollOptionType } from './SlidesToScroll';
import { ScrollContainOptionType } from './ScrollContain';
import { DragHandlerOptionType } from './DragHandler';
import { ResizeHandlerOptionType } from './ResizeHandler';
import { SlidesHandlerOptionType } from './SlidesHandler';
import { SlidesInViewOptionsType } from './SlidesInView';
import { FocusHandlerOptionType } from './SlideFocus';
export type LooseOptionsType = {
    [key: string]: unknown;
};
export type CreateOptionsType<Type extends LooseOptionsType> = Type & {
    active: boolean;
    breakpoints: {
        [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>;
    };
};
export type OptionsType = CreateOptionsType<{
    align: AlignmentOptionType;
    axis: AxisOptionType;
    container: string | HTMLElement | null;
    slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null;
    containScroll: ScrollContainOptionType;
    direction: AxisDirectionOptionType;
    slidesToScroll: SlidesToScrollOptionType;
    dragFree: boolean;
    dragThreshold: number;
    inViewThreshold: SlidesInViewOptionsType;
    loop: boolean;
    skipSnaps: boolean;
    duration: number;
    startIndex: number;
    watchDrag: DragHandlerOptionType;
    watchResize: ResizeHandlerOptionType;
    watchSlides: SlidesHandlerOptionType;
    watchFocus: FocusHandlerOptionType;
}>;
export declare const defaultOptions: OptionsType;
export type EmblaOptionsType = Partial<OptionsType>;

~~~

## node_modules\embla-carousel\cjs\components\OptionsHandler.d.ts

~~~ts
import { LooseOptionsType, CreateOptionsType } from './Options';
import { WindowType } from './utils';
type OptionsType = Partial<CreateOptionsType<LooseOptionsType>>;
export type OptionsHandlerType = {
    mergeOptions: <TypeA extends OptionsType, TypeB extends OptionsType>(optionsA: TypeA, optionsB?: TypeB) => TypeA;
    optionsAtMedia: <Type extends OptionsType>(options: Type) => Type;
    optionsMediaQueries: (optionsList: OptionsType[]) => MediaQueryList[];
};
export declare function OptionsHandler(ownerWindow: WindowType): OptionsHandlerType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\PercentOfView.d.ts

~~~ts
export type PercentOfViewType = {
    measure: (n: number) => number;
};
export declare function PercentOfView(viewSize: number): PercentOfViewType;

~~~

## node_modules\embla-carousel\cjs\components\Plugins.d.ts

~~~ts
import { CreateOptionsType, LooseOptionsType } from './Options';
import { EmblaCarouselType } from './EmblaCarousel';
import { OptionsHandlerType } from './OptionsHandler';
export type LoosePluginType = {
    [key: string]: unknown;
};
export type CreatePluginType<TypeA extends LoosePluginType, TypeB extends LooseOptionsType> = TypeA & {
    name: string;
    options: Partial<CreateOptionsType<TypeB>>;
    init: (embla: EmblaCarouselType, OptionsHandler: OptionsHandlerType) => void;
    destroy: () => void;
};
export interface EmblaPluginsType {
    [key: string]: CreatePluginType<LoosePluginType, {}>;
}
export type EmblaPluginType = EmblaPluginsType[keyof EmblaPluginsType];

~~~

## node_modules\embla-carousel\cjs\components\PluginsHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
import { OptionsHandlerType } from './OptionsHandler';
import { EmblaPluginsType, EmblaPluginType } from './Plugins';
export type PluginsHandlerType = {
    init: (emblaApi: EmblaCarouselType, plugins: EmblaPluginType[]) => EmblaPluginsType;
    destroy: () => void;
};
export declare function PluginsHandler(optionsHandler: OptionsHandlerType): PluginsHandlerType;

~~~

## node_modules\embla-carousel\cjs\components\ResizeHandler.d.ts

~~~ts
import { AxisType } from './Axis';
import { EmblaCarouselType } from './EmblaCarousel';
import { EventHandlerType } from './EventHandler';
import { NodeRectsType } from './NodeRects';
import { WindowType } from './utils';
type ResizeHandlerCallbackType = (emblaApi: EmblaCarouselType, entries: ResizeObserverEntry[]) => boolean | void;
export type ResizeHandlerOptionType = boolean | ResizeHandlerCallbackType;
export type ResizeHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
};
export declare function ResizeHandler(container: HTMLElement, eventHandler: EventHandlerType, ownerWindow: WindowType, slides: HTMLElement[], axis: AxisType, watchResize: ResizeHandlerOptionType, nodeRects: NodeRectsType): ResizeHandlerType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\ScrollBody.d.ts

~~~ts
import { Vector1DType } from './Vector1d';
export type ScrollBodyType = {
    direction: () => number;
    duration: () => number;
    velocity: () => number;
    seek: () => ScrollBodyType;
    settled: () => boolean;
    useBaseFriction: () => ScrollBodyType;
    useBaseDuration: () => ScrollBodyType;
    useFriction: (n: number) => ScrollBodyType;
    useDuration: (n: number) => ScrollBodyType;
};
export declare function ScrollBody(location: Vector1DType, offsetLocation: Vector1DType, previousLocation: Vector1DType, target: Vector1DType, baseDuration: number, baseFriction: number): ScrollBodyType;

~~~

## node_modules\embla-carousel\cjs\components\ScrollBounds.d.ts

~~~ts
import { LimitType } from './Limit';
import { ScrollBodyType } from './ScrollBody';
import { Vector1DType } from './Vector1d';
import { PercentOfViewType } from './PercentOfView';
export type ScrollBoundsType = {
    shouldConstrain: () => boolean;
    constrain: (pointerDown: boolean) => void;
    toggleActive: (active: boolean) => void;
};
export declare function ScrollBounds(limit: LimitType, location: Vector1DType, target: Vector1DType, scrollBody: ScrollBodyType, percentOfView: PercentOfViewType): ScrollBoundsType;

~~~

## node_modules\embla-carousel\cjs\components\ScrollContain.d.ts

~~~ts
import { LimitType } from './Limit';
export type ScrollContainOptionType = false | 'trimSnaps' | 'keepSnaps';
export type ScrollContainType = {
    snapsContained: number[];
    scrollContainLimit: LimitType;
};
export declare function ScrollContain(viewSize: number, contentSize: number, snapsAligned: number[], containScroll: ScrollContainOptionType, pixelTolerance: number): ScrollContainType;

~~~

## node_modules\embla-carousel\cjs\components\ScrollLimit.d.ts

~~~ts
import { LimitType } from './Limit';
export type ScrollLimitType = {
    limit: LimitType;
};
export declare function ScrollLimit(contentSize: number, scrollSnaps: number[], loop: boolean): ScrollLimitType;

~~~

## node_modules\embla-carousel\cjs\components\ScrollLooper.d.ts

~~~ts
import { LimitType } from './Limit';
import { Vector1DType } from './Vector1d';
export type ScrollLooperType = {
    loop: (direction: number) => void;
};
export declare function ScrollLooper(contentSize: number, limit: LimitType, location: Vector1DType, vectors: Vector1DType[]): ScrollLooperType;

~~~

## node_modules\embla-carousel\cjs\components\ScrollProgress.d.ts

~~~ts
import { LimitType } from './Limit';
export type ScrollProgressType = {
    get: (n: number) => number;
};
export declare function ScrollProgress(limit: LimitType): ScrollProgressType;

~~~

## node_modules\embla-carousel\cjs\components\ScrollSnaps.d.ts

~~~ts
import { AlignmentType } from './Alignment';
import { AxisType } from './Axis';
import { NodeRectType } from './NodeRects';
import { SlidesToScrollType } from './SlidesToScroll';
export type ScrollSnapsType = {
    snaps: number[];
    snapsAligned: number[];
};
export declare function ScrollSnaps(axis: AxisType, alignment: AlignmentType, containerRect: NodeRectType, slideRects: NodeRectType[], slidesToScroll: SlidesToScrollType): ScrollSnapsType;

~~~

## node_modules\embla-carousel\cjs\components\ScrollTarget.d.ts

~~~ts
import { LimitType } from './Limit';
import { Vector1DType } from './Vector1d';
export type TargetType = {
    distance: number;
    index: number;
};
export type ScrollTargetType = {
    byIndex: (target: number, direction: number) => TargetType;
    byDistance: (force: number, snap: boolean) => TargetType;
    shortcut: (target: number, direction: number) => number;
};
export declare function ScrollTarget(loop: boolean, scrollSnaps: number[], contentSize: number, limit: LimitType, targetVector: Vector1DType): ScrollTargetType;

~~~

## node_modules\embla-carousel\cjs\components\ScrollTo.d.ts

~~~ts
import { AnimationsType } from './Animations';
import { CounterType } from './Counter';
import { EventHandlerType } from './EventHandler';
import { ScrollBodyType } from './ScrollBody';
import { ScrollTargetType } from './ScrollTarget';
import { Vector1DType } from './Vector1d';
export type ScrollToType = {
    distance: (n: number, snap: boolean) => void;
    index: (n: number, direction: number) => void;
};
export declare function ScrollTo(animation: AnimationsType, indexCurrent: CounterType, indexPrevious: CounterType, scrollBody: ScrollBodyType, scrollTarget: ScrollTargetType, targetVector: Vector1DType, eventHandler: EventHandlerType): ScrollToType;

~~~

## node_modules\embla-carousel\cjs\components\SlideFocus.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
import { EventHandlerType } from './EventHandler';
import { EventStoreType } from './EventStore';
import { ScrollBodyType } from './ScrollBody';
import { ScrollToType } from './ScrollTo';
import { SlideRegistryType } from './SlideRegistry';
type FocusHandlerCallbackType = (emblaApi: EmblaCarouselType, evt: FocusEvent) => boolean | void;
export type FocusHandlerOptionType = boolean | FocusHandlerCallbackType;
export type SlideFocusType = {
    init: (emblaApi: EmblaCarouselType) => void;
};
export declare function SlideFocus(root: HTMLElement, slides: HTMLElement[], slideRegistry: SlideRegistryType['slideRegistry'], scrollTo: ScrollToType, scrollBody: ScrollBodyType, eventStore: EventStoreType, eventHandler: EventHandlerType, watchFocus: FocusHandlerOptionType): SlideFocusType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\SlideLooper.d.ts

~~~ts
import { AxisType } from './Axis';
import { Vector1DType } from './Vector1d';
import { TranslateType } from './Translate';
type LoopPointType = {
    loopPoint: number;
    index: number;
    translate: TranslateType;
    slideLocation: Vector1DType;
    target: () => number;
};
export type SlideLooperType = {
    canLoop: () => boolean;
    clear: () => void;
    loop: () => void;
    loopPoints: LoopPointType[];
};
export declare function SlideLooper(axis: AxisType, viewSize: number, contentSize: number, slideSizes: number[], slideSizesWithGaps: number[], snaps: number[], scrollSnaps: number[], location: Vector1DType, slides: HTMLElement[]): SlideLooperType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\SlideRegistry.d.ts

~~~ts
import { LimitType } from './Limit';
import { ScrollContainOptionType } from './ScrollContain';
import { SlidesToScrollType } from './SlidesToScroll';
export type SlideRegistryType = {
    slideRegistry: number[][];
};
export declare function SlideRegistry(containSnaps: boolean, containScroll: ScrollContainOptionType, scrollSnaps: number[], scrollContainLimit: LimitType, slidesToScroll: SlidesToScrollType, slideIndexes: number[]): SlideRegistryType;

~~~

## node_modules\embla-carousel\cjs\components\SlidesHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
import { EventHandlerType } from './EventHandler';
type SlidesHandlerCallbackType = (emblaApi: EmblaCarouselType, mutations: MutationRecord[]) => boolean | void;
export type SlidesHandlerOptionType = boolean | SlidesHandlerCallbackType;
export type SlidesHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
};
export declare function SlidesHandler(container: HTMLElement, eventHandler: EventHandlerType, watchSlides: SlidesHandlerOptionType): SlidesHandlerType;
export {};

~~~

## node_modules\embla-carousel\cjs\components\SlidesInView.d.ts

~~~ts
import { EventHandlerType } from './EventHandler';
export type SlidesInViewOptionsType = IntersectionObserverInit['threshold'];
export type SlidesInViewType = {
    init: () => void;
    destroy: () => void;
    get: (inView?: boolean) => number[];
};
export declare function SlidesInView(container: HTMLElement, slides: HTMLElement[], eventHandler: EventHandlerType, threshold: SlidesInViewOptionsType): SlidesInViewType;

~~~

## node_modules\embla-carousel\cjs\components\SlideSizes.d.ts

~~~ts
import { AxisType } from './Axis';
import { NodeRectType } from './NodeRects';
import { WindowType } from './utils';
export type SlideSizesType = {
    slideSizes: number[];
    slideSizesWithGaps: number[];
    startGap: number;
    endGap: number;
};
export declare function SlideSizes(axis: AxisType, containerRect: NodeRectType, slideRects: NodeRectType[], slides: HTMLElement[], readEdgeGap: boolean, ownerWindow: WindowType): SlideSizesType;

~~~

## node_modules\embla-carousel\cjs\components\SlidesToScroll.d.ts

~~~ts
import { AxisType } from './Axis';
import { NodeRectType } from './NodeRects';
export type SlidesToScrollOptionType = 'auto' | number;
export type SlidesToScrollType = {
    groupSlides: <Type>(array: Type[]) => Type[][];
};
export declare function SlidesToScroll(axis: AxisType, viewSize: number, slidesToScroll: SlidesToScrollOptionType, loop: boolean, containerRect: NodeRectType, slideRects: NodeRectType[], startGap: number, endGap: number, pixelTolerance: number): SlidesToScrollType;

~~~

## node_modules\embla-carousel\cjs\components\Translate.d.ts

~~~ts
import { AxisType } from './Axis';
export type TranslateType = {
    clear: () => void;
    to: (target: number) => void;
    toggleActive: (active: boolean) => void;
};
export declare function Translate(axis: AxisType, container: HTMLElement): TranslateType;

~~~

## node_modules\embla-carousel\cjs\components\utils.d.ts

~~~ts
import { PointerEventType } from './DragTracker';
export type WindowType = Window & typeof globalThis;
export declare function isNumber(subject: unknown): subject is number;
export declare function isString(subject: unknown): subject is string;
export declare function isBoolean(subject: unknown): subject is boolean;
export declare function isObject(subject: unknown): subject is Record<string, unknown>;
export declare function mathAbs(n: number): number;
export declare function mathSign(n: number): number;
export declare function deltaAbs(valueB: number, valueA: number): number;
export declare function factorAbs(valueB: number, valueA: number): number;
export declare function roundToTwoDecimals(num: number): number;
export declare function arrayKeys<Type>(array: Type[]): number[];
export declare function arrayLast<Type>(array: Type[]): Type;
export declare function arrayLastIndex<Type>(array: Type[]): number;
export declare function arrayIsLastIndex<Type>(array: Type[], index: number): boolean;
export declare function arrayFromNumber(n: number, startAt?: number): number[];
export declare function objectKeys<Type extends object>(object: Type): string[];
export declare function objectsMergeDeep(objectA: Record<string, unknown>, objectB: Record<string, unknown>): Record<string, unknown>;
export declare function isMouseEvent(evt: PointerEventType, ownerWindow: WindowType): evt is MouseEvent;

~~~

## node_modules\embla-carousel\cjs\components\Vector1d.d.ts

~~~ts
export type Vector1DType = {
    get: () => number;
    set: (n: Vector1DType | number) => void;
    add: (n: Vector1DType | number) => void;
    subtract: (n: Vector1DType | number) => void;
};
export declare function Vector1D(initialValue: number): Vector1DType;

~~~

## node_modules\embla-carousel\cjs\embla-carousel.cjs.js

~~~js
'use strict';

function isNumber(subject) {
  return typeof subject === 'number';
}
function isString(subject) {
  return typeof subject === 'string';
}
function isBoolean(subject) {
  return typeof subject === 'boolean';
}
function isObject(subject) {
  return Object.prototype.toString.call(subject) === '[object Object]';
}
function mathAbs(n) {
  return Math.abs(n);
}
function mathSign(n) {
  return Math.sign(n);
}
function deltaAbs(valueB, valueA) {
  return mathAbs(valueB - valueA);
}
function factorAbs(valueB, valueA) {
  if (valueB === 0 || valueA === 0) return 0;
  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;
  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));
  return mathAbs(diff / valueB);
}
function roundToTwoDecimals(num) {
  return Math.round(num * 100) / 100;
}
function arrayKeys(array) {
  return objectKeys(array).map(Number);
}
function arrayLast(array) {
  return array[arrayLastIndex(array)];
}
function arrayLastIndex(array) {
  return Math.max(0, array.length - 1);
}
function arrayIsLastIndex(array, index) {
  return index === arrayLastIndex(array);
}
function arrayFromNumber(n, startAt = 0) {
  return Array.from(Array(n), (_, i) => startAt + i);
}
function objectKeys(object) {
  return Object.keys(object);
}
function objectsMergeDeep(objectA, objectB) {
  return [objectA, objectB].reduce((mergedObjects, currentObject) => {
    objectKeys(currentObject).forEach(key => {
      const valueA = mergedObjects[key];
      const valueB = currentObject[key];
      const areObjects = isObject(valueA) && isObject(valueB);
      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;
    });
    return mergedObjects;
  }, {});
}
function isMouseEvent(evt, ownerWindow) {
  return typeof ownerWindow.MouseEvent !== 'undefined' && evt instanceof ownerWindow.MouseEvent;
}

function Alignment(align, viewSize) {
  const predefined = {
    start,
    center,
    end
  };
  function start() {
    return 0;
  }
  function center(n) {
    return end(n) / 2;
  }
  function end(n) {
    return viewSize - n;
  }
  function measure(n, index) {
    if (isString(align)) return predefined[align](n);
    return align(viewSize, n, index);
  }
  const self = {
    measure
  };
  return self;
}

function EventStore() {
  let listeners = [];
  function add(node, type, handler, options = {
    passive: true
  }) {
    let removeListener;
    if ('addEventListener' in node) {
      node.addEventListener(type, handler, options);
      removeListener = () => node.removeEventListener(type, handler, options);
    } else {
      const legacyMediaQueryList = node;
      legacyMediaQueryList.addListener(handler);
      removeListener = () => legacyMediaQueryList.removeListener(handler);
    }
    listeners.push(removeListener);
    return self;
  }
  function clear() {
    listeners = listeners.filter(remove => remove());
  }
  const self = {
    add,
    clear
  };
  return self;
}

function Animations(ownerDocument, ownerWindow, update, render) {
  const documentVisibleHandler = EventStore();
  const fixedTimeStep = 1000 / 60;
  let lastTimeStamp = null;
  let accumulatedTime = 0;
  let animationId = 0;
  function init() {
    documentVisibleHandler.add(ownerDocument, 'visibilitychange', () => {
      if (ownerDocument.hidden) reset();
    });
  }
  function destroy() {
    stop();
    documentVisibleHandler.clear();
  }
  function animate(timeStamp) {
    if (!animationId) return;
    if (!lastTimeStamp) {
      lastTimeStamp = timeStamp;
      update();
      update();
    }
    const timeElapsed = timeStamp - lastTimeStamp;
    lastTimeStamp = timeStamp;
    accumulatedTime += timeElapsed;
    while (accumulatedTime >= fixedTimeStep) {
      update();
      accumulatedTime -= fixedTimeStep;
    }
    const alpha = accumulatedTime / fixedTimeStep;
    render(alpha);
    if (animationId) {
      animationId = ownerWindow.requestAnimationFrame(animate);
    }
  }
  function start() {
    if (animationId) return;
    animationId = ownerWindow.requestAnimationFrame(animate);
  }
  function stop() {
    ownerWindow.cancelAnimationFrame(animationId);
    lastTimeStamp = null;
    accumulatedTime = 0;
    animationId = 0;
  }
  function reset() {
    lastTimeStamp = null;
    accumulatedTime = 0;
  }
  const self = {
    init,
    destroy,
    start,
    stop,
    update,
    render
  };
  return self;
}

function Axis(axis, contentDirection) {
  const isRightToLeft = contentDirection === 'rtl';
  const isVertical = axis === 'y';
  const scroll = isVertical ? 'y' : 'x';
  const cross = isVertical ? 'x' : 'y';
  const sign = !isVertical && isRightToLeft ? -1 : 1;
  const startEdge = getStartEdge();
  const endEdge = getEndEdge();
  function measureSize(nodeRect) {
    const {
      height,
      width
    } = nodeRect;
    return isVertical ? height : width;
  }
  function getStartEdge() {
    if (isVertical) return 'top';
    return isRightToLeft ? 'right' : 'left';
  }
  function getEndEdge() {
    if (isVertical) return 'bottom';
    return isRightToLeft ? 'left' : 'right';
  }
  function direction(n) {
    return n * sign;
  }
  const self = {
    scroll,
    cross,
    startEdge,
    endEdge,
    measureSize,
    direction
  };
  return self;
}

function Limit(min = 0, max = 0) {
  const length = mathAbs(min - max);
  function reachedMin(n) {
    return n < min;
  }
  function reachedMax(n) {
    return n > max;
  }
  function reachedAny(n) {
    return reachedMin(n) || reachedMax(n);
  }
  function constrain(n) {
    if (!reachedAny(n)) return n;
    return reachedMin(n) ? min : max;
  }
  function removeOffset(n) {
    if (!length) return n;
    return n - length * Math.ceil((n - max) / length);
  }
  const self = {
    length,
    max,
    min,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset
  };
  return self;
}

function Counter(max, start, loop) {
  const {
    constrain
  } = Limit(0, max);
  const loopEnd = max + 1;
  let counter = withinLimit(start);
  function withinLimit(n) {
    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);
  }
  function get() {
    return counter;
  }
  function set(n) {
    counter = withinLimit(n);
    return self;
  }
  function add(n) {
    return clone().set(get() + n);
  }
  function clone() {
    return Counter(max, get(), loop);
  }
  const self = {
    get,
    set,
    add,
    clone
  };
  return self;
}

function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
  const {
    cross: crossAxis,
    direction
  } = axis;
  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];
  const nonPassiveEvent = {
    passive: false
  };
  const initEvents = EventStore();
  const dragEvents = EventStore();
  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
  const snapForceBoost = {
    mouse: 300,
    touch: 400
  };
  const freeForceBoost = {
    mouse: 500,
    touch: 600
  };
  const baseSpeed = dragFree ? 43 : 25;
  let isMoving = false;
  let startScroll = 0;
  let startCross = 0;
  let pointerIsDown = false;
  let preventScroll = false;
  let preventClick = false;
  let isMouse = false;
  function init(emblaApi) {
    if (!watchDrag) return;
    function downIfAllowed(evt) {
      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);
    }
    const node = rootNode;
    initEvents.add(node, 'dragstart', evt => evt.preventDefault(), nonPassiveEvent).add(node, 'touchmove', () => undefined, nonPassiveEvent).add(node, 'touchend', () => undefined).add(node, 'touchstart', downIfAllowed).add(node, 'mousedown', downIfAllowed).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click, true);
  }
  function destroy() {
    initEvents.clear();
    dragEvents.clear();
  }
  function addDragEvents() {
    const node = isMouse ? ownerDocument : rootNode;
    dragEvents.add(node, 'touchmove', move, nonPassiveEvent).add(node, 'touchend', up).add(node, 'mousemove', move, nonPassiveEvent).add(node, 'mouseup', up);
  }
  function isFocusNode(node) {
    const nodeName = node.nodeName || '';
    return focusNodes.includes(nodeName);
  }
  function forceBoost() {
    const boost = dragFree ? freeForceBoost : snapForceBoost;
    const type = isMouse ? 'mouse' : 'touch';
    return boost[type];
  }
  function allowedForce(force, targetChanged) {
    const next = index.add(mathSign(force) * -1);
    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;
    if (skipSnaps && targetChanged) return baseForce * 0.5;
    return scrollTarget.byIndex(next.get(), 0).distance;
  }
  function down(evt) {
    const isMouseEvt = isMouseEvent(evt, ownerWindow);
    isMouse = isMouseEvt;
    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
    isMoving = deltaAbs(target.get(), location.get()) >= 2;
    if (isMouseEvt && evt.button !== 0) return;
    if (isFocusNode(evt.target)) return;
    pointerIsDown = true;
    dragTracker.pointerDown(evt);
    scrollBody.useFriction(0).useDuration(0);
    target.set(location);
    addDragEvents();
    startScroll = dragTracker.readPoint(evt);
    startCross = dragTracker.readPoint(evt, crossAxis);
    eventHandler.emit('pointerDown');
  }
  function move(evt) {
    const isTouchEvt = !isMouseEvent(evt, ownerWindow);
    if (isTouchEvt && evt.touches.length >= 2) return up(evt);
    const lastScroll = dragTracker.readPoint(evt);
    const lastCross = dragTracker.readPoint(evt, crossAxis);
    const diffScroll = deltaAbs(lastScroll, startScroll);
    const diffCross = deltaAbs(lastCross, startCross);
    if (!preventScroll && !isMouse) {
      if (!evt.cancelable) return up(evt);
      preventScroll = diffScroll > diffCross;
      if (!preventScroll) return up(evt);
    }
    const diff = dragTracker.pointerMove(evt);
    if (diffScroll > dragThreshold) preventClick = true;
    scrollBody.useFriction(0.3).useDuration(0.75);
    animation.start();
    target.add(direction(diff));
    evt.preventDefault();
  }
  function up(evt) {
    const currentLocation = scrollTarget.byDistance(0, false);
    const targetChanged = currentLocation.index !== index.get();
    const rawForce = dragTracker.pointerUp(evt) * forceBoost();
    const force = allowedForce(direction(rawForce), targetChanged);
    const forceFactor = factorAbs(rawForce, force);
    const speed = baseSpeed - 10 * forceFactor;
    const friction = baseFriction + forceFactor / 50;
    preventScroll = false;
    pointerIsDown = false;
    dragEvents.clear();
    scrollBody.useDuration(speed).useFriction(friction);
    scrollTo.distance(force, !dragFree);
    isMouse = false;
    eventHandler.emit('pointerUp');
  }
  function click(evt) {
    if (preventClick) {
      evt.stopPropagation();
      evt.preventDefault();
      preventClick = false;
    }
  }
  function pointerDown() {
    return pointerIsDown;
  }
  const self = {
    init,
    destroy,
    pointerDown
  };
  return self;
}

function DragTracker(axis, ownerWindow) {
  const logInterval = 170;
  let startEvent;
  let lastEvent;
  function readTime(evt) {
    return evt.timeStamp;
  }
  function readPoint(evt, evtAxis) {
    const property = evtAxis || axis.scroll;
    const coord = `client${property === 'x' ? 'X' : 'Y'}`;
    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];
  }
  function pointerDown(evt) {
    startEvent = evt;
    lastEvent = evt;
    return readPoint(evt);
  }
  function pointerMove(evt) {
    const diff = readPoint(evt) - readPoint(lastEvent);
    const expired = readTime(evt) - readTime(startEvent) > logInterval;
    lastEvent = evt;
    if (expired) startEvent = evt;
    return diff;
  }
  function pointerUp(evt) {
    if (!startEvent || !lastEvent) return 0;
    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
    const diffTime = readTime(evt) - readTime(startEvent);
    const expired = readTime(evt) - readTime(lastEvent) > logInterval;
    const force = diffDrag / diffTime;
    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;
    return isFlick ? force : 0;
  }
  const self = {
    pointerDown,
    pointerMove,
    pointerUp,
    readPoint
  };
  return self;
}

function NodeRects() {
  function measure(node) {
    const {
      offsetTop,
      offsetLeft,
      offsetWidth,
      offsetHeight
    } = node;
    const offset = {
      top: offsetTop,
      right: offsetLeft + offsetWidth,
      bottom: offsetTop + offsetHeight,
      left: offsetLeft,
      width: offsetWidth,
      height: offsetHeight
    };
    return offset;
  }
  const self = {
    measure
  };
  return self;
}

function PercentOfView(viewSize) {
  function measure(n) {
    return viewSize * (n / 100);
  }
  const self = {
    measure
  };
  return self;
}

function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
  const observeNodes = [container].concat(slides);
  let resizeObserver;
  let containerSize;
  let slideSizes = [];
  let destroyed = false;
  function readSize(node) {
    return axis.measureSize(nodeRects.measure(node));
  }
  function init(emblaApi) {
    if (!watchResize) return;
    containerSize = readSize(container);
    slideSizes = slides.map(readSize);
    function defaultCallback(entries) {
      for (const entry of entries) {
        if (destroyed) return;
        const isContainer = entry.target === container;
        const slideIndex = slides.indexOf(entry.target);
        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
        const newSize = readSize(isContainer ? container : slides[slideIndex]);
        const diffSize = mathAbs(newSize - lastSize);
        if (diffSize >= 0.5) {
          emblaApi.reInit();
          eventHandler.emit('resize');
          break;
        }
      }
    }
    resizeObserver = new ResizeObserver(entries => {
      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {
        defaultCallback(entries);
      }
    });
    ownerWindow.requestAnimationFrame(() => {
      observeNodes.forEach(node => resizeObserver.observe(node));
    });
  }
  function destroy() {
    destroyed = true;
    if (resizeObserver) resizeObserver.disconnect();
  }
  const self = {
    init,
    destroy
  };
  return self;
}

function ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
  let scrollVelocity = 0;
  let scrollDirection = 0;
  let scrollDuration = baseDuration;
  let scrollFriction = baseFriction;
  let rawLocation = location.get();
  let rawLocationPrevious = 0;
  function seek() {
    const displacement = target.get() - location.get();
    const isInstant = !scrollDuration;
    let scrollDistance = 0;
    if (isInstant) {
      scrollVelocity = 0;
      previousLocation.set(target);
      location.set(target);
      scrollDistance = displacement;
    } else {
      previousLocation.set(location);
      scrollVelocity += displacement / scrollDuration;
      scrollVelocity *= scrollFriction;
      rawLocation += scrollVelocity;
      location.add(scrollVelocity);
      scrollDistance = rawLocation - rawLocationPrevious;
    }
    scrollDirection = mathSign(scrollDistance);
    rawLocationPrevious = rawLocation;
    return self;
  }
  function settled() {
    const diff = target.get() - offsetLocation.get();
    return mathAbs(diff) < 0.001;
  }
  function duration() {
    return scrollDuration;
  }
  function direction() {
    return scrollDirection;
  }
  function velocity() {
    return scrollVelocity;
  }
  function useBaseDuration() {
    return useDuration(baseDuration);
  }
  function useBaseFriction() {
    return useFriction(baseFriction);
  }
  function useDuration(n) {
    scrollDuration = n;
    return self;
  }
  function useFriction(n) {
    scrollFriction = n;
    return self;
  }
  const self = {
    direction,
    duration,
    velocity,
    seek,
    settled,
    useBaseFriction,
    useBaseDuration,
    useFriction,
    useDuration
  };
  return self;
}

function ScrollBounds(limit, location, target, scrollBody, percentOfView) {
  const pullBackThreshold = percentOfView.measure(10);
  const edgeOffsetTolerance = percentOfView.measure(50);
  const frictionLimit = Limit(0.1, 0.99);
  let disabled = false;
  function shouldConstrain() {
    if (disabled) return false;
    if (!limit.reachedAny(target.get())) return false;
    if (!limit.reachedAny(location.get())) return false;
    return true;
  }
  function constrain(pointerDown) {
    if (!shouldConstrain()) return;
    const edge = limit.reachedMin(location.get()) ? 'min' : 'max';
    const diffToEdge = mathAbs(limit[edge] - location.get());
    const diffToTarget = target.get() - location.get();
    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
    target.subtract(diffToTarget * friction);
    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
      target.set(limit.constrain(target.get()));
      scrollBody.useDuration(25).useBaseFriction();
    }
  }
  function toggleActive(active) {
    disabled = !active;
  }
  const self = {
    shouldConstrain,
    constrain,
    toggleActive
  };
  return self;
}

function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
  const scrollBounds = Limit(-contentSize + viewSize, 0);
  const snapsBounded = measureBounded();
  const scrollContainLimit = findScrollContainLimit();
  const snapsContained = measureContained();
  function usePixelTolerance(bound, snap) {
    return deltaAbs(bound, snap) <= 1;
  }
  function findScrollContainLimit() {
    const startSnap = snapsBounded[0];
    const endSnap = arrayLast(snapsBounded);
    const min = snapsBounded.lastIndexOf(startSnap);
    const max = snapsBounded.indexOf(endSnap) + 1;
    return Limit(min, max);
  }
  function measureBounded() {
    return snapsAligned.map((snapAligned, index) => {
      const {
        min,
        max
      } = scrollBounds;
      const snap = scrollBounds.constrain(snapAligned);
      const isFirst = !index;
      const isLast = arrayIsLastIndex(snapsAligned, index);
      if (isFirst) return max;
      if (isLast) return min;
      if (usePixelTolerance(min, snap)) return min;
      if (usePixelTolerance(max, snap)) return max;
      return snap;
    }).map(scrollBound => parseFloat(scrollBound.toFixed(3)));
  }
  function measureContained() {
    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];
    if (containScroll === 'keepSnaps') return snapsBounded;
    const {
      min,
      max
    } = scrollContainLimit;
    return snapsBounded.slice(min, max);
  }
  const self = {
    snapsContained,
    scrollContainLimit
  };
  return self;
}

function ScrollLimit(contentSize, scrollSnaps, loop) {
  const max = scrollSnaps[0];
  const min = loop ? max - contentSize : arrayLast(scrollSnaps);
  const limit = Limit(min, max);
  const self = {
    limit
  };
  return self;
}

function ScrollLooper(contentSize, limit, location, vectors) {
  const jointSafety = 0.1;
  const min = limit.min + jointSafety;
  const max = limit.max + jointSafety;
  const {
    reachedMin,
    reachedMax
  } = Limit(min, max);
  function shouldLoop(direction) {
    if (direction === 1) return reachedMax(location.get());
    if (direction === -1) return reachedMin(location.get());
    return false;
  }
  function loop(direction) {
    if (!shouldLoop(direction)) return;
    const loopDistance = contentSize * (direction * -1);
    vectors.forEach(v => v.add(loopDistance));
  }
  const self = {
    loop
  };
  return self;
}

function ScrollProgress(limit) {
  const {
    max,
    length
  } = limit;
  function get(n) {
    const currentLocation = n - max;
    return length ? currentLocation / -length : 0;
  }
  const self = {
    get
  };
  return self;
}

function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
  const {
    startEdge,
    endEdge
  } = axis;
  const {
    groupSlides
  } = slidesToScroll;
  const alignments = measureSizes().map(alignment.measure);
  const snaps = measureUnaligned();
  const snapsAligned = measureAligned();
  function measureSizes() {
    return groupSlides(slideRects).map(rects => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
  }
  function measureUnaligned() {
    return slideRects.map(rect => containerRect[startEdge] - rect[startEdge]).map(snap => -mathAbs(snap));
  }
  function measureAligned() {
    return groupSlides(snaps).map(g => g[0]).map((snap, index) => snap + alignments[index]);
  }
  const self = {
    snaps,
    snapsAligned
  };
  return self;
}

function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
  const {
    groupSlides
  } = slidesToScroll;
  const {
    min,
    max
  } = scrollContainLimit;
  const slideRegistry = createSlideRegistry();
  function createSlideRegistry() {
    const groupedSlideIndexes = groupSlides(slideIndexes);
    const doNotContain = !containSnaps || containScroll === 'keepSnaps';
    if (scrollSnaps.length === 1) return [slideIndexes];
    if (doNotContain) return groupedSlideIndexes;
    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(groups, index);
      if (isFirst) {
        const range = arrayLast(groups[0]) + 1;
        return arrayFromNumber(range);
      }
      if (isLast) {
        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;
        return arrayFromNumber(range, arrayLast(groups)[0]);
      }
      return group;
    });
  }
  const self = {
    slideRegistry
  };
  return self;
}

function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
  const {
    reachedAny,
    removeOffset,
    constrain
  } = limit;
  function minDistance(distances) {
    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
  }
  function findTargetSnap(target) {
    const distance = loop ? removeOffset(target) : constrain(target);
    const ascDiffsToSnaps = scrollSnaps.map((snap, index) => ({
      diff: shortcut(snap - distance, 0),
      index
    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));
    const {
      index
    } = ascDiffsToSnaps[0];
    return {
      index,
      distance
    };
  }
  function shortcut(target, direction) {
    const targets = [target, target + contentSize, target - contentSize];
    if (!loop) return target;
    if (!direction) return minDistance(targets);
    const matchingTargets = targets.filter(t => mathSign(t) === direction);
    if (matchingTargets.length) return minDistance(matchingTargets);
    return arrayLast(targets) - contentSize;
  }
  function byIndex(index, direction) {
    const diffToSnap = scrollSnaps[index] - targetVector.get();
    const distance = shortcut(diffToSnap, direction);
    return {
      index,
      distance
    };
  }
  function byDistance(distance, snap) {
    const target = targetVector.get() + distance;
    const {
      index,
      distance: targetSnapDistance
    } = findTargetSnap(target);
    const reachedBound = !loop && reachedAny(target);
    if (!snap || reachedBound) return {
      index,
      distance
    };
    const diffToSnap = scrollSnaps[index] - targetSnapDistance;
    const snapDistance = distance + shortcut(diffToSnap, 0);
    return {
      index,
      distance: snapDistance
    };
  }
  const self = {
    byDistance,
    byIndex,
    shortcut
  };
  return self;
}

function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
  function scrollTo(target) {
    const distanceDiff = target.distance;
    const indexDiff = target.index !== indexCurrent.get();
    targetVector.add(distanceDiff);
    if (distanceDiff) {
      if (scrollBody.duration()) {
        animation.start();
      } else {
        animation.update();
        animation.render(1);
        animation.update();
      }
    }
    if (indexDiff) {
      indexPrevious.set(indexCurrent.get());
      indexCurrent.set(target.index);
      eventHandler.emit('select');
    }
  }
  function distance(n, snap) {
    const target = scrollTarget.byDistance(n, snap);
    scrollTo(target);
  }
  function index(n, direction) {
    const targetIndex = indexCurrent.clone().set(n);
    const target = scrollTarget.byIndex(targetIndex.get(), direction);
    scrollTo(target);
  }
  const self = {
    distance,
    index
  };
  return self;
}

function SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
  const focusListenerOptions = {
    passive: true,
    capture: true
  };
  let lastTabPressTime = 0;
  function init(emblaApi) {
    if (!watchFocus) return;
    function defaultCallback(index) {
      const nowTime = new Date().getTime();
      const diffTime = nowTime - lastTabPressTime;
      if (diffTime > 10) return;
      eventHandler.emit('slideFocusStart');
      root.scrollLeft = 0;
      const group = slideRegistry.findIndex(group => group.includes(index));
      if (!isNumber(group)) return;
      scrollBody.useDuration(0);
      scrollTo.index(group, 0);
      eventHandler.emit('slideFocus');
    }
    eventStore.add(document, 'keydown', registerTabPress, false);
    slides.forEach((slide, slideIndex) => {
      eventStore.add(slide, 'focus', evt => {
        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {
          defaultCallback(slideIndex);
        }
      }, focusListenerOptions);
    });
  }
  function registerTabPress(event) {
    if (event.code === 'Tab') lastTabPressTime = new Date().getTime();
  }
  const self = {
    init
  };
  return self;
}

function Vector1D(initialValue) {
  let value = initialValue;
  function get() {
    return value;
  }
  function set(n) {
    value = normalizeInput(n);
  }
  function add(n) {
    value += normalizeInput(n);
  }
  function subtract(n) {
    value -= normalizeInput(n);
  }
  function normalizeInput(n) {
    return isNumber(n) ? n : n.get();
  }
  const self = {
    get,
    set,
    add,
    subtract
  };
  return self;
}

function Translate(axis, container) {
  const translate = axis.scroll === 'x' ? x : y;
  const containerStyle = container.style;
  let previousTarget = null;
  let disabled = false;
  function x(n) {
    return `translate3d(${n}px,0px,0px)`;
  }
  function y(n) {
    return `translate3d(0px,${n}px,0px)`;
  }
  function to(target) {
    if (disabled) return;
    const newTarget = roundToTwoDecimals(axis.direction(target));
    if (newTarget === previousTarget) return;
    containerStyle.transform = translate(newTarget);
    previousTarget = newTarget;
  }
  function toggleActive(active) {
    disabled = !active;
  }
  function clear() {
    if (disabled) return;
    containerStyle.transform = '';
    if (!container.getAttribute('style')) container.removeAttribute('style');
  }
  const self = {
    clear,
    to,
    toggleActive
  };
  return self;
}

function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {
  const roundingSafety = 0.5;
  const ascItems = arrayKeys(slideSizesWithGaps);
  const descItems = arrayKeys(slideSizesWithGaps).reverse();
  const loopPoints = startPoints().concat(endPoints());
  function removeSlideSizes(indexes, from) {
    return indexes.reduce((a, i) => {
      return a - slideSizesWithGaps[i];
    }, from);
  }
  function slidesInGap(indexes, gap) {
    return indexes.reduce((a, i) => {
      const remainingGap = removeSlideSizes(a, gap);
      return remainingGap > 0 ? a.concat([i]) : a;
    }, []);
  }
  function findSlideBounds(offset) {
    return snaps.map((snap, index) => ({
      start: snap - slideSizes[index] + roundingSafety + offset,
      end: snap + viewSize - roundingSafety + offset
    }));
  }
  function findLoopPoints(indexes, offset, isEndEdge) {
    const slideBounds = findSlideBounds(offset);
    return indexes.map(index => {
      const initial = isEndEdge ? 0 : -contentSize;
      const altered = isEndEdge ? contentSize : 0;
      const boundEdge = isEndEdge ? 'end' : 'start';
      const loopPoint = slideBounds[index][boundEdge];
      return {
        index,
        loopPoint,
        slideLocation: Vector1D(-1),
        translate: Translate(axis, slides[index]),
        target: () => location.get() > loopPoint ? initial : altered
      };
    });
  }
  function startPoints() {
    const gap = scrollSnaps[0];
    const indexes = slidesInGap(descItems, gap);
    return findLoopPoints(indexes, contentSize, false);
  }
  function endPoints() {
    const gap = viewSize - scrollSnaps[0] - 1;
    const indexes = slidesInGap(ascItems, gap);
    return findLoopPoints(indexes, -contentSize, true);
  }
  function canLoop() {
    return loopPoints.every(({
      index
    }) => {
      const otherIndexes = ascItems.filter(i => i !== index);
      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;
    });
  }
  function loop() {
    loopPoints.forEach(loopPoint => {
      const {
        target,
        translate,
        slideLocation
      } = loopPoint;
      const shiftLocation = target();
      if (shiftLocation === slideLocation.get()) return;
      translate.to(shiftLocation);
      slideLocation.set(shiftLocation);
    });
  }
  function clear() {
    loopPoints.forEach(loopPoint => loopPoint.translate.clear());
  }
  const self = {
    canLoop,
    clear,
    loop,
    loopPoints
  };
  return self;
}

function SlidesHandler(container, eventHandler, watchSlides) {
  let mutationObserver;
  let destroyed = false;
  function init(emblaApi) {
    if (!watchSlides) return;
    function defaultCallback(mutations) {
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          emblaApi.reInit();
          eventHandler.emit('slidesChanged');
          break;
        }
      }
    }
    mutationObserver = new MutationObserver(mutations => {
      if (destroyed) return;
      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {
        defaultCallback(mutations);
      }
    });
    mutationObserver.observe(container, {
      childList: true
    });
  }
  function destroy() {
    if (mutationObserver) mutationObserver.disconnect();
    destroyed = true;
  }
  const self = {
    init,
    destroy
  };
  return self;
}

function SlidesInView(container, slides, eventHandler, threshold) {
  const intersectionEntryMap = {};
  let inViewCache = null;
  let notInViewCache = null;
  let intersectionObserver;
  let destroyed = false;
  function init() {
    intersectionObserver = new IntersectionObserver(entries => {
      if (destroyed) return;
      entries.forEach(entry => {
        const index = slides.indexOf(entry.target);
        intersectionEntryMap[index] = entry;
      });
      inViewCache = null;
      notInViewCache = null;
      eventHandler.emit('slidesInView');
    }, {
      root: container.parentElement,
      threshold
    });
    slides.forEach(slide => intersectionObserver.observe(slide));
  }
  function destroy() {
    if (intersectionObserver) intersectionObserver.disconnect();
    destroyed = true;
  }
  function createInViewList(inView) {
    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {
      const index = parseInt(slideIndex);
      const {
        isIntersecting
      } = intersectionEntryMap[index];
      const inViewMatch = inView && isIntersecting;
      const notInViewMatch = !inView && !isIntersecting;
      if (inViewMatch || notInViewMatch) list.push(index);
      return list;
    }, []);
  }
  function get(inView = true) {
    if (inView && inViewCache) return inViewCache;
    if (!inView && notInViewCache) return notInViewCache;
    const slideIndexes = createInViewList(inView);
    if (inView) inViewCache = slideIndexes;
    if (!inView) notInViewCache = slideIndexes;
    return slideIndexes;
  }
  const self = {
    init,
    destroy,
    get
  };
  return self;
}

function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
  const {
    measureSize,
    startEdge,
    endEdge
  } = axis;
  const withEdgeGap = slideRects[0] && readEdgeGap;
  const startGap = measureStartGap();
  const endGap = measureEndGap();
  const slideSizes = slideRects.map(measureSize);
  const slideSizesWithGaps = measureWithGaps();
  function measureStartGap() {
    if (!withEdgeGap) return 0;
    const slideRect = slideRects[0];
    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
  }
  function measureEndGap() {
    if (!withEdgeGap) return 0;
    const style = ownerWindow.getComputedStyle(arrayLast(slides));
    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));
  }
  function measureWithGaps() {
    return slideRects.map((rect, index, rects) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(rects, index);
      if (isFirst) return slideSizes[index] + startGap;
      if (isLast) return slideSizes[index] + endGap;
      return rects[index + 1][startEdge] - rect[startEdge];
    }).map(mathAbs);
  }
  const self = {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  };
  return self;
}

function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
  const {
    startEdge,
    endEdge,
    direction
  } = axis;
  const groupByNumber = isNumber(slidesToScroll);
  function byNumber(array, groupSize) {
    return arrayKeys(array).filter(i => i % groupSize === 0).map(i => array.slice(i, i + groupSize));
  }
  function bySize(array) {
    if (!array.length) return [];
    return arrayKeys(array).reduce((groups, rectB, index) => {
      const rectA = arrayLast(groups) || 0;
      const isFirst = rectA === 0;
      const isLast = rectB === arrayLastIndex(array);
      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
      const gapA = !loop && isFirst ? direction(startGap) : 0;
      const gapB = !loop && isLast ? direction(endGap) : 0;
      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));
      if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);
      if (isLast) groups.push(array.length);
      return groups;
    }, []).map((currentSize, index, groups) => {
      const previousSize = Math.max(groups[index - 1] || 0);
      return array.slice(previousSize, currentSize);
    });
  }
  function groupSlides(array) {
    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
  }
  const self = {
    groupSlides
  };
  return self;
}

function Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {
  // Options
  const {
    align,
    axis: scrollAxis,
    direction,
    startIndex,
    loop,
    duration,
    dragFree,
    dragThreshold,
    inViewThreshold,
    slidesToScroll: groupSlides,
    skipSnaps,
    containScroll,
    watchResize,
    watchSlides,
    watchDrag,
    watchFocus
  } = options;
  // Measurements
  const pixelTolerance = 2;
  const nodeRects = NodeRects();
  const containerRect = nodeRects.measure(container);
  const slideRects = slides.map(nodeRects.measure);
  const axis = Axis(scrollAxis, direction);
  const viewSize = axis.measureSize(containerRect);
  const percentOfView = PercentOfView(viewSize);
  const alignment = Alignment(align, viewSize);
  const containSnaps = !loop && !!containScroll;
  const readEdgeGap = loop || !!containScroll;
  const {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);
  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
  const {
    snaps,
    snapsAligned
  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
  const {
    snapsContained,
    scrollContainLimit
  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
  const {
    limit
  } = ScrollLimit(contentSize, scrollSnaps, loop);
  // Indexes
  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
  const indexPrevious = index.clone();
  const slideIndexes = arrayKeys(slides);
  // Animation
  const update = ({
    dragHandler,
    scrollBody,
    scrollBounds,
    options: {
      loop
    }
  }) => {
    if (!loop) scrollBounds.constrain(dragHandler.pointerDown());
    scrollBody.seek();
  };
  const render = ({
    scrollBody,
    translate,
    location,
    offsetLocation,
    previousLocation,
    scrollLooper,
    slideLooper,
    dragHandler,
    animation,
    eventHandler,
    scrollBounds,
    options: {
      loop
    }
  }, alpha) => {
    const shouldSettle = scrollBody.settled();
    const withinBounds = !scrollBounds.shouldConstrain();
    const hasSettled = loop ? shouldSettle : shouldSettle && withinBounds;
    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();
    if (hasSettledAndIdle) animation.stop();
    const interpolatedLocation = location.get() * alpha + previousLocation.get() * (1 - alpha);
    offsetLocation.set(interpolatedLocation);
    if (loop) {
      scrollLooper.loop(scrollBody.direction());
      slideLooper.loop();
    }
    translate.to(offsetLocation.get());
    if (hasSettledAndIdle) eventHandler.emit('settle');
    if (!hasSettled) eventHandler.emit('scroll');
  };
  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), alpha => render(engine, alpha));
  // Shared
  const friction = 0.68;
  const startLocation = scrollSnaps[index.get()];
  const location = Vector1D(startLocation);
  const previousLocation = Vector1D(startLocation);
  const offsetLocation = Vector1D(startLocation);
  const target = Vector1D(startLocation);
  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);
  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);
  const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);
  const scrollProgress = ScrollProgress(limit);
  const eventStore = EventStore();
  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);
  const {
    slideRegistry
  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
  // Engine
  const engine = {
    ownerDocument,
    ownerWindow,
    eventHandler,
    containerRect,
    slideRects,
    animation,
    axis,
    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
    eventStore,
    percentOfView,
    index,
    indexPrevious,
    limit,
    location,
    offsetLocation,
    previousLocation,
    options,
    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
    scrollBody,
    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),
    scrollProgress,
    scrollSnapList: scrollSnaps.map(scrollProgress.get),
    scrollSnaps,
    scrollTarget,
    scrollTo,
    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
    slideFocus,
    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
    slidesInView,
    slideIndexes,
    slideRegistry,
    slidesToScroll,
    target,
    translate: Translate(axis, container)
  };
  return engine;
}

function EventHandler() {
  let listeners = {};
  let api;
  function init(emblaApi) {
    api = emblaApi;
  }
  function getListeners(evt) {
    return listeners[evt] || [];
  }
  function emit(evt) {
    getListeners(evt).forEach(e => e(api, evt));
    return self;
  }
  function on(evt, cb) {
    listeners[evt] = getListeners(evt).concat([cb]);
    return self;
  }
  function off(evt, cb) {
    listeners[evt] = getListeners(evt).filter(e => e !== cb);
    return self;
  }
  function clear() {
    listeners = {};
  }
  const self = {
    init,
    emit,
    off,
    on,
    clear
  };
  return self;
}

const defaultOptions = {
  align: 'center',
  axis: 'x',
  container: null,
  slides: null,
  containScroll: 'trimSnaps',
  direction: 'ltr',
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: false,
  dragThreshold: 10,
  loop: false,
  skipSnaps: false,
  duration: 25,
  startIndex: 0,
  active: true,
  watchDrag: true,
  watchResize: true,
  watchSlides: true,
  watchFocus: true
};

function OptionsHandler(ownerWindow) {
  function mergeOptions(optionsA, optionsB) {
    return objectsMergeDeep(optionsA, optionsB || {});
  }
  function optionsAtMedia(options) {
    const optionsAtMedia = options.breakpoints || {};
    const matchedMediaOptions = objectKeys(optionsAtMedia).filter(media => ownerWindow.matchMedia(media).matches).map(media => optionsAtMedia[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});
    return mergeOptions(options, matchedMediaOptions);
  }
  function optionsMediaQueries(optionsList) {
    return optionsList.map(options => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
  }
  const self = {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  };
  return self;
}

function PluginsHandler(optionsHandler) {
  let activePlugins = [];
  function init(emblaApi, plugins) {
    activePlugins = plugins.filter(({
      options
    }) => optionsHandler.optionsAtMedia(options).active !== false);
    activePlugins.forEach(plugin => plugin.init(emblaApi, optionsHandler));
    return plugins.reduce((map, plugin) => Object.assign(map, {
      [plugin.name]: plugin
    }), {});
  }
  function destroy() {
    activePlugins = activePlugins.filter(plugin => plugin.destroy());
  }
  const self = {
    init,
    destroy
  };
  return self;
}

function EmblaCarousel(root, userOptions, userPlugins) {
  const ownerDocument = root.ownerDocument;
  const ownerWindow = ownerDocument.defaultView;
  const optionsHandler = OptionsHandler(ownerWindow);
  const pluginsHandler = PluginsHandler(optionsHandler);
  const mediaHandlers = EventStore();
  const eventHandler = EventHandler();
  const {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  } = optionsHandler;
  const {
    on,
    off,
    emit
  } = eventHandler;
  const reInit = reActivate;
  let destroyed = false;
  let engine;
  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);
  let options = mergeOptions(optionsBase);
  let pluginList = [];
  let pluginApis;
  let container;
  let slides;
  function storeElements() {
    const {
      container: userContainer,
      slides: userSlides
    } = options;
    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;
    container = customContainer || root.children[0];
    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;
    slides = [].slice.call(customSlides || container.children);
  }
  function createEngine(options) {
    const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler);
    if (options.loop && !engine.slideLooper.canLoop()) {
      const optionsWithoutLoop = Object.assign({}, options, {
        loop: false
      });
      return createEngine(optionsWithoutLoop);
    }
    return engine;
  }
  function activate(withOptions, withPlugins) {
    if (destroyed) return;
    optionsBase = mergeOptions(optionsBase, withOptions);
    options = optionsAtMedia(optionsBase);
    pluginList = withPlugins || pluginList;
    storeElements();
    engine = createEngine(options);
    optionsMediaQueries([optionsBase, ...pluginList.map(({
      options
    }) => options)]).forEach(query => mediaHandlers.add(query, 'change', reActivate));
    if (!options.active) return;
    engine.translate.to(engine.location.get());
    engine.animation.init();
    engine.slidesInView.init();
    engine.slideFocus.init(self);
    engine.eventHandler.init(self);
    engine.resizeHandler.init(self);
    engine.slidesHandler.init(self);
    if (engine.options.loop) engine.slideLooper.loop();
    if (container.offsetParent && slides.length) engine.dragHandler.init(self);
    pluginApis = pluginsHandler.init(self, pluginList);
  }
  function reActivate(withOptions, withPlugins) {
    const startIndex = selectedScrollSnap();
    deActivate();
    activate(mergeOptions({
      startIndex
    }, withOptions), withPlugins);
    eventHandler.emit('reInit');
  }
  function deActivate() {
    engine.dragHandler.destroy();
    engine.eventStore.clear();
    engine.translate.clear();
    engine.slideLooper.clear();
    engine.resizeHandler.destroy();
    engine.slidesHandler.destroy();
    engine.slidesInView.destroy();
    engine.animation.destroy();
    pluginsHandler.destroy();
    mediaHandlers.clear();
  }
  function destroy() {
    if (destroyed) return;
    destroyed = true;
    mediaHandlers.clear();
    deActivate();
    eventHandler.emit('destroy');
    eventHandler.clear();
  }
  function scrollTo(index, jump, direction) {
    if (!options.active || destroyed) return;
    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);
    engine.scrollTo.index(index, direction || 0);
  }
  function scrollNext(jump) {
    const next = engine.index.add(1).get();
    scrollTo(next, jump, -1);
  }
  function scrollPrev(jump) {
    const prev = engine.index.add(-1).get();
    scrollTo(prev, jump, 1);
  }
  function canScrollNext() {
    const next = engine.index.add(1).get();
    return next !== selectedScrollSnap();
  }
  function canScrollPrev() {
    const prev = engine.index.add(-1).get();
    return prev !== selectedScrollSnap();
  }
  function scrollSnapList() {
    return engine.scrollSnapList;
  }
  function scrollProgress() {
    return engine.scrollProgress.get(engine.offsetLocation.get());
  }
  function selectedScrollSnap() {
    return engine.index.get();
  }
  function previousScrollSnap() {
    return engine.indexPrevious.get();
  }
  function slidesInView() {
    return engine.slidesInView.get();
  }
  function slidesNotInView() {
    return engine.slidesInView.get(false);
  }
  function plugins() {
    return pluginApis;
  }
  function internalEngine() {
    return engine;
  }
  function rootNode() {
    return root;
  }
  function containerNode() {
    return container;
  }
  function slideNodes() {
    return slides;
  }
  const self = {
    canScrollNext,
    canScrollPrev,
    containerNode,
    internalEngine,
    destroy,
    off,
    on,
    emit,
    plugins,
    previousScrollSnap,
    reInit,
    rootNode,
    scrollNext,
    scrollPrev,
    scrollProgress,
    scrollSnapList,
    scrollTo,
    selectedScrollSnap,
    slideNodes,
    slidesInView,
    slidesNotInView
  };
  activate(userOptions, userPlugins);
  setTimeout(() => eventHandler.emit('init'), 0);
  return self;
}
EmblaCarousel.globalOptions = undefined;

module.exports = EmblaCarousel;
//# sourceMappingURL=embla-carousel.cjs.js.map

~~~

## node_modules\embla-carousel\cjs\embla-carousel.cjs.js.map

~~~map
{"version":3,"file":"embla-carousel.cjs.js","sources":["../src/components/utils.ts","../src/components/Alignment.ts","../src/components/EventStore.ts","../src/components/Animations.ts","../src/components/Axis.ts","../src/components/Limit.ts","../src/components/Counter.ts","../src/components/DragHandler.ts","../src/components/DragTracker.ts","../src/components/NodeRects.ts","../src/components/PercentOfView.ts","../src/components/ResizeHandler.ts","../src/components/ScrollBody.ts","../src/components/ScrollBounds.ts","../src/components/ScrollContain.ts","../src/components/ScrollLimit.ts","../src/components/ScrollLooper.ts","../src/components/ScrollProgress.ts","../src/components/ScrollSnaps.ts","../src/components/SlideRegistry.ts","../src/components/ScrollTarget.ts","../src/components/ScrollTo.ts","../src/components/SlideFocus.ts","../src/components/Vector1d.ts","../src/components/Translate.ts","../src/components/SlideLooper.ts","../src/components/SlidesHandler.ts","../src/components/SlidesInView.ts","../src/components/SlideSizes.ts","../src/components/SlidesToScroll.ts","../src/components/Engine.ts","../src/components/EventHandler.ts","../src/components/Options.ts","../src/components/OptionsHandler.ts","../src/components/PluginsHandler.ts","../src/components/EmblaCarousel.ts"],"sourcesContent":["import { PointerEventType } from './DragTracker'\n\nexport type WindowType = Window & typeof globalThis\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isString(subject: unknown): subject is string {\n  return typeof subject === 'string'\n}\n\nexport function isBoolean(subject: unknown): subject is boolean {\n  return typeof subject === 'boolean'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return Math.sign(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToTwoDecimals(num: number): number {\n  return Math.round(num * 100) / 100\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function arrayIsLastIndex<Type>(array: Type[], index: number): boolean {\n  return index === arrayLastIndex(array)\n}\n\nexport function arrayFromNumber(n: number, startAt: number = 0): number[] {\n  return Array.from(Array(n), (_, i) => startAt + i)\n}\n\nexport function objectKeys<Type extends object>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function isMouseEvent(\n  evt: PointerEventType,\n  ownerWindow: WindowType\n): evt is MouseEvent {\n  return (\n    typeof ownerWindow.MouseEvent !== 'undefined' &&\n    evt instanceof ownerWindow.MouseEvent\n  )\n}\n","import { isString } from './utils'\n\nexport type AlignmentOptionType =\n  | 'start'\n  | 'center'\n  | 'end'\n  | ((viewSize: number, snapSize: number, index: number) => number)\n\nexport type AlignmentType = {\n  measure: (n: number, index: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function measure(n: number, index: number): number {\n    if (isString(align)) return predefined[align](n)\n    return align(viewSize, n, index)\n  }\n\n  const self: AlignmentType = {\n    measure\n  }\n  return self\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType\n  ) => EventStoreType\n  clear: () => void\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = { passive: true }\n  ): EventStoreType {\n    let removeListener: EventRemoverType\n\n    if ('addEventListener' in node) {\n      node.addEventListener(type, handler, options)\n      removeListener = () => node.removeEventListener(type, handler, options)\n    } else {\n      const legacyMediaQueryList = <MediaQueryList>node\n      legacyMediaQueryList.addListener(handler)\n      removeListener = () => legacyMediaQueryList.removeListener(handler)\n    }\n\n    listeners.push(removeListener)\n    return self\n  }\n\n  function clear(): void {\n    listeners = listeners.filter((remove) => remove())\n  }\n\n  const self: EventStoreType = {\n    add,\n    clear\n  }\n  return self\n}\n","import { EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { WindowType } from './utils'\n\nexport type AnimationsUpdateType = (engine: EngineType) => void\nexport type AnimationsRenderType = (engine: EngineType, alpha: number) => void\n\nexport type AnimationsType = {\n  init: () => void\n  destroy: () => void\n  start: () => void\n  stop: () => void\n  update: () => void\n  render: (alpha: number) => void\n}\n\nexport function Animations(\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  update: () => void,\n  render: (alpha: number) => void\n): AnimationsType {\n  const documentVisibleHandler = EventStore()\n  const fixedTimeStep = 1000 / 60\n\n  let lastTimeStamp: number | null = null\n  let accumulatedTime = 0\n  let animationId = 0\n\n  function init(): void {\n    documentVisibleHandler.add(ownerDocument, 'visibilitychange', () => {\n      if (ownerDocument.hidden) reset()\n    })\n  }\n\n  function destroy(): void {\n    stop()\n    documentVisibleHandler.clear()\n  }\n\n  function animate(timeStamp: DOMHighResTimeStamp): void {\n    if (!animationId) return\n    if (!lastTimeStamp) {\n      lastTimeStamp = timeStamp\n      update()\n      update()\n    }\n\n    const timeElapsed = timeStamp - lastTimeStamp\n    lastTimeStamp = timeStamp\n    accumulatedTime += timeElapsed\n\n    while (accumulatedTime >= fixedTimeStep) {\n      update()\n      accumulatedTime -= fixedTimeStep\n    }\n\n    const alpha = accumulatedTime / fixedTimeStep\n    render(alpha)\n\n    if (animationId) {\n      animationId = ownerWindow.requestAnimationFrame(animate)\n    }\n  }\n\n  function start(): void {\n    if (animationId) return\n    animationId = ownerWindow.requestAnimationFrame(animate)\n  }\n\n  function stop(): void {\n    ownerWindow.cancelAnimationFrame(animationId)\n    lastTimeStamp = null\n    accumulatedTime = 0\n    animationId = 0\n  }\n\n  function reset(): void {\n    lastTimeStamp = null\n    accumulatedTime = 0\n  }\n\n  const self: AnimationsType = {\n    init,\n    destroy,\n    start,\n    stop,\n    update,\n    render\n  }\n  return self\n}\n","import { NodeRectType } from './NodeRects'\n\nexport type AxisOptionType = 'x' | 'y'\nexport type AxisDirectionOptionType = 'ltr' | 'rtl'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (nodeRect: NodeRectType) => number\n  direction: (n: number) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  contentDirection: AxisDirectionOptionType\n): AxisType {\n  const isRightToLeft = contentDirection === 'rtl'\n  const isVertical = axis === 'y'\n  const scroll = isVertical ? 'y' : 'x'\n  const cross = isVertical ? 'x' : 'y'\n  const sign = !isVertical && isRightToLeft ? -1 : 1\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(nodeRect: NodeRectType): number {\n    const { height, width } = nodeRect\n    return isVertical ? height : width\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (isVertical) return 'top'\n    return isRightToLeft ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (isVertical) return 'bottom'\n    return isRightToLeft ? 'left' : 'right'\n  }\n\n  function direction(n: number): number {\n    return n * sign\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n    direction\n  }\n  return self\n}\n","import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number = 0, max: number = 0): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean\n): CounterType {\n  const { constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return clone().set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    get,\n    set,\n    add,\n    clone\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { AnimationsType } from './Animations'\nimport { CounterType } from './Counter'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1DType } from './Vector1d'\nimport { PercentOfViewType } from './PercentOfView'\nimport { Limit } from './Limit'\nimport {\n  deltaAbs,\n  factorAbs,\n  isBoolean,\n  isMouseEvent,\n  mathAbs,\n  mathSign,\n  WindowType\n} from './utils'\n\ntype DragHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  evt: PointerEventType\n) => boolean | void\n\nexport type DragHandlerOptionType = boolean | DragHandlerCallbackType\n\nexport type DragHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n  pointerDown: () => boolean\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  rootNode: HTMLElement,\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationsType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  dragFree: boolean,\n  dragThreshold: number,\n  skipSnaps: boolean,\n  baseFriction: number,\n  watchDrag: DragHandlerOptionType\n): DragHandlerType {\n  const { cross: crossAxis, direction } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const nonPassiveEvent = { passive: false }\n  const initEvents = EventStore()\n  const dragEvents = EventStore()\n  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20))\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 43 : 25\n\n  let isMoving = false\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchDrag) return\n\n    function downIfAllowed(evt: PointerEventType): void {\n      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt)\n    }\n\n    const node = rootNode\n    initEvents\n      .add(node, 'dragstart', (evt) => evt.preventDefault(), nonPassiveEvent)\n      .add(node, 'touchmove', () => undefined, nonPassiveEvent)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', downIfAllowed)\n      .add(node, 'mousedown', downIfAllowed)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click, true)\n  }\n\n  function destroy(): void {\n    initEvents.clear()\n    dragEvents.clear()\n  }\n\n  function addDragEvents(): void {\n    const node = isMouse ? ownerDocument : rootNode\n    dragEvents\n      .add(node, 'touchmove', move, nonPassiveEvent)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move, nonPassiveEvent)\n      .add(node, 'mouseup', up)\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const nodeName = node.nodeName || ''\n    return focusNodes.includes(nodeName)\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.add(mathSign(force) * -1)\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    const isMouseEvt = isMouseEvent(evt, ownerWindow)\n    isMouse = isMouseEvt\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving\n    isMoving = deltaAbs(target.get(), location.get()) >= 2\n\n    if (isMouseEvt && evt.button !== 0) return\n    if (isFocusNode(evt.target as Element)) return\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    scrollBody.useFriction(0).useDuration(0)\n    target.set(location)\n    addDragEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n  }\n\n  function move(evt: PointerEventType): void {\n    const isTouchEvt = !isMouseEvent(evt, ownerWindow)\n    if (isTouchEvt && evt.touches.length >= 2) return up(evt)\n\n    const lastScroll = dragTracker.readPoint(evt)\n    const lastCross = dragTracker.readPoint(evt, crossAxis)\n    const diffScroll = deltaAbs(lastScroll, startScroll)\n    const diffCross = deltaAbs(lastCross, startCross)\n\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (diffScroll > dragThreshold) preventClick = true\n\n    scrollBody.useFriction(0.3).useDuration(0.75)\n    animation.start()\n    target.add(direction(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const speed = baseSpeed - 10 * forceFactor\n    const friction = baseFriction + forceFactor / 50\n\n    preventScroll = false\n    pointerIsDown = false\n    dragEvents.clear()\n    scrollBody.useDuration(speed).useFriction(friction)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) {\n      evt.stopPropagation()\n      evt.preventDefault()\n      preventClick = false\n    }\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    init,\n    destroy,\n    pointerDown\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { isMouseEvent, mathAbs, WindowType } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(\n  axis: AxisType,\n  ownerWindow: WindowType\n): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint\n  }\n  return self\n}\n","export type NodeRectType = {\n  top: number\n  right: number\n  bottom: number\n  left: number\n  width: number\n  height: number\n}\n\nexport type NodeRectsType = {\n  measure: (node: HTMLElement) => NodeRectType\n}\n\nexport function NodeRects(): NodeRectsType {\n  function measure(node: HTMLElement): NodeRectType {\n    const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node\n    const offset: NodeRectType = {\n      top: offsetTop,\n      right: offsetLeft + offsetWidth,\n      bottom: offsetTop + offsetHeight,\n      left: offsetLeft,\n      width: offsetWidth,\n      height: offsetHeight\n    }\n\n    return offset\n  }\n\n  const self: NodeRectsType = {\n    measure\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { NodeRectsType } from './NodeRects'\nimport { isBoolean, mathAbs, WindowType } from './utils'\n\ntype ResizeHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  entries: ResizeObserverEntry[]\n) => boolean | void\n\nexport type ResizeHandlerOptionType = boolean | ResizeHandlerCallbackType\n\nexport type ResizeHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n}\n\nexport function ResizeHandler(\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  ownerWindow: WindowType,\n  slides: HTMLElement[],\n  axis: AxisType,\n  watchResize: ResizeHandlerOptionType,\n  nodeRects: NodeRectsType\n): ResizeHandlerType {\n  const observeNodes = [container].concat(slides)\n  let resizeObserver: ResizeObserver\n  let containerSize: number\n  let slideSizes: number[] = []\n  let destroyed = false\n\n  function readSize(node: HTMLElement): number {\n    return axis.measureSize(nodeRects.measure(node))\n  }\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchResize) return\n\n    containerSize = readSize(container)\n    slideSizes = slides.map(readSize)\n\n    function defaultCallback(entries: ResizeObserverEntry[]): void {\n      for (const entry of entries) {\n        if (destroyed) return\n\n        const isContainer = entry.target === container\n        const slideIndex = slides.indexOf(<HTMLElement>entry.target)\n        const lastSize = isContainer ? containerSize : slideSizes[slideIndex]\n        const newSize = readSize(isContainer ? container : slides[slideIndex])\n        const diffSize = mathAbs(newSize - lastSize)\n\n        if (diffSize >= 0.5) {\n          emblaApi.reInit()\n          eventHandler.emit('resize')\n\n          break\n        }\n      }\n    }\n\n    resizeObserver = new ResizeObserver((entries) => {\n      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n        defaultCallback(entries)\n      }\n    })\n\n    ownerWindow.requestAnimationFrame(() => {\n      observeNodes.forEach((node) => resizeObserver.observe(node))\n    })\n  }\n\n  function destroy(): void {\n    destroyed = true\n    if (resizeObserver) resizeObserver.disconnect()\n  }\n\n  const self: ResizeHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { mathSign, mathAbs } from './utils'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  duration: () => number\n  velocity: () => number\n  seek: () => ScrollBodyType\n  settled: () => boolean\n  useBaseFriction: () => ScrollBodyType\n  useBaseDuration: () => ScrollBodyType\n  useFriction: (n: number) => ScrollBodyType\n  useDuration: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  offsetLocation: Vector1DType,\n  previousLocation: Vector1DType,\n  target: Vector1DType,\n  baseDuration: number,\n  baseFriction: number\n): ScrollBodyType {\n  let scrollVelocity = 0\n  let scrollDirection = 0\n  let scrollDuration = baseDuration\n  let scrollFriction = baseFriction\n  let rawLocation = location.get()\n  let rawLocationPrevious = 0\n\n  function seek(): ScrollBodyType {\n    const displacement = target.get() - location.get()\n    const isInstant = !scrollDuration\n    let scrollDistance = 0\n\n    if (isInstant) {\n      scrollVelocity = 0\n      previousLocation.set(target)\n      location.set(target)\n\n      scrollDistance = displacement\n    } else {\n      previousLocation.set(location)\n\n      scrollVelocity += displacement / scrollDuration\n      scrollVelocity *= scrollFriction\n      rawLocation += scrollVelocity\n      location.add(scrollVelocity)\n\n      scrollDistance = rawLocation - rawLocationPrevious\n    }\n\n    scrollDirection = mathSign(scrollDistance)\n    rawLocationPrevious = rawLocation\n    return self\n  }\n\n  function settled(): boolean {\n    const diff = target.get() - offsetLocation.get()\n    return mathAbs(diff) < 0.001\n  }\n\n  function duration(): number {\n    return scrollDuration\n  }\n\n  function direction(): number {\n    return scrollDirection\n  }\n\n  function velocity(): number {\n    return scrollVelocity\n  }\n\n  function useBaseDuration(): ScrollBodyType {\n    return useDuration(baseDuration)\n  }\n\n  function useBaseFriction(): ScrollBodyType {\n    return useFriction(baseFriction)\n  }\n\n  function useDuration(n: number): ScrollBodyType {\n    scrollDuration = n\n    return self\n  }\n\n  function useFriction(n: number): ScrollBodyType {\n    scrollFriction = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    duration,\n    velocity,\n    seek,\n    settled,\n    useBaseFriction,\n    useBaseDuration,\n    useFriction,\n    useDuration\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  shouldConstrain: () => boolean\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const frictionLimit = Limit(0.1, 0.99)\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useDuration(25).useBaseFriction()\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    shouldConstrain,\n    constrain,\n    toggleActive\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayIsLastIndex, arrayLast, deltaAbs } from './utils'\n\nexport type ScrollContainOptionType = false | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n  scrollContainLimit: LimitType\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n  pixelTolerance: number\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, 0)\n  const snapsBounded = measureBounded()\n  const scrollContainLimit = findScrollContainLimit()\n  const snapsContained = measureContained()\n\n  function usePixelTolerance(bound: number, snap: number): boolean {\n    return deltaAbs(bound, snap) <= 1\n  }\n\n  function findScrollContainLimit(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureBounded(): number[] {\n    return snapsAligned\n      .map((snapAligned, index) => {\n        const { min, max } = scrollBounds\n        const snap = scrollBounds.constrain(snapAligned)\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(snapsAligned, index)\n        if (isFirst) return max\n        if (isLast) return min\n        if (usePixelTolerance(min, snap)) return min\n        if (usePixelTolerance(max, snap)) return max\n        return snap\n      })\n      .map((scrollBound) => parseFloat(scrollBound.toFixed(3)))\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = scrollContainLimit\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n    scrollContainLimit\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean\n): ScrollLimitType {\n  const max = scrollSnaps[0]\n  const min = loop ? max - contentSize : arrayLast(scrollSnaps)\n  const limit = Limit(min, max)\n\n  const self: ScrollLimitType = {\n    limit\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[]\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return length ? currentLocation / -length : 0\n  }\n\n  const self: ScrollProgressType = {\n    get\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slidesToScroll: SlidesToScrollType\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport {\n  arrayFromNumber,\n  arrayIsLastIndex,\n  arrayLast,\n  arrayLastIndex\n} from './utils'\n\nexport type SlideRegistryType = {\n  slideRegistry: number[][]\n}\n\nexport function SlideRegistry(\n  containSnaps: boolean,\n  containScroll: ScrollContainOptionType,\n  scrollSnaps: number[],\n  scrollContainLimit: LimitType,\n  slidesToScroll: SlidesToScrollType,\n  slideIndexes: number[]\n): SlideRegistryType {\n  const { groupSlides } = slidesToScroll\n  const { min, max } = scrollContainLimit\n  const slideRegistry = createSlideRegistry()\n\n  function createSlideRegistry(): number[][] {\n    const groupedSlideIndexes = groupSlides(slideIndexes)\n    const doNotContain = !containSnaps || containScroll === 'keepSnaps'\n\n    if (scrollSnaps.length === 1) return [slideIndexes]\n    if (doNotContain) return groupedSlideIndexes\n\n    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {\n      const isFirst = !index\n      const isLast = arrayIsLastIndex(groups, index)\n\n      if (isFirst) {\n        const range = arrayLast(groups[0]) + 1\n        return arrayFromNumber(range)\n      }\n      if (isLast) {\n        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1\n        return arrayFromNumber(range, arrayLast(groups)[0])\n      }\n      return group\n    })\n  }\n\n  const self: SlideRegistryType = {\n    slideRegistry\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { arrayLast, mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((snap, index) => ({ diff: shortcut(snap - distance, 0), index }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return target\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    if (matchingTargets.length) return minDistance(matchingTargets)\n    return arrayLast(targets) - contentSize\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut\n  }\n  return self\n}\n","import { AnimationsType } from './Animations'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationsType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    targetVector.add(distanceDiff)\n\n    if (distanceDiff) {\n      if (scrollBody.duration()) {\n        animation.start()\n      } else {\n        animation.update()\n        animation.render(1)\n        animation.update()\n      }\n    }\n\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStoreType } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollToType } from './ScrollTo'\nimport { SlideRegistryType } from './SlideRegistry'\nimport { isBoolean, isNumber } from './utils'\n\ntype FocusHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  evt: FocusEvent\n) => boolean | void\n\nexport type FocusHandlerOptionType = boolean | FocusHandlerCallbackType\n\nexport type SlideFocusType = {\n  init: (emblaApi: EmblaCarouselType) => void\n}\n\nexport function SlideFocus(\n  root: HTMLElement,\n  slides: HTMLElement[],\n  slideRegistry: SlideRegistryType['slideRegistry'],\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  eventStore: EventStoreType,\n  eventHandler: EventHandlerType,\n  watchFocus: FocusHandlerOptionType\n): SlideFocusType {\n  const focusListenerOptions = { passive: true, capture: true }\n  let lastTabPressTime = 0\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchFocus) return\n\n    function defaultCallback(index: number): void {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n\n      if (diffTime > 10) return\n\n      eventHandler.emit('slideFocusStart')\n      root.scrollLeft = 0\n\n      const group = slideRegistry.findIndex((group) => group.includes(index))\n\n      if (!isNumber(group)) return\n\n      scrollBody.useDuration(0)\n      scrollTo.index(group, 0)\n\n      eventHandler.emit('slideFocus')\n    }\n\n    eventStore.add(document, 'keydown', registerTabPress, false)\n\n    slides.forEach((slide, slideIndex) => {\n      eventStore.add(\n        slide,\n        'focus',\n        (evt: FocusEvent) => {\n          if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {\n            defaultCallback(slideIndex)\n          }\n        },\n        focusListenerOptions\n      )\n    })\n  }\n\n  function registerTabPress(event: KeyboardEvent): void {\n    if (event.code === 'Tab') lastTabPressTime = new Date().getTime()\n  }\n\n  const self: SlideFocusType = {\n    init\n  }\n  return self\n}\n","import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (n: Vector1DType | number) => void\n  add: (n: Vector1DType | number) => void\n  subtract: (n: Vector1DType | number) => void\n}\n\nexport function Vector1D(initialValue: number): Vector1DType {\n  let value = initialValue\n\n  function get(): number {\n    return value\n  }\n\n  function set(n: Vector1DType | number): void {\n    value = normalizeInput(n)\n  }\n\n  function add(n: Vector1DType | number): void {\n    value += normalizeInput(n)\n  }\n\n  function subtract(n: Vector1DType | number): void {\n    value -= normalizeInput(n)\n  }\n\n  function normalizeInput(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    get,\n    set,\n    add,\n    subtract\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { roundToTwoDecimals } from './utils'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (target: number) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  container: HTMLElement\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let previousTarget: number | null = null\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: number): void {\n    if (disabled) return\n\n    const newTarget = roundToTwoDecimals(axis.direction(target))\n    if (newTarget === previousTarget) return\n\n    containerStyle.transform = translate(newTarget)\n    previousTarget = newTarget\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\n\ntype SlideBoundType = {\n  start: number\n  end: number\n}\n\ntype LoopPointType = {\n  loopPoint: number\n  index: number\n  translate: TranslateType\n  slideLocation: Vector1DType\n  target: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  slideSizesWithGaps: number[],\n  snaps: number[],\n  scrollSnaps: number[],\n  location: Vector1DType,\n  slides: HTMLElement[]\n): SlideLooperType {\n  const roundingSafety = 0.5\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findSlideBounds(offset: number): SlideBoundType[] {\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + roundingSafety + offset,\n      end: snap + viewSize - roundingSafety + offset\n    }))\n  }\n\n  function findLoopPoints(\n    indexes: number[],\n    offset: number,\n    isEndEdge: boolean\n  ): LoopPointType[] {\n    const slideBounds = findSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isEndEdge ? 0 : -contentSize\n      const altered = isEndEdge ? contentSize : 0\n      const boundEdge = isEndEdge ? 'end' : 'start'\n      const loopPoint = slideBounds[index][boundEdge]\n\n      return {\n        index,\n        loopPoint,\n        slideLocation: Vector1D(-1),\n        translate: Translate(axis, slides[index]),\n        target: () => (location.get() > loopPoint ? initial : altered)\n      }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0]\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, contentSize, false)\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, -contentSize, true)\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, slideLocation } = loopPoint\n      const shiftLocation = target()\n      if (shiftLocation === slideLocation.get()) return\n      translate.to(shiftLocation)\n      slideLocation.set(shiftLocation)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { isBoolean } from './utils'\n\ntype SlidesHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  mutations: MutationRecord[]\n) => boolean | void\n\nexport type SlidesHandlerOptionType = boolean | SlidesHandlerCallbackType\n\nexport type SlidesHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n}\n\nexport function SlidesHandler(\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  watchSlides: SlidesHandlerOptionType\n): SlidesHandlerType {\n  let mutationObserver: MutationObserver\n  let destroyed = false\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchSlides) return\n\n    function defaultCallback(mutations: MutationRecord[]): void {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          emblaApi.reInit()\n          eventHandler.emit('slidesChanged')\n          break\n        }\n      }\n    }\n\n    mutationObserver = new MutationObserver((mutations) => {\n      if (destroyed) return\n      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n        defaultCallback(mutations)\n      }\n    })\n\n    mutationObserver.observe(container, { childList: true })\n  }\n\n  function destroy(): void {\n    if (mutationObserver) mutationObserver.disconnect()\n    destroyed = true\n  }\n\n  const self: SlidesHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { EventHandlerType } from './EventHandler'\nimport { objectKeys } from './utils'\n\ntype IntersectionEntryMapType = {\n  [key: number]: IntersectionObserverEntry\n}\n\nexport type SlidesInViewOptionsType = IntersectionObserverInit['threshold']\n\nexport type SlidesInViewType = {\n  init: () => void\n  destroy: () => void\n  get: (inView?: boolean) => number[]\n}\n\nexport function SlidesInView(\n  container: HTMLElement,\n  slides: HTMLElement[],\n  eventHandler: EventHandlerType,\n  threshold: SlidesInViewOptionsType\n): SlidesInViewType {\n  const intersectionEntryMap: IntersectionEntryMapType = {}\n  let inViewCache: number[] | null = null\n  let notInViewCache: number[] | null = null\n  let intersectionObserver: IntersectionObserver\n  let destroyed = false\n\n  function init(): void {\n    intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        if (destroyed) return\n\n        entries.forEach((entry) => {\n          const index = slides.indexOf(<HTMLElement>entry.target)\n          intersectionEntryMap[index] = entry\n        })\n\n        inViewCache = null\n        notInViewCache = null\n        eventHandler.emit('slidesInView')\n      },\n      {\n        root: container.parentElement,\n        threshold\n      }\n    )\n\n    slides.forEach((slide) => intersectionObserver.observe(slide))\n  }\n\n  function destroy(): void {\n    if (intersectionObserver) intersectionObserver.disconnect()\n    destroyed = true\n  }\n\n  function createInViewList(inView: boolean): number[] {\n    return objectKeys(intersectionEntryMap).reduce(\n      (list: number[], slideIndex) => {\n        const index = parseInt(slideIndex)\n        const { isIntersecting } = intersectionEntryMap[index]\n        const inViewMatch = inView && isIntersecting\n        const notInViewMatch = !inView && !isIntersecting\n\n        if (inViewMatch || notInViewMatch) list.push(index)\n        return list\n      },\n      []\n    )\n  }\n\n  function get(inView: boolean = true): number[] {\n    if (inView && inViewCache) return inViewCache\n    if (!inView && notInViewCache) return notInViewCache\n\n    const slideIndexes = createInViewList(inView)\n\n    if (inView) inViewCache = slideIndexes\n    if (!inView) notInViewCache = slideIndexes\n\n    return slideIndexes\n  }\n\n  const self: SlidesInViewType = {\n    init,\n    destroy,\n    get\n  }\n\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport { arrayIsLastIndex, arrayLast, mathAbs, WindowType } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n  startGap: number\n  endGap: number\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slides: HTMLElement[],\n  readEdgeGap: boolean,\n  ownerWindow: WindowType\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const withEdgeGap = slideRects[0] && readEdgeGap\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!withEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!withEdgeGap) return 0\n    const style = ownerWindow.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(rects, index)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport {\n  arrayKeys,\n  arrayLast,\n  arrayLastIndex,\n  isNumber,\n  mathAbs\n} from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  axis: AxisType,\n  viewSize: number,\n  slidesToScroll: SlidesToScrollOptionType,\n  loop: boolean,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  startGap: number,\n  endGap: number,\n  pixelTolerance: number\n): SlidesToScrollType {\n  const { startEdge, endEdge, direction } = axis\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    if (!array.length) return []\n\n    return arrayKeys(array)\n      .reduce((groups: number[], rectB, index) => {\n        const rectA = arrayLast(groups) || 0\n        const isFirst = rectA === 0\n        const isLast = rectB === arrayLastIndex(array)\n\n        const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge]\n        const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge]\n        const gapA = !loop && isFirst ? direction(startGap) : 0\n        const gapB = !loop && isLast ? direction(endGap) : 0\n        const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA))\n\n        if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB)\n        if (isLast) groups.push(array.length)\n        return groups\n      }, [])\n      .map((currentSize, index, groups) => {\n        const previousSize = Math.max(groups[index - 1] || 0)\n        return array.slice(previousSize, currentSize)\n      })\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport {\n  Animations,\n  AnimationsType,\n  AnimationsUpdateType,\n  AnimationsRenderType\n} from './Animations'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { NodeRectType, NodeRects } from './NodeRects'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ResizeHandler, ResizeHandlerType } from './ResizeHandler'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { SlideRegistry, SlideRegistryType } from './SlideRegistry'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideFocus, SlideFocusType } from './SlideFocus'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesHandler, SlidesHandlerType } from './SlidesHandler'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex, WindowType } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  ownerDocument: Document\n  ownerWindow: WindowType\n  eventHandler: EventHandlerType\n  axis: AxisType\n  animation: AnimationsType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  offsetLocation: Vector1DType\n  previousLocation: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  resizeHandler: ResizeHandlerType\n  slidesHandler: SlidesHandlerType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnapList: number[]\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  slideFocus: SlideFocusType\n  slideRegistry: SlideRegistryType['slideRegistry']\n  containerRect: NodeRectType\n  slideRects: NodeRectType[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  options: OptionsType,\n  eventHandler: EventHandlerType\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction,\n    startIndex,\n    loop,\n    duration,\n    dragFree,\n    dragThreshold,\n    inViewThreshold,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n    watchResize,\n    watchSlides,\n    watchDrag,\n    watchFocus\n  } = options\n\n  // Measurements\n  const pixelTolerance = 2\n  const nodeRects = NodeRects()\n  const containerRect = nodeRects.measure(container)\n  const slideRects = slides.map(nodeRects.measure)\n  const axis = Axis(scrollAxis, direction)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && !!containScroll\n  const readEdgeGap = loop || !!containScroll\n  const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    readEdgeGap,\n    ownerWindow\n  )\n  const slidesToScroll = SlidesToScroll(\n    axis,\n    viewSize,\n    groupSlides,\n    loop,\n    containerRect,\n    slideRects,\n    startGap,\n    endGap,\n    pixelTolerance\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slidesToScroll\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained, scrollContainLimit } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n    pixelTolerance\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Animation\n  const update: AnimationsUpdateType = ({\n    dragHandler,\n    scrollBody,\n    scrollBounds,\n    options: { loop }\n  }) => {\n    if (!loop) scrollBounds.constrain(dragHandler.pointerDown())\n    scrollBody.seek()\n  }\n\n  const render: AnimationsRenderType = (\n    {\n      scrollBody,\n      translate,\n      location,\n      offsetLocation,\n      previousLocation,\n      scrollLooper,\n      slideLooper,\n      dragHandler,\n      animation,\n      eventHandler,\n      scrollBounds,\n      options: { loop }\n    },\n    alpha\n  ) => {\n    const shouldSettle = scrollBody.settled()\n    const withinBounds = !scrollBounds.shouldConstrain()\n    const hasSettled = loop ? shouldSettle : shouldSettle && withinBounds\n    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown()\n\n    if (hasSettledAndIdle) animation.stop()\n\n    const interpolatedLocation =\n      location.get() * alpha + previousLocation.get() * (1 - alpha)\n\n    offsetLocation.set(interpolatedLocation)\n\n    if (loop) {\n      scrollLooper.loop(scrollBody.direction())\n      slideLooper.loop()\n    }\n\n    translate.to(offsetLocation.get())\n\n    if (hasSettledAndIdle) eventHandler.emit('settle')\n    if (!hasSettled) eventHandler.emit('scroll')\n  }\n\n  const animation = Animations(\n    ownerDocument,\n    ownerWindow,\n    () => update(engine),\n    (alpha: number) => render(engine, alpha)\n  )\n\n  // Shared\n  const friction = 0.68\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const previousLocation = Vector1D(startLocation)\n  const offsetLocation = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(\n    location,\n    offsetLocation,\n    previousLocation,\n    target,\n    duration,\n    friction\n  )\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollBody,\n    scrollTarget,\n    target,\n    eventHandler\n  )\n  const scrollProgress = ScrollProgress(limit)\n  const eventStore = EventStore()\n  const slidesInView = SlidesInView(\n    container,\n    slides,\n    eventHandler,\n    inViewThreshold\n  )\n  const { slideRegistry } = SlideRegistry(\n    containSnaps,\n    containScroll,\n    scrollSnaps,\n    scrollContainLimit,\n    slidesToScroll,\n    slideIndexes\n  )\n  const slideFocus = SlideFocus(\n    root,\n    slides,\n    slideRegistry,\n    scrollTo,\n    scrollBody,\n    eventStore,\n    eventHandler,\n    watchFocus\n  )\n\n  // Engine\n  const engine: EngineType = {\n    ownerDocument,\n    ownerWindow,\n    eventHandler,\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    dragHandler: DragHandler(\n      axis,\n      root,\n      ownerDocument,\n      ownerWindow,\n      target,\n      DragTracker(axis, ownerWindow),\n      location,\n      animation,\n      scrollTo,\n      scrollBody,\n      scrollTarget,\n      index,\n      eventHandler,\n      percentOfView,\n      dragFree,\n      dragThreshold,\n      skipSnaps,\n      friction,\n      watchDrag\n    ),\n    eventStore,\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    offsetLocation,\n    previousLocation,\n    options,\n    resizeHandler: ResizeHandler(\n      container,\n      eventHandler,\n      ownerWindow,\n      slides,\n      axis,\n      watchResize,\n      nodeRects\n    ),\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      offsetLocation,\n      target,\n      scrollBody,\n      percentOfView\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n      location,\n      offsetLocation,\n      previousLocation,\n      target\n    ]),\n    scrollProgress,\n    scrollSnapList: scrollSnaps.map(scrollProgress.get),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      viewSize,\n      contentSize,\n      slideSizes,\n      slideSizesWithGaps,\n      snaps,\n      scrollSnaps,\n      offsetLocation,\n      slides\n    ),\n    slideFocus,\n    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n    slidesInView,\n    slideIndexes,\n    slideRegistry,\n    slidesToScroll,\n    target,\n    translate: Translate(axis, container)\n  }\n\n  return engine\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\n\ntype CallbackType = (emblaApi: EmblaCarouselType, evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType = EmblaEventListType[keyof EmblaEventListType]\n\nexport interface EmblaEventListType {\n  init: 'init'\n  pointerDown: 'pointerDown'\n  pointerUp: 'pointerUp'\n  slidesChanged: 'slidesChanged'\n  slidesInView: 'slidesInView'\n  scroll: 'scroll'\n  select: 'select'\n  settle: 'settle'\n  destroy: 'destroy'\n  reInit: 'reInit'\n  resize: 'resize'\n  slideFocusStart: 'slideFocusStart'\n  slideFocus: 'slideFocus'\n}\n\nexport type EventHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  clear: () => void\n}\n\nexport function EventHandler(): EventHandlerType {\n  let listeners: ListenersType = {}\n  let api: EmblaCarouselType\n\n  function init(emblaApi: EmblaCarouselType): void {\n    api = emblaApi\n  }\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(api, evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  function clear(): void {\n    listeners = {}\n  }\n\n  const self: EventHandlerType = {\n    init,\n    emit,\n    off,\n    on,\n    clear\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisDirectionOptionType, AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { DragHandlerOptionType } from './DragHandler'\nimport { ResizeHandlerOptionType } from './ResizeHandler'\nimport { SlidesHandlerOptionType } from './SlidesHandler'\nimport { SlidesInViewOptionsType } from './SlidesInView'\nimport { FocusHandlerOptionType } from './SlideFocus'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  container: string | HTMLElement | null\n  slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null\n  containScroll: ScrollContainOptionType\n  direction: AxisDirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  dragThreshold: number\n  inViewThreshold: SlidesInViewOptionsType\n  loop: boolean\n  skipSnaps: boolean\n  duration: number\n  startIndex: number\n  watchDrag: DragHandlerOptionType\n  watchResize: ResizeHandlerOptionType\n  watchSlides: SlidesHandlerOptionType\n  watchFocus: FocusHandlerOptionType\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  container: null,\n  slides: null,\n  containScroll: 'trimSnaps',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  inViewThreshold: 0,\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startIndex: 0,\n  active: true,\n  watchDrag: true,\n  watchResize: true,\n  watchSlides: true,\n  watchFocus: true\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsMergeDeep, WindowType } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  mergeOptions: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ) => TypeA\n  optionsAtMedia: <Type extends OptionsType>(options: Type) => Type\n  optionsMediaQueries: (optionsList: OptionsType[]) => MediaQueryList[]\n}\n\nexport function OptionsHandler(ownerWindow: WindowType): OptionsHandlerType {\n  function mergeOptions<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function optionsAtMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => ownerWindow.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => mergeOptions(a, mediaOption), {})\n\n    return mergeOptions(options, matchedMediaOptions)\n  }\n\n  function optionsMediaQueries(optionsList: OptionsType[]): MediaQueryList[] {\n    return optionsList\n      .map((options) => objectKeys(options.breakpoints || {}))\n      .reduce((acc, mediaQueries) => acc.concat(mediaQueries), [])\n      .map(ownerWindow.matchMedia)\n  }\n\n  const self: OptionsHandlerType = {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { OptionsHandlerType } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type PluginsHandlerType = {\n  init: (\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ) => EmblaPluginsType\n  destroy: () => void\n}\n\nexport function PluginsHandler(\n  optionsHandler: OptionsHandlerType\n): PluginsHandlerType {\n  let activePlugins: EmblaPluginType[] = []\n\n  function init(\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ): EmblaPluginsType {\n    activePlugins = plugins.filter(\n      ({ options }) => optionsHandler.optionsAtMedia(options).active !== false\n    )\n    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler))\n\n    return plugins.reduce(\n      (map, plugin) => Object.assign(map, { [plugin.name]: plugin }),\n      {}\n    )\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType, OptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\nimport { isString, WindowType } from './utils'\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  emit: EventHandlerType['emit']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: () => number[]\n  slidesNotInView: () => number[]\n}\n\nfunction EmblaCarousel(\n  root: HTMLElement,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[]\n): EmblaCarouselType {\n  const ownerDocument = root.ownerDocument\n  const ownerWindow = <WindowType>ownerDocument.defaultView\n  const optionsHandler = OptionsHandler(ownerWindow)\n  const pluginsHandler = PluginsHandler(optionsHandler)\n  const mediaHandlers = EventStore()\n  const eventHandler = EventHandler()\n  const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler\n  const { on, off, emit } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions)\n  let options = mergeOptions(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const { container: userContainer, slides: userSlides } = options\n\n    const customContainer = isString(userContainer)\n      ? root.querySelector(userContainer)\n      : userContainer\n    container = <HTMLElement>(customContainer || root.children[0])\n\n    const customSlides = isString(userSlides)\n      ? container.querySelectorAll(userSlides)\n      : userSlides\n    slides = <HTMLElement[]>[].slice.call(customSlides || container.children)\n  }\n\n  function createEngine(options: OptionsType): EngineType {\n    const engine = Engine(\n      root,\n      container,\n      slides,\n      ownerDocument,\n      ownerWindow,\n      options,\n      eventHandler\n    )\n\n    if (options.loop && !engine.slideLooper.canLoop()) {\n      const optionsWithoutLoop = Object.assign({}, options, { loop: false })\n      return createEngine(optionsWithoutLoop)\n    }\n    return engine\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    if (destroyed) return\n\n    optionsBase = mergeOptions(optionsBase, withOptions)\n    options = optionsAtMedia(optionsBase)\n    pluginList = withPlugins || pluginList\n\n    storeElements()\n\n    engine = createEngine(options)\n\n    optionsMediaQueries([\n      optionsBase,\n      ...pluginList.map(({ options }) => options)\n    ]).forEach((query) => mediaHandlers.add(query, 'change', reActivate))\n\n    if (!options.active) return\n\n    engine.translate.to(engine.location.get())\n    engine.animation.init()\n    engine.slidesInView.init()\n    engine.slideFocus.init(self)\n    engine.eventHandler.init(self)\n    engine.resizeHandler.init(self)\n    engine.slidesHandler.init(self)\n\n    if (engine.options.loop) engine.slideLooper.loop()\n    if (container.offsetParent && slides.length) engine.dragHandler.init(self)\n\n    pluginApis = pluginsHandler.init(self, pluginList)\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(mergeOptions({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.destroy()\n    engine.eventStore.clear()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    engine.resizeHandler.destroy()\n    engine.slidesHandler.destroy()\n    engine.slidesInView.destroy()\n    engine.animation.destroy()\n    pluginsHandler.destroy()\n    mediaHandlers.clear()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    mediaHandlers.clear()\n    deActivate()\n    eventHandler.emit('destroy')\n    eventHandler.clear()\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody\n      .useBaseFriction()\n      .useDuration(jump === true ? 0 : options.duration)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.add(1).get()\n    scrollTo(next, jump, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.add(-1).get()\n    scrollTo(prev, jump, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.add(1).get()\n    return next !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.add(-1).get()\n    return prev !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnapList\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.offsetLocation.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function slidesInView(): number[] {\n    return engine.slidesInView.get()\n  }\n\n  function slidesNotInView(): number[] {\n    return engine.slidesInView.get(false)\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    emit,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView\n  }\n\n  activate(userOptions, userPlugins)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\ndeclare namespace EmblaCarousel {\n  let globalOptions: EmblaOptionsType | undefined\n}\n\nEmblaCarousel.globalOptions = undefined\n\nexport default EmblaCarousel\n"],"names":["isNumber","subject","isString","isBoolean","isObject","Object","prototype","toString","call","mathAbs","n","Math","abs","mathSign","sign","deltaAbs","valueB","valueA","factorAbs","diff","roundToTwoDecimals","num","round","arrayKeys","array","objectKeys","map","Number","arrayLast","arrayLastIndex","max","length","arrayIsLastIndex","index","arrayFromNumber","startAt","Array","from","_","i","object","keys","objectsMergeDeep","objectA","objectB","reduce","mergedObjects","currentObject","forEach","key","areObjects","isMouseEvent","evt","ownerWindow","MouseEvent","Alignment","align","viewSize","predefined","start","center","end","measure","self","EventStore","listeners","add","node","type","handler","options","passive","removeListener","addEventListener","removeEventListener","legacyMediaQueryList","addListener","push","clear","filter","remove","Animations","ownerDocument","update","render","documentVisibleHandler","fixedTimeStep","lastTimeStamp","accumulatedTime","animationId","init","hidden","reset","destroy","stop","animate","timeStamp","timeElapsed","alpha","requestAnimationFrame","cancelAnimationFrame","Axis","axis","contentDirection","isRightToLeft","isVertical","scroll","cross","startEdge","getStartEdge","endEdge","getEndEdge","measureSize","nodeRect","height","width","direction","Limit","min","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","loop","loopEnd","counter","withinLimit","get","set","clone","DragHandler","rootNode","target","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","eventHandler","percentOfView","dragFree","dragThreshold","skipSnaps","baseFriction","watchDrag","crossAxis","focusNodes","nonPassiveEvent","initEvents","dragEvents","goToNextThreshold","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","isMoving","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","emblaApi","downIfAllowed","down","preventDefault","undefined","up","click","addDragEvents","move","isFocusNode","nodeName","includes","forceBoost","boost","allowedForce","force","targetChanged","next","baseForce","byDistance","distance","byIndex","isMouseEvt","buttons","button","pointerDown","useFriction","useDuration","readPoint","emit","isTouchEvt","touches","lastScroll","lastCross","diffScroll","diffCross","cancelable","pointerMove","currentLocation","rawForce","pointerUp","forceFactor","speed","friction","stopPropagation","DragTracker","logInterval","startEvent","lastEvent","readTime","evtAxis","property","coord","expired","diffDrag","diffTime","isFlick","NodeRects","offsetTop","offsetLeft","offsetWidth","offsetHeight","offset","top","right","bottom","left","PercentOfView","ResizeHandler","container","slides","watchResize","nodeRects","observeNodes","concat","resizeObserver","containerSize","slideSizes","destroyed","readSize","defaultCallback","entries","entry","isContainer","slideIndex","indexOf","lastSize","newSize","diffSize","reInit","ResizeObserver","observe","disconnect","ScrollBody","offsetLocation","previousLocation","baseDuration","scrollVelocity","scrollDirection","scrollDuration","scrollFriction","rawLocation","rawLocationPrevious","seek","displacement","isInstant","scrollDistance","settled","duration","velocity","useBaseDuration","useBaseFriction","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","frictionLimit","disabled","shouldConstrain","edge","diffToEdge","diffToTarget","subtract","toggleActive","active","ScrollContain","contentSize","snapsAligned","containScroll","pixelTolerance","scrollBounds","snapsBounded","measureBounded","scrollContainLimit","findScrollContainLimit","snapsContained","measureContained","usePixelTolerance","bound","snap","startSnap","endSnap","lastIndexOf","snapAligned","isFirst","isLast","scrollBound","parseFloat","toFixed","slice","ScrollLimit","scrollSnaps","ScrollLooper","vectors","jointSafety","shouldLoop","loopDistance","v","ScrollProgress","ScrollSnaps","alignment","containerRect","slideRects","slidesToScroll","groupSlides","alignments","measureSizes","snaps","measureUnaligned","measureAligned","rects","rect","g","SlideRegistry","containSnaps","slideIndexes","slideRegistry","createSlideRegistry","groupedSlideIndexes","doNotContain","group","groups","range","ScrollTarget","targetVector","minDistance","distances","sort","a","b","findTargetSnap","ascDiffsToSnaps","shortcut","d1","d2","targets","matchingTargets","t","diffToSnap","targetSnapDistance","reachedBound","snapDistance","ScrollTo","indexCurrent","indexPrevious","distanceDiff","indexDiff","targetIndex","SlideFocus","root","eventStore","watchFocus","focusListenerOptions","capture","lastTabPressTime","nowTime","Date","getTime","scrollLeft","findIndex","document","registerTabPress","slide","event","code","Vector1D","initialValue","value","normalizeInput","Translate","translate","x","y","containerStyle","style","previousTarget","to","newTarget","transform","getAttribute","removeAttribute","SlideLooper","slideSizesWithGaps","roundingSafety","ascItems","descItems","reverse","loopPoints","startPoints","endPoints","removeSlideSizes","indexes","slidesInGap","gap","remainingGap","findSlideBounds","findLoopPoints","isEndEdge","slideBounds","initial","altered","boundEdge","loopPoint","slideLocation","canLoop","every","otherIndexes","shiftLocation","SlidesHandler","watchSlides","mutationObserver","mutations","mutation","MutationObserver","childList","SlidesInView","threshold","intersectionEntryMap","inViewCache","notInViewCache","intersectionObserver","IntersectionObserver","parentElement","createInViewList","inView","list","parseInt","isIntersecting","inViewMatch","notInViewMatch","SlideSizes","readEdgeGap","withEdgeGap","startGap","measureStartGap","endGap","measureEndGap","measureWithGaps","slideRect","getComputedStyle","getPropertyValue","SlidesToScroll","groupByNumber","byNumber","groupSize","bySize","rectB","rectA","edgeA","edgeB","gapA","gapB","chunkSize","currentSize","previousSize","Engine","scrollAxis","startIndex","inViewThreshold","dragHandler","scrollLooper","slideLooper","shouldSettle","withinBounds","hasSettled","hasSettledAndIdle","interpolatedLocation","engine","startLocation","scrollProgress","slidesInView","slideFocus","resizeHandler","scrollSnapList","slidesHandler","EventHandler","api","getListeners","e","on","cb","off","defaultOptions","breakpoints","OptionsHandler","mergeOptions","optionsA","optionsB","optionsAtMedia","matchedMediaOptions","media","matchMedia","matches","mediaOption","optionsMediaQueries","optionsList","acc","mediaQueries","PluginsHandler","optionsHandler","activePlugins","plugins","plugin","assign","name","EmblaCarousel","userOptions","userPlugins","defaultView","pluginsHandler","mediaHandlers","reActivate","optionsBase","globalOptions","pluginList","pluginApis","storeElements","userContainer","userSlides","customContainer","querySelector","children","customSlides","querySelectorAll","createEngine","optionsWithoutLoop","activate","withOptions","withPlugins","query","offsetParent","selectedScrollSnap","deActivate","jump","scrollNext","scrollPrev","prev","canScrollNext","canScrollPrev","previousScrollSnap","slidesNotInView","internalEngine","containerNode","slideNodes","setTimeout"],"mappings":"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"}
~~~

## node_modules\embla-carousel\cjs\index.d.ts

~~~ts
export { EmblaOptionsType } from './components/Options';
export { EmblaEventType } from './components/EventHandler';
export { EmblaPluginType } from './components/Plugins';
export { EmblaCarouselType } from './components/EmblaCarousel';
export { default } from './components/EmblaCarousel';
export { CreatePluginType, EmblaPluginsType } from './components/Plugins';
export { CreateOptionsType } from './components/Options';
export { OptionsHandlerType } from './components/OptionsHandler';
export { EmblaEventListType } from './components/EventHandler';
export { EngineType } from './components/Engine';
export { ScrollBodyType } from './components/ScrollBody';

~~~

## node_modules\embla-carousel\cjs\package.json

~~~json
{
  "name": "embla-carousel",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "A lightweight carousel library with fluid motion and great swipe precision",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel*",
    "components/**/*",
    "index.d.ts"
  ],
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "main": "embla-carousel.cjs.js",
  "type": "commonjs"
}

~~~

## node_modules\embla-carousel\components\Alignment.d.ts

~~~ts
export type AlignmentOptionType = 'start' | 'center' | 'end' | ((viewSize: number, snapSize: number, index: number) => number);
export type AlignmentType = {
    measure: (n: number, index: number) => number;
};
export declare function Alignment(align: AlignmentOptionType, viewSize: number): AlignmentType;

~~~

## node_modules\embla-carousel\components\Animations.d.ts

~~~ts
import { EngineType } from './Engine';
import { WindowType } from './utils';
export type AnimationsUpdateType = (engine: EngineType) => void;
export type AnimationsRenderType = (engine: EngineType, alpha: number) => void;
export type AnimationsType = {
    init: () => void;
    destroy: () => void;
    start: () => void;
    stop: () => void;
    update: () => void;
    render: (alpha: number) => void;
};
export declare function Animations(ownerDocument: Document, ownerWindow: WindowType, update: () => void, render: (alpha: number) => void): AnimationsType;

~~~

## node_modules\embla-carousel\components\Axis.d.ts

~~~ts
import { NodeRectType } from './NodeRects';
export type AxisOptionType = 'x' | 'y';
export type AxisDirectionOptionType = 'ltr' | 'rtl';
type AxisEdgeType = 'top' | 'right' | 'bottom' | 'left';
export type AxisType = {
    scroll: AxisOptionType;
    cross: AxisOptionType;
    startEdge: AxisEdgeType;
    endEdge: AxisEdgeType;
    measureSize: (nodeRect: NodeRectType) => number;
    direction: (n: number) => number;
};
export declare function Axis(axis: AxisOptionType, contentDirection: AxisDirectionOptionType): AxisType;
export {};

~~~

## node_modules\embla-carousel\components\Counter.d.ts

~~~ts
export type CounterType = {
    get: () => number;
    set: (n: number) => CounterType;
    add: (n: number) => CounterType;
    clone: () => CounterType;
};
export declare function Counter(max: number, start: number, loop: boolean): CounterType;

~~~

## node_modules\embla-carousel\components\DragHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
import { AnimationsType } from './Animations';
import { CounterType } from './Counter';
import { DragTrackerType, PointerEventType } from './DragTracker';
import { EventHandlerType } from './EventHandler';
import { AxisType } from './Axis';
import { ScrollBodyType } from './ScrollBody';
import { ScrollTargetType } from './ScrollTarget';
import { ScrollToType } from './ScrollTo';
import { Vector1DType } from './Vector1d';
import { PercentOfViewType } from './PercentOfView';
import { WindowType } from './utils';
type DragHandlerCallbackType = (emblaApi: EmblaCarouselType, evt: PointerEventType) => boolean | void;
export type DragHandlerOptionType = boolean | DragHandlerCallbackType;
export type DragHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
    pointerDown: () => boolean;
};
export declare function DragHandler(axis: AxisType, rootNode: HTMLElement, ownerDocument: Document, ownerWindow: WindowType, target: Vector1DType, dragTracker: DragTrackerType, location: Vector1DType, animation: AnimationsType, scrollTo: ScrollToType, scrollBody: ScrollBodyType, scrollTarget: ScrollTargetType, index: CounterType, eventHandler: EventHandlerType, percentOfView: PercentOfViewType, dragFree: boolean, dragThreshold: number, skipSnaps: boolean, baseFriction: number, watchDrag: DragHandlerOptionType): DragHandlerType;
export {};

~~~

## node_modules\embla-carousel\components\DragTracker.d.ts

~~~ts
import { AxisOptionType, AxisType } from './Axis';
import { WindowType } from './utils';
export type PointerEventType = TouchEvent | MouseEvent;
export type DragTrackerType = {
    pointerDown: (evt: PointerEventType) => number;
    pointerMove: (evt: PointerEventType) => number;
    pointerUp: (evt: PointerEventType) => number;
    readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number;
};
export declare function DragTracker(axis: AxisType, ownerWindow: WindowType): DragTrackerType;

~~~

## node_modules\embla-carousel\components\EmblaCarousel.d.ts

~~~ts
import { EngineType } from './Engine';
import { EventHandlerType } from './EventHandler';
import { EmblaOptionsType } from './Options';
import { EmblaPluginsType, EmblaPluginType } from './Plugins';
export type EmblaCarouselType = {
    canScrollNext: () => boolean;
    canScrollPrev: () => boolean;
    containerNode: () => HTMLElement;
    internalEngine: () => EngineType;
    destroy: () => void;
    off: EventHandlerType['off'];
    on: EventHandlerType['on'];
    emit: EventHandlerType['emit'];
    plugins: () => EmblaPluginsType;
    previousScrollSnap: () => number;
    reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void;
    rootNode: () => HTMLElement;
    scrollNext: (jump?: boolean) => void;
    scrollPrev: (jump?: boolean) => void;
    scrollProgress: () => number;
    scrollSnapList: () => number[];
    scrollTo: (index: number, jump?: boolean) => void;
    selectedScrollSnap: () => number;
    slideNodes: () => HTMLElement[];
    slidesInView: () => number[];
    slidesNotInView: () => number[];
};
declare function EmblaCarousel(root: HTMLElement, userOptions?: EmblaOptionsType, userPlugins?: EmblaPluginType[]): EmblaCarouselType;
declare namespace EmblaCarousel {
    let globalOptions: EmblaOptionsType | undefined;
}
export default EmblaCarousel;

~~~

## node_modules\embla-carousel\components\Engine.d.ts

~~~ts
import { AnimationsType } from './Animations';
import { AxisType } from './Axis';
import { CounterType } from './Counter';
import { DragHandlerType } from './DragHandler';
import { EventHandlerType } from './EventHandler';
import { EventStoreType } from './EventStore';
import { LimitType } from './Limit';
import { NodeRectType } from './NodeRects';
import { OptionsType } from './Options';
import { PercentOfViewType } from './PercentOfView';
import { ResizeHandlerType } from './ResizeHandler';
import { ScrollBodyType } from './ScrollBody';
import { ScrollBoundsType } from './ScrollBounds';
import { ScrollLooperType } from './ScrollLooper';
import { ScrollProgressType } from './ScrollProgress';
import { SlideRegistryType } from './SlideRegistry';
import { ScrollTargetType } from './ScrollTarget';
import { ScrollToType } from './ScrollTo';
import { SlideFocusType } from './SlideFocus';
import { SlideLooperType } from './SlideLooper';
import { SlidesHandlerType } from './SlidesHandler';
import { SlidesInViewType } from './SlidesInView';
import { SlidesToScrollType } from './SlidesToScroll';
import { TranslateType } from './Translate';
import { WindowType } from './utils';
import { Vector1DType } from './Vector1d';
export type EngineType = {
    ownerDocument: Document;
    ownerWindow: WindowType;
    eventHandler: EventHandlerType;
    axis: AxisType;
    animation: AnimationsType;
    scrollBounds: ScrollBoundsType;
    scrollLooper: ScrollLooperType;
    scrollProgress: ScrollProgressType;
    index: CounterType;
    indexPrevious: CounterType;
    limit: LimitType;
    location: Vector1DType;
    offsetLocation: Vector1DType;
    previousLocation: Vector1DType;
    options: OptionsType;
    percentOfView: PercentOfViewType;
    scrollBody: ScrollBodyType;
    dragHandler: DragHandlerType;
    eventStore: EventStoreType;
    slideLooper: SlideLooperType;
    slidesInView: SlidesInViewType;
    slidesToScroll: SlidesToScrollType;
    target: Vector1DType;
    translate: TranslateType;
    resizeHandler: ResizeHandlerType;
    slidesHandler: SlidesHandlerType;
    scrollTo: ScrollToType;
    scrollTarget: ScrollTargetType;
    scrollSnapList: number[];
    scrollSnaps: number[];
    slideIndexes: number[];
    slideFocus: SlideFocusType;
    slideRegistry: SlideRegistryType['slideRegistry'];
    containerRect: NodeRectType;
    slideRects: NodeRectType[];
};
export declare function Engine(root: HTMLElement, container: HTMLElement, slides: HTMLElement[], ownerDocument: Document, ownerWindow: WindowType, options: OptionsType, eventHandler: EventHandlerType): EngineType;

~~~

## node_modules\embla-carousel\components\EventHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
type CallbackType = (emblaApi: EmblaCarouselType, evt: EmblaEventType) => void;
export type EmblaEventType = EmblaEventListType[keyof EmblaEventListType];
export interface EmblaEventListType {
    init: 'init';
    pointerDown: 'pointerDown';
    pointerUp: 'pointerUp';
    slidesChanged: 'slidesChanged';
    slidesInView: 'slidesInView';
    scroll: 'scroll';
    select: 'select';
    settle: 'settle';
    destroy: 'destroy';
    reInit: 'reInit';
    resize: 'resize';
    slideFocusStart: 'slideFocusStart';
    slideFocus: 'slideFocus';
}
export type EventHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    emit: (evt: EmblaEventType) => EventHandlerType;
    on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType;
    off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType;
    clear: () => void;
};
export declare function EventHandler(): EventHandlerType;
export {};

~~~

## node_modules\embla-carousel\components\EventStore.d.ts

~~~ts
type EventNameType = keyof DocumentEventMap | keyof WindowEventMap;
type EventHandlerType = (evt: any) => void;
type EventOptionsType = boolean | AddEventListenerOptions | undefined;
export type EventStoreType = {
    add: (node: EventTarget, type: EventNameType, handler: EventHandlerType, options?: EventOptionsType) => EventStoreType;
    clear: () => void;
};
export declare function EventStore(): EventStoreType;
export {};

~~~

## node_modules\embla-carousel\components\Limit.d.ts

~~~ts
export type LimitType = {
    min: number;
    max: number;
    length: number;
    constrain: (n: number) => number;
    reachedAny: (n: number) => boolean;
    reachedMax: (n: number) => boolean;
    reachedMin: (n: number) => boolean;
    removeOffset: (n: number) => number;
};
export declare function Limit(min?: number, max?: number): LimitType;

~~~

## node_modules\embla-carousel\components\NodeRects.d.ts

~~~ts
export type NodeRectType = {
    top: number;
    right: number;
    bottom: number;
    left: number;
    width: number;
    height: number;
};
export type NodeRectsType = {
    measure: (node: HTMLElement) => NodeRectType;
};
export declare function NodeRects(): NodeRectsType;

~~~

## node_modules\embla-carousel\components\Options.d.ts

~~~ts
import { AlignmentOptionType } from './Alignment';
import { AxisDirectionOptionType, AxisOptionType } from './Axis';
import { SlidesToScrollOptionType } from './SlidesToScroll';
import { ScrollContainOptionType } from './ScrollContain';
import { DragHandlerOptionType } from './DragHandler';
import { ResizeHandlerOptionType } from './ResizeHandler';
import { SlidesHandlerOptionType } from './SlidesHandler';
import { SlidesInViewOptionsType } from './SlidesInView';
import { FocusHandlerOptionType } from './SlideFocus';
export type LooseOptionsType = {
    [key: string]: unknown;
};
export type CreateOptionsType<Type extends LooseOptionsType> = Type & {
    active: boolean;
    breakpoints: {
        [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>;
    };
};
export type OptionsType = CreateOptionsType<{
    align: AlignmentOptionType;
    axis: AxisOptionType;
    container: string | HTMLElement | null;
    slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null;
    containScroll: ScrollContainOptionType;
    direction: AxisDirectionOptionType;
    slidesToScroll: SlidesToScrollOptionType;
    dragFree: boolean;
    dragThreshold: number;
    inViewThreshold: SlidesInViewOptionsType;
    loop: boolean;
    skipSnaps: boolean;
    duration: number;
    startIndex: number;
    watchDrag: DragHandlerOptionType;
    watchResize: ResizeHandlerOptionType;
    watchSlides: SlidesHandlerOptionType;
    watchFocus: FocusHandlerOptionType;
}>;
export declare const defaultOptions: OptionsType;
export type EmblaOptionsType = Partial<OptionsType>;

~~~

## node_modules\embla-carousel\components\OptionsHandler.d.ts

~~~ts
import { LooseOptionsType, CreateOptionsType } from './Options';
import { WindowType } from './utils';
type OptionsType = Partial<CreateOptionsType<LooseOptionsType>>;
export type OptionsHandlerType = {
    mergeOptions: <TypeA extends OptionsType, TypeB extends OptionsType>(optionsA: TypeA, optionsB?: TypeB) => TypeA;
    optionsAtMedia: <Type extends OptionsType>(options: Type) => Type;
    optionsMediaQueries: (optionsList: OptionsType[]) => MediaQueryList[];
};
export declare function OptionsHandler(ownerWindow: WindowType): OptionsHandlerType;
export {};

~~~

## node_modules\embla-carousel\components\PercentOfView.d.ts

~~~ts
export type PercentOfViewType = {
    measure: (n: number) => number;
};
export declare function PercentOfView(viewSize: number): PercentOfViewType;

~~~

## node_modules\embla-carousel\components\Plugins.d.ts

~~~ts
import { CreateOptionsType, LooseOptionsType } from './Options';
import { EmblaCarouselType } from './EmblaCarousel';
import { OptionsHandlerType } from './OptionsHandler';
export type LoosePluginType = {
    [key: string]: unknown;
};
export type CreatePluginType<TypeA extends LoosePluginType, TypeB extends LooseOptionsType> = TypeA & {
    name: string;
    options: Partial<CreateOptionsType<TypeB>>;
    init: (embla: EmblaCarouselType, OptionsHandler: OptionsHandlerType) => void;
    destroy: () => void;
};
export interface EmblaPluginsType {
    [key: string]: CreatePluginType<LoosePluginType, {}>;
}
export type EmblaPluginType = EmblaPluginsType[keyof EmblaPluginsType];

~~~

## node_modules\embla-carousel\components\PluginsHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
import { OptionsHandlerType } from './OptionsHandler';
import { EmblaPluginsType, EmblaPluginType } from './Plugins';
export type PluginsHandlerType = {
    init: (emblaApi: EmblaCarouselType, plugins: EmblaPluginType[]) => EmblaPluginsType;
    destroy: () => void;
};
export declare function PluginsHandler(optionsHandler: OptionsHandlerType): PluginsHandlerType;

~~~

## node_modules\embla-carousel\components\ResizeHandler.d.ts

~~~ts
import { AxisType } from './Axis';
import { EmblaCarouselType } from './EmblaCarousel';
import { EventHandlerType } from './EventHandler';
import { NodeRectsType } from './NodeRects';
import { WindowType } from './utils';
type ResizeHandlerCallbackType = (emblaApi: EmblaCarouselType, entries: ResizeObserverEntry[]) => boolean | void;
export type ResizeHandlerOptionType = boolean | ResizeHandlerCallbackType;
export type ResizeHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
};
export declare function ResizeHandler(container: HTMLElement, eventHandler: EventHandlerType, ownerWindow: WindowType, slides: HTMLElement[], axis: AxisType, watchResize: ResizeHandlerOptionType, nodeRects: NodeRectsType): ResizeHandlerType;
export {};

~~~

## node_modules\embla-carousel\components\ScrollBody.d.ts

~~~ts
import { Vector1DType } from './Vector1d';
export type ScrollBodyType = {
    direction: () => number;
    duration: () => number;
    velocity: () => number;
    seek: () => ScrollBodyType;
    settled: () => boolean;
    useBaseFriction: () => ScrollBodyType;
    useBaseDuration: () => ScrollBodyType;
    useFriction: (n: number) => ScrollBodyType;
    useDuration: (n: number) => ScrollBodyType;
};
export declare function ScrollBody(location: Vector1DType, offsetLocation: Vector1DType, previousLocation: Vector1DType, target: Vector1DType, baseDuration: number, baseFriction: number): ScrollBodyType;

~~~

## node_modules\embla-carousel\components\ScrollBounds.d.ts

~~~ts
import { LimitType } from './Limit';
import { ScrollBodyType } from './ScrollBody';
import { Vector1DType } from './Vector1d';
import { PercentOfViewType } from './PercentOfView';
export type ScrollBoundsType = {
    shouldConstrain: () => boolean;
    constrain: (pointerDown: boolean) => void;
    toggleActive: (active: boolean) => void;
};
export declare function ScrollBounds(limit: LimitType, location: Vector1DType, target: Vector1DType, scrollBody: ScrollBodyType, percentOfView: PercentOfViewType): ScrollBoundsType;

~~~

## node_modules\embla-carousel\components\ScrollContain.d.ts

~~~ts
import { LimitType } from './Limit';
export type ScrollContainOptionType = false | 'trimSnaps' | 'keepSnaps';
export type ScrollContainType = {
    snapsContained: number[];
    scrollContainLimit: LimitType;
};
export declare function ScrollContain(viewSize: number, contentSize: number, snapsAligned: number[], containScroll: ScrollContainOptionType, pixelTolerance: number): ScrollContainType;

~~~

## node_modules\embla-carousel\components\ScrollLimit.d.ts

~~~ts
import { LimitType } from './Limit';
export type ScrollLimitType = {
    limit: LimitType;
};
export declare function ScrollLimit(contentSize: number, scrollSnaps: number[], loop: boolean): ScrollLimitType;

~~~

## node_modules\embla-carousel\components\ScrollLooper.d.ts

~~~ts
import { LimitType } from './Limit';
import { Vector1DType } from './Vector1d';
export type ScrollLooperType = {
    loop: (direction: number) => void;
};
export declare function ScrollLooper(contentSize: number, limit: LimitType, location: Vector1DType, vectors: Vector1DType[]): ScrollLooperType;

~~~

## node_modules\embla-carousel\components\ScrollProgress.d.ts

~~~ts
import { LimitType } from './Limit';
export type ScrollProgressType = {
    get: (n: number) => number;
};
export declare function ScrollProgress(limit: LimitType): ScrollProgressType;

~~~

## node_modules\embla-carousel\components\ScrollSnaps.d.ts

~~~ts
import { AlignmentType } from './Alignment';
import { AxisType } from './Axis';
import { NodeRectType } from './NodeRects';
import { SlidesToScrollType } from './SlidesToScroll';
export type ScrollSnapsType = {
    snaps: number[];
    snapsAligned: number[];
};
export declare function ScrollSnaps(axis: AxisType, alignment: AlignmentType, containerRect: NodeRectType, slideRects: NodeRectType[], slidesToScroll: SlidesToScrollType): ScrollSnapsType;

~~~

## node_modules\embla-carousel\components\ScrollTarget.d.ts

~~~ts
import { LimitType } from './Limit';
import { Vector1DType } from './Vector1d';
export type TargetType = {
    distance: number;
    index: number;
};
export type ScrollTargetType = {
    byIndex: (target: number, direction: number) => TargetType;
    byDistance: (force: number, snap: boolean) => TargetType;
    shortcut: (target: number, direction: number) => number;
};
export declare function ScrollTarget(loop: boolean, scrollSnaps: number[], contentSize: number, limit: LimitType, targetVector: Vector1DType): ScrollTargetType;

~~~

## node_modules\embla-carousel\components\ScrollTo.d.ts

~~~ts
import { AnimationsType } from './Animations';
import { CounterType } from './Counter';
import { EventHandlerType } from './EventHandler';
import { ScrollBodyType } from './ScrollBody';
import { ScrollTargetType } from './ScrollTarget';
import { Vector1DType } from './Vector1d';
export type ScrollToType = {
    distance: (n: number, snap: boolean) => void;
    index: (n: number, direction: number) => void;
};
export declare function ScrollTo(animation: AnimationsType, indexCurrent: CounterType, indexPrevious: CounterType, scrollBody: ScrollBodyType, scrollTarget: ScrollTargetType, targetVector: Vector1DType, eventHandler: EventHandlerType): ScrollToType;

~~~

## node_modules\embla-carousel\components\SlideFocus.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
import { EventHandlerType } from './EventHandler';
import { EventStoreType } from './EventStore';
import { ScrollBodyType } from './ScrollBody';
import { ScrollToType } from './ScrollTo';
import { SlideRegistryType } from './SlideRegistry';
type FocusHandlerCallbackType = (emblaApi: EmblaCarouselType, evt: FocusEvent) => boolean | void;
export type FocusHandlerOptionType = boolean | FocusHandlerCallbackType;
export type SlideFocusType = {
    init: (emblaApi: EmblaCarouselType) => void;
};
export declare function SlideFocus(root: HTMLElement, slides: HTMLElement[], slideRegistry: SlideRegistryType['slideRegistry'], scrollTo: ScrollToType, scrollBody: ScrollBodyType, eventStore: EventStoreType, eventHandler: EventHandlerType, watchFocus: FocusHandlerOptionType): SlideFocusType;
export {};

~~~

## node_modules\embla-carousel\components\SlideLooper.d.ts

~~~ts
import { AxisType } from './Axis';
import { Vector1DType } from './Vector1d';
import { TranslateType } from './Translate';
type LoopPointType = {
    loopPoint: number;
    index: number;
    translate: TranslateType;
    slideLocation: Vector1DType;
    target: () => number;
};
export type SlideLooperType = {
    canLoop: () => boolean;
    clear: () => void;
    loop: () => void;
    loopPoints: LoopPointType[];
};
export declare function SlideLooper(axis: AxisType, viewSize: number, contentSize: number, slideSizes: number[], slideSizesWithGaps: number[], snaps: number[], scrollSnaps: number[], location: Vector1DType, slides: HTMLElement[]): SlideLooperType;
export {};

~~~

## node_modules\embla-carousel\components\SlideRegistry.d.ts

~~~ts
import { LimitType } from './Limit';
import { ScrollContainOptionType } from './ScrollContain';
import { SlidesToScrollType } from './SlidesToScroll';
export type SlideRegistryType = {
    slideRegistry: number[][];
};
export declare function SlideRegistry(containSnaps: boolean, containScroll: ScrollContainOptionType, scrollSnaps: number[], scrollContainLimit: LimitType, slidesToScroll: SlidesToScrollType, slideIndexes: number[]): SlideRegistryType;

~~~

## node_modules\embla-carousel\components\SlidesHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel';
import { EventHandlerType } from './EventHandler';
type SlidesHandlerCallbackType = (emblaApi: EmblaCarouselType, mutations: MutationRecord[]) => boolean | void;
export type SlidesHandlerOptionType = boolean | SlidesHandlerCallbackType;
export type SlidesHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
};
export declare function SlidesHandler(container: HTMLElement, eventHandler: EventHandlerType, watchSlides: SlidesHandlerOptionType): SlidesHandlerType;
export {};

~~~

## node_modules\embla-carousel\components\SlidesInView.d.ts

~~~ts
import { EventHandlerType } from './EventHandler';
export type SlidesInViewOptionsType = IntersectionObserverInit['threshold'];
export type SlidesInViewType = {
    init: () => void;
    destroy: () => void;
    get: (inView?: boolean) => number[];
};
export declare function SlidesInView(container: HTMLElement, slides: HTMLElement[], eventHandler: EventHandlerType, threshold: SlidesInViewOptionsType): SlidesInViewType;

~~~

## node_modules\embla-carousel\components\SlideSizes.d.ts

~~~ts
import { AxisType } from './Axis';
import { NodeRectType } from './NodeRects';
import { WindowType } from './utils';
export type SlideSizesType = {
    slideSizes: number[];
    slideSizesWithGaps: number[];
    startGap: number;
    endGap: number;
};
export declare function SlideSizes(axis: AxisType, containerRect: NodeRectType, slideRects: NodeRectType[], slides: HTMLElement[], readEdgeGap: boolean, ownerWindow: WindowType): SlideSizesType;

~~~

## node_modules\embla-carousel\components\SlidesToScroll.d.ts

~~~ts
import { AxisType } from './Axis';
import { NodeRectType } from './NodeRects';
export type SlidesToScrollOptionType = 'auto' | number;
export type SlidesToScrollType = {
    groupSlides: <Type>(array: Type[]) => Type[][];
};
export declare function SlidesToScroll(axis: AxisType, viewSize: number, slidesToScroll: SlidesToScrollOptionType, loop: boolean, containerRect: NodeRectType, slideRects: NodeRectType[], startGap: number, endGap: number, pixelTolerance: number): SlidesToScrollType;

~~~

## node_modules\embla-carousel\components\Translate.d.ts

~~~ts
import { AxisType } from './Axis';
export type TranslateType = {
    clear: () => void;
    to: (target: number) => void;
    toggleActive: (active: boolean) => void;
};
export declare function Translate(axis: AxisType, container: HTMLElement): TranslateType;

~~~

## node_modules\embla-carousel\components\utils.d.ts

~~~ts
import { PointerEventType } from './DragTracker';
export type WindowType = Window & typeof globalThis;
export declare function isNumber(subject: unknown): subject is number;
export declare function isString(subject: unknown): subject is string;
export declare function isBoolean(subject: unknown): subject is boolean;
export declare function isObject(subject: unknown): subject is Record<string, unknown>;
export declare function mathAbs(n: number): number;
export declare function mathSign(n: number): number;
export declare function deltaAbs(valueB: number, valueA: number): number;
export declare function factorAbs(valueB: number, valueA: number): number;
export declare function roundToTwoDecimals(num: number): number;
export declare function arrayKeys<Type>(array: Type[]): number[];
export declare function arrayLast<Type>(array: Type[]): Type;
export declare function arrayLastIndex<Type>(array: Type[]): number;
export declare function arrayIsLastIndex<Type>(array: Type[], index: number): boolean;
export declare function arrayFromNumber(n: number, startAt?: number): number[];
export declare function objectKeys<Type extends object>(object: Type): string[];
export declare function objectsMergeDeep(objectA: Record<string, unknown>, objectB: Record<string, unknown>): Record<string, unknown>;
export declare function isMouseEvent(evt: PointerEventType, ownerWindow: WindowType): evt is MouseEvent;

~~~

## node_modules\embla-carousel\components\Vector1d.d.ts

~~~ts
export type Vector1DType = {
    get: () => number;
    set: (n: Vector1DType | number) => void;
    add: (n: Vector1DType | number) => void;
    subtract: (n: Vector1DType | number) => void;
};
export declare function Vector1D(initialValue: number): Vector1DType;

~~~

## node_modules\embla-carousel\embla-carousel.umd.js

~~~js
!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(n="undefined"!=typeof globalThis?globalThis:n||self).EmblaCarousel=t()}(this,(function(){"use strict";function n(n){return"number"==typeof n}function t(n){return"string"==typeof n}function e(n){return"boolean"==typeof n}function r(n){return"[object Object]"===Object.prototype.toString.call(n)}function o(n){return Math.abs(n)}function i(n){return Math.sign(n)}function c(n,t){return o(n-t)}function u(n){return f(n).map(Number)}function s(n){return n[a(n)]}function a(n){return Math.max(0,n.length-1)}function d(n,t){return t===a(n)}function l(n,t=0){return Array.from(Array(n),((n,e)=>t+e))}function f(n){return Object.keys(n)}function p(n,t){return[n,t].reduce(((n,t)=>(f(t).forEach((e=>{const o=n[e],i=t[e],c=r(o)&&r(i);n[e]=c?p(o,i):i})),n)),{})}function m(n,t){return void 0!==t.MouseEvent&&n instanceof t.MouseEvent}function g(){let n=[];const t={add:function(e,r,o,i={passive:!0}){let c;if("addEventListener"in e)e.addEventListener(r,o,i),c=()=>e.removeEventListener(r,o,i);else{const n=e;n.addListener(o),c=()=>n.removeListener(o)}return n.push(c),t},clear:function(){n=n.filter((n=>n()))}};return t}function h(n,t,e,r){const o=g(),i=1e3/60;let c=null,u=0,s=0;function a(n){if(!s)return;c||(c=n,e(),e());const o=n-c;for(c=n,u+=o;u>=i;)e(),u-=i;r(u/i),s&&(s=t.requestAnimationFrame(a))}function d(){t.cancelAnimationFrame(s),c=null,u=0,s=0}return{init:function(){o.add(n,"visibilitychange",(()=>{n.hidden&&(c=null,u=0)}))},destroy:function(){d(),o.clear()},start:function(){s||(s=t.requestAnimationFrame(a))},stop:d,update:e,render:r}}function x(n=0,t=0){const e=o(n-t);function r(t){return t<n}function i(n){return n>t}function c(n){return r(n)||i(n)}return{length:e,max:t,min:n,constrain:function(e){return c(e)?r(e)?n:t:e},reachedAny:c,reachedMax:i,reachedMin:r,removeOffset:function(n){return e?n-e*Math.ceil((n-t)/e):n}}}function y(n,t,e){const{constrain:r}=x(0,n),i=n+1;let c=u(t);function u(n){return e?o((i+n)%i):r(n)}function s(){return c}function a(){return y(n,s(),e)}const d={get:s,set:function(n){return c=u(n),d},add:function(n){return a().set(s()+n)},clone:a};return d}function v(n,t,r,u,s,a,d,l,f,p,h,y,v,b,S,w,E,L,D){const{cross:I,direction:M}=n,A=["INPUT","SELECT","TEXTAREA"],F={passive:!1},T=g(),O=g(),P=x(50,225).constrain(b.measure(20)),z={mouse:300,touch:400},H={mouse:500,touch:600},k=S?43:25;let V=!1,B=0,C=0,N=!1,R=!1,j=!1,G=!1;function q(n){if(!m(n,u)&&n.touches.length>=2)return U(n);const t=a.readPoint(n),e=a.readPoint(n,I),r=c(t,B),o=c(e,C);if(!R&&!G){if(!n.cancelable)return U(n);if(R=r>o,!R)return U(n)}const i=a.pointerMove(n);r>w&&(j=!0),p.useFriction(.3).useDuration(.75),l.start(),s.add(M(i)),n.preventDefault()}function U(n){const t=h.byDistance(0,!1).index!==y.get(),e=a.pointerUp(n)*(S?H:z)[G?"mouse":"touch"],r=function(n,t){const e=y.add(-1*i(n)),r=h.byDistance(n,!S).distance;return S||o(n)<P?r:E&&t?.5*r:h.byIndex(e.get(),0).distance}(M(e),t),u=function(n,t){if(0===n||0===t)return 0;if(o(n)<=o(t))return 0;const e=c(o(n),o(t));return o(e/n)}(e,r),s=k-10*u,d=L+u/50;R=!1,N=!1,O.clear(),p.useDuration(s).useFriction(d),f.distance(r,!S),G=!1,v.emit("pointerUp")}function W(n){j&&(n.stopPropagation(),n.preventDefault(),j=!1)}return{init:function(n){if(!D)return;function o(o){(e(D)||D(n,o))&&function(n){const e=m(n,u);if(G=e,j=S&&e&&!n.buttons&&V,V=c(s.get(),d.get())>=2,e&&0!==n.button)return;if(function(n){const t=n.nodeName||"";return A.includes(t)}(n.target))return;N=!0,a.pointerDown(n),p.useFriction(0).useDuration(0),s.set(d),function(){const n=G?r:t;O.add(n,"touchmove",q,F).add(n,"touchend",U).add(n,"mousemove",q,F).add(n,"mouseup",U)}(),B=a.readPoint(n),C=a.readPoint(n,I),v.emit("pointerDown")}(o)}const i=t;T.add(i,"dragstart",(n=>n.preventDefault()),F).add(i,"touchmove",(()=>{}),F).add(i,"touchend",(()=>{})).add(i,"touchstart",o).add(i,"mousedown",o).add(i,"touchcancel",U).add(i,"contextmenu",U).add(i,"click",W,!0)},destroy:function(){T.clear(),O.clear()},pointerDown:function(){return N}}}function b(n,t){let e,r;function i(n){return n.timeStamp}function c(e,r){const o="client"+("x"===(r||n.scroll)?"X":"Y");return(m(e,t)?e:e.touches[0])[o]}return{pointerDown:function(n){return e=n,r=n,c(n)},pointerMove:function(n){const t=c(n)-c(r),o=i(n)-i(e)>170;return r=n,o&&(e=n),t},pointerUp:function(n){if(!e||!r)return 0;const t=c(r)-c(e),u=i(n)-i(e),s=i(n)-i(r)>170,a=t/u;return u&&!s&&o(a)>.1?a:0},readPoint:c}}function S(n,t,r,i,c,u,s){const a=[n].concat(i);let d,l,f=[],p=!1;function m(n){return c.measureSize(s.measure(n))}return{init:function(c){u&&(l=m(n),f=i.map(m),d=new ResizeObserver((r=>{(e(u)||u(c,r))&&function(e){for(const r of e){if(p)return;const e=r.target===n,u=i.indexOf(r.target),s=e?l:f[u];if(o(m(e?n:i[u])-s)>=.5){c.reInit(),t.emit("resize");break}}}(r)})),r.requestAnimationFrame((()=>{a.forEach((n=>d.observe(n)))})))},destroy:function(){p=!0,d&&d.disconnect()}}}function w(n,t,e,r,i){const c=i.measure(10),u=i.measure(50),s=x(.1,.99);let a=!1;function d(){return!a&&(!!n.reachedAny(e.get())&&!!n.reachedAny(t.get()))}return{shouldConstrain:d,constrain:function(i){if(!d())return;const a=n.reachedMin(t.get())?"min":"max",l=o(n[a]-t.get()),f=e.get()-t.get(),p=s.constrain(l/u);e.subtract(f*p),!i&&o(f)<c&&(e.set(n.constrain(e.get())),r.useDuration(25).useBaseFriction())},toggleActive:function(n){a=!n}}}function E(n,t,e,r){const o=t.min+.1,i=t.max+.1,{reachedMin:c,reachedMax:u}=x(o,i);return{loop:function(t){if(!function(n){return 1===n?u(e.get()):-1===n&&c(e.get())}(t))return;const o=n*(-1*t);r.forEach((n=>n.add(o)))}}}function L(n,t,e,r,c){const{reachedAny:u,removeOffset:a,constrain:d}=r;function l(n){return n.concat().sort(((n,t)=>o(n)-o(t)))[0]}function f(t,r){const o=[t,t+e,t-e];if(!n)return t;if(!r)return l(o);const c=o.filter((n=>i(n)===r));return c.length?l(c):s(o)-e}return{byDistance:function(e,r){const i=c.get()+e,{index:s,distance:l}=function(e){const r=n?a(e):d(e),i=t.map(((n,t)=>({diff:f(n-r,0),index:t}))).sort(((n,t)=>o(n.diff)-o(t.diff))),{index:c}=i[0];return{index:c,distance:r}}(i),p=!n&&u(i);return!r||p?{index:s,distance:e}:{index:s,distance:e+f(t[s]-l,0)}},byIndex:function(n,e){return{index:n,distance:f(t[n]-c.get(),e)}},shortcut:f}}function D(t,r,o,i,c,u,s,a){const d={passive:!0,capture:!0};let l=0;function f(n){"Tab"===n.code&&(l=(new Date).getTime())}return{init:function(p){a&&(u.add(document,"keydown",f,!1),r.forEach(((r,f)=>{u.add(r,"focus",(r=>{(e(a)||a(p,r))&&function(e){if((new Date).getTime()-l>10)return;s.emit("slideFocusStart"),t.scrollLeft=0;const r=o.findIndex((n=>n.includes(e)));n(r)&&(c.useDuration(0),i.index(r,0),s.emit("slideFocus"))}(f)}),d)})))}}}function I(t){let e=t;function r(t){return n(t)?t:t.get()}return{get:function(){return e},set:function(n){e=r(n)},add:function(n){e+=r(n)},subtract:function(n){e-=r(n)}}}function M(n,t){const e="x"===n.scroll?function(n){return`translate3d(${n}px,0px,0px)`}:function(n){return`translate3d(0px,${n}px,0px)`},r=t.style;let o=null,i=!1;return{clear:function(){i||(r.transform="",t.getAttribute("style")||t.removeAttribute("style"))},to:function(t){if(i)return;const c=(u=n.direction(t),Math.round(100*u)/100);var u;c!==o&&(r.transform=e(c),o=c)},toggleActive:function(n){i=!n}}}function A(n,t,e,r,o,i,c,s,a){const d=.5,l=u(o),f=u(o).reverse(),p=function(){const n=c[0];return h(g(f,n),e,!1)}().concat(function(){const n=t-c[0]-1;return h(g(l,n),-e,!0)}());function m(n,t){return n.reduce(((n,t)=>n-o[t]),t)}function g(n,t){return n.reduce(((n,e)=>m(n,t)>0?n.concat([e]):n),[])}function h(o,c,u){const l=function(n){return i.map(((e,o)=>({start:e-r[o]+d+n,end:e+t-d+n})))}(c);return o.map((t=>{const r=u?0:-e,o=u?e:0,i=u?"end":"start",c=l[t][i];return{index:t,loopPoint:c,slideLocation:I(-1),translate:M(n,a[t]),target:()=>s.get()>c?r:o}}))}return{canLoop:function(){return p.every((({index:n})=>m(l.filter((t=>t!==n)),t)<=.1))},clear:function(){p.forEach((n=>n.translate.clear()))},loop:function(){p.forEach((n=>{const{target:t,translate:e,slideLocation:r}=n,o=t();o!==r.get()&&(e.to(o),r.set(o))}))},loopPoints:p}}function F(n,t,r){let o,i=!1;return{init:function(c){r&&(o=new MutationObserver((n=>{i||(e(r)||r(c,n))&&function(n){for(const e of n)if("childList"===e.type){c.reInit(),t.emit("slidesChanged");break}}(n)})),o.observe(n,{childList:!0}))},destroy:function(){o&&o.disconnect(),i=!0}}}function T(n,t,e,r){const o={};let i,c=null,u=null,s=!1;return{init:function(){i=new IntersectionObserver((n=>{s||(n.forEach((n=>{const e=t.indexOf(n.target);o[e]=n})),c=null,u=null,e.emit("slidesInView"))}),{root:n.parentElement,threshold:r}),t.forEach((n=>i.observe(n)))},destroy:function(){i&&i.disconnect(),s=!0},get:function(n=!0){if(n&&c)return c;if(!n&&u)return u;const t=function(n){return f(o).reduce(((t,e)=>{const r=parseInt(e),{isIntersecting:i}=o[r];return(n&&i||!n&&!i)&&t.push(r),t}),[])}(n);return n&&(c=t),n||(u=t),t}}}function O(t,e,r,i,c,d,l,f,p){const{startEdge:m,endEdge:g,direction:h}=t,x=n(r);return{groupSlides:function(n){return x?function(n,t){return u(n).filter((n=>n%t==0)).map((e=>n.slice(e,e+t)))}(n,r):function(n){return n.length?u(n).reduce(((t,r,u)=>{const x=s(t)||0,y=0===x,v=r===a(n),b=c[m]-d[x][m],S=c[m]-d[r][g],w=!i&&y?h(l):0,E=o(S-(!i&&v?h(f):0)-(b+w));return u&&E>e+p&&t.push(r),v&&t.push(n.length),t}),[]).map(((t,e,r)=>{const o=Math.max(r[e-1]||0);return n.slice(o,t)})):[]}(n)}}}function P(n,e,r,f,p,m,P){const{align:z,axis:H,direction:k,startIndex:V,loop:B,duration:C,dragFree:N,dragThreshold:R,inViewThreshold:j,slidesToScroll:G,skipSnaps:q,containScroll:U,watchResize:W,watchSlides:$,watchDrag:Q,watchFocus:X}=m,Y={measure:function(n){const{offsetTop:t,offsetLeft:e,offsetWidth:r,offsetHeight:o}=n;return{top:t,right:e+r,bottom:t+o,left:e,width:r,height:o}}},J=Y.measure(e),K=r.map(Y.measure),Z=function(n,t){const e="rtl"===t,r="y"===n,o=!r&&e?-1:1;return{scroll:r?"y":"x",cross:r?"x":"y",startEdge:r?"top":e?"right":"left",endEdge:r?"bottom":e?"left":"right",measureSize:function(n){const{height:t,width:e}=n;return r?t:e},direction:function(n){return n*o}}}(H,k),_=Z.measureSize(J),nn=function(n){return{measure:function(t){return n*(t/100)}}}(_),tn=function(n,e){const r={start:function(){return 0},center:function(n){return o(n)/2},end:o};function o(n){return e-n}return{measure:function(o,i){return t(n)?r[n](o):n(e,o,i)}}}(z,_),en=!B&&!!U,rn=B||!!U,{slideSizes:on,slideSizesWithGaps:cn,startGap:un,endGap:sn}=function(n,t,e,r,i,c){const{measureSize:u,startEdge:a,endEdge:l}=n,f=e[0]&&i,p=function(){if(!f)return 0;const n=e[0];return o(t[a]-n[a])}(),m=function(){if(!f)return 0;const n=c.getComputedStyle(s(r));return parseFloat(n.getPropertyValue(`margin-${l}`))}(),g=e.map(u),h=e.map(((n,t,e)=>{const r=!t,o=d(e,t);return r?g[t]+p:o?g[t]+m:e[t+1][a]-n[a]})).map(o);return{slideSizes:g,slideSizesWithGaps:h,startGap:p,endGap:m}}(Z,J,K,r,rn,p),an=O(Z,_,G,B,J,K,un,sn,2),{snaps:dn,snapsAligned:ln}=function(n,t,e,r,i){const{startEdge:c,endEdge:u}=n,{groupSlides:a}=i,d=a(r).map((n=>s(n)[u]-n[0][c])).map(o).map(t.measure),l=r.map((n=>e[c]-n[c])).map((n=>-o(n))),f=a(l).map((n=>n[0])).map(((n,t)=>n+d[t]));return{snaps:l,snapsAligned:f}}(Z,tn,J,K,an),fn=-s(dn)+s(cn),{snapsContained:pn,scrollContainLimit:mn}=function(n,t,e,r,o){const i=x(-t+n,0),u=e.map(((n,t)=>{const{min:r,max:o}=i,c=i.constrain(n),u=!t,s=d(e,t);return u?o:s||l(r,c)?r:l(o,c)?o:c})).map((n=>parseFloat(n.toFixed(3)))),a=function(){const n=u[0],t=s(u);return x(u.lastIndexOf(n),u.indexOf(t)+1)}();function l(n,t){return c(n,t)<=1}return{snapsContained:function(){if(t<=n+o)return[i.max];if("keepSnaps"===r)return u;const{min:e,max:c}=a;return u.slice(e,c)}(),scrollContainLimit:a}}(_,fn,ln,U,2),gn=en?pn:ln,{limit:hn}=function(n,t,e){const r=t[0];return{limit:x(e?r-n:s(t),r)}}(fn,gn,B),xn=y(a(gn),V,B),yn=xn.clone(),vn=u(r),bn=h(f,p,(()=>(({dragHandler:n,scrollBody:t,scrollBounds:e,options:{loop:r}})=>{r||e.constrain(n.pointerDown()),t.seek()})(Hn)),(n=>(({scrollBody:n,translate:t,location:e,offsetLocation:r,previousLocation:o,scrollLooper:i,slideLooper:c,dragHandler:u,animation:s,eventHandler:a,scrollBounds:d,options:{loop:l}},f)=>{const p=n.settled(),m=!d.shouldConstrain(),g=l?p:p&&m,h=g&&!u.pointerDown();h&&s.stop();const x=e.get()*f+o.get()*(1-f);r.set(x),l&&(i.loop(n.direction()),c.loop()),t.to(r.get()),h&&a.emit("settle"),g||a.emit("scroll")})(Hn,n))),Sn=gn[xn.get()],wn=I(Sn),En=I(Sn),Ln=I(Sn),Dn=I(Sn),In=function(n,t,e,r,c,u){let s=0,a=0,d=c,l=u,f=n.get(),p=0;function m(n){return d=n,h}function g(n){return l=n,h}const h={direction:function(){return a},duration:function(){return d},velocity:function(){return s},seek:function(){const t=r.get()-n.get();let o=0;return d?(e.set(n),s+=t/d,s*=l,f+=s,n.add(s),o=f-p):(s=0,e.set(r),n.set(r),o=t),a=i(o),p=f,h},settled:function(){return o(r.get()-t.get())<.001},useBaseFriction:function(){return g(u)},useBaseDuration:function(){return m(c)},useFriction:g,useDuration:m};return h}(wn,Ln,En,Dn,C,.68),Mn=L(B,gn,fn,hn,Dn),An=function(n,t,e,r,o,i,c){function u(o){const u=o.distance,s=o.index!==t.get();i.add(u),u&&(r.duration()?n.start():(n.update(),n.render(1),n.update())),s&&(e.set(t.get()),t.set(o.index),c.emit("select"))}return{distance:function(n,t){u(o.byDistance(n,t))},index:function(n,e){const r=t.clone().set(n);u(o.byIndex(r.get(),e))}}}(bn,xn,yn,In,Mn,Dn,P),Fn=function(n){const{max:t,length:e}=n;return{get:function(n){return e?(n-t)/-e:0}}}(hn),Tn=g(),On=T(e,r,P,j),{slideRegistry:Pn}=function(n,t,e,r,o,i){const{groupSlides:c}=o,{min:u,max:f}=r;return{slideRegistry:function(){const r=c(i),o=!n||"keepSnaps"===t;return 1===e.length?[i]:o?r:r.slice(u,f).map(((n,t,e)=>{const r=!t,o=d(e,t);return r?l(s(e[0])+1):o?l(a(i)-s(e)[0]+1,s(e)[0]):n}))}()}}(en,U,gn,mn,an,vn),zn=D(n,r,Pn,An,In,Tn,P,X),Hn={ownerDocument:f,ownerWindow:p,eventHandler:P,containerRect:J,slideRects:K,animation:bn,axis:Z,dragHandler:v(Z,n,f,p,Dn,b(Z,p),wn,bn,An,In,Mn,xn,P,nn,N,R,q,.68,Q),eventStore:Tn,percentOfView:nn,index:xn,indexPrevious:yn,limit:hn,location:wn,offsetLocation:Ln,previousLocation:En,options:m,resizeHandler:S(e,P,p,r,Z,W,Y),scrollBody:In,scrollBounds:w(hn,Ln,Dn,In,nn),scrollLooper:E(fn,hn,Ln,[wn,Ln,En,Dn]),scrollProgress:Fn,scrollSnapList:gn.map(Fn.get),scrollSnaps:gn,scrollTarget:Mn,scrollTo:An,slideLooper:A(Z,_,fn,on,cn,dn,gn,Ln,r),slideFocus:zn,slidesHandler:F(e,P,$),slidesInView:On,slideIndexes:vn,slideRegistry:Pn,slidesToScroll:an,target:Dn,translate:M(Z,e)};return Hn}const z={align:"center",axis:"x",container:null,slides:null,containScroll:"trimSnaps",direction:"ltr",slidesToScroll:1,inViewThreshold:0,breakpoints:{},dragFree:!1,dragThreshold:10,loop:!1,skipSnaps:!1,duration:25,startIndex:0,active:!0,watchDrag:!0,watchResize:!0,watchSlides:!0,watchFocus:!0};function H(n){function t(n,t){return p(n,t||{})}const e={mergeOptions:t,optionsAtMedia:function(e){const r=e.breakpoints||{},o=f(r).filter((t=>n.matchMedia(t).matches)).map((n=>r[n])).reduce(((n,e)=>t(n,e)),{});return t(e,o)},optionsMediaQueries:function(t){return t.map((n=>f(n.breakpoints||{}))).reduce(((n,t)=>n.concat(t)),[]).map(n.matchMedia)}};return e}function k(n,e,r){const o=n.ownerDocument,i=o.defaultView,c=H(i),u=function(n){let t=[];return{init:function(e,r){return t=r.filter((({options:t})=>!1!==n.optionsAtMedia(t).active)),t.forEach((t=>t.init(e,n))),r.reduce(((n,t)=>Object.assign(n,{[t.name]:t})),{})},destroy:function(){t=t.filter((n=>n.destroy()))}}}(c),s=g(),a=function(){let n,t={};function e(n){return t[n]||[]}const r={init:function(t){n=t},emit:function(t){return e(t).forEach((e=>e(n,t))),r},off:function(n,o){return t[n]=e(n).filter((n=>n!==o)),r},on:function(n,o){return t[n]=e(n).concat([o]),r},clear:function(){t={}}};return r}(),{mergeOptions:d,optionsAtMedia:l,optionsMediaQueries:f}=c,{on:p,off:m,emit:h}=a,x=A;let y,v,b,S,w=!1,E=d(z,k.globalOptions),L=d(E),D=[];function I(t){const e=P(n,b,S,o,i,t,a);if(t.loop&&!e.slideLooper.canLoop()){return I(Object.assign({},t,{loop:!1}))}return e}function M(e,r){w||(E=d(E,e),L=l(E),D=r||D,function(){const{container:e,slides:r}=L,o=t(e)?n.querySelector(e):e;b=o||n.children[0];const i=t(r)?b.querySelectorAll(r):r;S=[].slice.call(i||b.children)}(),y=I(L),f([E,...D.map((({options:n})=>n))]).forEach((n=>s.add(n,"change",A))),L.active&&(y.translate.to(y.location.get()),y.animation.init(),y.slidesInView.init(),y.slideFocus.init(V),y.eventHandler.init(V),y.resizeHandler.init(V),y.slidesHandler.init(V),y.options.loop&&y.slideLooper.loop(),b.offsetParent&&S.length&&y.dragHandler.init(V),v=u.init(V,D)))}function A(n,t){const e=O();F(),M(d({startIndex:e},n),t),a.emit("reInit")}function F(){y.dragHandler.destroy(),y.eventStore.clear(),y.translate.clear(),y.slideLooper.clear(),y.resizeHandler.destroy(),y.slidesHandler.destroy(),y.slidesInView.destroy(),y.animation.destroy(),u.destroy(),s.clear()}function T(n,t,e){L.active&&!w&&(y.scrollBody.useBaseFriction().useDuration(!0===t?0:L.duration),y.scrollTo.index(n,e||0))}function O(){return y.index.get()}const V={canScrollNext:function(){return y.index.add(1).get()!==O()},canScrollPrev:function(){return y.index.add(-1).get()!==O()},containerNode:function(){return b},internalEngine:function(){return y},destroy:function(){w||(w=!0,s.clear(),F(),a.emit("destroy"),a.clear())},off:m,on:p,emit:h,plugins:function(){return v},previousScrollSnap:function(){return y.indexPrevious.get()},reInit:x,rootNode:function(){return n},scrollNext:function(n){T(y.index.add(1).get(),n,-1)},scrollPrev:function(n){T(y.index.add(-1).get(),n,1)},scrollProgress:function(){return y.scrollProgress.get(y.offsetLocation.get())},scrollSnapList:function(){return y.scrollSnapList},scrollTo:T,selectedScrollSnap:O,slideNodes:function(){return S},slidesInView:function(){return y.slidesInView.get()},slidesNotInView:function(){return y.slidesInView.get(!1)}};return M(e,r),setTimeout((()=>a.emit("init")),0),V}return k.globalOptions=void 0,k}));

~~~

## node_modules\embla-carousel\esm\components\Alignment.d.ts

~~~ts
export type AlignmentOptionType = 'start' | 'center' | 'end' | ((viewSize: number, snapSize: number, index: number) => number);
export type AlignmentType = {
    measure: (n: number, index: number) => number;
};
export declare function Alignment(align: AlignmentOptionType, viewSize: number): AlignmentType;

~~~

## node_modules\embla-carousel\esm\components\Animations.d.ts

~~~ts
import { EngineType } from './Engine.js';
import { WindowType } from './utils.js';
export type AnimationsUpdateType = (engine: EngineType) => void;
export type AnimationsRenderType = (engine: EngineType, alpha: number) => void;
export type AnimationsType = {
    init: () => void;
    destroy: () => void;
    start: () => void;
    stop: () => void;
    update: () => void;
    render: (alpha: number) => void;
};
export declare function Animations(ownerDocument: Document, ownerWindow: WindowType, update: () => void, render: (alpha: number) => void): AnimationsType;

~~~

## node_modules\embla-carousel\esm\components\Axis.d.ts

~~~ts
import { NodeRectType } from './NodeRects.js';
export type AxisOptionType = 'x' | 'y';
export type AxisDirectionOptionType = 'ltr' | 'rtl';
type AxisEdgeType = 'top' | 'right' | 'bottom' | 'left';
export type AxisType = {
    scroll: AxisOptionType;
    cross: AxisOptionType;
    startEdge: AxisEdgeType;
    endEdge: AxisEdgeType;
    measureSize: (nodeRect: NodeRectType) => number;
    direction: (n: number) => number;
};
export declare function Axis(axis: AxisOptionType, contentDirection: AxisDirectionOptionType): AxisType;
export {};

~~~

## node_modules\embla-carousel\esm\components\Counter.d.ts

~~~ts
export type CounterType = {
    get: () => number;
    set: (n: number) => CounterType;
    add: (n: number) => CounterType;
    clone: () => CounterType;
};
export declare function Counter(max: number, start: number, loop: boolean): CounterType;

~~~

## node_modules\embla-carousel\esm\components\DragHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel.js';
import { AnimationsType } from './Animations.js';
import { CounterType } from './Counter.js';
import { DragTrackerType, PointerEventType } from './DragTracker.js';
import { EventHandlerType } from './EventHandler.js';
import { AxisType } from './Axis.js';
import { ScrollBodyType } from './ScrollBody.js';
import { ScrollTargetType } from './ScrollTarget.js';
import { ScrollToType } from './ScrollTo.js';
import { Vector1DType } from './Vector1d.js';
import { PercentOfViewType } from './PercentOfView.js';
import { WindowType } from './utils.js';
type DragHandlerCallbackType = (emblaApi: EmblaCarouselType, evt: PointerEventType) => boolean | void;
export type DragHandlerOptionType = boolean | DragHandlerCallbackType;
export type DragHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
    pointerDown: () => boolean;
};
export declare function DragHandler(axis: AxisType, rootNode: HTMLElement, ownerDocument: Document, ownerWindow: WindowType, target: Vector1DType, dragTracker: DragTrackerType, location: Vector1DType, animation: AnimationsType, scrollTo: ScrollToType, scrollBody: ScrollBodyType, scrollTarget: ScrollTargetType, index: CounterType, eventHandler: EventHandlerType, percentOfView: PercentOfViewType, dragFree: boolean, dragThreshold: number, skipSnaps: boolean, baseFriction: number, watchDrag: DragHandlerOptionType): DragHandlerType;
export {};

~~~

## node_modules\embla-carousel\esm\components\DragTracker.d.ts

~~~ts
import { AxisOptionType, AxisType } from './Axis.js';
import { WindowType } from './utils.js';
export type PointerEventType = TouchEvent | MouseEvent;
export type DragTrackerType = {
    pointerDown: (evt: PointerEventType) => number;
    pointerMove: (evt: PointerEventType) => number;
    pointerUp: (evt: PointerEventType) => number;
    readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number;
};
export declare function DragTracker(axis: AxisType, ownerWindow: WindowType): DragTrackerType;

~~~

## node_modules\embla-carousel\esm\components\EmblaCarousel.d.ts

~~~ts
import { EngineType } from './Engine.js';
import { EventHandlerType } from './EventHandler.js';
import { EmblaOptionsType } from './Options.js';
import { EmblaPluginsType, EmblaPluginType } from './Plugins.js';
export type EmblaCarouselType = {
    canScrollNext: () => boolean;
    canScrollPrev: () => boolean;
    containerNode: () => HTMLElement;
    internalEngine: () => EngineType;
    destroy: () => void;
    off: EventHandlerType['off'];
    on: EventHandlerType['on'];
    emit: EventHandlerType['emit'];
    plugins: () => EmblaPluginsType;
    previousScrollSnap: () => number;
    reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void;
    rootNode: () => HTMLElement;
    scrollNext: (jump?: boolean) => void;
    scrollPrev: (jump?: boolean) => void;
    scrollProgress: () => number;
    scrollSnapList: () => number[];
    scrollTo: (index: number, jump?: boolean) => void;
    selectedScrollSnap: () => number;
    slideNodes: () => HTMLElement[];
    slidesInView: () => number[];
    slidesNotInView: () => number[];
};
declare function EmblaCarousel(root: HTMLElement, userOptions?: EmblaOptionsType, userPlugins?: EmblaPluginType[]): EmblaCarouselType;
declare namespace EmblaCarousel {
    let globalOptions: EmblaOptionsType | undefined;
}
export default EmblaCarousel;

~~~

## node_modules\embla-carousel\esm\components\Engine.d.ts

~~~ts
import { AnimationsType } from './Animations.js';
import { AxisType } from './Axis.js';
import { CounterType } from './Counter.js';
import { DragHandlerType } from './DragHandler.js';
import { EventHandlerType } from './EventHandler.js';
import { EventStoreType } from './EventStore.js';
import { LimitType } from './Limit.js';
import { NodeRectType } from './NodeRects.js';
import { OptionsType } from './Options.js';
import { PercentOfViewType } from './PercentOfView.js';
import { ResizeHandlerType } from './ResizeHandler.js';
import { ScrollBodyType } from './ScrollBody.js';
import { ScrollBoundsType } from './ScrollBounds.js';
import { ScrollLooperType } from './ScrollLooper.js';
import { ScrollProgressType } from './ScrollProgress.js';
import { SlideRegistryType } from './SlideRegistry.js';
import { ScrollTargetType } from './ScrollTarget.js';
import { ScrollToType } from './ScrollTo.js';
import { SlideFocusType } from './SlideFocus.js';
import { SlideLooperType } from './SlideLooper.js';
import { SlidesHandlerType } from './SlidesHandler.js';
import { SlidesInViewType } from './SlidesInView.js';
import { SlidesToScrollType } from './SlidesToScroll.js';
import { TranslateType } from './Translate.js';
import { WindowType } from './utils.js';
import { Vector1DType } from './Vector1d.js';
export type EngineType = {
    ownerDocument: Document;
    ownerWindow: WindowType;
    eventHandler: EventHandlerType;
    axis: AxisType;
    animation: AnimationsType;
    scrollBounds: ScrollBoundsType;
    scrollLooper: ScrollLooperType;
    scrollProgress: ScrollProgressType;
    index: CounterType;
    indexPrevious: CounterType;
    limit: LimitType;
    location: Vector1DType;
    offsetLocation: Vector1DType;
    previousLocation: Vector1DType;
    options: OptionsType;
    percentOfView: PercentOfViewType;
    scrollBody: ScrollBodyType;
    dragHandler: DragHandlerType;
    eventStore: EventStoreType;
    slideLooper: SlideLooperType;
    slidesInView: SlidesInViewType;
    slidesToScroll: SlidesToScrollType;
    target: Vector1DType;
    translate: TranslateType;
    resizeHandler: ResizeHandlerType;
    slidesHandler: SlidesHandlerType;
    scrollTo: ScrollToType;
    scrollTarget: ScrollTargetType;
    scrollSnapList: number[];
    scrollSnaps: number[];
    slideIndexes: number[];
    slideFocus: SlideFocusType;
    slideRegistry: SlideRegistryType['slideRegistry'];
    containerRect: NodeRectType;
    slideRects: NodeRectType[];
};
export declare function Engine(root: HTMLElement, container: HTMLElement, slides: HTMLElement[], ownerDocument: Document, ownerWindow: WindowType, options: OptionsType, eventHandler: EventHandlerType): EngineType;

~~~

## node_modules\embla-carousel\esm\components\EventHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel.js';
type CallbackType = (emblaApi: EmblaCarouselType, evt: EmblaEventType) => void;
export type EmblaEventType = EmblaEventListType[keyof EmblaEventListType];
export interface EmblaEventListType {
    init: 'init';
    pointerDown: 'pointerDown';
    pointerUp: 'pointerUp';
    slidesChanged: 'slidesChanged';
    slidesInView: 'slidesInView';
    scroll: 'scroll';
    select: 'select';
    settle: 'settle';
    destroy: 'destroy';
    reInit: 'reInit';
    resize: 'resize';
    slideFocusStart: 'slideFocusStart';
    slideFocus: 'slideFocus';
}
export type EventHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    emit: (evt: EmblaEventType) => EventHandlerType;
    on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType;
    off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType;
    clear: () => void;
};
export declare function EventHandler(): EventHandlerType;
export {};

~~~

## node_modules\embla-carousel\esm\components\EventStore.d.ts

~~~ts
type EventNameType = keyof DocumentEventMap | keyof WindowEventMap;
type EventHandlerType = (evt: any) => void;
type EventOptionsType = boolean | AddEventListenerOptions | undefined;
export type EventStoreType = {
    add: (node: EventTarget, type: EventNameType, handler: EventHandlerType, options?: EventOptionsType) => EventStoreType;
    clear: () => void;
};
export declare function EventStore(): EventStoreType;
export {};

~~~

## node_modules\embla-carousel\esm\components\Limit.d.ts

~~~ts
export type LimitType = {
    min: number;
    max: number;
    length: number;
    constrain: (n: number) => number;
    reachedAny: (n: number) => boolean;
    reachedMax: (n: number) => boolean;
    reachedMin: (n: number) => boolean;
    removeOffset: (n: number) => number;
};
export declare function Limit(min?: number, max?: number): LimitType;

~~~

## node_modules\embla-carousel\esm\components\NodeRects.d.ts

~~~ts
export type NodeRectType = {
    top: number;
    right: number;
    bottom: number;
    left: number;
    width: number;
    height: number;
};
export type NodeRectsType = {
    measure: (node: HTMLElement) => NodeRectType;
};
export declare function NodeRects(): NodeRectsType;

~~~

## node_modules\embla-carousel\esm\components\Options.d.ts

~~~ts
import { AlignmentOptionType } from './Alignment.js';
import { AxisDirectionOptionType, AxisOptionType } from './Axis.js';
import { SlidesToScrollOptionType } from './SlidesToScroll.js';
import { ScrollContainOptionType } from './ScrollContain.js';
import { DragHandlerOptionType } from './DragHandler.js';
import { ResizeHandlerOptionType } from './ResizeHandler.js';
import { SlidesHandlerOptionType } from './SlidesHandler.js';
import { SlidesInViewOptionsType } from './SlidesInView.js';
import { FocusHandlerOptionType } from './SlideFocus.js';
export type LooseOptionsType = {
    [key: string]: unknown;
};
export type CreateOptionsType<Type extends LooseOptionsType> = Type & {
    active: boolean;
    breakpoints: {
        [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>;
    };
};
export type OptionsType = CreateOptionsType<{
    align: AlignmentOptionType;
    axis: AxisOptionType;
    container: string | HTMLElement | null;
    slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null;
    containScroll: ScrollContainOptionType;
    direction: AxisDirectionOptionType;
    slidesToScroll: SlidesToScrollOptionType;
    dragFree: boolean;
    dragThreshold: number;
    inViewThreshold: SlidesInViewOptionsType;
    loop: boolean;
    skipSnaps: boolean;
    duration: number;
    startIndex: number;
    watchDrag: DragHandlerOptionType;
    watchResize: ResizeHandlerOptionType;
    watchSlides: SlidesHandlerOptionType;
    watchFocus: FocusHandlerOptionType;
}>;
export declare const defaultOptions: OptionsType;
export type EmblaOptionsType = Partial<OptionsType>;

~~~

## node_modules\embla-carousel\esm\components\OptionsHandler.d.ts

~~~ts
import { LooseOptionsType, CreateOptionsType } from './Options.js';
import { WindowType } from './utils.js';
type OptionsType = Partial<CreateOptionsType<LooseOptionsType>>;
export type OptionsHandlerType = {
    mergeOptions: <TypeA extends OptionsType, TypeB extends OptionsType>(optionsA: TypeA, optionsB?: TypeB) => TypeA;
    optionsAtMedia: <Type extends OptionsType>(options: Type) => Type;
    optionsMediaQueries: (optionsList: OptionsType[]) => MediaQueryList[];
};
export declare function OptionsHandler(ownerWindow: WindowType): OptionsHandlerType;
export {};

~~~

## node_modules\embla-carousel\esm\components\PercentOfView.d.ts

~~~ts
export type PercentOfViewType = {
    measure: (n: number) => number;
};
export declare function PercentOfView(viewSize: number): PercentOfViewType;

~~~

## node_modules\embla-carousel\esm\components\Plugins.d.ts

~~~ts
import { CreateOptionsType, LooseOptionsType } from './Options.js';
import { EmblaCarouselType } from './EmblaCarousel.js';
import { OptionsHandlerType } from './OptionsHandler.js';
export type LoosePluginType = {
    [key: string]: unknown;
};
export type CreatePluginType<TypeA extends LoosePluginType, TypeB extends LooseOptionsType> = TypeA & {
    name: string;
    options: Partial<CreateOptionsType<TypeB>>;
    init: (embla: EmblaCarouselType, OptionsHandler: OptionsHandlerType) => void;
    destroy: () => void;
};
export interface EmblaPluginsType {
    [key: string]: CreatePluginType<LoosePluginType, {}>;
}
export type EmblaPluginType = EmblaPluginsType[keyof EmblaPluginsType];

~~~

## node_modules\embla-carousel\esm\components\PluginsHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel.js';
import { OptionsHandlerType } from './OptionsHandler.js';
import { EmblaPluginsType, EmblaPluginType } from './Plugins.js';
export type PluginsHandlerType = {
    init: (emblaApi: EmblaCarouselType, plugins: EmblaPluginType[]) => EmblaPluginsType;
    destroy: () => void;
};
export declare function PluginsHandler(optionsHandler: OptionsHandlerType): PluginsHandlerType;

~~~

## node_modules\embla-carousel\esm\components\ResizeHandler.d.ts

~~~ts
import { AxisType } from './Axis.js';
import { EmblaCarouselType } from './EmblaCarousel.js';
import { EventHandlerType } from './EventHandler.js';
import { NodeRectsType } from './NodeRects.js';
import { WindowType } from './utils.js';
type ResizeHandlerCallbackType = (emblaApi: EmblaCarouselType, entries: ResizeObserverEntry[]) => boolean | void;
export type ResizeHandlerOptionType = boolean | ResizeHandlerCallbackType;
export type ResizeHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
};
export declare function ResizeHandler(container: HTMLElement, eventHandler: EventHandlerType, ownerWindow: WindowType, slides: HTMLElement[], axis: AxisType, watchResize: ResizeHandlerOptionType, nodeRects: NodeRectsType): ResizeHandlerType;
export {};

~~~

## node_modules\embla-carousel\esm\components\ScrollBody.d.ts

~~~ts
import { Vector1DType } from './Vector1d.js';
export type ScrollBodyType = {
    direction: () => number;
    duration: () => number;
    velocity: () => number;
    seek: () => ScrollBodyType;
    settled: () => boolean;
    useBaseFriction: () => ScrollBodyType;
    useBaseDuration: () => ScrollBodyType;
    useFriction: (n: number) => ScrollBodyType;
    useDuration: (n: number) => ScrollBodyType;
};
export declare function ScrollBody(location: Vector1DType, offsetLocation: Vector1DType, previousLocation: Vector1DType, target: Vector1DType, baseDuration: number, baseFriction: number): ScrollBodyType;

~~~

## node_modules\embla-carousel\esm\components\ScrollBounds.d.ts

~~~ts
import { LimitType } from './Limit.js';
import { ScrollBodyType } from './ScrollBody.js';
import { Vector1DType } from './Vector1d.js';
import { PercentOfViewType } from './PercentOfView.js';
export type ScrollBoundsType = {
    shouldConstrain: () => boolean;
    constrain: (pointerDown: boolean) => void;
    toggleActive: (active: boolean) => void;
};
export declare function ScrollBounds(limit: LimitType, location: Vector1DType, target: Vector1DType, scrollBody: ScrollBodyType, percentOfView: PercentOfViewType): ScrollBoundsType;

~~~

## node_modules\embla-carousel\esm\components\ScrollContain.d.ts

~~~ts
import { LimitType } from './Limit.js';
export type ScrollContainOptionType = false | 'trimSnaps' | 'keepSnaps';
export type ScrollContainType = {
    snapsContained: number[];
    scrollContainLimit: LimitType;
};
export declare function ScrollContain(viewSize: number, contentSize: number, snapsAligned: number[], containScroll: ScrollContainOptionType, pixelTolerance: number): ScrollContainType;

~~~

## node_modules\embla-carousel\esm\components\ScrollLimit.d.ts

~~~ts
import { LimitType } from './Limit.js';
export type ScrollLimitType = {
    limit: LimitType;
};
export declare function ScrollLimit(contentSize: number, scrollSnaps: number[], loop: boolean): ScrollLimitType;

~~~

## node_modules\embla-carousel\esm\components\ScrollLooper.d.ts

~~~ts
import { LimitType } from './Limit.js';
import { Vector1DType } from './Vector1d.js';
export type ScrollLooperType = {
    loop: (direction: number) => void;
};
export declare function ScrollLooper(contentSize: number, limit: LimitType, location: Vector1DType, vectors: Vector1DType[]): ScrollLooperType;

~~~

## node_modules\embla-carousel\esm\components\ScrollProgress.d.ts

~~~ts
import { LimitType } from './Limit.js';
export type ScrollProgressType = {
    get: (n: number) => number;
};
export declare function ScrollProgress(limit: LimitType): ScrollProgressType;

~~~

## node_modules\embla-carousel\esm\components\ScrollSnaps.d.ts

~~~ts
import { AlignmentType } from './Alignment.js';
import { AxisType } from './Axis.js';
import { NodeRectType } from './NodeRects.js';
import { SlidesToScrollType } from './SlidesToScroll.js';
export type ScrollSnapsType = {
    snaps: number[];
    snapsAligned: number[];
};
export declare function ScrollSnaps(axis: AxisType, alignment: AlignmentType, containerRect: NodeRectType, slideRects: NodeRectType[], slidesToScroll: SlidesToScrollType): ScrollSnapsType;

~~~

## node_modules\embla-carousel\esm\components\ScrollTarget.d.ts

~~~ts
import { LimitType } from './Limit.js';
import { Vector1DType } from './Vector1d.js';
export type TargetType = {
    distance: number;
    index: number;
};
export type ScrollTargetType = {
    byIndex: (target: number, direction: number) => TargetType;
    byDistance: (force: number, snap: boolean) => TargetType;
    shortcut: (target: number, direction: number) => number;
};
export declare function ScrollTarget(loop: boolean, scrollSnaps: number[], contentSize: number, limit: LimitType, targetVector: Vector1DType): ScrollTargetType;

~~~

## node_modules\embla-carousel\esm\components\ScrollTo.d.ts

~~~ts
import { AnimationsType } from './Animations.js';
import { CounterType } from './Counter.js';
import { EventHandlerType } from './EventHandler.js';
import { ScrollBodyType } from './ScrollBody.js';
import { ScrollTargetType } from './ScrollTarget.js';
import { Vector1DType } from './Vector1d.js';
export type ScrollToType = {
    distance: (n: number, snap: boolean) => void;
    index: (n: number, direction: number) => void;
};
export declare function ScrollTo(animation: AnimationsType, indexCurrent: CounterType, indexPrevious: CounterType, scrollBody: ScrollBodyType, scrollTarget: ScrollTargetType, targetVector: Vector1DType, eventHandler: EventHandlerType): ScrollToType;

~~~

## node_modules\embla-carousel\esm\components\SlideFocus.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel.js';
import { EventHandlerType } from './EventHandler.js';
import { EventStoreType } from './EventStore.js';
import { ScrollBodyType } from './ScrollBody.js';
import { ScrollToType } from './ScrollTo.js';
import { SlideRegistryType } from './SlideRegistry.js';
type FocusHandlerCallbackType = (emblaApi: EmblaCarouselType, evt: FocusEvent) => boolean | void;
export type FocusHandlerOptionType = boolean | FocusHandlerCallbackType;
export type SlideFocusType = {
    init: (emblaApi: EmblaCarouselType) => void;
};
export declare function SlideFocus(root: HTMLElement, slides: HTMLElement[], slideRegistry: SlideRegistryType['slideRegistry'], scrollTo: ScrollToType, scrollBody: ScrollBodyType, eventStore: EventStoreType, eventHandler: EventHandlerType, watchFocus: FocusHandlerOptionType): SlideFocusType;
export {};

~~~

## node_modules\embla-carousel\esm\components\SlideLooper.d.ts

~~~ts
import { AxisType } from './Axis.js';
import { Vector1DType } from './Vector1d.js';
import { TranslateType } from './Translate.js';
type LoopPointType = {
    loopPoint: number;
    index: number;
    translate: TranslateType;
    slideLocation: Vector1DType;
    target: () => number;
};
export type SlideLooperType = {
    canLoop: () => boolean;
    clear: () => void;
    loop: () => void;
    loopPoints: LoopPointType[];
};
export declare function SlideLooper(axis: AxisType, viewSize: number, contentSize: number, slideSizes: number[], slideSizesWithGaps: number[], snaps: number[], scrollSnaps: number[], location: Vector1DType, slides: HTMLElement[]): SlideLooperType;
export {};

~~~

## node_modules\embla-carousel\esm\components\SlideRegistry.d.ts

~~~ts
import { LimitType } from './Limit.js';
import { ScrollContainOptionType } from './ScrollContain.js';
import { SlidesToScrollType } from './SlidesToScroll.js';
export type SlideRegistryType = {
    slideRegistry: number[][];
};
export declare function SlideRegistry(containSnaps: boolean, containScroll: ScrollContainOptionType, scrollSnaps: number[], scrollContainLimit: LimitType, slidesToScroll: SlidesToScrollType, slideIndexes: number[]): SlideRegistryType;

~~~

## node_modules\embla-carousel\esm\components\SlidesHandler.d.ts

~~~ts
import { EmblaCarouselType } from './EmblaCarousel.js';
import { EventHandlerType } from './EventHandler.js';
type SlidesHandlerCallbackType = (emblaApi: EmblaCarouselType, mutations: MutationRecord[]) => boolean | void;
export type SlidesHandlerOptionType = boolean | SlidesHandlerCallbackType;
export type SlidesHandlerType = {
    init: (emblaApi: EmblaCarouselType) => void;
    destroy: () => void;
};
export declare function SlidesHandler(container: HTMLElement, eventHandler: EventHandlerType, watchSlides: SlidesHandlerOptionType): SlidesHandlerType;
export {};

~~~

## node_modules\embla-carousel\esm\components\SlidesInView.d.ts

~~~ts
import { EventHandlerType } from './EventHandler.js';
export type SlidesInViewOptionsType = IntersectionObserverInit['threshold'];
export type SlidesInViewType = {
    init: () => void;
    destroy: () => void;
    get: (inView?: boolean) => number[];
};
export declare function SlidesInView(container: HTMLElement, slides: HTMLElement[], eventHandler: EventHandlerType, threshold: SlidesInViewOptionsType): SlidesInViewType;

~~~

## node_modules\embla-carousel\esm\components\SlideSizes.d.ts

~~~ts
import { AxisType } from './Axis.js';
import { NodeRectType } from './NodeRects.js';
import { WindowType } from './utils.js';
export type SlideSizesType = {
    slideSizes: number[];
    slideSizesWithGaps: number[];
    startGap: number;
    endGap: number;
};
export declare function SlideSizes(axis: AxisType, containerRect: NodeRectType, slideRects: NodeRectType[], slides: HTMLElement[], readEdgeGap: boolean, ownerWindow: WindowType): SlideSizesType;

~~~

## node_modules\embla-carousel\esm\components\SlidesToScroll.d.ts

~~~ts
import { AxisType } from './Axis.js';
import { NodeRectType } from './NodeRects.js';
export type SlidesToScrollOptionType = 'auto' | number;
export type SlidesToScrollType = {
    groupSlides: <Type>(array: Type[]) => Type[][];
};
export declare function SlidesToScroll(axis: AxisType, viewSize: number, slidesToScroll: SlidesToScrollOptionType, loop: boolean, containerRect: NodeRectType, slideRects: NodeRectType[], startGap: number, endGap: number, pixelTolerance: number): SlidesToScrollType;

~~~

## node_modules\embla-carousel\esm\components\Translate.d.ts

~~~ts
import { AxisType } from './Axis.js';
export type TranslateType = {
    clear: () => void;
    to: (target: number) => void;
    toggleActive: (active: boolean) => void;
};
export declare function Translate(axis: AxisType, container: HTMLElement): TranslateType;

~~~

## node_modules\embla-carousel\esm\components\utils.d.ts

~~~ts
import { PointerEventType } from './DragTracker.js';
export type WindowType = Window & typeof globalThis;
export declare function isNumber(subject: unknown): subject is number;
export declare function isString(subject: unknown): subject is string;
export declare function isBoolean(subject: unknown): subject is boolean;
export declare function isObject(subject: unknown): subject is Record<string, unknown>;
export declare function mathAbs(n: number): number;
export declare function mathSign(n: number): number;
export declare function deltaAbs(valueB: number, valueA: number): number;
export declare function factorAbs(valueB: number, valueA: number): number;
export declare function roundToTwoDecimals(num: number): number;
export declare function arrayKeys<Type>(array: Type[]): number[];
export declare function arrayLast<Type>(array: Type[]): Type;
export declare function arrayLastIndex<Type>(array: Type[]): number;
export declare function arrayIsLastIndex<Type>(array: Type[], index: number): boolean;
export declare function arrayFromNumber(n: number, startAt?: number): number[];
export declare function objectKeys<Type extends object>(object: Type): string[];
export declare function objectsMergeDeep(objectA: Record<string, unknown>, objectB: Record<string, unknown>): Record<string, unknown>;
export declare function isMouseEvent(evt: PointerEventType, ownerWindow: WindowType): evt is MouseEvent;

~~~

## node_modules\embla-carousel\esm\components\Vector1d.d.ts

~~~ts
export type Vector1DType = {
    get: () => number;
    set: (n: Vector1DType | number) => void;
    add: (n: Vector1DType | number) => void;
    subtract: (n: Vector1DType | number) => void;
};
export declare function Vector1D(initialValue: number): Vector1DType;

~~~

## node_modules\embla-carousel\esm\embla-carousel.esm.js

~~~js
function isNumber(subject) {
  return typeof subject === 'number';
}
function isString(subject) {
  return typeof subject === 'string';
}
function isBoolean(subject) {
  return typeof subject === 'boolean';
}
function isObject(subject) {
  return Object.prototype.toString.call(subject) === '[object Object]';
}
function mathAbs(n) {
  return Math.abs(n);
}
function mathSign(n) {
  return Math.sign(n);
}
function deltaAbs(valueB, valueA) {
  return mathAbs(valueB - valueA);
}
function factorAbs(valueB, valueA) {
  if (valueB === 0 || valueA === 0) return 0;
  if (mathAbs(valueB) <= mathAbs(valueA)) return 0;
  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA));
  return mathAbs(diff / valueB);
}
function roundToTwoDecimals(num) {
  return Math.round(num * 100) / 100;
}
function arrayKeys(array) {
  return objectKeys(array).map(Number);
}
function arrayLast(array) {
  return array[arrayLastIndex(array)];
}
function arrayLastIndex(array) {
  return Math.max(0, array.length - 1);
}
function arrayIsLastIndex(array, index) {
  return index === arrayLastIndex(array);
}
function arrayFromNumber(n, startAt = 0) {
  return Array.from(Array(n), (_, i) => startAt + i);
}
function objectKeys(object) {
  return Object.keys(object);
}
function objectsMergeDeep(objectA, objectB) {
  return [objectA, objectB].reduce((mergedObjects, currentObject) => {
    objectKeys(currentObject).forEach(key => {
      const valueA = mergedObjects[key];
      const valueB = currentObject[key];
      const areObjects = isObject(valueA) && isObject(valueB);
      mergedObjects[key] = areObjects ? objectsMergeDeep(valueA, valueB) : valueB;
    });
    return mergedObjects;
  }, {});
}
function isMouseEvent(evt, ownerWindow) {
  return typeof ownerWindow.MouseEvent !== 'undefined' && evt instanceof ownerWindow.MouseEvent;
}

function Alignment(align, viewSize) {
  const predefined = {
    start,
    center,
    end
  };
  function start() {
    return 0;
  }
  function center(n) {
    return end(n) / 2;
  }
  function end(n) {
    return viewSize - n;
  }
  function measure(n, index) {
    if (isString(align)) return predefined[align](n);
    return align(viewSize, n, index);
  }
  const self = {
    measure
  };
  return self;
}

function EventStore() {
  let listeners = [];
  function add(node, type, handler, options = {
    passive: true
  }) {
    let removeListener;
    if ('addEventListener' in node) {
      node.addEventListener(type, handler, options);
      removeListener = () => node.removeEventListener(type, handler, options);
    } else {
      const legacyMediaQueryList = node;
      legacyMediaQueryList.addListener(handler);
      removeListener = () => legacyMediaQueryList.removeListener(handler);
    }
    listeners.push(removeListener);
    return self;
  }
  function clear() {
    listeners = listeners.filter(remove => remove());
  }
  const self = {
    add,
    clear
  };
  return self;
}

function Animations(ownerDocument, ownerWindow, update, render) {
  const documentVisibleHandler = EventStore();
  const fixedTimeStep = 1000 / 60;
  let lastTimeStamp = null;
  let accumulatedTime = 0;
  let animationId = 0;
  function init() {
    documentVisibleHandler.add(ownerDocument, 'visibilitychange', () => {
      if (ownerDocument.hidden) reset();
    });
  }
  function destroy() {
    stop();
    documentVisibleHandler.clear();
  }
  function animate(timeStamp) {
    if (!animationId) return;
    if (!lastTimeStamp) {
      lastTimeStamp = timeStamp;
      update();
      update();
    }
    const timeElapsed = timeStamp - lastTimeStamp;
    lastTimeStamp = timeStamp;
    accumulatedTime += timeElapsed;
    while (accumulatedTime >= fixedTimeStep) {
      update();
      accumulatedTime -= fixedTimeStep;
    }
    const alpha = accumulatedTime / fixedTimeStep;
    render(alpha);
    if (animationId) {
      animationId = ownerWindow.requestAnimationFrame(animate);
    }
  }
  function start() {
    if (animationId) return;
    animationId = ownerWindow.requestAnimationFrame(animate);
  }
  function stop() {
    ownerWindow.cancelAnimationFrame(animationId);
    lastTimeStamp = null;
    accumulatedTime = 0;
    animationId = 0;
  }
  function reset() {
    lastTimeStamp = null;
    accumulatedTime = 0;
  }
  const self = {
    init,
    destroy,
    start,
    stop,
    update,
    render
  };
  return self;
}

function Axis(axis, contentDirection) {
  const isRightToLeft = contentDirection === 'rtl';
  const isVertical = axis === 'y';
  const scroll = isVertical ? 'y' : 'x';
  const cross = isVertical ? 'x' : 'y';
  const sign = !isVertical && isRightToLeft ? -1 : 1;
  const startEdge = getStartEdge();
  const endEdge = getEndEdge();
  function measureSize(nodeRect) {
    const {
      height,
      width
    } = nodeRect;
    return isVertical ? height : width;
  }
  function getStartEdge() {
    if (isVertical) return 'top';
    return isRightToLeft ? 'right' : 'left';
  }
  function getEndEdge() {
    if (isVertical) return 'bottom';
    return isRightToLeft ? 'left' : 'right';
  }
  function direction(n) {
    return n * sign;
  }
  const self = {
    scroll,
    cross,
    startEdge,
    endEdge,
    measureSize,
    direction
  };
  return self;
}

function Limit(min = 0, max = 0) {
  const length = mathAbs(min - max);
  function reachedMin(n) {
    return n < min;
  }
  function reachedMax(n) {
    return n > max;
  }
  function reachedAny(n) {
    return reachedMin(n) || reachedMax(n);
  }
  function constrain(n) {
    if (!reachedAny(n)) return n;
    return reachedMin(n) ? min : max;
  }
  function removeOffset(n) {
    if (!length) return n;
    return n - length * Math.ceil((n - max) / length);
  }
  const self = {
    length,
    max,
    min,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset
  };
  return self;
}

function Counter(max, start, loop) {
  const {
    constrain
  } = Limit(0, max);
  const loopEnd = max + 1;
  let counter = withinLimit(start);
  function withinLimit(n) {
    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd);
  }
  function get() {
    return counter;
  }
  function set(n) {
    counter = withinLimit(n);
    return self;
  }
  function add(n) {
    return clone().set(get() + n);
  }
  function clone() {
    return Counter(max, get(), loop);
  }
  const self = {
    get,
    set,
    add,
    clone
  };
  return self;
}

function DragHandler(axis, rootNode, ownerDocument, ownerWindow, target, dragTracker, location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, baseFriction, watchDrag) {
  const {
    cross: crossAxis,
    direction
  } = axis;
  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];
  const nonPassiveEvent = {
    passive: false
  };
  const initEvents = EventStore();
  const dragEvents = EventStore();
  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20));
  const snapForceBoost = {
    mouse: 300,
    touch: 400
  };
  const freeForceBoost = {
    mouse: 500,
    touch: 600
  };
  const baseSpeed = dragFree ? 43 : 25;
  let isMoving = false;
  let startScroll = 0;
  let startCross = 0;
  let pointerIsDown = false;
  let preventScroll = false;
  let preventClick = false;
  let isMouse = false;
  function init(emblaApi) {
    if (!watchDrag) return;
    function downIfAllowed(evt) {
      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt);
    }
    const node = rootNode;
    initEvents.add(node, 'dragstart', evt => evt.preventDefault(), nonPassiveEvent).add(node, 'touchmove', () => undefined, nonPassiveEvent).add(node, 'touchend', () => undefined).add(node, 'touchstart', downIfAllowed).add(node, 'mousedown', downIfAllowed).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click, true);
  }
  function destroy() {
    initEvents.clear();
    dragEvents.clear();
  }
  function addDragEvents() {
    const node = isMouse ? ownerDocument : rootNode;
    dragEvents.add(node, 'touchmove', move, nonPassiveEvent).add(node, 'touchend', up).add(node, 'mousemove', move, nonPassiveEvent).add(node, 'mouseup', up);
  }
  function isFocusNode(node) {
    const nodeName = node.nodeName || '';
    return focusNodes.includes(nodeName);
  }
  function forceBoost() {
    const boost = dragFree ? freeForceBoost : snapForceBoost;
    const type = isMouse ? 'mouse' : 'touch';
    return boost[type];
  }
  function allowedForce(force, targetChanged) {
    const next = index.add(mathSign(force) * -1);
    const baseForce = scrollTarget.byDistance(force, !dragFree).distance;
    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce;
    if (skipSnaps && targetChanged) return baseForce * 0.5;
    return scrollTarget.byIndex(next.get(), 0).distance;
  }
  function down(evt) {
    const isMouseEvt = isMouseEvent(evt, ownerWindow);
    isMouse = isMouseEvt;
    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving;
    isMoving = deltaAbs(target.get(), location.get()) >= 2;
    if (isMouseEvt && evt.button !== 0) return;
    if (isFocusNode(evt.target)) return;
    pointerIsDown = true;
    dragTracker.pointerDown(evt);
    scrollBody.useFriction(0).useDuration(0);
    target.set(location);
    addDragEvents();
    startScroll = dragTracker.readPoint(evt);
    startCross = dragTracker.readPoint(evt, crossAxis);
    eventHandler.emit('pointerDown');
  }
  function move(evt) {
    const isTouchEvt = !isMouseEvent(evt, ownerWindow);
    if (isTouchEvt && evt.touches.length >= 2) return up(evt);
    const lastScroll = dragTracker.readPoint(evt);
    const lastCross = dragTracker.readPoint(evt, crossAxis);
    const diffScroll = deltaAbs(lastScroll, startScroll);
    const diffCross = deltaAbs(lastCross, startCross);
    if (!preventScroll && !isMouse) {
      if (!evt.cancelable) return up(evt);
      preventScroll = diffScroll > diffCross;
      if (!preventScroll) return up(evt);
    }
    const diff = dragTracker.pointerMove(evt);
    if (diffScroll > dragThreshold) preventClick = true;
    scrollBody.useFriction(0.3).useDuration(0.75);
    animation.start();
    target.add(direction(diff));
    evt.preventDefault();
  }
  function up(evt) {
    const currentLocation = scrollTarget.byDistance(0, false);
    const targetChanged = currentLocation.index !== index.get();
    const rawForce = dragTracker.pointerUp(evt) * forceBoost();
    const force = allowedForce(direction(rawForce), targetChanged);
    const forceFactor = factorAbs(rawForce, force);
    const speed = baseSpeed - 10 * forceFactor;
    const friction = baseFriction + forceFactor / 50;
    preventScroll = false;
    pointerIsDown = false;
    dragEvents.clear();
    scrollBody.useDuration(speed).useFriction(friction);
    scrollTo.distance(force, !dragFree);
    isMouse = false;
    eventHandler.emit('pointerUp');
  }
  function click(evt) {
    if (preventClick) {
      evt.stopPropagation();
      evt.preventDefault();
      preventClick = false;
    }
  }
  function pointerDown() {
    return pointerIsDown;
  }
  const self = {
    init,
    destroy,
    pointerDown
  };
  return self;
}

function DragTracker(axis, ownerWindow) {
  const logInterval = 170;
  let startEvent;
  let lastEvent;
  function readTime(evt) {
    return evt.timeStamp;
  }
  function readPoint(evt, evtAxis) {
    const property = evtAxis || axis.scroll;
    const coord = `client${property === 'x' ? 'X' : 'Y'}`;
    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord];
  }
  function pointerDown(evt) {
    startEvent = evt;
    lastEvent = evt;
    return readPoint(evt);
  }
  function pointerMove(evt) {
    const diff = readPoint(evt) - readPoint(lastEvent);
    const expired = readTime(evt) - readTime(startEvent) > logInterval;
    lastEvent = evt;
    if (expired) startEvent = evt;
    return diff;
  }
  function pointerUp(evt) {
    if (!startEvent || !lastEvent) return 0;
    const diffDrag = readPoint(lastEvent) - readPoint(startEvent);
    const diffTime = readTime(evt) - readTime(startEvent);
    const expired = readTime(evt) - readTime(lastEvent) > logInterval;
    const force = diffDrag / diffTime;
    const isFlick = diffTime && !expired && mathAbs(force) > 0.1;
    return isFlick ? force : 0;
  }
  const self = {
    pointerDown,
    pointerMove,
    pointerUp,
    readPoint
  };
  return self;
}

function NodeRects() {
  function measure(node) {
    const {
      offsetTop,
      offsetLeft,
      offsetWidth,
      offsetHeight
    } = node;
    const offset = {
      top: offsetTop,
      right: offsetLeft + offsetWidth,
      bottom: offsetTop + offsetHeight,
      left: offsetLeft,
      width: offsetWidth,
      height: offsetHeight
    };
    return offset;
  }
  const self = {
    measure
  };
  return self;
}

function PercentOfView(viewSize) {
  function measure(n) {
    return viewSize * (n / 100);
  }
  const self = {
    measure
  };
  return self;
}

function ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects) {
  const observeNodes = [container].concat(slides);
  let resizeObserver;
  let containerSize;
  let slideSizes = [];
  let destroyed = false;
  function readSize(node) {
    return axis.measureSize(nodeRects.measure(node));
  }
  function init(emblaApi) {
    if (!watchResize) return;
    containerSize = readSize(container);
    slideSizes = slides.map(readSize);
    function defaultCallback(entries) {
      for (const entry of entries) {
        if (destroyed) return;
        const isContainer = entry.target === container;
        const slideIndex = slides.indexOf(entry.target);
        const lastSize = isContainer ? containerSize : slideSizes[slideIndex];
        const newSize = readSize(isContainer ? container : slides[slideIndex]);
        const diffSize = mathAbs(newSize - lastSize);
        if (diffSize >= 0.5) {
          emblaApi.reInit();
          eventHandler.emit('resize');
          break;
        }
      }
    }
    resizeObserver = new ResizeObserver(entries => {
      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {
        defaultCallback(entries);
      }
    });
    ownerWindow.requestAnimationFrame(() => {
      observeNodes.forEach(node => resizeObserver.observe(node));
    });
  }
  function destroy() {
    destroyed = true;
    if (resizeObserver) resizeObserver.disconnect();
  }
  const self = {
    init,
    destroy
  };
  return self;
}

function ScrollBody(location, offsetLocation, previousLocation, target, baseDuration, baseFriction) {
  let scrollVelocity = 0;
  let scrollDirection = 0;
  let scrollDuration = baseDuration;
  let scrollFriction = baseFriction;
  let rawLocation = location.get();
  let rawLocationPrevious = 0;
  function seek() {
    const displacement = target.get() - location.get();
    const isInstant = !scrollDuration;
    let scrollDistance = 0;
    if (isInstant) {
      scrollVelocity = 0;
      previousLocation.set(target);
      location.set(target);
      scrollDistance = displacement;
    } else {
      previousLocation.set(location);
      scrollVelocity += displacement / scrollDuration;
      scrollVelocity *= scrollFriction;
      rawLocation += scrollVelocity;
      location.add(scrollVelocity);
      scrollDistance = rawLocation - rawLocationPrevious;
    }
    scrollDirection = mathSign(scrollDistance);
    rawLocationPrevious = rawLocation;
    return self;
  }
  function settled() {
    const diff = target.get() - offsetLocation.get();
    return mathAbs(diff) < 0.001;
  }
  function duration() {
    return scrollDuration;
  }
  function direction() {
    return scrollDirection;
  }
  function velocity() {
    return scrollVelocity;
  }
  function useBaseDuration() {
    return useDuration(baseDuration);
  }
  function useBaseFriction() {
    return useFriction(baseFriction);
  }
  function useDuration(n) {
    scrollDuration = n;
    return self;
  }
  function useFriction(n) {
    scrollFriction = n;
    return self;
  }
  const self = {
    direction,
    duration,
    velocity,
    seek,
    settled,
    useBaseFriction,
    useBaseDuration,
    useFriction,
    useDuration
  };
  return self;
}

function ScrollBounds(limit, location, target, scrollBody, percentOfView) {
  const pullBackThreshold = percentOfView.measure(10);
  const edgeOffsetTolerance = percentOfView.measure(50);
  const frictionLimit = Limit(0.1, 0.99);
  let disabled = false;
  function shouldConstrain() {
    if (disabled) return false;
    if (!limit.reachedAny(target.get())) return false;
    if (!limit.reachedAny(location.get())) return false;
    return true;
  }
  function constrain(pointerDown) {
    if (!shouldConstrain()) return;
    const edge = limit.reachedMin(location.get()) ? 'min' : 'max';
    const diffToEdge = mathAbs(limit[edge] - location.get());
    const diffToTarget = target.get() - location.get();
    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance);
    target.subtract(diffToTarget * friction);
    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {
      target.set(limit.constrain(target.get()));
      scrollBody.useDuration(25).useBaseFriction();
    }
  }
  function toggleActive(active) {
    disabled = !active;
  }
  const self = {
    shouldConstrain,
    constrain,
    toggleActive
  };
  return self;
}

function ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance) {
  const scrollBounds = Limit(-contentSize + viewSize, 0);
  const snapsBounded = measureBounded();
  const scrollContainLimit = findScrollContainLimit();
  const snapsContained = measureContained();
  function usePixelTolerance(bound, snap) {
    return deltaAbs(bound, snap) <= 1;
  }
  function findScrollContainLimit() {
    const startSnap = snapsBounded[0];
    const endSnap = arrayLast(snapsBounded);
    const min = snapsBounded.lastIndexOf(startSnap);
    const max = snapsBounded.indexOf(endSnap) + 1;
    return Limit(min, max);
  }
  function measureBounded() {
    return snapsAligned.map((snapAligned, index) => {
      const {
        min,
        max
      } = scrollBounds;
      const snap = scrollBounds.constrain(snapAligned);
      const isFirst = !index;
      const isLast = arrayIsLastIndex(snapsAligned, index);
      if (isFirst) return max;
      if (isLast) return min;
      if (usePixelTolerance(min, snap)) return min;
      if (usePixelTolerance(max, snap)) return max;
      return snap;
    }).map(scrollBound => parseFloat(scrollBound.toFixed(3)));
  }
  function measureContained() {
    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max];
    if (containScroll === 'keepSnaps') return snapsBounded;
    const {
      min,
      max
    } = scrollContainLimit;
    return snapsBounded.slice(min, max);
  }
  const self = {
    snapsContained,
    scrollContainLimit
  };
  return self;
}

function ScrollLimit(contentSize, scrollSnaps, loop) {
  const max = scrollSnaps[0];
  const min = loop ? max - contentSize : arrayLast(scrollSnaps);
  const limit = Limit(min, max);
  const self = {
    limit
  };
  return self;
}

function ScrollLooper(contentSize, limit, location, vectors) {
  const jointSafety = 0.1;
  const min = limit.min + jointSafety;
  const max = limit.max + jointSafety;
  const {
    reachedMin,
    reachedMax
  } = Limit(min, max);
  function shouldLoop(direction) {
    if (direction === 1) return reachedMax(location.get());
    if (direction === -1) return reachedMin(location.get());
    return false;
  }
  function loop(direction) {
    if (!shouldLoop(direction)) return;
    const loopDistance = contentSize * (direction * -1);
    vectors.forEach(v => v.add(loopDistance));
  }
  const self = {
    loop
  };
  return self;
}

function ScrollProgress(limit) {
  const {
    max,
    length
  } = limit;
  function get(n) {
    const currentLocation = n - max;
    return length ? currentLocation / -length : 0;
  }
  const self = {
    get
  };
  return self;
}

function ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll) {
  const {
    startEdge,
    endEdge
  } = axis;
  const {
    groupSlides
  } = slidesToScroll;
  const alignments = measureSizes().map(alignment.measure);
  const snaps = measureUnaligned();
  const snapsAligned = measureAligned();
  function measureSizes() {
    return groupSlides(slideRects).map(rects => arrayLast(rects)[endEdge] - rects[0][startEdge]).map(mathAbs);
  }
  function measureUnaligned() {
    return slideRects.map(rect => containerRect[startEdge] - rect[startEdge]).map(snap => -mathAbs(snap));
  }
  function measureAligned() {
    return groupSlides(snaps).map(g => g[0]).map((snap, index) => snap + alignments[index]);
  }
  const self = {
    snaps,
    snapsAligned
  };
  return self;
}

function SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes) {
  const {
    groupSlides
  } = slidesToScroll;
  const {
    min,
    max
  } = scrollContainLimit;
  const slideRegistry = createSlideRegistry();
  function createSlideRegistry() {
    const groupedSlideIndexes = groupSlides(slideIndexes);
    const doNotContain = !containSnaps || containScroll === 'keepSnaps';
    if (scrollSnaps.length === 1) return [slideIndexes];
    if (doNotContain) return groupedSlideIndexes;
    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(groups, index);
      if (isFirst) {
        const range = arrayLast(groups[0]) + 1;
        return arrayFromNumber(range);
      }
      if (isLast) {
        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1;
        return arrayFromNumber(range, arrayLast(groups)[0]);
      }
      return group;
    });
  }
  const self = {
    slideRegistry
  };
  return self;
}

function ScrollTarget(loop, scrollSnaps, contentSize, limit, targetVector) {
  const {
    reachedAny,
    removeOffset,
    constrain
  } = limit;
  function minDistance(distances) {
    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0];
  }
  function findTargetSnap(target) {
    const distance = loop ? removeOffset(target) : constrain(target);
    const ascDiffsToSnaps = scrollSnaps.map((snap, index) => ({
      diff: shortcut(snap - distance, 0),
      index
    })).sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff));
    const {
      index
    } = ascDiffsToSnaps[0];
    return {
      index,
      distance
    };
  }
  function shortcut(target, direction) {
    const targets = [target, target + contentSize, target - contentSize];
    if (!loop) return target;
    if (!direction) return minDistance(targets);
    const matchingTargets = targets.filter(t => mathSign(t) === direction);
    if (matchingTargets.length) return minDistance(matchingTargets);
    return arrayLast(targets) - contentSize;
  }
  function byIndex(index, direction) {
    const diffToSnap = scrollSnaps[index] - targetVector.get();
    const distance = shortcut(diffToSnap, direction);
    return {
      index,
      distance
    };
  }
  function byDistance(distance, snap) {
    const target = targetVector.get() + distance;
    const {
      index,
      distance: targetSnapDistance
    } = findTargetSnap(target);
    const reachedBound = !loop && reachedAny(target);
    if (!snap || reachedBound) return {
      index,
      distance
    };
    const diffToSnap = scrollSnaps[index] - targetSnapDistance;
    const snapDistance = distance + shortcut(diffToSnap, 0);
    return {
      index,
      distance: snapDistance
    };
  }
  const self = {
    byDistance,
    byIndex,
    shortcut
  };
  return self;
}

function ScrollTo(animation, indexCurrent, indexPrevious, scrollBody, scrollTarget, targetVector, eventHandler) {
  function scrollTo(target) {
    const distanceDiff = target.distance;
    const indexDiff = target.index !== indexCurrent.get();
    targetVector.add(distanceDiff);
    if (distanceDiff) {
      if (scrollBody.duration()) {
        animation.start();
      } else {
        animation.update();
        animation.render(1);
        animation.update();
      }
    }
    if (indexDiff) {
      indexPrevious.set(indexCurrent.get());
      indexCurrent.set(target.index);
      eventHandler.emit('select');
    }
  }
  function distance(n, snap) {
    const target = scrollTarget.byDistance(n, snap);
    scrollTo(target);
  }
  function index(n, direction) {
    const targetIndex = indexCurrent.clone().set(n);
    const target = scrollTarget.byIndex(targetIndex.get(), direction);
    scrollTo(target);
  }
  const self = {
    distance,
    index
  };
  return self;
}

function SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus) {
  const focusListenerOptions = {
    passive: true,
    capture: true
  };
  let lastTabPressTime = 0;
  function init(emblaApi) {
    if (!watchFocus) return;
    function defaultCallback(index) {
      const nowTime = new Date().getTime();
      const diffTime = nowTime - lastTabPressTime;
      if (diffTime > 10) return;
      eventHandler.emit('slideFocusStart');
      root.scrollLeft = 0;
      const group = slideRegistry.findIndex(group => group.includes(index));
      if (!isNumber(group)) return;
      scrollBody.useDuration(0);
      scrollTo.index(group, 0);
      eventHandler.emit('slideFocus');
    }
    eventStore.add(document, 'keydown', registerTabPress, false);
    slides.forEach((slide, slideIndex) => {
      eventStore.add(slide, 'focus', evt => {
        if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {
          defaultCallback(slideIndex);
        }
      }, focusListenerOptions);
    });
  }
  function registerTabPress(event) {
    if (event.code === 'Tab') lastTabPressTime = new Date().getTime();
  }
  const self = {
    init
  };
  return self;
}

function Vector1D(initialValue) {
  let value = initialValue;
  function get() {
    return value;
  }
  function set(n) {
    value = normalizeInput(n);
  }
  function add(n) {
    value += normalizeInput(n);
  }
  function subtract(n) {
    value -= normalizeInput(n);
  }
  function normalizeInput(n) {
    return isNumber(n) ? n : n.get();
  }
  const self = {
    get,
    set,
    add,
    subtract
  };
  return self;
}

function Translate(axis, container) {
  const translate = axis.scroll === 'x' ? x : y;
  const containerStyle = container.style;
  let previousTarget = null;
  let disabled = false;
  function x(n) {
    return `translate3d(${n}px,0px,0px)`;
  }
  function y(n) {
    return `translate3d(0px,${n}px,0px)`;
  }
  function to(target) {
    if (disabled) return;
    const newTarget = roundToTwoDecimals(axis.direction(target));
    if (newTarget === previousTarget) return;
    containerStyle.transform = translate(newTarget);
    previousTarget = newTarget;
  }
  function toggleActive(active) {
    disabled = !active;
  }
  function clear() {
    if (disabled) return;
    containerStyle.transform = '';
    if (!container.getAttribute('style')) container.removeAttribute('style');
  }
  const self = {
    clear,
    to,
    toggleActive
  };
  return self;
}

function SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, location, slides) {
  const roundingSafety = 0.5;
  const ascItems = arrayKeys(slideSizesWithGaps);
  const descItems = arrayKeys(slideSizesWithGaps).reverse();
  const loopPoints = startPoints().concat(endPoints());
  function removeSlideSizes(indexes, from) {
    return indexes.reduce((a, i) => {
      return a - slideSizesWithGaps[i];
    }, from);
  }
  function slidesInGap(indexes, gap) {
    return indexes.reduce((a, i) => {
      const remainingGap = removeSlideSizes(a, gap);
      return remainingGap > 0 ? a.concat([i]) : a;
    }, []);
  }
  function findSlideBounds(offset) {
    return snaps.map((snap, index) => ({
      start: snap - slideSizes[index] + roundingSafety + offset,
      end: snap + viewSize - roundingSafety + offset
    }));
  }
  function findLoopPoints(indexes, offset, isEndEdge) {
    const slideBounds = findSlideBounds(offset);
    return indexes.map(index => {
      const initial = isEndEdge ? 0 : -contentSize;
      const altered = isEndEdge ? contentSize : 0;
      const boundEdge = isEndEdge ? 'end' : 'start';
      const loopPoint = slideBounds[index][boundEdge];
      return {
        index,
        loopPoint,
        slideLocation: Vector1D(-1),
        translate: Translate(axis, slides[index]),
        target: () => location.get() > loopPoint ? initial : altered
      };
    });
  }
  function startPoints() {
    const gap = scrollSnaps[0];
    const indexes = slidesInGap(descItems, gap);
    return findLoopPoints(indexes, contentSize, false);
  }
  function endPoints() {
    const gap = viewSize - scrollSnaps[0] - 1;
    const indexes = slidesInGap(ascItems, gap);
    return findLoopPoints(indexes, -contentSize, true);
  }
  function canLoop() {
    return loopPoints.every(({
      index
    }) => {
      const otherIndexes = ascItems.filter(i => i !== index);
      return removeSlideSizes(otherIndexes, viewSize) <= 0.1;
    });
  }
  function loop() {
    loopPoints.forEach(loopPoint => {
      const {
        target,
        translate,
        slideLocation
      } = loopPoint;
      const shiftLocation = target();
      if (shiftLocation === slideLocation.get()) return;
      translate.to(shiftLocation);
      slideLocation.set(shiftLocation);
    });
  }
  function clear() {
    loopPoints.forEach(loopPoint => loopPoint.translate.clear());
  }
  const self = {
    canLoop,
    clear,
    loop,
    loopPoints
  };
  return self;
}

function SlidesHandler(container, eventHandler, watchSlides) {
  let mutationObserver;
  let destroyed = false;
  function init(emblaApi) {
    if (!watchSlides) return;
    function defaultCallback(mutations) {
      for (const mutation of mutations) {
        if (mutation.type === 'childList') {
          emblaApi.reInit();
          eventHandler.emit('slidesChanged');
          break;
        }
      }
    }
    mutationObserver = new MutationObserver(mutations => {
      if (destroyed) return;
      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {
        defaultCallback(mutations);
      }
    });
    mutationObserver.observe(container, {
      childList: true
    });
  }
  function destroy() {
    if (mutationObserver) mutationObserver.disconnect();
    destroyed = true;
  }
  const self = {
    init,
    destroy
  };
  return self;
}

function SlidesInView(container, slides, eventHandler, threshold) {
  const intersectionEntryMap = {};
  let inViewCache = null;
  let notInViewCache = null;
  let intersectionObserver;
  let destroyed = false;
  function init() {
    intersectionObserver = new IntersectionObserver(entries => {
      if (destroyed) return;
      entries.forEach(entry => {
        const index = slides.indexOf(entry.target);
        intersectionEntryMap[index] = entry;
      });
      inViewCache = null;
      notInViewCache = null;
      eventHandler.emit('slidesInView');
    }, {
      root: container.parentElement,
      threshold
    });
    slides.forEach(slide => intersectionObserver.observe(slide));
  }
  function destroy() {
    if (intersectionObserver) intersectionObserver.disconnect();
    destroyed = true;
  }
  function createInViewList(inView) {
    return objectKeys(intersectionEntryMap).reduce((list, slideIndex) => {
      const index = parseInt(slideIndex);
      const {
        isIntersecting
      } = intersectionEntryMap[index];
      const inViewMatch = inView && isIntersecting;
      const notInViewMatch = !inView && !isIntersecting;
      if (inViewMatch || notInViewMatch) list.push(index);
      return list;
    }, []);
  }
  function get(inView = true) {
    if (inView && inViewCache) return inViewCache;
    if (!inView && notInViewCache) return notInViewCache;
    const slideIndexes = createInViewList(inView);
    if (inView) inViewCache = slideIndexes;
    if (!inView) notInViewCache = slideIndexes;
    return slideIndexes;
  }
  const self = {
    init,
    destroy,
    get
  };
  return self;
}

function SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow) {
  const {
    measureSize,
    startEdge,
    endEdge
  } = axis;
  const withEdgeGap = slideRects[0] && readEdgeGap;
  const startGap = measureStartGap();
  const endGap = measureEndGap();
  const slideSizes = slideRects.map(measureSize);
  const slideSizesWithGaps = measureWithGaps();
  function measureStartGap() {
    if (!withEdgeGap) return 0;
    const slideRect = slideRects[0];
    return mathAbs(containerRect[startEdge] - slideRect[startEdge]);
  }
  function measureEndGap() {
    if (!withEdgeGap) return 0;
    const style = ownerWindow.getComputedStyle(arrayLast(slides));
    return parseFloat(style.getPropertyValue(`margin-${endEdge}`));
  }
  function measureWithGaps() {
    return slideRects.map((rect, index, rects) => {
      const isFirst = !index;
      const isLast = arrayIsLastIndex(rects, index);
      if (isFirst) return slideSizes[index] + startGap;
      if (isLast) return slideSizes[index] + endGap;
      return rects[index + 1][startEdge] - rect[startEdge];
    }).map(mathAbs);
  }
  const self = {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  };
  return self;
}

function SlidesToScroll(axis, viewSize, slidesToScroll, loop, containerRect, slideRects, startGap, endGap, pixelTolerance) {
  const {
    startEdge,
    endEdge,
    direction
  } = axis;
  const groupByNumber = isNumber(slidesToScroll);
  function byNumber(array, groupSize) {
    return arrayKeys(array).filter(i => i % groupSize === 0).map(i => array.slice(i, i + groupSize));
  }
  function bySize(array) {
    if (!array.length) return [];
    return arrayKeys(array).reduce((groups, rectB, index) => {
      const rectA = arrayLast(groups) || 0;
      const isFirst = rectA === 0;
      const isLast = rectB === arrayLastIndex(array);
      const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge];
      const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge];
      const gapA = !loop && isFirst ? direction(startGap) : 0;
      const gapB = !loop && isLast ? direction(endGap) : 0;
      const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA));
      if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB);
      if (isLast) groups.push(array.length);
      return groups;
    }, []).map((currentSize, index, groups) => {
      const previousSize = Math.max(groups[index - 1] || 0);
      return array.slice(previousSize, currentSize);
    });
  }
  function groupSlides(array) {
    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array);
  }
  const self = {
    groupSlides
  };
  return self;
}

function Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler) {
  // Options
  const {
    align,
    axis: scrollAxis,
    direction,
    startIndex,
    loop,
    duration,
    dragFree,
    dragThreshold,
    inViewThreshold,
    slidesToScroll: groupSlides,
    skipSnaps,
    containScroll,
    watchResize,
    watchSlides,
    watchDrag,
    watchFocus
  } = options;
  // Measurements
  const pixelTolerance = 2;
  const nodeRects = NodeRects();
  const containerRect = nodeRects.measure(container);
  const slideRects = slides.map(nodeRects.measure);
  const axis = Axis(scrollAxis, direction);
  const viewSize = axis.measureSize(containerRect);
  const percentOfView = PercentOfView(viewSize);
  const alignment = Alignment(align, viewSize);
  const containSnaps = !loop && !!containScroll;
  const readEdgeGap = loop || !!containScroll;
  const {
    slideSizes,
    slideSizesWithGaps,
    startGap,
    endGap
  } = SlideSizes(axis, containerRect, slideRects, slides, readEdgeGap, ownerWindow);
  const slidesToScroll = SlidesToScroll(axis, viewSize, groupSlides, loop, containerRect, slideRects, startGap, endGap, pixelTolerance);
  const {
    snaps,
    snapsAligned
  } = ScrollSnaps(axis, alignment, containerRect, slideRects, slidesToScroll);
  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
  const {
    snapsContained,
    scrollContainLimit
  } = ScrollContain(viewSize, contentSize, snapsAligned, containScroll, pixelTolerance);
  const scrollSnaps = containSnaps ? snapsContained : snapsAligned;
  const {
    limit
  } = ScrollLimit(contentSize, scrollSnaps, loop);
  // Indexes
  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop);
  const indexPrevious = index.clone();
  const slideIndexes = arrayKeys(slides);
  // Animation
  const update = ({
    dragHandler,
    scrollBody,
    scrollBounds,
    options: {
      loop
    }
  }) => {
    if (!loop) scrollBounds.constrain(dragHandler.pointerDown());
    scrollBody.seek();
  };
  const render = ({
    scrollBody,
    translate,
    location,
    offsetLocation,
    previousLocation,
    scrollLooper,
    slideLooper,
    dragHandler,
    animation,
    eventHandler,
    scrollBounds,
    options: {
      loop
    }
  }, alpha) => {
    const shouldSettle = scrollBody.settled();
    const withinBounds = !scrollBounds.shouldConstrain();
    const hasSettled = loop ? shouldSettle : shouldSettle && withinBounds;
    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown();
    if (hasSettledAndIdle) animation.stop();
    const interpolatedLocation = location.get() * alpha + previousLocation.get() * (1 - alpha);
    offsetLocation.set(interpolatedLocation);
    if (loop) {
      scrollLooper.loop(scrollBody.direction());
      slideLooper.loop();
    }
    translate.to(offsetLocation.get());
    if (hasSettledAndIdle) eventHandler.emit('settle');
    if (!hasSettled) eventHandler.emit('scroll');
  };
  const animation = Animations(ownerDocument, ownerWindow, () => update(engine), alpha => render(engine, alpha));
  // Shared
  const friction = 0.68;
  const startLocation = scrollSnaps[index.get()];
  const location = Vector1D(startLocation);
  const previousLocation = Vector1D(startLocation);
  const offsetLocation = Vector1D(startLocation);
  const target = Vector1D(startLocation);
  const scrollBody = ScrollBody(location, offsetLocation, previousLocation, target, duration, friction);
  const scrollTarget = ScrollTarget(loop, scrollSnaps, contentSize, limit, target);
  const scrollTo = ScrollTo(animation, index, indexPrevious, scrollBody, scrollTarget, target, eventHandler);
  const scrollProgress = ScrollProgress(limit);
  const eventStore = EventStore();
  const slidesInView = SlidesInView(container, slides, eventHandler, inViewThreshold);
  const {
    slideRegistry
  } = SlideRegistry(containSnaps, containScroll, scrollSnaps, scrollContainLimit, slidesToScroll, slideIndexes);
  const slideFocus = SlideFocus(root, slides, slideRegistry, scrollTo, scrollBody, eventStore, eventHandler, watchFocus);
  // Engine
  const engine = {
    ownerDocument,
    ownerWindow,
    eventHandler,
    containerRect,
    slideRects,
    animation,
    axis,
    dragHandler: DragHandler(axis, root, ownerDocument, ownerWindow, target, DragTracker(axis, ownerWindow), location, animation, scrollTo, scrollBody, scrollTarget, index, eventHandler, percentOfView, dragFree, dragThreshold, skipSnaps, friction, watchDrag),
    eventStore,
    percentOfView,
    index,
    indexPrevious,
    limit,
    location,
    offsetLocation,
    previousLocation,
    options,
    resizeHandler: ResizeHandler(container, eventHandler, ownerWindow, slides, axis, watchResize, nodeRects),
    scrollBody,
    scrollBounds: ScrollBounds(limit, offsetLocation, target, scrollBody, percentOfView),
    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [location, offsetLocation, previousLocation, target]),
    scrollProgress,
    scrollSnapList: scrollSnaps.map(scrollProgress.get),
    scrollSnaps,
    scrollTarget,
    scrollTo,
    slideLooper: SlideLooper(axis, viewSize, contentSize, slideSizes, slideSizesWithGaps, snaps, scrollSnaps, offsetLocation, slides),
    slideFocus,
    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),
    slidesInView,
    slideIndexes,
    slideRegistry,
    slidesToScroll,
    target,
    translate: Translate(axis, container)
  };
  return engine;
}

function EventHandler() {
  let listeners = {};
  let api;
  function init(emblaApi) {
    api = emblaApi;
  }
  function getListeners(evt) {
    return listeners[evt] || [];
  }
  function emit(evt) {
    getListeners(evt).forEach(e => e(api, evt));
    return self;
  }
  function on(evt, cb) {
    listeners[evt] = getListeners(evt).concat([cb]);
    return self;
  }
  function off(evt, cb) {
    listeners[evt] = getListeners(evt).filter(e => e !== cb);
    return self;
  }
  function clear() {
    listeners = {};
  }
  const self = {
    init,
    emit,
    off,
    on,
    clear
  };
  return self;
}

const defaultOptions = {
  align: 'center',
  axis: 'x',
  container: null,
  slides: null,
  containScroll: 'trimSnaps',
  direction: 'ltr',
  slidesToScroll: 1,
  inViewThreshold: 0,
  breakpoints: {},
  dragFree: false,
  dragThreshold: 10,
  loop: false,
  skipSnaps: false,
  duration: 25,
  startIndex: 0,
  active: true,
  watchDrag: true,
  watchResize: true,
  watchSlides: true,
  watchFocus: true
};

function OptionsHandler(ownerWindow) {
  function mergeOptions(optionsA, optionsB) {
    return objectsMergeDeep(optionsA, optionsB || {});
  }
  function optionsAtMedia(options) {
    const optionsAtMedia = options.breakpoints || {};
    const matchedMediaOptions = objectKeys(optionsAtMedia).filter(media => ownerWindow.matchMedia(media).matches).map(media => optionsAtMedia[media]).reduce((a, mediaOption) => mergeOptions(a, mediaOption), {});
    return mergeOptions(options, matchedMediaOptions);
  }
  function optionsMediaQueries(optionsList) {
    return optionsList.map(options => objectKeys(options.breakpoints || {})).reduce((acc, mediaQueries) => acc.concat(mediaQueries), []).map(ownerWindow.matchMedia);
  }
  const self = {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  };
  return self;
}

function PluginsHandler(optionsHandler) {
  let activePlugins = [];
  function init(emblaApi, plugins) {
    activePlugins = plugins.filter(({
      options
    }) => optionsHandler.optionsAtMedia(options).active !== false);
    activePlugins.forEach(plugin => plugin.init(emblaApi, optionsHandler));
    return plugins.reduce((map, plugin) => Object.assign(map, {
      [plugin.name]: plugin
    }), {});
  }
  function destroy() {
    activePlugins = activePlugins.filter(plugin => plugin.destroy());
  }
  const self = {
    init,
    destroy
  };
  return self;
}

function EmblaCarousel(root, userOptions, userPlugins) {
  const ownerDocument = root.ownerDocument;
  const ownerWindow = ownerDocument.defaultView;
  const optionsHandler = OptionsHandler(ownerWindow);
  const pluginsHandler = PluginsHandler(optionsHandler);
  const mediaHandlers = EventStore();
  const eventHandler = EventHandler();
  const {
    mergeOptions,
    optionsAtMedia,
    optionsMediaQueries
  } = optionsHandler;
  const {
    on,
    off,
    emit
  } = eventHandler;
  const reInit = reActivate;
  let destroyed = false;
  let engine;
  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions);
  let options = mergeOptions(optionsBase);
  let pluginList = [];
  let pluginApis;
  let container;
  let slides;
  function storeElements() {
    const {
      container: userContainer,
      slides: userSlides
    } = options;
    const customContainer = isString(userContainer) ? root.querySelector(userContainer) : userContainer;
    container = customContainer || root.children[0];
    const customSlides = isString(userSlides) ? container.querySelectorAll(userSlides) : userSlides;
    slides = [].slice.call(customSlides || container.children);
  }
  function createEngine(options) {
    const engine = Engine(root, container, slides, ownerDocument, ownerWindow, options, eventHandler);
    if (options.loop && !engine.slideLooper.canLoop()) {
      const optionsWithoutLoop = Object.assign({}, options, {
        loop: false
      });
      return createEngine(optionsWithoutLoop);
    }
    return engine;
  }
  function activate(withOptions, withPlugins) {
    if (destroyed) return;
    optionsBase = mergeOptions(optionsBase, withOptions);
    options = optionsAtMedia(optionsBase);
    pluginList = withPlugins || pluginList;
    storeElements();
    engine = createEngine(options);
    optionsMediaQueries([optionsBase, ...pluginList.map(({
      options
    }) => options)]).forEach(query => mediaHandlers.add(query, 'change', reActivate));
    if (!options.active) return;
    engine.translate.to(engine.location.get());
    engine.animation.init();
    engine.slidesInView.init();
    engine.slideFocus.init(self);
    engine.eventHandler.init(self);
    engine.resizeHandler.init(self);
    engine.slidesHandler.init(self);
    if (engine.options.loop) engine.slideLooper.loop();
    if (container.offsetParent && slides.length) engine.dragHandler.init(self);
    pluginApis = pluginsHandler.init(self, pluginList);
  }
  function reActivate(withOptions, withPlugins) {
    const startIndex = selectedScrollSnap();
    deActivate();
    activate(mergeOptions({
      startIndex
    }, withOptions), withPlugins);
    eventHandler.emit('reInit');
  }
  function deActivate() {
    engine.dragHandler.destroy();
    engine.eventStore.clear();
    engine.translate.clear();
    engine.slideLooper.clear();
    engine.resizeHandler.destroy();
    engine.slidesHandler.destroy();
    engine.slidesInView.destroy();
    engine.animation.destroy();
    pluginsHandler.destroy();
    mediaHandlers.clear();
  }
  function destroy() {
    if (destroyed) return;
    destroyed = true;
    mediaHandlers.clear();
    deActivate();
    eventHandler.emit('destroy');
    eventHandler.clear();
  }
  function scrollTo(index, jump, direction) {
    if (!options.active || destroyed) return;
    engine.scrollBody.useBaseFriction().useDuration(jump === true ? 0 : options.duration);
    engine.scrollTo.index(index, direction || 0);
  }
  function scrollNext(jump) {
    const next = engine.index.add(1).get();
    scrollTo(next, jump, -1);
  }
  function scrollPrev(jump) {
    const prev = engine.index.add(-1).get();
    scrollTo(prev, jump, 1);
  }
  function canScrollNext() {
    const next = engine.index.add(1).get();
    return next !== selectedScrollSnap();
  }
  function canScrollPrev() {
    const prev = engine.index.add(-1).get();
    return prev !== selectedScrollSnap();
  }
  function scrollSnapList() {
    return engine.scrollSnapList;
  }
  function scrollProgress() {
    return engine.scrollProgress.get(engine.offsetLocation.get());
  }
  function selectedScrollSnap() {
    return engine.index.get();
  }
  function previousScrollSnap() {
    return engine.indexPrevious.get();
  }
  function slidesInView() {
    return engine.slidesInView.get();
  }
  function slidesNotInView() {
    return engine.slidesInView.get(false);
  }
  function plugins() {
    return pluginApis;
  }
  function internalEngine() {
    return engine;
  }
  function rootNode() {
    return root;
  }
  function containerNode() {
    return container;
  }
  function slideNodes() {
    return slides;
  }
  const self = {
    canScrollNext,
    canScrollPrev,
    containerNode,
    internalEngine,
    destroy,
    off,
    on,
    emit,
    plugins,
    previousScrollSnap,
    reInit,
    rootNode,
    scrollNext,
    scrollPrev,
    scrollProgress,
    scrollSnapList,
    scrollTo,
    selectedScrollSnap,
    slideNodes,
    slidesInView,
    slidesNotInView
  };
  activate(userOptions, userPlugins);
  setTimeout(() => eventHandler.emit('init'), 0);
  return self;
}
EmblaCarousel.globalOptions = undefined;

export { EmblaCarousel as default };
//# sourceMappingURL=embla-carousel.esm.js.map

~~~

## node_modules\embla-carousel\esm\embla-carousel.esm.js.map

~~~map
{"version":3,"file":"embla-carousel.esm.js","sources":["../src/components/utils.ts","../src/components/Alignment.ts","../src/components/EventStore.ts","../src/components/Animations.ts","../src/components/Axis.ts","../src/components/Limit.ts","../src/components/Counter.ts","../src/components/DragHandler.ts","../src/components/DragTracker.ts","../src/components/NodeRects.ts","../src/components/PercentOfView.ts","../src/components/ResizeHandler.ts","../src/components/ScrollBody.ts","../src/components/ScrollBounds.ts","../src/components/ScrollContain.ts","../src/components/ScrollLimit.ts","../src/components/ScrollLooper.ts","../src/components/ScrollProgress.ts","../src/components/ScrollSnaps.ts","../src/components/SlideRegistry.ts","../src/components/ScrollTarget.ts","../src/components/ScrollTo.ts","../src/components/SlideFocus.ts","../src/components/Vector1d.ts","../src/components/Translate.ts","../src/components/SlideLooper.ts","../src/components/SlidesHandler.ts","../src/components/SlidesInView.ts","../src/components/SlideSizes.ts","../src/components/SlidesToScroll.ts","../src/components/Engine.ts","../src/components/EventHandler.ts","../src/components/Options.ts","../src/components/OptionsHandler.ts","../src/components/PluginsHandler.ts","../src/components/EmblaCarousel.ts"],"sourcesContent":["import { PointerEventType } from './DragTracker'\n\nexport type WindowType = Window & typeof globalThis\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isString(subject: unknown): subject is string {\n  return typeof subject === 'string'\n}\n\nexport function isBoolean(subject: unknown): subject is boolean {\n  return typeof subject === 'boolean'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return Math.sign(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToTwoDecimals(num: number): number {\n  return Math.round(num * 100) / 100\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function arrayIsLastIndex<Type>(array: Type[], index: number): boolean {\n  return index === arrayLastIndex(array)\n}\n\nexport function arrayFromNumber(n: number, startAt: number = 0): number[] {\n  return Array.from(Array(n), (_, i) => startAt + i)\n}\n\nexport function objectKeys<Type extends object>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function isMouseEvent(\n  evt: PointerEventType,\n  ownerWindow: WindowType\n): evt is MouseEvent {\n  return (\n    typeof ownerWindow.MouseEvent !== 'undefined' &&\n    evt instanceof ownerWindow.MouseEvent\n  )\n}\n","import { isString } from './utils'\n\nexport type AlignmentOptionType =\n  | 'start'\n  | 'center'\n  | 'end'\n  | ((viewSize: number, snapSize: number, index: number) => number)\n\nexport type AlignmentType = {\n  measure: (n: number, index: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function measure(n: number, index: number): number {\n    if (isString(align)) return predefined[align](n)\n    return align(viewSize, n, index)\n  }\n\n  const self: AlignmentType = {\n    measure\n  }\n  return self\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType\n  ) => EventStoreType\n  clear: () => void\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = { passive: true }\n  ): EventStoreType {\n    let removeListener: EventRemoverType\n\n    if ('addEventListener' in node) {\n      node.addEventListener(type, handler, options)\n      removeListener = () => node.removeEventListener(type, handler, options)\n    } else {\n      const legacyMediaQueryList = <MediaQueryList>node\n      legacyMediaQueryList.addListener(handler)\n      removeListener = () => legacyMediaQueryList.removeListener(handler)\n    }\n\n    listeners.push(removeListener)\n    return self\n  }\n\n  function clear(): void {\n    listeners = listeners.filter((remove) => remove())\n  }\n\n  const self: EventStoreType = {\n    add,\n    clear\n  }\n  return self\n}\n","import { EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { WindowType } from './utils'\n\nexport type AnimationsUpdateType = (engine: EngineType) => void\nexport type AnimationsRenderType = (engine: EngineType, alpha: number) => void\n\nexport type AnimationsType = {\n  init: () => void\n  destroy: () => void\n  start: () => void\n  stop: () => void\n  update: () => void\n  render: (alpha: number) => void\n}\n\nexport function Animations(\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  update: () => void,\n  render: (alpha: number) => void\n): AnimationsType {\n  const documentVisibleHandler = EventStore()\n  const fixedTimeStep = 1000 / 60\n\n  let lastTimeStamp: number | null = null\n  let accumulatedTime = 0\n  let animationId = 0\n\n  function init(): void {\n    documentVisibleHandler.add(ownerDocument, 'visibilitychange', () => {\n      if (ownerDocument.hidden) reset()\n    })\n  }\n\n  function destroy(): void {\n    stop()\n    documentVisibleHandler.clear()\n  }\n\n  function animate(timeStamp: DOMHighResTimeStamp): void {\n    if (!animationId) return\n    if (!lastTimeStamp) {\n      lastTimeStamp = timeStamp\n      update()\n      update()\n    }\n\n    const timeElapsed = timeStamp - lastTimeStamp\n    lastTimeStamp = timeStamp\n    accumulatedTime += timeElapsed\n\n    while (accumulatedTime >= fixedTimeStep) {\n      update()\n      accumulatedTime -= fixedTimeStep\n    }\n\n    const alpha = accumulatedTime / fixedTimeStep\n    render(alpha)\n\n    if (animationId) {\n      animationId = ownerWindow.requestAnimationFrame(animate)\n    }\n  }\n\n  function start(): void {\n    if (animationId) return\n    animationId = ownerWindow.requestAnimationFrame(animate)\n  }\n\n  function stop(): void {\n    ownerWindow.cancelAnimationFrame(animationId)\n    lastTimeStamp = null\n    accumulatedTime = 0\n    animationId = 0\n  }\n\n  function reset(): void {\n    lastTimeStamp = null\n    accumulatedTime = 0\n  }\n\n  const self: AnimationsType = {\n    init,\n    destroy,\n    start,\n    stop,\n    update,\n    render\n  }\n  return self\n}\n","import { NodeRectType } from './NodeRects'\n\nexport type AxisOptionType = 'x' | 'y'\nexport type AxisDirectionOptionType = 'ltr' | 'rtl'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (nodeRect: NodeRectType) => number\n  direction: (n: number) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  contentDirection: AxisDirectionOptionType\n): AxisType {\n  const isRightToLeft = contentDirection === 'rtl'\n  const isVertical = axis === 'y'\n  const scroll = isVertical ? 'y' : 'x'\n  const cross = isVertical ? 'x' : 'y'\n  const sign = !isVertical && isRightToLeft ? -1 : 1\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(nodeRect: NodeRectType): number {\n    const { height, width } = nodeRect\n    return isVertical ? height : width\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (isVertical) return 'top'\n    return isRightToLeft ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (isVertical) return 'bottom'\n    return isRightToLeft ? 'left' : 'right'\n  }\n\n  function direction(n: number): number {\n    return n * sign\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n    direction\n  }\n  return self\n}\n","import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number = 0, max: number = 0): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean\n): CounterType {\n  const { constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return clone().set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    get,\n    set,\n    add,\n    clone\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { AnimationsType } from './Animations'\nimport { CounterType } from './Counter'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1DType } from './Vector1d'\nimport { PercentOfViewType } from './PercentOfView'\nimport { Limit } from './Limit'\nimport {\n  deltaAbs,\n  factorAbs,\n  isBoolean,\n  isMouseEvent,\n  mathAbs,\n  mathSign,\n  WindowType\n} from './utils'\n\ntype DragHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  evt: PointerEventType\n) => boolean | void\n\nexport type DragHandlerOptionType = boolean | DragHandlerCallbackType\n\nexport type DragHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n  pointerDown: () => boolean\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  rootNode: HTMLElement,\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationsType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  dragFree: boolean,\n  dragThreshold: number,\n  skipSnaps: boolean,\n  baseFriction: number,\n  watchDrag: DragHandlerOptionType\n): DragHandlerType {\n  const { cross: crossAxis, direction } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const nonPassiveEvent = { passive: false }\n  const initEvents = EventStore()\n  const dragEvents = EventStore()\n  const goToNextThreshold = Limit(50, 225).constrain(percentOfView.measure(20))\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 43 : 25\n\n  let isMoving = false\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchDrag) return\n\n    function downIfAllowed(evt: PointerEventType): void {\n      if (isBoolean(watchDrag) || watchDrag(emblaApi, evt)) down(evt)\n    }\n\n    const node = rootNode\n    initEvents\n      .add(node, 'dragstart', (evt) => evt.preventDefault(), nonPassiveEvent)\n      .add(node, 'touchmove', () => undefined, nonPassiveEvent)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', downIfAllowed)\n      .add(node, 'mousedown', downIfAllowed)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click, true)\n  }\n\n  function destroy(): void {\n    initEvents.clear()\n    dragEvents.clear()\n  }\n\n  function addDragEvents(): void {\n    const node = isMouse ? ownerDocument : rootNode\n    dragEvents\n      .add(node, 'touchmove', move, nonPassiveEvent)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move, nonPassiveEvent)\n      .add(node, 'mouseup', up)\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const nodeName = node.nodeName || ''\n    return focusNodes.includes(nodeName)\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.add(mathSign(force) * -1)\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < goToNextThreshold) return baseForce\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    const isMouseEvt = isMouseEvent(evt, ownerWindow)\n    isMouse = isMouseEvt\n    preventClick = dragFree && isMouseEvt && !evt.buttons && isMoving\n    isMoving = deltaAbs(target.get(), location.get()) >= 2\n\n    if (isMouseEvt && evt.button !== 0) return\n    if (isFocusNode(evt.target as Element)) return\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    scrollBody.useFriction(0).useDuration(0)\n    target.set(location)\n    addDragEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n  }\n\n  function move(evt: PointerEventType): void {\n    const isTouchEvt = !isMouseEvent(evt, ownerWindow)\n    if (isTouchEvt && evt.touches.length >= 2) return up(evt)\n\n    const lastScroll = dragTracker.readPoint(evt)\n    const lastCross = dragTracker.readPoint(evt, crossAxis)\n    const diffScroll = deltaAbs(lastScroll, startScroll)\n    const diffCross = deltaAbs(lastCross, startCross)\n\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (diffScroll > dragThreshold) preventClick = true\n\n    scrollBody.useFriction(0.3).useDuration(0.75)\n    animation.start()\n    target.add(direction(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const speed = baseSpeed - 10 * forceFactor\n    const friction = baseFriction + forceFactor / 50\n\n    preventScroll = false\n    pointerIsDown = false\n    dragEvents.clear()\n    scrollBody.useDuration(speed).useFriction(friction)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) {\n      evt.stopPropagation()\n      evt.preventDefault()\n      preventClick = false\n    }\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    init,\n    destroy,\n    pointerDown\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { isMouseEvent, mathAbs, WindowType } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(\n  axis: AxisType,\n  ownerWindow: WindowType\n): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isMouseEvent(evt, ownerWindow) ? evt : evt.touches[0])[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint\n  }\n  return self\n}\n","export type NodeRectType = {\n  top: number\n  right: number\n  bottom: number\n  left: number\n  width: number\n  height: number\n}\n\nexport type NodeRectsType = {\n  measure: (node: HTMLElement) => NodeRectType\n}\n\nexport function NodeRects(): NodeRectsType {\n  function measure(node: HTMLElement): NodeRectType {\n    const { offsetTop, offsetLeft, offsetWidth, offsetHeight } = node\n    const offset: NodeRectType = {\n      top: offsetTop,\n      right: offsetLeft + offsetWidth,\n      bottom: offsetTop + offsetHeight,\n      left: offsetLeft,\n      width: offsetWidth,\n      height: offsetHeight\n    }\n\n    return offset\n  }\n\n  const self: NodeRectsType = {\n    measure\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { NodeRectsType } from './NodeRects'\nimport { isBoolean, mathAbs, WindowType } from './utils'\n\ntype ResizeHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  entries: ResizeObserverEntry[]\n) => boolean | void\n\nexport type ResizeHandlerOptionType = boolean | ResizeHandlerCallbackType\n\nexport type ResizeHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n}\n\nexport function ResizeHandler(\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  ownerWindow: WindowType,\n  slides: HTMLElement[],\n  axis: AxisType,\n  watchResize: ResizeHandlerOptionType,\n  nodeRects: NodeRectsType\n): ResizeHandlerType {\n  const observeNodes = [container].concat(slides)\n  let resizeObserver: ResizeObserver\n  let containerSize: number\n  let slideSizes: number[] = []\n  let destroyed = false\n\n  function readSize(node: HTMLElement): number {\n    return axis.measureSize(nodeRects.measure(node))\n  }\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchResize) return\n\n    containerSize = readSize(container)\n    slideSizes = slides.map(readSize)\n\n    function defaultCallback(entries: ResizeObserverEntry[]): void {\n      for (const entry of entries) {\n        if (destroyed) return\n\n        const isContainer = entry.target === container\n        const slideIndex = slides.indexOf(<HTMLElement>entry.target)\n        const lastSize = isContainer ? containerSize : slideSizes[slideIndex]\n        const newSize = readSize(isContainer ? container : slides[slideIndex])\n        const diffSize = mathAbs(newSize - lastSize)\n\n        if (diffSize >= 0.5) {\n          emblaApi.reInit()\n          eventHandler.emit('resize')\n\n          break\n        }\n      }\n    }\n\n    resizeObserver = new ResizeObserver((entries) => {\n      if (isBoolean(watchResize) || watchResize(emblaApi, entries)) {\n        defaultCallback(entries)\n      }\n    })\n\n    ownerWindow.requestAnimationFrame(() => {\n      observeNodes.forEach((node) => resizeObserver.observe(node))\n    })\n  }\n\n  function destroy(): void {\n    destroyed = true\n    if (resizeObserver) resizeObserver.disconnect()\n  }\n\n  const self: ResizeHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { mathSign, mathAbs } from './utils'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  duration: () => number\n  velocity: () => number\n  seek: () => ScrollBodyType\n  settled: () => boolean\n  useBaseFriction: () => ScrollBodyType\n  useBaseDuration: () => ScrollBodyType\n  useFriction: (n: number) => ScrollBodyType\n  useDuration: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  offsetLocation: Vector1DType,\n  previousLocation: Vector1DType,\n  target: Vector1DType,\n  baseDuration: number,\n  baseFriction: number\n): ScrollBodyType {\n  let scrollVelocity = 0\n  let scrollDirection = 0\n  let scrollDuration = baseDuration\n  let scrollFriction = baseFriction\n  let rawLocation = location.get()\n  let rawLocationPrevious = 0\n\n  function seek(): ScrollBodyType {\n    const displacement = target.get() - location.get()\n    const isInstant = !scrollDuration\n    let scrollDistance = 0\n\n    if (isInstant) {\n      scrollVelocity = 0\n      previousLocation.set(target)\n      location.set(target)\n\n      scrollDistance = displacement\n    } else {\n      previousLocation.set(location)\n\n      scrollVelocity += displacement / scrollDuration\n      scrollVelocity *= scrollFriction\n      rawLocation += scrollVelocity\n      location.add(scrollVelocity)\n\n      scrollDistance = rawLocation - rawLocationPrevious\n    }\n\n    scrollDirection = mathSign(scrollDistance)\n    rawLocationPrevious = rawLocation\n    return self\n  }\n\n  function settled(): boolean {\n    const diff = target.get() - offsetLocation.get()\n    return mathAbs(diff) < 0.001\n  }\n\n  function duration(): number {\n    return scrollDuration\n  }\n\n  function direction(): number {\n    return scrollDirection\n  }\n\n  function velocity(): number {\n    return scrollVelocity\n  }\n\n  function useBaseDuration(): ScrollBodyType {\n    return useDuration(baseDuration)\n  }\n\n  function useBaseFriction(): ScrollBodyType {\n    return useFriction(baseFriction)\n  }\n\n  function useDuration(n: number): ScrollBodyType {\n    scrollDuration = n\n    return self\n  }\n\n  function useFriction(n: number): ScrollBodyType {\n    scrollFriction = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    duration,\n    velocity,\n    seek,\n    settled,\n    useBaseFriction,\n    useBaseDuration,\n    useFriction,\n    useDuration\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  shouldConstrain: () => boolean\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const frictionLimit = Limit(0.1, 0.99)\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = frictionLimit.constrain(diffToEdge / edgeOffsetTolerance)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useDuration(25).useBaseFriction()\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    shouldConstrain,\n    constrain,\n    toggleActive\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayIsLastIndex, arrayLast, deltaAbs } from './utils'\n\nexport type ScrollContainOptionType = false | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n  scrollContainLimit: LimitType\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n  pixelTolerance: number\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, 0)\n  const snapsBounded = measureBounded()\n  const scrollContainLimit = findScrollContainLimit()\n  const snapsContained = measureContained()\n\n  function usePixelTolerance(bound: number, snap: number): boolean {\n    return deltaAbs(bound, snap) <= 1\n  }\n\n  function findScrollContainLimit(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureBounded(): number[] {\n    return snapsAligned\n      .map((snapAligned, index) => {\n        const { min, max } = scrollBounds\n        const snap = scrollBounds.constrain(snapAligned)\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(snapsAligned, index)\n        if (isFirst) return max\n        if (isLast) return min\n        if (usePixelTolerance(min, snap)) return min\n        if (usePixelTolerance(max, snap)) return max\n        return snap\n      })\n      .map((scrollBound) => parseFloat(scrollBound.toFixed(3)))\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize + pixelTolerance) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = scrollContainLimit\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n    scrollContainLimit\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean\n): ScrollLimitType {\n  const max = scrollSnaps[0]\n  const min = loop ? max - contentSize : arrayLast(scrollSnaps)\n  const limit = Limit(min, max)\n\n  const self: ScrollLimitType = {\n    limit\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[]\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return length ? currentLocation / -length : 0\n  }\n\n  const self: ScrollProgressType = {\n    get\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slidesToScroll: SlidesToScrollType\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index) => snap + alignments[index])\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport {\n  arrayFromNumber,\n  arrayIsLastIndex,\n  arrayLast,\n  arrayLastIndex\n} from './utils'\n\nexport type SlideRegistryType = {\n  slideRegistry: number[][]\n}\n\nexport function SlideRegistry(\n  containSnaps: boolean,\n  containScroll: ScrollContainOptionType,\n  scrollSnaps: number[],\n  scrollContainLimit: LimitType,\n  slidesToScroll: SlidesToScrollType,\n  slideIndexes: number[]\n): SlideRegistryType {\n  const { groupSlides } = slidesToScroll\n  const { min, max } = scrollContainLimit\n  const slideRegistry = createSlideRegistry()\n\n  function createSlideRegistry(): number[][] {\n    const groupedSlideIndexes = groupSlides(slideIndexes)\n    const doNotContain = !containSnaps || containScroll === 'keepSnaps'\n\n    if (scrollSnaps.length === 1) return [slideIndexes]\n    if (doNotContain) return groupedSlideIndexes\n\n    return groupedSlideIndexes.slice(min, max).map((group, index, groups) => {\n      const isFirst = !index\n      const isLast = arrayIsLastIndex(groups, index)\n\n      if (isFirst) {\n        const range = arrayLast(groups[0]) + 1\n        return arrayFromNumber(range)\n      }\n      if (isLast) {\n        const range = arrayLastIndex(slideIndexes) - arrayLast(groups)[0] + 1\n        return arrayFromNumber(range, arrayLast(groups)[0])\n      }\n      return group\n    })\n  }\n\n  const self: SlideRegistryType = {\n    slideRegistry\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { arrayLast, mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((snap, index) => ({ diff: shortcut(snap - distance, 0), index }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return target\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    if (matchingTargets.length) return minDistance(matchingTargets)\n    return arrayLast(targets) - contentSize\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut\n  }\n  return self\n}\n","import { AnimationsType } from './Animations'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationsType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    targetVector.add(distanceDiff)\n\n    if (distanceDiff) {\n      if (scrollBody.duration()) {\n        animation.start()\n      } else {\n        animation.update()\n        animation.render(1)\n        animation.update()\n      }\n    }\n\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStoreType } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollToType } from './ScrollTo'\nimport { SlideRegistryType } from './SlideRegistry'\nimport { isBoolean, isNumber } from './utils'\n\ntype FocusHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  evt: FocusEvent\n) => boolean | void\n\nexport type FocusHandlerOptionType = boolean | FocusHandlerCallbackType\n\nexport type SlideFocusType = {\n  init: (emblaApi: EmblaCarouselType) => void\n}\n\nexport function SlideFocus(\n  root: HTMLElement,\n  slides: HTMLElement[],\n  slideRegistry: SlideRegistryType['slideRegistry'],\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  eventStore: EventStoreType,\n  eventHandler: EventHandlerType,\n  watchFocus: FocusHandlerOptionType\n): SlideFocusType {\n  const focusListenerOptions = { passive: true, capture: true }\n  let lastTabPressTime = 0\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchFocus) return\n\n    function defaultCallback(index: number): void {\n      const nowTime = new Date().getTime()\n      const diffTime = nowTime - lastTabPressTime\n\n      if (diffTime > 10) return\n\n      eventHandler.emit('slideFocusStart')\n      root.scrollLeft = 0\n\n      const group = slideRegistry.findIndex((group) => group.includes(index))\n\n      if (!isNumber(group)) return\n\n      scrollBody.useDuration(0)\n      scrollTo.index(group, 0)\n\n      eventHandler.emit('slideFocus')\n    }\n\n    eventStore.add(document, 'keydown', registerTabPress, false)\n\n    slides.forEach((slide, slideIndex) => {\n      eventStore.add(\n        slide,\n        'focus',\n        (evt: FocusEvent) => {\n          if (isBoolean(watchFocus) || watchFocus(emblaApi, evt)) {\n            defaultCallback(slideIndex)\n          }\n        },\n        focusListenerOptions\n      )\n    })\n  }\n\n  function registerTabPress(event: KeyboardEvent): void {\n    if (event.code === 'Tab') lastTabPressTime = new Date().getTime()\n  }\n\n  const self: SlideFocusType = {\n    init\n  }\n  return self\n}\n","import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (n: Vector1DType | number) => void\n  add: (n: Vector1DType | number) => void\n  subtract: (n: Vector1DType | number) => void\n}\n\nexport function Vector1D(initialValue: number): Vector1DType {\n  let value = initialValue\n\n  function get(): number {\n    return value\n  }\n\n  function set(n: Vector1DType | number): void {\n    value = normalizeInput(n)\n  }\n\n  function add(n: Vector1DType | number): void {\n    value += normalizeInput(n)\n  }\n\n  function subtract(n: Vector1DType | number): void {\n    value -= normalizeInput(n)\n  }\n\n  function normalizeInput(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    get,\n    set,\n    add,\n    subtract\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { roundToTwoDecimals } from './utils'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (target: number) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  container: HTMLElement\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let previousTarget: number | null = null\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: number): void {\n    if (disabled) return\n\n    const newTarget = roundToTwoDecimals(axis.direction(target))\n    if (newTarget === previousTarget) return\n\n    containerStyle.transform = translate(newTarget)\n    previousTarget = newTarget\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\n\ntype SlideBoundType = {\n  start: number\n  end: number\n}\n\ntype LoopPointType = {\n  loopPoint: number\n  index: number\n  translate: TranslateType\n  slideLocation: Vector1DType\n  target: () => number\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  slideSizesWithGaps: number[],\n  snaps: number[],\n  scrollSnaps: number[],\n  location: Vector1DType,\n  slides: HTMLElement[]\n): SlideLooperType {\n  const roundingSafety = 0.5\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findSlideBounds(offset: number): SlideBoundType[] {\n    return snaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + roundingSafety + offset,\n      end: snap + viewSize - roundingSafety + offset\n    }))\n  }\n\n  function findLoopPoints(\n    indexes: number[],\n    offset: number,\n    isEndEdge: boolean\n  ): LoopPointType[] {\n    const slideBounds = findSlideBounds(offset)\n\n    return indexes.map((index) => {\n      const initial = isEndEdge ? 0 : -contentSize\n      const altered = isEndEdge ? contentSize : 0\n      const boundEdge = isEndEdge ? 'end' : 'start'\n      const loopPoint = slideBounds[index][boundEdge]\n\n      return {\n        index,\n        loopPoint,\n        slideLocation: Vector1D(-1),\n        translate: Translate(axis, slides[index]),\n        target: () => (location.get() > loopPoint ? initial : altered)\n      }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0]\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, contentSize, false)\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, -contentSize, true)\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, slideLocation } = loopPoint\n      const shiftLocation = target()\n      if (shiftLocation === slideLocation.get()) return\n      translate.to(shiftLocation)\n      slideLocation.set(shiftLocation)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { EventHandlerType } from './EventHandler'\nimport { isBoolean } from './utils'\n\ntype SlidesHandlerCallbackType = (\n  emblaApi: EmblaCarouselType,\n  mutations: MutationRecord[]\n) => boolean | void\n\nexport type SlidesHandlerOptionType = boolean | SlidesHandlerCallbackType\n\nexport type SlidesHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  destroy: () => void\n}\n\nexport function SlidesHandler(\n  container: HTMLElement,\n  eventHandler: EventHandlerType,\n  watchSlides: SlidesHandlerOptionType\n): SlidesHandlerType {\n  let mutationObserver: MutationObserver\n  let destroyed = false\n\n  function init(emblaApi: EmblaCarouselType): void {\n    if (!watchSlides) return\n\n    function defaultCallback(mutations: MutationRecord[]): void {\n      for (const mutation of mutations) {\n        if (mutation.type === 'childList') {\n          emblaApi.reInit()\n          eventHandler.emit('slidesChanged')\n          break\n        }\n      }\n    }\n\n    mutationObserver = new MutationObserver((mutations) => {\n      if (destroyed) return\n      if (isBoolean(watchSlides) || watchSlides(emblaApi, mutations)) {\n        defaultCallback(mutations)\n      }\n    })\n\n    mutationObserver.observe(container, { childList: true })\n  }\n\n  function destroy(): void {\n    if (mutationObserver) mutationObserver.disconnect()\n    destroyed = true\n  }\n\n  const self: SlidesHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { EventHandlerType } from './EventHandler'\nimport { objectKeys } from './utils'\n\ntype IntersectionEntryMapType = {\n  [key: number]: IntersectionObserverEntry\n}\n\nexport type SlidesInViewOptionsType = IntersectionObserverInit['threshold']\n\nexport type SlidesInViewType = {\n  init: () => void\n  destroy: () => void\n  get: (inView?: boolean) => number[]\n}\n\nexport function SlidesInView(\n  container: HTMLElement,\n  slides: HTMLElement[],\n  eventHandler: EventHandlerType,\n  threshold: SlidesInViewOptionsType\n): SlidesInViewType {\n  const intersectionEntryMap: IntersectionEntryMapType = {}\n  let inViewCache: number[] | null = null\n  let notInViewCache: number[] | null = null\n  let intersectionObserver: IntersectionObserver\n  let destroyed = false\n\n  function init(): void {\n    intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        if (destroyed) return\n\n        entries.forEach((entry) => {\n          const index = slides.indexOf(<HTMLElement>entry.target)\n          intersectionEntryMap[index] = entry\n        })\n\n        inViewCache = null\n        notInViewCache = null\n        eventHandler.emit('slidesInView')\n      },\n      {\n        root: container.parentElement,\n        threshold\n      }\n    )\n\n    slides.forEach((slide) => intersectionObserver.observe(slide))\n  }\n\n  function destroy(): void {\n    if (intersectionObserver) intersectionObserver.disconnect()\n    destroyed = true\n  }\n\n  function createInViewList(inView: boolean): number[] {\n    return objectKeys(intersectionEntryMap).reduce(\n      (list: number[], slideIndex) => {\n        const index = parseInt(slideIndex)\n        const { isIntersecting } = intersectionEntryMap[index]\n        const inViewMatch = inView && isIntersecting\n        const notInViewMatch = !inView && !isIntersecting\n\n        if (inViewMatch || notInViewMatch) list.push(index)\n        return list\n      },\n      []\n    )\n  }\n\n  function get(inView: boolean = true): number[] {\n    if (inView && inViewCache) return inViewCache\n    if (!inView && notInViewCache) return notInViewCache\n\n    const slideIndexes = createInViewList(inView)\n\n    if (inView) inViewCache = slideIndexes\n    if (!inView) notInViewCache = slideIndexes\n\n    return slideIndexes\n  }\n\n  const self: SlidesInViewType = {\n    init,\n    destroy,\n    get\n  }\n\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport { arrayIsLastIndex, arrayLast, mathAbs, WindowType } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n  startGap: number\n  endGap: number\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  slides: HTMLElement[],\n  readEdgeGap: boolean,\n  ownerWindow: WindowType\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const withEdgeGap = slideRects[0] && readEdgeGap\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!withEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!withEdgeGap) return 0\n    const style = ownerWindow.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = arrayIsLastIndex(rects, index)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n    startGap,\n    endGap\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { NodeRectType } from './NodeRects'\nimport {\n  arrayKeys,\n  arrayLast,\n  arrayLastIndex,\n  isNumber,\n  mathAbs\n} from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  axis: AxisType,\n  viewSize: number,\n  slidesToScroll: SlidesToScrollOptionType,\n  loop: boolean,\n  containerRect: NodeRectType,\n  slideRects: NodeRectType[],\n  startGap: number,\n  endGap: number,\n  pixelTolerance: number\n): SlidesToScrollType {\n  const { startEdge, endEdge, direction } = axis\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    if (!array.length) return []\n\n    return arrayKeys(array)\n      .reduce((groups: number[], rectB, index) => {\n        const rectA = arrayLast(groups) || 0\n        const isFirst = rectA === 0\n        const isLast = rectB === arrayLastIndex(array)\n\n        const edgeA = containerRect[startEdge] - slideRects[rectA][startEdge]\n        const edgeB = containerRect[startEdge] - slideRects[rectB][endEdge]\n        const gapA = !loop && isFirst ? direction(startGap) : 0\n        const gapB = !loop && isLast ? direction(endGap) : 0\n        const chunkSize = mathAbs(edgeB - gapB - (edgeA + gapA))\n\n        if (index && chunkSize > viewSize + pixelTolerance) groups.push(rectB)\n        if (isLast) groups.push(array.length)\n        return groups\n      }, [])\n      .map((currentSize, index, groups) => {\n        const previousSize = Math.max(groups[index - 1] || 0)\n        return array.slice(previousSize, currentSize)\n      })\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport {\n  Animations,\n  AnimationsType,\n  AnimationsUpdateType,\n  AnimationsRenderType\n} from './Animations'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { NodeRectType, NodeRects } from './NodeRects'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ResizeHandler, ResizeHandlerType } from './ResizeHandler'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { SlideRegistry, SlideRegistryType } from './SlideRegistry'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideFocus, SlideFocusType } from './SlideFocus'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesHandler, SlidesHandlerType } from './SlidesHandler'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex, WindowType } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  ownerDocument: Document\n  ownerWindow: WindowType\n  eventHandler: EventHandlerType\n  axis: AxisType\n  animation: AnimationsType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  offsetLocation: Vector1DType\n  previousLocation: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  resizeHandler: ResizeHandlerType\n  slidesHandler: SlidesHandlerType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnapList: number[]\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  slideFocus: SlideFocusType\n  slideRegistry: SlideRegistryType['slideRegistry']\n  containerRect: NodeRectType\n  slideRects: NodeRectType[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  ownerDocument: Document,\n  ownerWindow: WindowType,\n  options: OptionsType,\n  eventHandler: EventHandlerType\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction,\n    startIndex,\n    loop,\n    duration,\n    dragFree,\n    dragThreshold,\n    inViewThreshold,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n    watchResize,\n    watchSlides,\n    watchDrag,\n    watchFocus\n  } = options\n\n  // Measurements\n  const pixelTolerance = 2\n  const nodeRects = NodeRects()\n  const containerRect = nodeRects.measure(container)\n  const slideRects = slides.map(nodeRects.measure)\n  const axis = Axis(scrollAxis, direction)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && !!containScroll\n  const readEdgeGap = loop || !!containScroll\n  const { slideSizes, slideSizesWithGaps, startGap, endGap } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    readEdgeGap,\n    ownerWindow\n  )\n  const slidesToScroll = SlidesToScroll(\n    axis,\n    viewSize,\n    groupSlides,\n    loop,\n    containerRect,\n    slideRects,\n    startGap,\n    endGap,\n    pixelTolerance\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slidesToScroll\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained, scrollContainLimit } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n    pixelTolerance\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Animation\n  const update: AnimationsUpdateType = ({\n    dragHandler,\n    scrollBody,\n    scrollBounds,\n    options: { loop }\n  }) => {\n    if (!loop) scrollBounds.constrain(dragHandler.pointerDown())\n    scrollBody.seek()\n  }\n\n  const render: AnimationsRenderType = (\n    {\n      scrollBody,\n      translate,\n      location,\n      offsetLocation,\n      previousLocation,\n      scrollLooper,\n      slideLooper,\n      dragHandler,\n      animation,\n      eventHandler,\n      scrollBounds,\n      options: { loop }\n    },\n    alpha\n  ) => {\n    const shouldSettle = scrollBody.settled()\n    const withinBounds = !scrollBounds.shouldConstrain()\n    const hasSettled = loop ? shouldSettle : shouldSettle && withinBounds\n    const hasSettledAndIdle = hasSettled && !dragHandler.pointerDown()\n\n    if (hasSettledAndIdle) animation.stop()\n\n    const interpolatedLocation =\n      location.get() * alpha + previousLocation.get() * (1 - alpha)\n\n    offsetLocation.set(interpolatedLocation)\n\n    if (loop) {\n      scrollLooper.loop(scrollBody.direction())\n      slideLooper.loop()\n    }\n\n    translate.to(offsetLocation.get())\n\n    if (hasSettledAndIdle) eventHandler.emit('settle')\n    if (!hasSettled) eventHandler.emit('scroll')\n  }\n\n  const animation = Animations(\n    ownerDocument,\n    ownerWindow,\n    () => update(engine),\n    (alpha: number) => render(engine, alpha)\n  )\n\n  // Shared\n  const friction = 0.68\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const previousLocation = Vector1D(startLocation)\n  const offsetLocation = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(\n    location,\n    offsetLocation,\n    previousLocation,\n    target,\n    duration,\n    friction\n  )\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollBody,\n    scrollTarget,\n    target,\n    eventHandler\n  )\n  const scrollProgress = ScrollProgress(limit)\n  const eventStore = EventStore()\n  const slidesInView = SlidesInView(\n    container,\n    slides,\n    eventHandler,\n    inViewThreshold\n  )\n  const { slideRegistry } = SlideRegistry(\n    containSnaps,\n    containScroll,\n    scrollSnaps,\n    scrollContainLimit,\n    slidesToScroll,\n    slideIndexes\n  )\n  const slideFocus = SlideFocus(\n    root,\n    slides,\n    slideRegistry,\n    scrollTo,\n    scrollBody,\n    eventStore,\n    eventHandler,\n    watchFocus\n  )\n\n  // Engine\n  const engine: EngineType = {\n    ownerDocument,\n    ownerWindow,\n    eventHandler,\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    dragHandler: DragHandler(\n      axis,\n      root,\n      ownerDocument,\n      ownerWindow,\n      target,\n      DragTracker(axis, ownerWindow),\n      location,\n      animation,\n      scrollTo,\n      scrollBody,\n      scrollTarget,\n      index,\n      eventHandler,\n      percentOfView,\n      dragFree,\n      dragThreshold,\n      skipSnaps,\n      friction,\n      watchDrag\n    ),\n    eventStore,\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    offsetLocation,\n    previousLocation,\n    options,\n    resizeHandler: ResizeHandler(\n      container,\n      eventHandler,\n      ownerWindow,\n      slides,\n      axis,\n      watchResize,\n      nodeRects\n    ),\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      offsetLocation,\n      target,\n      scrollBody,\n      percentOfView\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, offsetLocation, [\n      location,\n      offsetLocation,\n      previousLocation,\n      target\n    ]),\n    scrollProgress,\n    scrollSnapList: scrollSnaps.map(scrollProgress.get),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      viewSize,\n      contentSize,\n      slideSizes,\n      slideSizesWithGaps,\n      snaps,\n      scrollSnaps,\n      offsetLocation,\n      slides\n    ),\n    slideFocus,\n    slidesHandler: SlidesHandler(container, eventHandler, watchSlides),\n    slidesInView,\n    slideIndexes,\n    slideRegistry,\n    slidesToScroll,\n    target,\n    translate: Translate(axis, container)\n  }\n\n  return engine\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\n\ntype CallbackType = (emblaApi: EmblaCarouselType, evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType = EmblaEventListType[keyof EmblaEventListType]\n\nexport interface EmblaEventListType {\n  init: 'init'\n  pointerDown: 'pointerDown'\n  pointerUp: 'pointerUp'\n  slidesChanged: 'slidesChanged'\n  slidesInView: 'slidesInView'\n  scroll: 'scroll'\n  select: 'select'\n  settle: 'settle'\n  destroy: 'destroy'\n  reInit: 'reInit'\n  resize: 'resize'\n  slideFocusStart: 'slideFocusStart'\n  slideFocus: 'slideFocus'\n}\n\nexport type EventHandlerType = {\n  init: (emblaApi: EmblaCarouselType) => void\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  clear: () => void\n}\n\nexport function EventHandler(): EventHandlerType {\n  let listeners: ListenersType = {}\n  let api: EmblaCarouselType\n\n  function init(emblaApi: EmblaCarouselType): void {\n    api = emblaApi\n  }\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(api, evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  function clear(): void {\n    listeners = {}\n  }\n\n  const self: EventHandlerType = {\n    init,\n    emit,\n    off,\n    on,\n    clear\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisDirectionOptionType, AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { ScrollContainOptionType } from './ScrollContain'\nimport { DragHandlerOptionType } from './DragHandler'\nimport { ResizeHandlerOptionType } from './ResizeHandler'\nimport { SlidesHandlerOptionType } from './SlidesHandler'\nimport { SlidesInViewOptionsType } from './SlidesInView'\nimport { FocusHandlerOptionType } from './SlideFocus'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  container: string | HTMLElement | null\n  slides: string | HTMLElement[] | NodeListOf<HTMLElement> | null\n  containScroll: ScrollContainOptionType\n  direction: AxisDirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  dragThreshold: number\n  inViewThreshold: SlidesInViewOptionsType\n  loop: boolean\n  skipSnaps: boolean\n  duration: number\n  startIndex: number\n  watchDrag: DragHandlerOptionType\n  watchResize: ResizeHandlerOptionType\n  watchSlides: SlidesHandlerOptionType\n  watchFocus: FocusHandlerOptionType\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  container: null,\n  slides: null,\n  containScroll: 'trimSnaps',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  inViewThreshold: 0,\n  breakpoints: {},\n  dragFree: false,\n  dragThreshold: 10,\n  loop: false,\n  skipSnaps: false,\n  duration: 25,\n  startIndex: 0,\n  active: true,\n  watchDrag: true,\n  watchResize: true,\n  watchSlides: true,\n  watchFocus: true\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsMergeDeep, WindowType } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  mergeOptions: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ) => TypeA\n  optionsAtMedia: <Type extends OptionsType>(options: Type) => Type\n  optionsMediaQueries: (optionsList: OptionsType[]) => MediaQueryList[]\n}\n\nexport function OptionsHandler(ownerWindow: WindowType): OptionsHandlerType {\n  function mergeOptions<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function optionsAtMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => ownerWindow.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => mergeOptions(a, mediaOption), {})\n\n    return mergeOptions(options, matchedMediaOptions)\n  }\n\n  function optionsMediaQueries(optionsList: OptionsType[]): MediaQueryList[] {\n    return optionsList\n      .map((options) => objectKeys(options.breakpoints || {}))\n      .reduce((acc, mediaQueries) => acc.concat(mediaQueries), [])\n      .map(ownerWindow.matchMedia)\n  }\n\n  const self: OptionsHandlerType = {\n    mergeOptions,\n    optionsAtMedia,\n    optionsMediaQueries\n  }\n  return self\n}\n","import { EmblaCarouselType } from './EmblaCarousel'\nimport { OptionsHandlerType } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type PluginsHandlerType = {\n  init: (\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ) => EmblaPluginsType\n  destroy: () => void\n}\n\nexport function PluginsHandler(\n  optionsHandler: OptionsHandlerType\n): PluginsHandlerType {\n  let activePlugins: EmblaPluginType[] = []\n\n  function init(\n    emblaApi: EmblaCarouselType,\n    plugins: EmblaPluginType[]\n  ): EmblaPluginsType {\n    activePlugins = plugins.filter(\n      ({ options }) => optionsHandler.optionsAtMedia(options).active !== false\n    )\n    activePlugins.forEach((plugin) => plugin.init(emblaApi, optionsHandler))\n\n    return plugins.reduce(\n      (map, plugin) => Object.assign(map, { [plugin.name]: plugin }),\n      {}\n    )\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType, OptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\nimport { isString, WindowType } from './utils'\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  emit: EventHandlerType['emit']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: () => number[]\n  slidesNotInView: () => number[]\n}\n\nfunction EmblaCarousel(\n  root: HTMLElement,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[]\n): EmblaCarouselType {\n  const ownerDocument = root.ownerDocument\n  const ownerWindow = <WindowType>ownerDocument.defaultView\n  const optionsHandler = OptionsHandler(ownerWindow)\n  const pluginsHandler = PluginsHandler(optionsHandler)\n  const mediaHandlers = EventStore()\n  const eventHandler = EventHandler()\n  const { mergeOptions, optionsAtMedia, optionsMediaQueries } = optionsHandler\n  const { on, off, emit } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = mergeOptions(defaultOptions, EmblaCarousel.globalOptions)\n  let options = mergeOptions(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const { container: userContainer, slides: userSlides } = options\n\n    const customContainer = isString(userContainer)\n      ? root.querySelector(userContainer)\n      : userContainer\n    container = <HTMLElement>(customContainer || root.children[0])\n\n    const customSlides = isString(userSlides)\n      ? container.querySelectorAll(userSlides)\n      : userSlides\n    slides = <HTMLElement[]>[].slice.call(customSlides || container.children)\n  }\n\n  function createEngine(options: OptionsType): EngineType {\n    const engine = Engine(\n      root,\n      container,\n      slides,\n      ownerDocument,\n      ownerWindow,\n      options,\n      eventHandler\n    )\n\n    if (options.loop && !engine.slideLooper.canLoop()) {\n      const optionsWithoutLoop = Object.assign({}, options, { loop: false })\n      return createEngine(optionsWithoutLoop)\n    }\n    return engine\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    if (destroyed) return\n\n    optionsBase = mergeOptions(optionsBase, withOptions)\n    options = optionsAtMedia(optionsBase)\n    pluginList = withPlugins || pluginList\n\n    storeElements()\n\n    engine = createEngine(options)\n\n    optionsMediaQueries([\n      optionsBase,\n      ...pluginList.map(({ options }) => options)\n    ]).forEach((query) => mediaHandlers.add(query, 'change', reActivate))\n\n    if (!options.active) return\n\n    engine.translate.to(engine.location.get())\n    engine.animation.init()\n    engine.slidesInView.init()\n    engine.slideFocus.init(self)\n    engine.eventHandler.init(self)\n    engine.resizeHandler.init(self)\n    engine.slidesHandler.init(self)\n\n    if (engine.options.loop) engine.slideLooper.loop()\n    if (container.offsetParent && slides.length) engine.dragHandler.init(self)\n\n    pluginApis = pluginsHandler.init(self, pluginList)\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[]\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(mergeOptions({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.destroy()\n    engine.eventStore.clear()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    engine.resizeHandler.destroy()\n    engine.slidesHandler.destroy()\n    engine.slidesInView.destroy()\n    engine.animation.destroy()\n    pluginsHandler.destroy()\n    mediaHandlers.clear()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    mediaHandlers.clear()\n    deActivate()\n    eventHandler.emit('destroy')\n    eventHandler.clear()\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody\n      .useBaseFriction()\n      .useDuration(jump === true ? 0 : options.duration)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.add(1).get()\n    scrollTo(next, jump, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.add(-1).get()\n    scrollTo(prev, jump, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.add(1).get()\n    return next !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.add(-1).get()\n    return prev !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnapList\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.offsetLocation.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function slidesInView(): number[] {\n    return engine.slidesInView.get()\n  }\n\n  function slidesNotInView(): number[] {\n    return engine.slidesInView.get(false)\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    emit,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView\n  }\n\n  activate(userOptions, userPlugins)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\ndeclare namespace EmblaCarousel {\n  let globalOptions: EmblaOptionsType | undefined\n}\n\nEmblaCarousel.globalOptions = undefined\n\nexport default EmblaCarousel\n"],"names":["isNumber","subject","isString","isBoolean","isObject","Object","prototype","toString","call","mathAbs","n","Math","abs","mathSign","sign","deltaAbs","valueB","valueA","factorAbs","diff","roundToTwoDecimals","num","round","arrayKeys","array","objectKeys","map","Number","arrayLast","arrayLastIndex","max","length","arrayIsLastIndex","index","arrayFromNumber","startAt","Array","from","_","i","object","keys","objectsMergeDeep","objectA","objectB","reduce","mergedObjects","currentObject","forEach","key","areObjects","isMouseEvent","evt","ownerWindow","MouseEvent","Alignment","align","viewSize","predefined","start","center","end","measure","self","EventStore","listeners","add","node","type","handler","options","passive","removeListener","addEventListener","removeEventListener","legacyMediaQueryList","addListener","push","clear","filter","remove","Animations","ownerDocument","update","render","documentVisibleHandler","fixedTimeStep","lastTimeStamp","accumulatedTime","animationId","init","hidden","reset","destroy","stop","animate","timeStamp","timeElapsed","alpha","requestAnimationFrame","cancelAnimationFrame","Axis","axis","contentDirection","isRightToLeft","isVertical","scroll","cross","startEdge","getStartEdge","endEdge","getEndEdge","measureSize","nodeRect","height","width","direction","Limit","min","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","loop","loopEnd","counter","withinLimit","get","set","clone","DragHandler","rootNode","target","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","eventHandler","percentOfView","dragFree","dragThreshold","skipSnaps","baseFriction","watchDrag","crossAxis","focusNodes","nonPassiveEvent","initEvents","dragEvents","goToNextThreshold","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","isMoving","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","emblaApi","downIfAllowed","down","preventDefault","undefined","up","click","addDragEvents","move","isFocusNode","nodeName","includes","forceBoost","boost","allowedForce","force","targetChanged","next","baseForce","byDistance","distance","byIndex","isMouseEvt","buttons","button","pointerDown","useFriction","useDuration","readPoint","emit","isTouchEvt","touches","lastScroll","lastCross","diffScroll","diffCross","cancelable","pointerMove","currentLocation","rawForce","pointerUp","forceFactor","speed","friction","stopPropagation","DragTracker","logInterval","startEvent","lastEvent","readTime","evtAxis","property","coord","expired","diffDrag","diffTime","isFlick","NodeRects","offsetTop","offsetLeft","offsetWidth","offsetHeight","offset","top","right","bottom","left","PercentOfView","ResizeHandler","container","slides","watchResize","nodeRects","observeNodes","concat","resizeObserver","containerSize","slideSizes","destroyed","readSize","defaultCallback","entries","entry","isContainer","slideIndex","indexOf","lastSize","newSize","diffSize","reInit","ResizeObserver","observe","disconnect","ScrollBody","offsetLocation","previousLocation","baseDuration","scrollVelocity","scrollDirection","scrollDuration","scrollFriction","rawLocation","rawLocationPrevious","seek","displacement","isInstant","scrollDistance","settled","duration","velocity","useBaseDuration","useBaseFriction","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","frictionLimit","disabled","shouldConstrain","edge","diffToEdge","diffToTarget","subtract","toggleActive","active","ScrollContain","contentSize","snapsAligned","containScroll","pixelTolerance","scrollBounds","snapsBounded","measureBounded","scrollContainLimit","findScrollContainLimit","snapsContained","measureContained","usePixelTolerance","bound","snap","startSnap","endSnap","lastIndexOf","snapAligned","isFirst","isLast","scrollBound","parseFloat","toFixed","slice","ScrollLimit","scrollSnaps","ScrollLooper","vectors","jointSafety","shouldLoop","loopDistance","v","ScrollProgress","ScrollSnaps","alignment","containerRect","slideRects","slidesToScroll","groupSlides","alignments","measureSizes","snaps","measureUnaligned","measureAligned","rects","rect","g","SlideRegistry","containSnaps","slideIndexes","slideRegistry","createSlideRegistry","groupedSlideIndexes","doNotContain","group","groups","range","ScrollTarget","targetVector","minDistance","distances","sort","a","b","findTargetSnap","ascDiffsToSnaps","shortcut","d1","d2","targets","matchingTargets","t","diffToSnap","targetSnapDistance","reachedBound","snapDistance","ScrollTo","indexCurrent","indexPrevious","distanceDiff","indexDiff","targetIndex","SlideFocus","root","eventStore","watchFocus","focusListenerOptions","capture","lastTabPressTime","nowTime","Date","getTime","scrollLeft","findIndex","document","registerTabPress","slide","event","code","Vector1D","initialValue","value","normalizeInput","Translate","translate","x","y","containerStyle","style","previousTarget","to","newTarget","transform","getAttribute","removeAttribute","SlideLooper","slideSizesWithGaps","roundingSafety","ascItems","descItems","reverse","loopPoints","startPoints","endPoints","removeSlideSizes","indexes","slidesInGap","gap","remainingGap","findSlideBounds","findLoopPoints","isEndEdge","slideBounds","initial","altered","boundEdge","loopPoint","slideLocation","canLoop","every","otherIndexes","shiftLocation","SlidesHandler","watchSlides","mutationObserver","mutations","mutation","MutationObserver","childList","SlidesInView","threshold","intersectionEntryMap","inViewCache","notInViewCache","intersectionObserver","IntersectionObserver","parentElement","createInViewList","inView","list","parseInt","isIntersecting","inViewMatch","notInViewMatch","SlideSizes","readEdgeGap","withEdgeGap","startGap","measureStartGap","endGap","measureEndGap","measureWithGaps","slideRect","getComputedStyle","getPropertyValue","SlidesToScroll","groupByNumber","byNumber","groupSize","bySize","rectB","rectA","edgeA","edgeB","gapA","gapB","chunkSize","currentSize","previousSize","Engine","scrollAxis","startIndex","inViewThreshold","dragHandler","scrollLooper","slideLooper","shouldSettle","withinBounds","hasSettled","hasSettledAndIdle","interpolatedLocation","engine","startLocation","scrollProgress","slidesInView","slideFocus","resizeHandler","scrollSnapList","slidesHandler","EventHandler","api","getListeners","e","on","cb","off","defaultOptions","breakpoints","OptionsHandler","mergeOptions","optionsA","optionsB","optionsAtMedia","matchedMediaOptions","media","matchMedia","matches","mediaOption","optionsMediaQueries","optionsList","acc","mediaQueries","PluginsHandler","optionsHandler","activePlugins","plugins","plugin","assign","name","EmblaCarousel","userOptions","userPlugins","defaultView","pluginsHandler","mediaHandlers","reActivate","optionsBase","globalOptions","pluginList","pluginApis","storeElements","userContainer","userSlides","customContainer","querySelector","children","customSlides","querySelectorAll","createEngine","optionsWithoutLoop","activate","withOptions","withPlugins","query","offsetParent","selectedScrollSnap","deActivate","jump","scrollNext","scrollPrev","prev","canScrollNext","canScrollPrev","previousScrollSnap","slidesNotInView","internalEngine","containerNode","slideNodes","setTimeout"],"mappings":"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"}
~~~

## node_modules\embla-carousel\esm\index.d.ts

~~~ts
export { EmblaOptionsType } from './components/Options.js';
export { EmblaEventType } from './components/EventHandler.js';
export { EmblaPluginType } from './components/Plugins.js';
export { EmblaCarouselType } from './components/EmblaCarousel.js';
export { default } from './components/EmblaCarousel.js';
export { CreatePluginType, EmblaPluginsType } from './components/Plugins.js';
export { CreateOptionsType } from './components/Options.js';
export { OptionsHandlerType } from './components/OptionsHandler.js';
export { EmblaEventListType } from './components/EventHandler.js';
export { EngineType } from './components/Engine.js';
export { ScrollBodyType } from './components/ScrollBody.js';

~~~

## node_modules\embla-carousel\esm\package.json

~~~json
{
  "name": "embla-carousel",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "A lightweight carousel library with fluid motion and great swipe precision",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel*",
    "components/**/*",
    "index.d.ts"
  ],
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "module": "embla-carousel.esm.js",
  "type": "module"
}

~~~

## node_modules\embla-carousel\index.d.ts

~~~ts
export { EmblaOptionsType } from './components/Options';
export { EmblaEventType } from './components/EventHandler';
export { EmblaPluginType } from './components/Plugins';
export { EmblaCarouselType } from './components/EmblaCarousel';
export { default } from './components/EmblaCarousel';
export { CreatePluginType, EmblaPluginsType } from './components/Plugins';
export { CreateOptionsType } from './components/Options';
export { OptionsHandlerType } from './components/OptionsHandler';
export { EmblaEventListType } from './components/EventHandler';
export { EngineType } from './components/Engine';
export { ScrollBodyType } from './components/ScrollBody';

~~~

## node_modules\embla-carousel\package.json

~~~json
{
  "name": "embla-carousel",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "A lightweight carousel library with fluid motion and great swipe precision",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "main": "embla-carousel.umd.js",
  "unpkg": "embla-carousel.umd.js",
  "module": "./esm/embla-carousel.esm.js",
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel*",
    "components/**/*",
    "index.d.ts",
    "esm/**/*",
    "cjs/**/*"
  ],
  "scripts": {
    "test": "jest --config jest.config.js",
    "build": "rollup --bundleConfigAsCjs -c",
    "start": "rollup --bundleConfigAsCjs -c --watch --environment BUILD:development",
    "eslint:report": "eslint \"src/**/*.{js,tsx,ts}\""
  },
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./esm/index.d.ts",
        "default": "./esm/embla-carousel.esm.js"
      },
      "require": {
        "types": "./cjs/index.d.ts",
        "default": "./cjs/embla-carousel.cjs.js"
      }
    }
  }
}
~~~

## node_modules\embla-carousel\README.md

~~~md
<br />
<div align="center">
  <p align="center">
    <a href="https://www.embla-carousel.com/"><img width="100" height="100" src="https://www.embla-carousel.com/embla-logo.svg" alt="Embla Carousel">
    </a>
  </p>

  <p align="center">
    <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/npm/l/embla-carousel?color=%238ab4f8"></a>
    <a href="https://www.npmjs.com/package/embla-carousel"><img src="https://img.shields.io/npm/v/embla-carousel.svg?color=%23c1a8e2"></a>
    <a href="https://github.com/davidjerleke/embla-carousel/actions?query=workflow%3A%22Continuous+Integration%22"><img src="https://img.shields.io/github/actions/workflow/status/davidjerleke/embla-carousel/cd.yml?color=%238ab4f8"></a>
    <a href="https://prettier.io"><img src="https://img.shields.io/badge/code_style-prettier-ff69b4.svg?color=%23c1a8e2"></a>
    <a href="https://bundlephobia.com/result?p=embla-carousel@latest"><img src="https://img.shields.io/bundlephobia/minzip/embla-carousel?color=%238ab4f8&label=gzip%20size">
    </a>
  </p>

  <strong>
    <h2 align="center">Embla Carousel</h2>
  </strong>

  <p align="center">
    <strong>Embla Carousel</strong> is a bare bones carousel library with great fluid motion and awesome swipe precision. It's library agnostic, dependency free and 100% open source.
  </p>

  <br>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/examples/predefined/">Examples</a>&nbsp;</code>
    </strong>
  </p>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/examples/generator/">Generator</a>&nbsp;</code>
    </strong>
  </p>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/get-started/#choose-installation-type">Installation</a>&nbsp;</code>
    </strong>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Ready for</h2>
  </strong>
  
  <p align="center">
    <a href="https://www.embla-carousel.com/get-started/module/">
      <img src="https://www.embla-carousel.com/javascript-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/module/">
      <img src="https://www.embla-carousel.com/typescript-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/react/">
      <img src="https://www.embla-carousel.com/react-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/vue/">
      <img src="https://www.embla-carousel.com/vue-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/svelte/">
      <img src="https://www.embla-carousel.com/svelte-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/solid/">
      <img src="https://www.embla-carousel.com/solid-logo.svg" width="40" height="40" />
    </a>
    <a href="https://github.com/donaldxdonald/embla-carousel-angular">
      <img src="https://www.embla-carousel.com/angular-logo.svg" width="40" height="40" />
    </a>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Contributors</h2>
  </strong>
  <p align="center">
    Thank you to all contributors for making <a href="https://www.embla-carousel.com/">Embla Carousel</a> awesome! <a href="https://github.com/davidjerleke/embla-carousel/blob/master/CONTRIBUTING.md">Contributions</a> are welcome.
  </p>
  <p align="center">
    <a href="https://github.com/davidjerleke">
      <img src="https://avatars2.githubusercontent.com/u/11529148?s=120&v=4" title="davidjerleke" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Ronit-gurjar">
      <img src="https://avatars2.githubusercontent.com/u/92150685?s=120&v=4" title="Ronit-gurjar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/zaaakher">
      <img src="https://avatars2.githubusercontent.com/u/46135573?s=120&v=4" title="zaaakher" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/xiel">
      <img src="https://avatars2.githubusercontent.com/u/615522?s=120&v=4" title="xiel" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/javiergonzalezGenially">
      <img src="https://avatars2.githubusercontent.com/u/78730098?s=120&v=4" title="javiergonzalezGenially" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/meirroth">
      <img src="https://avatars2.githubusercontent.com/u/12494197?s=120&v=4" title="meirroth" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/hamidrezahanafi">
      <img src="https://avatars2.githubusercontent.com/u/91487491?s=120&v=4" title="hamidrezahanafi" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/negezor">
      <img src="https://avatars2.githubusercontent.com/u/9392723?s=120&v=4" title="negezor" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/th-km">
      <img src="https://avatars2.githubusercontent.com/u/35410212?s=120&v=4" title="th-km" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/openscript">
      <img src="https://avatars2.githubusercontent.com/u/1105080?s=120&v=4" title="openscript" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/nwidynski">
      <img src="https://avatars2.githubusercontent.com/u/25958801?s=120&v=4" title="nwidynski" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/wopian">
      <img src="https://avatars2.githubusercontent.com/u/3440094?s=120&v=4" title="wopian" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/horseeyephil">
      <img src="https://avatars2.githubusercontent.com/u/32337092?s=120&v=4" title="horseeyephil" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/pipisasa">
      <img src="https://avatars2.githubusercontent.com/u/54534600?s=120&v=4" title="pipisasa" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ranno-lauri">
      <img src="https://avatars2.githubusercontent.com/u/87007115?s=120&v=4" title="ranno-lauri" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ruijdacd">
      <img src="https://avatars2.githubusercontent.com/u/9107610?s=120&v=4" title="ruijdacd" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/rojadesign">
      <img src="https://avatars2.githubusercontent.com/u/35687281?s=120&v=4" title="rojadesign" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sadeghbarati">
      <img src="https://avatars2.githubusercontent.com/u/17789047?s=120&v=4" title="sadeghbarati" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/S-Shingler">
      <img src="https://avatars2.githubusercontent.com/u/48463809?s=120&v=4" title="S-Shingler" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Yonom">
      <img src="https://avatars2.githubusercontent.com/u/1394504?s=120&v=4" title="Yonom" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/smultar">
      <img src="https://avatars2.githubusercontent.com/u/6223536?s=120&v=4" title="smultar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/dev-suraj-kumar">
      <img src="https://avatars2.githubusercontent.com/u/184739775?s=120&v=4" title="dev-suraj-kumar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Matoseb">
      <img src="https://avatars2.githubusercontent.com/u/24431250?s=120&v=4" title="Matoseb" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/tlo-johnson">
      <img src="https://avatars2.githubusercontent.com/u/8763144?s=120&v=4" title="tlo-johnson" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/yasuhiro-yamamoto">
      <img src="https://avatars2.githubusercontent.com/u/25109330?s=120&v=4" title="yasuhiro-yamamoto" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/anzbert">
      <img src="https://avatars2.githubusercontent.com/u/38823700?s=120&v=4" title="anzbert" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sarussss">
      <img src="https://avatars2.githubusercontent.com/u/15656996?s=120&v=4" title="sarussss" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/silllli">
      <img src="https://avatars2.githubusercontent.com/u/9334305?s=120&v=4" title="silllli" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/nikrowell">
      <img src="https://avatars2.githubusercontent.com/u/260039?s=120&v=4" title="nikrowell" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/mujahidfa">
      <img src="https://avatars2.githubusercontent.com/u/17759705?s=120&v=4" title="mujahidfa" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Mitch-At-Work">
      <img src="https://avatars2.githubusercontent.com/u/99835933?s=120&v=4" title="Mitch-At-Work" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/romellem">
      <img src="https://avatars2.githubusercontent.com/u/8504000?s=120&v=4" title="romellem" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/junlarsen">
      <img src="https://avatars2.githubusercontent.com/u/42585241?s=120&v=4" title="junlarsen" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/LucasMariniFalbo">
      <img src="https://avatars2.githubusercontent.com/u/9245477?s=120&v=4" title="LucasMariniFalbo" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/LiamMartens">
      <img src="https://avatars2.githubusercontent.com/u/5265324?s=120&v=4" title="LiamMartens" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/S1r-Lanzelot">
      <img src="https://avatars2.githubusercontent.com/u/4487160?s=120&v=4" title="S1r-Lanzelot" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ishaqibrahimbot">
      <img src="https://avatars2.githubusercontent.com/u/74908398?s=120&v=4" title="ishaqibrahimbot" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/fcasibu">
      <img src="https://avatars2.githubusercontent.com/u/75290989?s=120&v=4" title="fcasibu" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/cundd">
      <img src="https://avatars2.githubusercontent.com/u/743122?s=120&v=4" title="cundd" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sedlukha">
      <img src="https://avatars2.githubusercontent.com/u/14075940?s=120&v=4" title="sedlukha" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/allen-garvey">
      <img src="https://avatars2.githubusercontent.com/u/9314727?s=120&v=4" title="allen-garvey" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/lesha1201">
      <img src="https://avatars2.githubusercontent.com/u/10157660?s=120&v=4" title="lesha1201" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/SaizFerri">
      <img src="https://avatars2.githubusercontent.com/u/19834971?s=120&v=4" title="SaizFerri" width="50" height="50" style="max-width: 100%" />
    </a>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Special Thanks</h2>
  </strong>
  <p align="center">
    <sup>
      <a href="https://github.com/gunnarx2">gunnarx2</a> - React wrapper <a href="https://www.embla-carousel.com/get-started/react/">useEmblaCarousel</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/LiamMartens">LiamMartens</a> - Solid wrapper <a href="https://www.embla-carousel.com/get-started/solid/">createEmblaCarousel</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/donaldxdonald">donaldxdonald</a>, <a href="https://github.com/zip-fa">zip-fa</a>, <a href="https://github.com/JeanMeche">JeanMeche</a> - Angular wrapper <a href="https://github.com/donaldxdonald/embla-carousel-angular?tab=readme-ov-file#installation">EmblaCarouselDirective</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/xiel">xiel</a> - Plugin <a href="https://github.com/xiel/embla-carousel-wheel-gestures">Embla Carousel Wheel Gestures</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/zaaakher">zaaakher</a> - Contributing <a href="https://github.com/davidjerleke/embla-carousel/blob/master/CONTRIBUTING.md">guidelines</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/sarussss">sarussss</a> - Answering questions.
    </sup>
  </p>
</div>

<br>

<h2 align="center">Open Source</h2>

<p align="center">
  Embla is <a href="https://github.com/davidjerleke/embla-carousel/blob/master/LICENSE">MIT licensed</a> ?뮇.<br><br>
  <sup>Embla Carousel - Copyright 짤 2019-present.</sup><br />
  <sup>Package created by David Jerleke.</sup>
</p>

<p align="center">
  <strong>쨌 쨌 쨌</strong>
</p>

<p align="center">
  Thanks <a href="https://www.browserstack.com">BrowserStack</a>.
</p>

<p align="center">
  <a href="https://www.browserstack.com">
    <img src="https://www.embla-carousel.com/browserstack-logo.svg" width="45" height="45" />
    </a>
</p>

~~~

## node_modules\embla-carousel-react\cjs\components\useEmblaCarousel.d.ts

~~~ts
import { EmblaCarouselType, EmblaOptionsType, EmblaPluginType } from 'embla-carousel';
export type EmblaViewportRefType = <ViewportElement extends HTMLElement>(instance: ViewportElement | null) => void;
export type UseEmblaCarouselType = [
    EmblaViewportRefType,
    EmblaCarouselType | undefined
];
declare function useEmblaCarousel(options?: EmblaOptionsType, plugins?: EmblaPluginType[]): UseEmblaCarouselType;
declare namespace useEmblaCarousel {
    let globalOptions: EmblaOptionsType | undefined;
}
export default useEmblaCarousel;

~~~

## node_modules\embla-carousel-react\cjs\embla-carousel-react.cjs.js

~~~js
'use strict';

var react = require('react');
var emblaCarouselReactiveUtils = require('embla-carousel-reactive-utils');
var EmblaCarousel = require('embla-carousel');

function useEmblaCarousel(options = {}, plugins = []) {
  const storedOptions = react.useRef(options);
  const storedPlugins = react.useRef(plugins);
  const [emblaApi, setEmblaApi] = react.useState();
  const [viewport, setViewport] = react.useState();
  const reInit = react.useCallback(() => {
    if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current);
  }, [emblaApi]);
  react.useEffect(() => {
    if (emblaCarouselReactiveUtils.areOptionsEqual(storedOptions.current, options)) return;
    storedOptions.current = options;
    reInit();
  }, [options, reInit]);
  react.useEffect(() => {
    if (emblaCarouselReactiveUtils.arePluginsEqual(storedPlugins.current, plugins)) return;
    storedPlugins.current = plugins;
    reInit();
  }, [plugins, reInit]);
  react.useEffect(() => {
    if (emblaCarouselReactiveUtils.canUseDOM() && viewport) {
      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
      const newEmblaApi = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);
      setEmblaApi(newEmblaApi);
      return () => newEmblaApi.destroy();
    } else {
      setEmblaApi(undefined);
    }
  }, [viewport, setEmblaApi]);
  return [setViewport, emblaApi];
}
useEmblaCarousel.globalOptions = undefined;

module.exports = useEmblaCarousel;
//# sourceMappingURL=embla-carousel-react.cjs.js.map

~~~

## node_modules\embla-carousel-react\cjs\embla-carousel-react.cjs.js.map

~~~map
{"version":3,"file":"embla-carousel-react.cjs.js","sources":["../src/components/useEmblaCarousel.ts"],"sourcesContent":["import { useRef, useEffect, useState, useCallback } from 'react'\nimport {\n  areOptionsEqual,\n  arePluginsEqual,\n  canUseDOM\n} from 'embla-carousel-reactive-utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType\n} from 'embla-carousel'\n\nexport type EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = []\n): UseEmblaCarouselType {\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [emblaApi, setEmblaApi] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current)\n  }, [emblaApi])\n\n  useEffect(() => {\n    if (areOptionsEqual(storedOptions.current, options)) return\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmblaApi = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current\n      )\n      setEmblaApi(newEmblaApi)\n      return () => newEmblaApi.destroy()\n    } else {\n      setEmblaApi(undefined)\n    }\n  }, [viewport, setEmblaApi])\n\n  return [<EmblaViewportRefType>setViewport, emblaApi]\n}\n\ndeclare namespace useEmblaCarousel {\n  let globalOptions: EmblaOptionsType | undefined\n}\n\nuseEmblaCarousel.globalOptions = undefined\n\nexport default useEmblaCarousel\n"],"names":["useEmblaCarousel","options","plugins","storedOptions","useRef","storedPlugins","emblaApi","setEmblaApi","useState","viewport","setViewport","reInit","useCallback","current","useEffect","areOptionsEqual","arePluginsEqual","canUseDOM","EmblaCarousel","globalOptions","newEmblaApi","destroy","undefined"],"mappings":";;;;;;AAqBA,SAASA,gBAAgBA,CACvBC,OAAA,GAA4B,EAAE,EAC9BC,UAA6B,EAAE,EAAA;AAE/B,EAAA,MAAMC,aAAa,GAAGC,YAAM,CAACH,OAAO,CAAC;AACrC,EAAA,MAAMI,aAAa,GAAGD,YAAM,CAACF,OAAO,CAAC;EACrC,MAAM,CAACI,QAAQ,EAAEC,WAAW,CAAC,GAAGC,cAAQ,EAAqB;EAC7D,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGF,cAAQ,EAAe;AAEvD,EAAA,MAAMG,MAAM,GAAGC,iBAAW,CAAC,MAAK;AAC9B,IAAA,IAAIN,QAAQ,EAAEA,QAAQ,CAACK,MAAM,CAACR,aAAa,CAACU,OAAO,EAAER,aAAa,CAACQ,OAAO,CAAC;AAC7E,GAAC,EAAE,CAACP,QAAQ,CAAC,CAAC;AAEdQ,EAAAA,eAAS,CAAC,MAAK;IACb,IAAIC,0CAAe,CAACZ,aAAa,CAACU,OAAO,EAAEZ,OAAO,CAAC,EAAE;IACrDE,aAAa,CAACU,OAAO,GAAGZ,OAAO;AAC/BU,IAAAA,MAAM,EAAE;AACV,GAAC,EAAE,CAACV,OAAO,EAAEU,MAAM,CAAC,CAAC;AAErBG,EAAAA,eAAS,CAAC,MAAK;IACb,IAAIE,0CAAe,CAACX,aAAa,CAACQ,OAAO,EAAEX,OAAO,CAAC,EAAE;IACrDG,aAAa,CAACQ,OAAO,GAAGX,OAAO;AAC/BS,IAAAA,MAAM,EAAE;AACV,GAAC,EAAE,CAACT,OAAO,EAAES,MAAM,CAAC,CAAC;AAErBG,EAAAA,eAAS,CAAC,MAAK;AACb,IAAA,IAAIG,oCAAS,EAAE,IAAIR,QAAQ,EAAE;AAC3BS,MAAAA,aAAa,CAACC,aAAa,GAAGnB,gBAAgB,CAACmB,aAAa;AAC5D,MAAA,MAAMC,WAAW,GAAGF,aAAa,CAC/BT,QAAQ,EACRN,aAAa,CAACU,OAAO,EACrBR,aAAa,CAACQ,OAAO,CACtB;MACDN,WAAW,CAACa,WAAW,CAAC;AACxB,MAAA,OAAO,MAAMA,WAAW,CAACC,OAAO,EAAE;AACpC,KAAC,MAAM;MACLd,WAAW,CAACe,SAAS,CAAC;AACxB;AACF,GAAC,EAAE,CAACb,QAAQ,EAAEF,WAAW,CAAC,CAAC;AAE3B,EAAA,OAAO,CAAuBG,WAAW,EAAEJ,QAAQ,CAAC;AACtD;AAMAN,gBAAgB,CAACmB,aAAa,GAAGG,SAAS;;;;"}
~~~

## node_modules\embla-carousel-react\cjs\index.d.ts

~~~ts
export { UseEmblaCarouselType, EmblaViewportRefType } from './components/useEmblaCarousel';
export { default } from './components/useEmblaCarousel';

~~~

## node_modules\embla-carousel-react\cjs\package.json

~~~json
{
  "name": "embla-carousel-react",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "A lightweight carousel library with fluid motion and great swipe precision",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel-react*",
    "components/**/*",
    "index.d.ts"
  ],
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@types/react": "^18.0.8",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "dependencies": {
    "embla-carousel": "8.6.0",
    "embla-carousel-reactive-utils": "8.6.0"
  },
  "peerDependencies": {
    "react": "^16.8.0 || ^17.0.1 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
  },
  "main": "embla-carousel-react.cjs.js",
  "type": "commonjs"
}

~~~

## node_modules\embla-carousel-react\components\useEmblaCarousel.d.ts

~~~ts
import { EmblaCarouselType, EmblaOptionsType, EmblaPluginType } from 'embla-carousel';
export type EmblaViewportRefType = <ViewportElement extends HTMLElement>(instance: ViewportElement | null) => void;
export type UseEmblaCarouselType = [
    EmblaViewportRefType,
    EmblaCarouselType | undefined
];
declare function useEmblaCarousel(options?: EmblaOptionsType, plugins?: EmblaPluginType[]): UseEmblaCarouselType;
declare namespace useEmblaCarousel {
    let globalOptions: EmblaOptionsType | undefined;
}
export default useEmblaCarousel;

~~~

## node_modules\embla-carousel-react\embla-carousel-react.umd.js

~~~js
!function(n,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("react")):"function"==typeof define&&define.amd?define(["react"],t):(n="undefined"!=typeof globalThis?globalThis:n||self).EmblaCarouselReact=t(n.React)}(this,(function(n){"use strict";function t(n){return function(n){return"[object Object]"===Object.prototype.toString.call(n)}(n)||Array.isArray(n)}function e(n,r){const o=Object.keys(n),i=Object.keys(r);if(o.length!==i.length)return!1;return JSON.stringify(Object.keys(n.breakpoints||{}))===JSON.stringify(Object.keys(r.breakpoints||{}))&&o.every((o=>{const i=n[o],c=r[o];return"function"==typeof i?`${i}`==`${c}`:t(i)&&t(c)?e(i,c):i===c}))}function r(n){return n.concat().sort(((n,t)=>n.name>t.name?1:-1)).map((n=>n.options))}function o(n){return"number"==typeof n}function i(n){return"string"==typeof n}function c(n){return"boolean"==typeof n}function u(n){return"[object Object]"===Object.prototype.toString.call(n)}function s(n){return Math.abs(n)}function a(n){return Math.sign(n)}function d(n,t){return s(n-t)}function f(n){return h(n).map(Number)}function l(n){return n[p(n)]}function p(n){return Math.max(0,n.length-1)}function g(n,t){return t===p(n)}function m(n,t=0){return Array.from(Array(n),((n,e)=>t+e))}function h(n){return Object.keys(n)}function y(n,t){return[n,t].reduce(((n,t)=>(h(t).forEach((e=>{const r=n[e],o=t[e],i=u(r)&&u(o);n[e]=i?y(r,o):o})),n)),{})}function x(n,t){return void 0!==t.MouseEvent&&n instanceof t.MouseEvent}function b(){let n=[];const t={add:function(e,r,o,i={passive:!0}){let c;if("addEventListener"in e)e.addEventListener(r,o,i),c=()=>e.removeEventListener(r,o,i);else{const n=e;n.addListener(o),c=()=>n.removeListener(o)}return n.push(c),t},clear:function(){n=n.filter((n=>n()))}};return t}function v(n,t,e,r){const o=b(),i=1e3/60;let c=null,u=0,s=0;function a(n){if(!s)return;c||(c=n,e(),e());const o=n-c;for(c=n,u+=o;u>=i;)e(),u-=i;r(u/i),s&&(s=t.requestAnimationFrame(a))}function d(){t.cancelAnimationFrame(s),c=null,u=0,s=0}return{init:function(){o.add(n,"visibilitychange",(()=>{n.hidden&&(c=null,u=0)}))},destroy:function(){d(),o.clear()},start:function(){s||(s=t.requestAnimationFrame(a))},stop:d,update:e,render:r}}function S(n=0,t=0){const e=s(n-t);function r(t){return t<n}function o(n){return n>t}function i(n){return r(n)||o(n)}return{length:e,max:t,min:n,constrain:function(e){return i(e)?r(e)?n:t:e},reachedAny:i,reachedMax:o,reachedMin:r,removeOffset:function(n){return e?n-e*Math.ceil((n-t)/e):n}}}function w(n,t,e){const{constrain:r}=S(0,n),o=n+1;let i=c(t);function c(n){return e?s((o+n)%o):r(n)}function u(){return i}function a(){return w(n,u(),e)}const d={get:u,set:function(n){return i=c(n),d},add:function(n){return a().set(u()+n)},clone:a};return d}function E(n,t,e,r,o,i,u,f,l,p,g,m,h,y,v,w,E,L,O){const{cross:D,direction:I}=n,A=["INPUT","SELECT","TEXTAREA"],M={passive:!1},F=b(),T=b(),k=S(50,225).constrain(y.measure(20)),P={mouse:300,touch:400},z={mouse:500,touch:600},H=v?43:25;let j=!1,R=0,V=0,B=!1,C=!1,N=!1,q=!1;function G(n){if(!x(n,r)&&n.touches.length>=2)return $(n);const t=i.readPoint(n),e=i.readPoint(n,D),c=d(t,R),u=d(e,V);if(!C&&!q){if(!n.cancelable)return $(n);if(C=c>u,!C)return $(n)}const s=i.pointerMove(n);c>w&&(N=!0),p.useFriction(.3).useDuration(.75),f.start(),o.add(I(s)),n.preventDefault()}function $(n){const t=g.byDistance(0,!1).index!==m.get(),e=i.pointerUp(n)*(v?z:P)[q?"mouse":"touch"],r=function(n,t){const e=m.add(-1*a(n)),r=g.byDistance(n,!v).distance;return v||s(n)<k?r:E&&t?.5*r:g.byIndex(e.get(),0).distance}(I(e),t),o=function(n,t){if(0===n||0===t)return 0;if(s(n)<=s(t))return 0;const e=d(s(n),s(t));return s(e/n)}(e,r),c=H-10*o,u=L+o/50;C=!1,B=!1,T.clear(),p.useDuration(c).useFriction(u),l.distance(r,!v),q=!1,h.emit("pointerUp")}function U(n){N&&(n.stopPropagation(),n.preventDefault(),N=!1)}return{init:function(n){if(!O)return;function s(s){(c(O)||O(n,s))&&function(n){const c=x(n,r);if(q=c,N=v&&c&&!n.buttons&&j,j=d(o.get(),u.get())>=2,c&&0!==n.button)return;if(function(n){const t=n.nodeName||"";return A.includes(t)}(n.target))return;B=!0,i.pointerDown(n),p.useFriction(0).useDuration(0),o.set(u),function(){const n=q?e:t;T.add(n,"touchmove",G,M).add(n,"touchend",$).add(n,"mousemove",G,M).add(n,"mouseup",$)}(),R=i.readPoint(n),V=i.readPoint(n,D),h.emit("pointerDown")}(s)}const a=t;F.add(a,"dragstart",(n=>n.preventDefault()),M).add(a,"touchmove",(()=>{}),M).add(a,"touchend",(()=>{})).add(a,"touchstart",s).add(a,"mousedown",s).add(a,"touchcancel",$).add(a,"contextmenu",$).add(a,"click",U,!0)},destroy:function(){F.clear(),T.clear()},pointerDown:function(){return B}}}function L(n,t){let e,r;function o(n){return n.timeStamp}function i(e,r){const o="client"+("x"===(r||n.scroll)?"X":"Y");return(x(e,t)?e:e.touches[0])[o]}return{pointerDown:function(n){return e=n,r=n,i(n)},pointerMove:function(n){const t=i(n)-i(r),c=o(n)-o(e)>170;return r=n,c&&(e=n),t},pointerUp:function(n){if(!e||!r)return 0;const t=i(r)-i(e),c=o(n)-o(e),u=o(n)-o(r)>170,a=t/c;return c&&!u&&s(a)>.1?a:0},readPoint:i}}function O(n,t,e,r,o,i,u){const a=[n].concat(r);let d,f,l=[],p=!1;function g(n){return o.measureSize(u.measure(n))}return{init:function(o){i&&(f=g(n),l=r.map(g),d=new ResizeObserver((e=>{(c(i)||i(o,e))&&function(e){for(const i of e){if(p)return;const e=i.target===n,c=r.indexOf(i.target),u=e?f:l[c];if(s(g(e?n:r[c])-u)>=.5){o.reInit(),t.emit("resize");break}}}(e)})),e.requestAnimationFrame((()=>{a.forEach((n=>d.observe(n)))})))},destroy:function(){p=!0,d&&d.disconnect()}}}function D(n,t,e,r,o){const i=o.measure(10),c=o.measure(50),u=S(.1,.99);let a=!1;function d(){return!a&&(!!n.reachedAny(e.get())&&!!n.reachedAny(t.get()))}return{shouldConstrain:d,constrain:function(o){if(!d())return;const a=n.reachedMin(t.get())?"min":"max",f=s(n[a]-t.get()),l=e.get()-t.get(),p=u.constrain(f/c);e.subtract(l*p),!o&&s(l)<i&&(e.set(n.constrain(e.get())),r.useDuration(25).useBaseFriction())},toggleActive:function(n){a=!n}}}function I(n,t,e,r){const o=t.min+.1,i=t.max+.1,{reachedMin:c,reachedMax:u}=S(o,i);return{loop:function(t){if(!function(n){return 1===n?u(e.get()):-1===n&&c(e.get())}(t))return;const o=n*(-1*t);r.forEach((n=>n.add(o)))}}}function A(n,t,e,r,o){const{reachedAny:i,removeOffset:c,constrain:u}=r;function d(n){return n.concat().sort(((n,t)=>s(n)-s(t)))[0]}function f(t,r){const o=[t,t+e,t-e];if(!n)return t;if(!r)return d(o);const i=o.filter((n=>a(n)===r));return i.length?d(i):l(o)-e}return{byDistance:function(e,r){const a=o.get()+e,{index:d,distance:l}=function(e){const r=n?c(e):u(e),o=t.map(((n,t)=>({diff:f(n-r,0),index:t}))).sort(((n,t)=>s(n.diff)-s(t.diff))),{index:i}=o[0];return{index:i,distance:r}}(a),p=!n&&i(a);return!r||p?{index:d,distance:e}:{index:d,distance:e+f(t[d]-l,0)}},byIndex:function(n,e){return{index:n,distance:f(t[n]-o.get(),e)}},shortcut:f}}function M(n,t,e,r,i,u,s,a){const d={passive:!0,capture:!0};let f=0;function l(n){"Tab"===n.code&&(f=(new Date).getTime())}return{init:function(p){a&&(u.add(document,"keydown",l,!1),t.forEach(((t,l)=>{u.add(t,"focus",(t=>{(c(a)||a(p,t))&&function(t){if((new Date).getTime()-f>10)return;s.emit("slideFocusStart"),n.scrollLeft=0;const c=e.findIndex((n=>n.includes(t)));o(c)&&(i.useDuration(0),r.index(c,0),s.emit("slideFocus"))}(l)}),d)})))}}}function F(n){let t=n;function e(n){return o(n)?n:n.get()}return{get:function(){return t},set:function(n){t=e(n)},add:function(n){t+=e(n)},subtract:function(n){t-=e(n)}}}function T(n,t){const e="x"===n.scroll?function(n){return`translate3d(${n}px,0px,0px)`}:function(n){return`translate3d(0px,${n}px,0px)`},r=t.style;let o=null,i=!1;return{clear:function(){i||(r.transform="",t.getAttribute("style")||t.removeAttribute("style"))},to:function(t){if(i)return;const c=(u=n.direction(t),Math.round(100*u)/100);var u;c!==o&&(r.transform=e(c),o=c)},toggleActive:function(n){i=!n}}}function k(n,t,e,r,o,i,c,u,s){const a=.5,d=f(o),l=f(o).reverse(),p=function(){const n=c[0];return h(m(l,n),e,!1)}().concat(function(){const n=t-c[0]-1;return h(m(d,n),-e,!0)}());function g(n,t){return n.reduce(((n,t)=>n-o[t]),t)}function m(n,t){return n.reduce(((n,e)=>g(n,t)>0?n.concat([e]):n),[])}function h(o,c,d){const f=function(n){return i.map(((e,o)=>({start:e-r[o]+a+n,end:e+t-a+n})))}(c);return o.map((t=>{const r=d?0:-e,o=d?e:0,i=d?"end":"start",c=f[t][i];return{index:t,loopPoint:c,slideLocation:F(-1),translate:T(n,s[t]),target:()=>u.get()>c?r:o}}))}return{canLoop:function(){return p.every((({index:n})=>g(d.filter((t=>t!==n)),t)<=.1))},clear:function(){p.forEach((n=>n.translate.clear()))},loop:function(){p.forEach((n=>{const{target:t,translate:e,slideLocation:r}=n,o=t();o!==r.get()&&(e.to(o),r.set(o))}))},loopPoints:p}}function P(n,t,e){let r,o=!1;return{init:function(i){e&&(r=new MutationObserver((n=>{o||(c(e)||e(i,n))&&function(n){for(const e of n)if("childList"===e.type){i.reInit(),t.emit("slidesChanged");break}}(n)})),r.observe(n,{childList:!0}))},destroy:function(){r&&r.disconnect(),o=!0}}}function z(n,t,e,r){const o={};let i,c=null,u=null,s=!1;return{init:function(){i=new IntersectionObserver((n=>{s||(n.forEach((n=>{const e=t.indexOf(n.target);o[e]=n})),c=null,u=null,e.emit("slidesInView"))}),{root:n.parentElement,threshold:r}),t.forEach((n=>i.observe(n)))},destroy:function(){i&&i.disconnect(),s=!0},get:function(n=!0){if(n&&c)return c;if(!n&&u)return u;const t=function(n){return h(o).reduce(((t,e)=>{const r=parseInt(e),{isIntersecting:i}=o[r];return(n&&i||!n&&!i)&&t.push(r),t}),[])}(n);return n&&(c=t),n||(u=t),t}}}function H(n,t,e,r,i,c,u,a,d){const{startEdge:g,endEdge:m,direction:h}=n,y=o(e);return{groupSlides:function(n){return y?function(n,t){return f(n).filter((n=>n%t==0)).map((e=>n.slice(e,e+t)))}(n,e):function(n){return n.length?f(n).reduce(((e,o,f)=>{const y=l(e)||0,x=0===y,b=o===p(n),v=i[g]-c[y][g],S=i[g]-c[o][m],w=!r&&x?h(u):0,E=s(S-(!r&&b?h(a):0)-(v+w));return f&&E>t+d&&e.push(o),b&&e.push(n.length),e}),[]).map(((t,e,r)=>{const o=Math.max(r[e-1]||0);return n.slice(o,t)})):[]}(n)}}}function j(n,t,e,r,o,c,u){const{align:h,axis:y,direction:x,startIndex:j,loop:R,duration:V,dragFree:B,dragThreshold:C,inViewThreshold:N,slidesToScroll:q,skipSnaps:G,containScroll:$,watchResize:U,watchSlides:W,watchDrag:J,watchFocus:Q}=c,X={measure:function(n){const{offsetTop:t,offsetLeft:e,offsetWidth:r,offsetHeight:o}=n;return{top:t,right:e+r,bottom:t+o,left:e,width:r,height:o}}},Y=X.measure(t),K=e.map(X.measure),Z=function(n,t){const e="rtl"===t,r="y"===n,o=!r&&e?-1:1;return{scroll:r?"y":"x",cross:r?"x":"y",startEdge:r?"top":e?"right":"left",endEdge:r?"bottom":e?"left":"right",measureSize:function(n){const{height:t,width:e}=n;return r?t:e},direction:function(n){return n*o}}}(y,x),_=Z.measureSize(Y),nn=function(n){return{measure:function(t){return n*(t/100)}}}(_),tn=function(n,t){const e={start:function(){return 0},center:function(n){return r(n)/2},end:r};function r(n){return t-n}return{measure:function(r,o){return i(n)?e[n](r):n(t,r,o)}}}(h,_),en=!R&&!!$,rn=R||!!$,{slideSizes:on,slideSizesWithGaps:cn,startGap:un,endGap:sn}=function(n,t,e,r,o,i){const{measureSize:c,startEdge:u,endEdge:a}=n,d=e[0]&&o,f=function(){if(!d)return 0;const n=e[0];return s(t[u]-n[u])}(),p=function(){if(!d)return 0;const n=i.getComputedStyle(l(r));return parseFloat(n.getPropertyValue(`margin-${a}`))}(),m=e.map(c),h=e.map(((n,t,e)=>{const r=!t,o=g(e,t);return r?m[t]+f:o?m[t]+p:e[t+1][u]-n[u]})).map(s);return{slideSizes:m,slideSizesWithGaps:h,startGap:f,endGap:p}}(Z,Y,K,e,rn,o),an=H(Z,_,q,R,Y,K,un,sn,2),{snaps:dn,snapsAligned:fn}=function(n,t,e,r,o){const{startEdge:i,endEdge:c}=n,{groupSlides:u}=o,a=u(r).map((n=>l(n)[c]-n[0][i])).map(s).map(t.measure),d=r.map((n=>e[i]-n[i])).map((n=>-s(n))),f=u(d).map((n=>n[0])).map(((n,t)=>n+a[t]));return{snaps:d,snapsAligned:f}}(Z,tn,Y,K,an),ln=-l(dn)+l(cn),{snapsContained:pn,scrollContainLimit:gn}=function(n,t,e,r,o){const i=S(-t+n,0),c=e.map(((n,t)=>{const{min:r,max:o}=i,c=i.constrain(n),u=!t,a=g(e,t);return u?o:a||s(r,c)?r:s(o,c)?o:c})).map((n=>parseFloat(n.toFixed(3)))),u=function(){const n=c[0],t=l(c);return S(c.lastIndexOf(n),c.indexOf(t)+1)}();function s(n,t){return d(n,t)<=1}return{snapsContained:function(){if(t<=n+o)return[i.max];if("keepSnaps"===r)return c;const{min:e,max:s}=u;return c.slice(e,s)}(),scrollContainLimit:u}}(_,ln,fn,$,2),mn=en?pn:fn,{limit:hn}=function(n,t,e){const r=t[0];return{limit:S(e?r-n:l(t),r)}}(ln,mn,R),yn=w(p(mn),j,R),xn=yn.clone(),bn=f(e),vn=v(r,o,(()=>(({dragHandler:n,scrollBody:t,scrollBounds:e,options:{loop:r}})=>{r||e.constrain(n.pointerDown()),t.seek()})(zn)),(n=>(({scrollBody:n,translate:t,location:e,offsetLocation:r,previousLocation:o,scrollLooper:i,slideLooper:c,dragHandler:u,animation:s,eventHandler:a,scrollBounds:d,options:{loop:f}},l)=>{const p=n.settled(),g=!d.shouldConstrain(),m=f?p:p&&g,h=m&&!u.pointerDown();h&&s.stop();const y=e.get()*l+o.get()*(1-l);r.set(y),f&&(i.loop(n.direction()),c.loop()),t.to(r.get()),h&&a.emit("settle"),m||a.emit("scroll")})(zn,n))),Sn=mn[yn.get()],wn=F(Sn),En=F(Sn),Ln=F(Sn),On=F(Sn),Dn=function(n,t,e,r,o,i){let c=0,u=0,d=o,f=i,l=n.get(),p=0;function g(n){return d=n,h}function m(n){return f=n,h}const h={direction:function(){return u},duration:function(){return d},velocity:function(){return c},seek:function(){const t=r.get()-n.get();let o=0;return d?(e.set(n),c+=t/d,c*=f,l+=c,n.add(c),o=l-p):(c=0,e.set(r),n.set(r),o=t),u=a(o),p=l,h},settled:function(){return s(r.get()-t.get())<.001},useBaseFriction:function(){return m(i)},useBaseDuration:function(){return g(o)},useFriction:m,useDuration:g};return h}(wn,Ln,En,On,V,.68),In=A(R,mn,ln,hn,On),An=function(n,t,e,r,o,i,c){function u(o){const u=o.distance,s=o.index!==t.get();i.add(u),u&&(r.duration()?n.start():(n.update(),n.render(1),n.update())),s&&(e.set(t.get()),t.set(o.index),c.emit("select"))}return{distance:function(n,t){u(o.byDistance(n,t))},index:function(n,e){const r=t.clone().set(n);u(o.byIndex(r.get(),e))}}}(vn,yn,xn,Dn,In,On,u),Mn=function(n){const{max:t,length:e}=n;return{get:function(n){return e?(n-t)/-e:0}}}(hn),Fn=b(),Tn=z(t,e,u,N),{slideRegistry:kn}=function(n,t,e,r,o,i){const{groupSlides:c}=o,{min:u,max:s}=r;return{slideRegistry:function(){const r=c(i),o=!n||"keepSnaps"===t;return 1===e.length?[i]:o?r:r.slice(u,s).map(((n,t,e)=>{const r=!t,o=g(e,t);return r?m(l(e[0])+1):o?m(p(i)-l(e)[0]+1,l(e)[0]):n}))}()}}(en,$,mn,gn,an,bn),Pn=M(n,e,kn,An,Dn,Fn,u,Q),zn={ownerDocument:r,ownerWindow:o,eventHandler:u,containerRect:Y,slideRects:K,animation:vn,axis:Z,dragHandler:E(Z,n,r,o,On,L(Z,o),wn,vn,An,Dn,In,yn,u,nn,B,C,G,.68,J),eventStore:Fn,percentOfView:nn,index:yn,indexPrevious:xn,limit:hn,location:wn,offsetLocation:Ln,previousLocation:En,options:c,resizeHandler:O(t,u,o,e,Z,U,X),scrollBody:Dn,scrollBounds:D(hn,Ln,On,Dn,nn),scrollLooper:I(ln,hn,Ln,[wn,Ln,En,On]),scrollProgress:Mn,scrollSnapList:mn.map(Mn.get),scrollSnaps:mn,scrollTarget:In,scrollTo:An,slideLooper:k(Z,_,ln,on,cn,dn,mn,Ln,e),slideFocus:Pn,slidesHandler:P(t,u,W),slidesInView:Tn,slideIndexes:bn,slideRegistry:kn,slidesToScroll:an,target:On,translate:T(Z,t)};return zn}const R={align:"center",axis:"x",container:null,slides:null,containScroll:"trimSnaps",direction:"ltr",slidesToScroll:1,inViewThreshold:0,breakpoints:{},dragFree:!1,dragThreshold:10,loop:!1,skipSnaps:!1,duration:25,startIndex:0,active:!0,watchDrag:!0,watchResize:!0,watchSlides:!0,watchFocus:!0};function V(n){function t(n,t){return y(n,t||{})}const e={mergeOptions:t,optionsAtMedia:function(e){const r=e.breakpoints||{},o=h(r).filter((t=>n.matchMedia(t).matches)).map((n=>r[n])).reduce(((n,e)=>t(n,e)),{});return t(e,o)},optionsMediaQueries:function(t){return t.map((n=>h(n.breakpoints||{}))).reduce(((n,t)=>n.concat(t)),[]).map(n.matchMedia)}};return e}function B(n,t,e){const r=n.ownerDocument,o=r.defaultView,c=V(o),u=function(n){let t=[];return{init:function(e,r){return t=r.filter((({options:t})=>!1!==n.optionsAtMedia(t).active)),t.forEach((t=>t.init(e,n))),r.reduce(((n,t)=>Object.assign(n,{[t.name]:t})),{})},destroy:function(){t=t.filter((n=>n.destroy()))}}}(c),s=b(),a=function(){let n,t={};function e(n){return t[n]||[]}const r={init:function(t){n=t},emit:function(t){return e(t).forEach((e=>e(n,t))),r},off:function(n,o){return t[n]=e(n).filter((n=>n!==o)),r},on:function(n,o){return t[n]=e(n).concat([o]),r},clear:function(){t={}}};return r}(),{mergeOptions:d,optionsAtMedia:f,optionsMediaQueries:l}=c,{on:p,off:g,emit:m}=a,h=A;let y,x,v,S,w=!1,E=d(R,B.globalOptions),L=d(E),O=[];function D(t){const e=j(n,v,S,r,o,t,a);if(t.loop&&!e.slideLooper.canLoop()){return D(Object.assign({},t,{loop:!1}))}return e}function I(t,e){w||(E=d(E,t),L=f(E),O=e||O,function(){const{container:t,slides:e}=L,r=i(t)?n.querySelector(t):t;v=r||n.children[0];const o=i(e)?v.querySelectorAll(e):e;S=[].slice.call(o||v.children)}(),y=D(L),l([E,...O.map((({options:n})=>n))]).forEach((n=>s.add(n,"change",A))),L.active&&(y.translate.to(y.location.get()),y.animation.init(),y.slidesInView.init(),y.slideFocus.init(k),y.eventHandler.init(k),y.resizeHandler.init(k),y.slidesHandler.init(k),y.options.loop&&y.slideLooper.loop(),v.offsetParent&&S.length&&y.dragHandler.init(k),x=u.init(k,O)))}function A(n,t){const e=T();M(),I(d({startIndex:e},n),t),a.emit("reInit")}function M(){y.dragHandler.destroy(),y.eventStore.clear(),y.translate.clear(),y.slideLooper.clear(),y.resizeHandler.destroy(),y.slidesHandler.destroy(),y.slidesInView.destroy(),y.animation.destroy(),u.destroy(),s.clear()}function F(n,t,e){L.active&&!w&&(y.scrollBody.useBaseFriction().useDuration(!0===t?0:L.duration),y.scrollTo.index(n,e||0))}function T(){return y.index.get()}const k={canScrollNext:function(){return y.index.add(1).get()!==T()},canScrollPrev:function(){return y.index.add(-1).get()!==T()},containerNode:function(){return v},internalEngine:function(){return y},destroy:function(){w||(w=!0,s.clear(),M(),a.emit("destroy"),a.clear())},off:g,on:p,emit:m,plugins:function(){return x},previousScrollSnap:function(){return y.indexPrevious.get()},reInit:h,rootNode:function(){return n},scrollNext:function(n){F(y.index.add(1).get(),n,-1)},scrollPrev:function(n){F(y.index.add(-1).get(),n,1)},scrollProgress:function(){return y.scrollProgress.get(y.offsetLocation.get())},scrollSnapList:function(){return y.scrollSnapList},scrollTo:F,selectedScrollSnap:T,slideNodes:function(){return S},slidesInView:function(){return y.slidesInView.get()},slidesNotInView:function(){return y.slidesInView.get(!1)}};return I(t,e),setTimeout((()=>a.emit("init")),0),k}function C(t={},o=[]){const i=n.useRef(t),c=n.useRef(o),[u,s]=n.useState(),[a,d]=n.useState(),f=n.useCallback((()=>{u&&u.reInit(i.current,c.current)}),[u]);return n.useEffect((()=>{e(i.current,t)||(i.current=t,f())}),[t,f]),n.useEffect((()=>{(function(n,t){if(n.length!==t.length)return!1;const o=r(n),i=r(t);return o.every(((n,t)=>e(n,i[t])))})(c.current,o)||(c.current=o,f())}),[o,f]),n.useEffect((()=>{if("undefined"!=typeof window&&window.document&&window.document.createElement&&a){B.globalOptions=C.globalOptions;const n=B(a,i.current,c.current);return s(n),()=>n.destroy()}s(void 0)}),[a,s]),[d,u]}return B.globalOptions=void 0,C.globalOptions=void 0,C}));

~~~

## node_modules\embla-carousel-react\esm\components\useEmblaCarousel.d.ts

~~~ts
import { EmblaCarouselType, EmblaOptionsType, EmblaPluginType } from 'embla-carousel';
export type EmblaViewportRefType = <ViewportElement extends HTMLElement>(instance: ViewportElement | null) => void;
export type UseEmblaCarouselType = [
    EmblaViewportRefType,
    EmblaCarouselType | undefined
];
declare function useEmblaCarousel(options?: EmblaOptionsType, plugins?: EmblaPluginType[]): UseEmblaCarouselType;
declare namespace useEmblaCarousel {
    let globalOptions: EmblaOptionsType | undefined;
}
export default useEmblaCarousel;

~~~

## node_modules\embla-carousel-react\esm\embla-carousel-react.esm.js

~~~js
import { useRef, useState, useCallback, useEffect } from 'react';
import { areOptionsEqual, arePluginsEqual, canUseDOM } from 'embla-carousel-reactive-utils';
import EmblaCarousel from 'embla-carousel';

function useEmblaCarousel(options = {}, plugins = []) {
  const storedOptions = useRef(options);
  const storedPlugins = useRef(plugins);
  const [emblaApi, setEmblaApi] = useState();
  const [viewport, setViewport] = useState();
  const reInit = useCallback(() => {
    if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current);
  }, [emblaApi]);
  useEffect(() => {
    if (areOptionsEqual(storedOptions.current, options)) return;
    storedOptions.current = options;
    reInit();
  }, [options, reInit]);
  useEffect(() => {
    if (arePluginsEqual(storedPlugins.current, plugins)) return;
    storedPlugins.current = plugins;
    reInit();
  }, [plugins, reInit]);
  useEffect(() => {
    if (canUseDOM() && viewport) {
      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
      const newEmblaApi = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);
      setEmblaApi(newEmblaApi);
      return () => newEmblaApi.destroy();
    } else {
      setEmblaApi(undefined);
    }
  }, [viewport, setEmblaApi]);
  return [setViewport, emblaApi];
}
useEmblaCarousel.globalOptions = undefined;

export { useEmblaCarousel as default };
//# sourceMappingURL=embla-carousel-react.esm.js.map

~~~

## node_modules\embla-carousel-react\esm\embla-carousel-react.esm.js.map

~~~map
{"version":3,"file":"embla-carousel-react.esm.js","sources":["../src/components/useEmblaCarousel.ts"],"sourcesContent":["import { useRef, useEffect, useState, useCallback } from 'react'\nimport {\n  areOptionsEqual,\n  arePluginsEqual,\n  canUseDOM\n} from 'embla-carousel-reactive-utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType\n} from 'embla-carousel'\n\nexport type EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = []\n): UseEmblaCarouselType {\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [emblaApi, setEmblaApi] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (emblaApi) emblaApi.reInit(storedOptions.current, storedPlugins.current)\n  }, [emblaApi])\n\n  useEffect(() => {\n    if (areOptionsEqual(storedOptions.current, options)) return\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmblaApi = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current\n      )\n      setEmblaApi(newEmblaApi)\n      return () => newEmblaApi.destroy()\n    } else {\n      setEmblaApi(undefined)\n    }\n  }, [viewport, setEmblaApi])\n\n  return [<EmblaViewportRefType>setViewport, emblaApi]\n}\n\ndeclare namespace useEmblaCarousel {\n  let globalOptions: EmblaOptionsType | undefined\n}\n\nuseEmblaCarousel.globalOptions = undefined\n\nexport default useEmblaCarousel\n"],"names":["useEmblaCarousel","options","plugins","storedOptions","useRef","storedPlugins","emblaApi","setEmblaApi","useState","viewport","setViewport","reInit","useCallback","current","useEffect","areOptionsEqual","arePluginsEqual","canUseDOM","EmblaCarousel","globalOptions","newEmblaApi","destroy","undefined"],"mappings":";;;;AAqBA,SAASA,gBAAgBA,CACvBC,OAAA,GAA4B,EAAE,EAC9BC,UAA6B,EAAE,EAAA;AAE/B,EAAA,MAAMC,aAAa,GAAGC,MAAM,CAACH,OAAO,CAAC;AACrC,EAAA,MAAMI,aAAa,GAAGD,MAAM,CAACF,OAAO,CAAC;EACrC,MAAM,CAACI,QAAQ,EAAEC,WAAW,CAAC,GAAGC,QAAQ,EAAqB;EAC7D,MAAM,CAACC,QAAQ,EAAEC,WAAW,CAAC,GAAGF,QAAQ,EAAe;AAEvD,EAAA,MAAMG,MAAM,GAAGC,WAAW,CAAC,MAAK;AAC9B,IAAA,IAAIN,QAAQ,EAAEA,QAAQ,CAACK,MAAM,CAACR,aAAa,CAACU,OAAO,EAAER,aAAa,CAACQ,OAAO,CAAC;AAC7E,GAAC,EAAE,CAACP,QAAQ,CAAC,CAAC;AAEdQ,EAAAA,SAAS,CAAC,MAAK;IACb,IAAIC,eAAe,CAACZ,aAAa,CAACU,OAAO,EAAEZ,OAAO,CAAC,EAAE;IACrDE,aAAa,CAACU,OAAO,GAAGZ,OAAO;AAC/BU,IAAAA,MAAM,EAAE;AACV,GAAC,EAAE,CAACV,OAAO,EAAEU,MAAM,CAAC,CAAC;AAErBG,EAAAA,SAAS,CAAC,MAAK;IACb,IAAIE,eAAe,CAACX,aAAa,CAACQ,OAAO,EAAEX,OAAO,CAAC,EAAE;IACrDG,aAAa,CAACQ,OAAO,GAAGX,OAAO;AAC/BS,IAAAA,MAAM,EAAE;AACV,GAAC,EAAE,CAACT,OAAO,EAAES,MAAM,CAAC,CAAC;AAErBG,EAAAA,SAAS,CAAC,MAAK;AACb,IAAA,IAAIG,SAAS,EAAE,IAAIR,QAAQ,EAAE;AAC3BS,MAAAA,aAAa,CAACC,aAAa,GAAGnB,gBAAgB,CAACmB,aAAa;AAC5D,MAAA,MAAMC,WAAW,GAAGF,aAAa,CAC/BT,QAAQ,EACRN,aAAa,CAACU,OAAO,EACrBR,aAAa,CAACQ,OAAO,CACtB;MACDN,WAAW,CAACa,WAAW,CAAC;AACxB,MAAA,OAAO,MAAMA,WAAW,CAACC,OAAO,EAAE;AACpC,KAAC,MAAM;MACLd,WAAW,CAACe,SAAS,CAAC;AACxB;AACF,GAAC,EAAE,CAACb,QAAQ,EAAEF,WAAW,CAAC,CAAC;AAE3B,EAAA,OAAO,CAAuBG,WAAW,EAAEJ,QAAQ,CAAC;AACtD;AAMAN,gBAAgB,CAACmB,aAAa,GAAGG,SAAS;;;;"}
~~~

## node_modules\embla-carousel-react\esm\index.d.ts

~~~ts
export { UseEmblaCarouselType, EmblaViewportRefType } from './components/useEmblaCarousel.js';
export { default } from './components/useEmblaCarousel.js';

~~~

## node_modules\embla-carousel-react\esm\package.json

~~~json
{
  "name": "embla-carousel-react",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "A lightweight carousel library with fluid motion and great swipe precision",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel-react*",
    "components/**/*",
    "index.d.ts"
  ],
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@types/react": "^18.0.8",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "dependencies": {
    "embla-carousel": "8.6.0",
    "embla-carousel-reactive-utils": "8.6.0"
  },
  "peerDependencies": {
    "react": "^16.8.0 || ^17.0.1 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
  },
  "module": "embla-carousel-react.esm.js",
  "type": "module"
}

~~~

## node_modules\embla-carousel-react\index.d.ts

~~~ts
export { UseEmblaCarouselType, EmblaViewportRefType } from './components/useEmblaCarousel';
export { default } from './components/useEmblaCarousel';

~~~

## node_modules\embla-carousel-react\package.json

~~~json
{
  "name": "embla-carousel-react",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "A lightweight carousel library with fluid motion and great swipe precision",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "main": "embla-carousel-react.umd.js",
  "unpkg": "embla-carousel-react.umd.js",
  "module": "./esm/embla-carousel-react.esm.js",
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel-react*",
    "components/**/*",
    "index.d.ts",
    "esm/**/*",
    "cjs/**/*"
  ],
  "scripts": {
    "test": "echo \"Info: no tests specified\" && exit 0",
    "build": "rollup --bundleConfigAsCjs -c",
    "start": "rollup --bundleConfigAsCjs -c --watch --environment BUILD:development",
    "eslint:report": "eslint \"src/**/*.{js,tsx,ts}\""
  },
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@types/react": "^18.0.8",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "dependencies": {
    "embla-carousel": "8.6.0",
    "embla-carousel-reactive-utils": "8.6.0"
  },
  "peerDependencies": {
    "react": "^16.8.0 || ^17.0.1 || ^18.0.0 || ^19.0.0 || ^19.0.0-rc"
  },
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./esm/index.d.ts",
        "default": "./esm/embla-carousel-react.esm.js"
      },
      "require": {
        "types": "./cjs/index.d.ts",
        "default": "./cjs/embla-carousel-react.cjs.js"
      }
    }
  }
}
~~~

## node_modules\embla-carousel-react\README.md

~~~md
<br />
<div align="center">
  <p align="center">
    <a href="https://www.embla-carousel.com/"><img width="100" height="100" src="https://www.embla-carousel.com/embla-logo.svg" alt="Embla Carousel">
    </a>
  </p>

  <p align="center">
    <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/npm/l/embla-carousel?color=%238ab4f8"></a>
    <a href="https://www.npmjs.com/package/embla-carousel-react"><img src="https://img.shields.io/npm/v/embla-carousel-react.svg?color=%23c1a8e2"></a>
    <a href="https://github.com/davidjerleke/embla-carousel/actions?query=workflow%3A%22Continuous+Integration%22"><img src="https://img.shields.io/github/actions/workflow/status/davidjerleke/embla-carousel/cd.yml?color=%238ab4f8"></a>
    <a href="https://prettier.io"><img src="https://img.shields.io/badge/code_style-prettier-ff69b4.svg?color=%23c1a8e2"></a>
    <a href="https://bundlephobia.com/result?p=embla-carousel-react@latest"><img src="https://img.shields.io/bundlephobia/minzip/embla-carousel-react?color=%238ab4f8&label=gzip%20size">
    </a>
  </p>

  <strong>
    <h2 align="center">Embla Carousel React</h2>
  </strong>

  <p align="center">
    <strong>Embla Carousel</strong> is a bare bones carousel library with great fluid motion and awesome swipe precision. It's library agnostic, dependency free and 100% open source.
  </p>

  <br>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/examples/predefined/">Examples</a>&nbsp;</code>
    </strong>
  </p>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/examples/generator/">Generator</a>&nbsp;</code>
    </strong>
  </p>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/get-started/#choose-installation-type">Installation</a>&nbsp;</code>
    </strong>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Ready for</h2>
  </strong>
  
  <p align="center">
    <a href="https://www.embla-carousel.com/get-started/module/">
      <img src="https://www.embla-carousel.com/javascript-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/module/">
      <img src="https://www.embla-carousel.com/typescript-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/react/">
      <img src="https://www.embla-carousel.com/react-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/vue/">
      <img src="https://www.embla-carousel.com/vue-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/svelte/">
      <img src="https://www.embla-carousel.com/svelte-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/solid/">
      <img src="https://www.embla-carousel.com/solid-logo.svg" width="40" height="40" />
    </a>
    <a href="https://github.com/donaldxdonald/embla-carousel-angular">
      <img src="https://www.embla-carousel.com/angular-logo.svg" width="40" height="40" />
    </a>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Contributors</h2>
  </strong>
  <p align="center">
    Thank you to all contributors for making <a href="https://www.embla-carousel.com/">Embla Carousel</a> awesome! <a href="https://github.com/davidjerleke/embla-carousel/blob/master/CONTRIBUTING.md">Contributions</a> are welcome.
  </p>
  <p align="center">
    <a href="https://github.com/davidjerleke">
      <img src="https://avatars2.githubusercontent.com/u/11529148?s=120&v=4" title="davidjerleke" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Ronit-gurjar">
      <img src="https://avatars2.githubusercontent.com/u/92150685?s=120&v=4" title="Ronit-gurjar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/zaaakher">
      <img src="https://avatars2.githubusercontent.com/u/46135573?s=120&v=4" title="zaaakher" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/xiel">
      <img src="https://avatars2.githubusercontent.com/u/615522?s=120&v=4" title="xiel" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/javiergonzalezGenially">
      <img src="https://avatars2.githubusercontent.com/u/78730098?s=120&v=4" title="javiergonzalezGenially" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/meirroth">
      <img src="https://avatars2.githubusercontent.com/u/12494197?s=120&v=4" title="meirroth" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/hamidrezahanafi">
      <img src="https://avatars2.githubusercontent.com/u/91487491?s=120&v=4" title="hamidrezahanafi" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/negezor">
      <img src="https://avatars2.githubusercontent.com/u/9392723?s=120&v=4" title="negezor" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/th-km">
      <img src="https://avatars2.githubusercontent.com/u/35410212?s=120&v=4" title="th-km" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/openscript">
      <img src="https://avatars2.githubusercontent.com/u/1105080?s=120&v=4" title="openscript" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/nwidynski">
      <img src="https://avatars2.githubusercontent.com/u/25958801?s=120&v=4" title="nwidynski" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/wopian">
      <img src="https://avatars2.githubusercontent.com/u/3440094?s=120&v=4" title="wopian" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/horseeyephil">
      <img src="https://avatars2.githubusercontent.com/u/32337092?s=120&v=4" title="horseeyephil" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/pipisasa">
      <img src="https://avatars2.githubusercontent.com/u/54534600?s=120&v=4" title="pipisasa" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ranno-lauri">
      <img src="https://avatars2.githubusercontent.com/u/87007115?s=120&v=4" title="ranno-lauri" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ruijdacd">
      <img src="https://avatars2.githubusercontent.com/u/9107610?s=120&v=4" title="ruijdacd" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/rojadesign">
      <img src="https://avatars2.githubusercontent.com/u/35687281?s=120&v=4" title="rojadesign" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sadeghbarati">
      <img src="https://avatars2.githubusercontent.com/u/17789047?s=120&v=4" title="sadeghbarati" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/S-Shingler">
      <img src="https://avatars2.githubusercontent.com/u/48463809?s=120&v=4" title="S-Shingler" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Yonom">
      <img src="https://avatars2.githubusercontent.com/u/1394504?s=120&v=4" title="Yonom" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/smultar">
      <img src="https://avatars2.githubusercontent.com/u/6223536?s=120&v=4" title="smultar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/dev-suraj-kumar">
      <img src="https://avatars2.githubusercontent.com/u/184739775?s=120&v=4" title="dev-suraj-kumar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Matoseb">
      <img src="https://avatars2.githubusercontent.com/u/24431250?s=120&v=4" title="Matoseb" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/tlo-johnson">
      <img src="https://avatars2.githubusercontent.com/u/8763144?s=120&v=4" title="tlo-johnson" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/yasuhiro-yamamoto">
      <img src="https://avatars2.githubusercontent.com/u/25109330?s=120&v=4" title="yasuhiro-yamamoto" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/anzbert">
      <img src="https://avatars2.githubusercontent.com/u/38823700?s=120&v=4" title="anzbert" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sarussss">
      <img src="https://avatars2.githubusercontent.com/u/15656996?s=120&v=4" title="sarussss" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/silllli">
      <img src="https://avatars2.githubusercontent.com/u/9334305?s=120&v=4" title="silllli" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/nikrowell">
      <img src="https://avatars2.githubusercontent.com/u/260039?s=120&v=4" title="nikrowell" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/mujahidfa">
      <img src="https://avatars2.githubusercontent.com/u/17759705?s=120&v=4" title="mujahidfa" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Mitch-At-Work">
      <img src="https://avatars2.githubusercontent.com/u/99835933?s=120&v=4" title="Mitch-At-Work" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/romellem">
      <img src="https://avatars2.githubusercontent.com/u/8504000?s=120&v=4" title="romellem" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/junlarsen">
      <img src="https://avatars2.githubusercontent.com/u/42585241?s=120&v=4" title="junlarsen" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/LucasMariniFalbo">
      <img src="https://avatars2.githubusercontent.com/u/9245477?s=120&v=4" title="LucasMariniFalbo" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/LiamMartens">
      <img src="https://avatars2.githubusercontent.com/u/5265324?s=120&v=4" title="LiamMartens" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/S1r-Lanzelot">
      <img src="https://avatars2.githubusercontent.com/u/4487160?s=120&v=4" title="S1r-Lanzelot" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ishaqibrahimbot">
      <img src="https://avatars2.githubusercontent.com/u/74908398?s=120&v=4" title="ishaqibrahimbot" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/fcasibu">
      <img src="https://avatars2.githubusercontent.com/u/75290989?s=120&v=4" title="fcasibu" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/cundd">
      <img src="https://avatars2.githubusercontent.com/u/743122?s=120&v=4" title="cundd" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sedlukha">
      <img src="https://avatars2.githubusercontent.com/u/14075940?s=120&v=4" title="sedlukha" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/allen-garvey">
      <img src="https://avatars2.githubusercontent.com/u/9314727?s=120&v=4" title="allen-garvey" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/lesha1201">
      <img src="https://avatars2.githubusercontent.com/u/10157660?s=120&v=4" title="lesha1201" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/SaizFerri">
      <img src="https://avatars2.githubusercontent.com/u/19834971?s=120&v=4" title="SaizFerri" width="50" height="50" style="max-width: 100%" />
    </a>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Special Thanks</h2>
  </strong>
  <p align="center">
    <sup>
      <a href="https://github.com/gunnarx2">gunnarx2</a> - React wrapper <a href="https://www.embla-carousel.com/get-started/react/">useEmblaCarousel</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/LiamMartens">LiamMartens</a> - Solid wrapper <a href="https://www.embla-carousel.com/get-started/solid/">createEmblaCarousel</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/donaldxdonald">donaldxdonald</a>, <a href="https://github.com/zip-fa">zip-fa</a>, <a href="https://github.com/JeanMeche">JeanMeche</a> - Angular wrapper <a href="https://github.com/donaldxdonald/embla-carousel-angular?tab=readme-ov-file#installation">EmblaCarouselDirective</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/xiel">xiel</a> - Plugin <a href="https://github.com/xiel/embla-carousel-wheel-gestures">Embla Carousel Wheel Gestures</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/zaaakher">zaaakher</a> - Contributing <a href="https://github.com/davidjerleke/embla-carousel/blob/master/CONTRIBUTING.md">guidelines</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/sarussss">sarussss</a> - Answering questions.
    </sup>
  </p>
</div>

<br>

<h2 align="center">Open Source</h2>

<p align="center">
  Embla is <a href="https://github.com/davidjerleke/embla-carousel/blob/master/LICENSE">MIT licensed</a> ?뮇.<br><br>
  <sup>Embla Carousel - Copyright 짤 2019-present.</sup><br />
  <sup>Package created by David Jerleke.</sup>
</p>

<p align="center">
  <strong>쨌 쨌 쨌</strong>
</p>

<p align="center">
  Thanks <a href="https://www.browserstack.com">BrowserStack</a>.
</p>

<p align="center">
  <a href="https://www.browserstack.com">
    <img src="https://www.embla-carousel.com/browserstack-logo.svg" width="45" height="45" />
    </a>
</p>

~~~

## node_modules\embla-carousel-reactive-utils\cjs\components\utils.d.ts

~~~ts
import { EmblaPluginType } from 'embla-carousel';
export declare function isObject(subject: unknown): subject is Record<string, unknown>;
export declare function isRecord(subject: unknown): subject is Record<string | number, unknown>;
export declare function canUseDOM(): boolean;
export declare function areOptionsEqual(optionsA: Record<string, unknown>, optionsB: Record<string, unknown>): boolean;
export declare function sortAndMapPluginToOptions(plugins: EmblaPluginType[]): EmblaPluginType['options'][];
export declare function arePluginsEqual(pluginsA: EmblaPluginType[], pluginsB: EmblaPluginType[]): boolean;

~~~

## node_modules\embla-carousel-reactive-utils\cjs\embla-carousel-reactive-utils.cjs.js

~~~js
'use strict';

function isObject(subject) {
  return Object.prototype.toString.call(subject) === '[object Object]';
}
function isRecord(subject) {
  return isObject(subject) || Array.isArray(subject);
}
function canUseDOM() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}
function areOptionsEqual(optionsA, optionsB) {
  const optionsAKeys = Object.keys(optionsA);
  const optionsBKeys = Object.keys(optionsB);
  if (optionsAKeys.length !== optionsBKeys.length) return false;
  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}));
  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}));
  if (breakpointsA !== breakpointsB) return false;
  return optionsAKeys.every(key => {
    const valueA = optionsA[key];
    const valueB = optionsB[key];
    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`;
    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB;
    return areOptionsEqual(valueA, valueB);
  });
}
function sortAndMapPluginToOptions(plugins) {
  return plugins.concat().sort((a, b) => a.name > b.name ? 1 : -1).map(plugin => plugin.options);
}
function arePluginsEqual(pluginsA, pluginsB) {
  if (pluginsA.length !== pluginsB.length) return false;
  const optionsA = sortAndMapPluginToOptions(pluginsA);
  const optionsB = sortAndMapPluginToOptions(pluginsB);
  return optionsA.every((optionA, index) => {
    const optionB = optionsB[index];
    return areOptionsEqual(optionA, optionB);
  });
}

exports.areOptionsEqual = areOptionsEqual;
exports.arePluginsEqual = arePluginsEqual;
exports.canUseDOM = canUseDOM;
exports.sortAndMapPluginToOptions = sortAndMapPluginToOptions;
//# sourceMappingURL=embla-carousel-reactive-utils.cjs.js.map

~~~

## node_modules\embla-carousel-reactive-utils\cjs\embla-carousel-reactive-utils.cjs.js.map

~~~map
{"version":3,"file":"embla-carousel-reactive-utils.cjs.js","sources":["../src/components/utils.ts"],"sourcesContent":["import { EmblaPluginType } from 'embla-carousel'\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isRecord(\n  subject: unknown\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || Array.isArray(subject)\n}\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function areOptionsEqual(\n  optionsA: Record<string, unknown>,\n  optionsB: Record<string, unknown>\n): boolean {\n  const optionsAKeys = Object.keys(optionsA)\n  const optionsBKeys = Object.keys(optionsB)\n\n  if (optionsAKeys.length !== optionsBKeys.length) return false\n\n  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}))\n  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}))\n\n  if (breakpointsA !== breakpointsB) return false\n\n  return optionsAKeys.every((key) => {\n    const valueA = optionsA[key]\n    const valueB = optionsB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return areOptionsEqual(valueA, valueB)\n  })\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[]\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[]\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areOptionsEqual(optionA, optionB)\n  })\n}\n"],"names":["isObject","subject","Object","prototype","toString","call","isRecord","Array","isArray","canUseDOM","window","document","createElement","areOptionsEqual","optionsA","optionsB","optionsAKeys","keys","optionsBKeys","length","breakpointsA","JSON","stringify","breakpoints","breakpointsB","every","key","valueA","valueB","sortAndMapPluginToOptions","plugins","concat","sort","a","b","name","map","plugin","options","arePluginsEqual","pluginsA","pluginsB","optionA","index","optionB"],"mappings":";;AAEM,SAAUA,QAAQA,CAACC,OAAgB,EAAA;EACvC,OAAOC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACJ,OAAO,CAAC,KAAK,iBAAiB;AACtE;AAEM,SAAUK,QAAQA,CACtBL,OAAgB,EAAA;EAEhB,OAAOD,QAAQ,CAACC,OAAO,CAAC,IAAIM,KAAK,CAACC,OAAO,CAACP,OAAO,CAAC;AACpD;SAEgBQ,SAASA,GAAA;AACvB,EAAA,OAAO,CAAC,EACN,OAAOC,MAAM,KAAK,WAAW,IAC7BA,MAAM,CAACC,QAAQ,IACfD,MAAM,CAACC,QAAQ,CAACC,aAAa,CAC9B;AACH;AAEgB,SAAAC,eAAeA,CAC7BC,QAAiC,EACjCC,QAAiC,EAAA;AAEjC,EAAA,MAAMC,YAAY,GAAGd,MAAM,CAACe,IAAI,CAACH,QAAQ,CAAC;AAC1C,EAAA,MAAMI,YAAY,GAAGhB,MAAM,CAACe,IAAI,CAACF,QAAQ,CAAC;EAE1C,IAAIC,YAAY,CAACG,MAAM,KAAKD,YAAY,CAACC,MAAM,EAAE,OAAO,KAAK;AAE7D,EAAA,MAAMC,YAAY,GAAGC,IAAI,CAACC,SAAS,CAACpB,MAAM,CAACe,IAAI,CAACH,QAAQ,CAACS,WAAW,IAAI,EAAE,CAAC,CAAC;AAC5E,EAAA,MAAMC,YAAY,GAAGH,IAAI,CAACC,SAAS,CAACpB,MAAM,CAACe,IAAI,CAACF,QAAQ,CAACQ,WAAW,IAAI,EAAE,CAAC,CAAC;AAE5E,EAAA,IAAIH,YAAY,KAAKI,YAAY,EAAE,OAAO,KAAK;AAE/C,EAAA,OAAOR,YAAY,CAACS,KAAK,CAAEC,GAAG,IAAI;AAChC,IAAA,MAAMC,MAAM,GAAGb,QAAQ,CAACY,GAAG,CAAC;AAC5B,IAAA,MAAME,MAAM,GAAGb,QAAQ,CAACW,GAAG,CAAC;AAC5B,IAAA,IAAI,OAAOC,MAAM,KAAK,UAAU,EAAE,OAAO,CAAGA,EAAAA,MAAM,CAAE,CAAA,KAAK,CAAGC,EAAAA,MAAM,CAAE,CAAA;AACpE,IAAA,IAAI,CAACtB,QAAQ,CAACqB,MAAM,CAAC,IAAI,CAACrB,QAAQ,CAACsB,MAAM,CAAC,EAAE,OAAOD,MAAM,KAAKC,MAAM;AACpE,IAAA,OAAOf,eAAe,CAACc,MAAM,EAAEC,MAAM,CAAC;AACxC,GAAC,CAAC;AACJ;AAEM,SAAUC,yBAAyBA,CACvCC,OAA0B,EAAA;AAE1B,EAAA,OAAOA,OAAO,CACXC,MAAM,EAAE,CACRC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAMD,CAAC,CAACE,IAAI,GAAGD,CAAC,CAACC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAE,CAAC,CAC1CC,GAAG,CAAEC,MAAM,IAAKA,MAAM,CAACC,OAAO,CAAC;AACpC;AAEgB,SAAAC,eAAeA,CAC7BC,QAA2B,EAC3BC,QAA2B,EAAA;EAE3B,IAAID,QAAQ,CAACrB,MAAM,KAAKsB,QAAQ,CAACtB,MAAM,EAAE,OAAO,KAAK;AAErD,EAAA,MAAML,QAAQ,GAAGe,yBAAyB,CAACW,QAAQ,CAAC;AACpD,EAAA,MAAMzB,QAAQ,GAAGc,yBAAyB,CAACY,QAAQ,CAAC;EAEpD,OAAO3B,QAAQ,CAACW,KAAK,CAAC,CAACiB,OAAO,EAAEC,KAAK,KAAI;AACvC,IAAA,MAAMC,OAAO,GAAG7B,QAAQ,CAAC4B,KAAK,CAAC;AAC/B,IAAA,OAAO9B,eAAe,CAAC6B,OAAO,EAAEE,OAAO,CAAC;AAC1C,GAAC,CAAC;AACJ;;;;;;;"}
~~~

## node_modules\embla-carousel-reactive-utils\cjs\index.d.ts

~~~ts
export { canUseDOM, areOptionsEqual, sortAndMapPluginToOptions, arePluginsEqual } from './components/utils';

~~~

## node_modules\embla-carousel-reactive-utils\cjs\package.json

~~~json
{
  "name": "embla-carousel-reactive-utils",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "Reactive utilities for Embla Carousel",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel-reactive-utils*",
    "components/**/*",
    "index.d.ts"
  ],
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "peerDependencies": {
    "embla-carousel": "8.6.0"
  },
  "main": "embla-carousel-reactive-utils.cjs.js",
  "type": "commonjs"
}

~~~

## node_modules\embla-carousel-reactive-utils\components\utils.d.ts

~~~ts
import { EmblaPluginType } from 'embla-carousel';
export declare function isObject(subject: unknown): subject is Record<string, unknown>;
export declare function isRecord(subject: unknown): subject is Record<string | number, unknown>;
export declare function canUseDOM(): boolean;
export declare function areOptionsEqual(optionsA: Record<string, unknown>, optionsB: Record<string, unknown>): boolean;
export declare function sortAndMapPluginToOptions(plugins: EmblaPluginType[]): EmblaPluginType['options'][];
export declare function arePluginsEqual(pluginsA: EmblaPluginType[], pluginsB: EmblaPluginType[]): boolean;

~~~

## node_modules\embla-carousel-reactive-utils\embla-carousel-reactive-utils.umd.js

~~~js
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports):"function"==typeof define&&define.amd?define(["exports"],n):n((e="undefined"!=typeof globalThis?globalThis:e||self).EmblaCarouselReactiveUtils={})}(this,(function(e){"use strict";function n(e){return function(e){return"[object Object]"===Object.prototype.toString.call(e)}(e)||Array.isArray(e)}function t(e,o){const i=Object.keys(e),r=Object.keys(o);if(i.length!==r.length)return!1;return JSON.stringify(Object.keys(e.breakpoints||{}))===JSON.stringify(Object.keys(o.breakpoints||{}))&&i.every((i=>{const r=e[i],u=o[i];return"function"==typeof r?`${r}`==`${u}`:n(r)&&n(u)?t(r,u):r===u}))}function o(e){return e.concat().sort(((e,n)=>e.name>n.name?1:-1)).map((e=>e.options))}e.areOptionsEqual=t,e.arePluginsEqual=function(e,n){if(e.length!==n.length)return!1;const i=o(e),r=o(n);return i.every(((e,n)=>t(e,r[n])))},e.canUseDOM=function(){return!("undefined"==typeof window||!window.document||!window.document.createElement)},e.sortAndMapPluginToOptions=o}));

~~~

## node_modules\embla-carousel-reactive-utils\esm\components\utils.d.ts

~~~ts
import { EmblaPluginType } from 'embla-carousel';
export declare function isObject(subject: unknown): subject is Record<string, unknown>;
export declare function isRecord(subject: unknown): subject is Record<string | number, unknown>;
export declare function canUseDOM(): boolean;
export declare function areOptionsEqual(optionsA: Record<string, unknown>, optionsB: Record<string, unknown>): boolean;
export declare function sortAndMapPluginToOptions(plugins: EmblaPluginType[]): EmblaPluginType['options'][];
export declare function arePluginsEqual(pluginsA: EmblaPluginType[], pluginsB: EmblaPluginType[]): boolean;

~~~

## node_modules\embla-carousel-reactive-utils\esm\embla-carousel-reactive-utils.esm.js

~~~js
function isObject(subject) {
  return Object.prototype.toString.call(subject) === '[object Object]';
}
function isRecord(subject) {
  return isObject(subject) || Array.isArray(subject);
}
function canUseDOM() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}
function areOptionsEqual(optionsA, optionsB) {
  const optionsAKeys = Object.keys(optionsA);
  const optionsBKeys = Object.keys(optionsB);
  if (optionsAKeys.length !== optionsBKeys.length) return false;
  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}));
  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}));
  if (breakpointsA !== breakpointsB) return false;
  return optionsAKeys.every(key => {
    const valueA = optionsA[key];
    const valueB = optionsB[key];
    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`;
    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB;
    return areOptionsEqual(valueA, valueB);
  });
}
function sortAndMapPluginToOptions(plugins) {
  return plugins.concat().sort((a, b) => a.name > b.name ? 1 : -1).map(plugin => plugin.options);
}
function arePluginsEqual(pluginsA, pluginsB) {
  if (pluginsA.length !== pluginsB.length) return false;
  const optionsA = sortAndMapPluginToOptions(pluginsA);
  const optionsB = sortAndMapPluginToOptions(pluginsB);
  return optionsA.every((optionA, index) => {
    const optionB = optionsB[index];
    return areOptionsEqual(optionA, optionB);
  });
}

export { areOptionsEqual, arePluginsEqual, canUseDOM, sortAndMapPluginToOptions };
//# sourceMappingURL=embla-carousel-reactive-utils.esm.js.map

~~~

## node_modules\embla-carousel-reactive-utils\esm\embla-carousel-reactive-utils.esm.js.map

~~~map
{"version":3,"file":"embla-carousel-reactive-utils.esm.js","sources":["../src/components/utils.ts"],"sourcesContent":["import { EmblaPluginType } from 'embla-carousel'\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isRecord(\n  subject: unknown\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || Array.isArray(subject)\n}\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function areOptionsEqual(\n  optionsA: Record<string, unknown>,\n  optionsB: Record<string, unknown>\n): boolean {\n  const optionsAKeys = Object.keys(optionsA)\n  const optionsBKeys = Object.keys(optionsB)\n\n  if (optionsAKeys.length !== optionsBKeys.length) return false\n\n  const breakpointsA = JSON.stringify(Object.keys(optionsA.breakpoints || {}))\n  const breakpointsB = JSON.stringify(Object.keys(optionsB.breakpoints || {}))\n\n  if (breakpointsA !== breakpointsB) return false\n\n  return optionsAKeys.every((key) => {\n    const valueA = optionsA[key]\n    const valueB = optionsB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return areOptionsEqual(valueA, valueB)\n  })\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[]\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[]\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areOptionsEqual(optionA, optionB)\n  })\n}\n"],"names":["isObject","subject","Object","prototype","toString","call","isRecord","Array","isArray","canUseDOM","window","document","createElement","areOptionsEqual","optionsA","optionsB","optionsAKeys","keys","optionsBKeys","length","breakpointsA","JSON","stringify","breakpoints","breakpointsB","every","key","valueA","valueB","sortAndMapPluginToOptions","plugins","concat","sort","a","b","name","map","plugin","options","arePluginsEqual","pluginsA","pluginsB","optionA","index","optionB"],"mappings":"AAEM,SAAUA,QAAQA,CAACC,OAAgB,EAAA;EACvC,OAAOC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACJ,OAAO,CAAC,KAAK,iBAAiB;AACtE;AAEM,SAAUK,QAAQA,CACtBL,OAAgB,EAAA;EAEhB,OAAOD,QAAQ,CAACC,OAAO,CAAC,IAAIM,KAAK,CAACC,OAAO,CAACP,OAAO,CAAC;AACpD;SAEgBQ,SAASA,GAAA;AACvB,EAAA,OAAO,CAAC,EACN,OAAOC,MAAM,KAAK,WAAW,IAC7BA,MAAM,CAACC,QAAQ,IACfD,MAAM,CAACC,QAAQ,CAACC,aAAa,CAC9B;AACH;AAEgB,SAAAC,eAAeA,CAC7BC,QAAiC,EACjCC,QAAiC,EAAA;AAEjC,EAAA,MAAMC,YAAY,GAAGd,MAAM,CAACe,IAAI,CAACH,QAAQ,CAAC;AAC1C,EAAA,MAAMI,YAAY,GAAGhB,MAAM,CAACe,IAAI,CAACF,QAAQ,CAAC;EAE1C,IAAIC,YAAY,CAACG,MAAM,KAAKD,YAAY,CAACC,MAAM,EAAE,OAAO,KAAK;AAE7D,EAAA,MAAMC,YAAY,GAAGC,IAAI,CAACC,SAAS,CAACpB,MAAM,CAACe,IAAI,CAACH,QAAQ,CAACS,WAAW,IAAI,EAAE,CAAC,CAAC;AAC5E,EAAA,MAAMC,YAAY,GAAGH,IAAI,CAACC,SAAS,CAACpB,MAAM,CAACe,IAAI,CAACF,QAAQ,CAACQ,WAAW,IAAI,EAAE,CAAC,CAAC;AAE5E,EAAA,IAAIH,YAAY,KAAKI,YAAY,EAAE,OAAO,KAAK;AAE/C,EAAA,OAAOR,YAAY,CAACS,KAAK,CAAEC,GAAG,IAAI;AAChC,IAAA,MAAMC,MAAM,GAAGb,QAAQ,CAACY,GAAG,CAAC;AAC5B,IAAA,MAAME,MAAM,GAAGb,QAAQ,CAACW,GAAG,CAAC;AAC5B,IAAA,IAAI,OAAOC,MAAM,KAAK,UAAU,EAAE,OAAO,CAAGA,EAAAA,MAAM,CAAE,CAAA,KAAK,CAAGC,EAAAA,MAAM,CAAE,CAAA;AACpE,IAAA,IAAI,CAACtB,QAAQ,CAACqB,MAAM,CAAC,IAAI,CAACrB,QAAQ,CAACsB,MAAM,CAAC,EAAE,OAAOD,MAAM,KAAKC,MAAM;AACpE,IAAA,OAAOf,eAAe,CAACc,MAAM,EAAEC,MAAM,CAAC;AACxC,GAAC,CAAC;AACJ;AAEM,SAAUC,yBAAyBA,CACvCC,OAA0B,EAAA;AAE1B,EAAA,OAAOA,OAAO,CACXC,MAAM,EAAE,CACRC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAMD,CAAC,CAACE,IAAI,GAAGD,CAAC,CAACC,IAAI,GAAG,CAAC,GAAG,CAAC,CAAE,CAAC,CAC1CC,GAAG,CAAEC,MAAM,IAAKA,MAAM,CAACC,OAAO,CAAC;AACpC;AAEgB,SAAAC,eAAeA,CAC7BC,QAA2B,EAC3BC,QAA2B,EAAA;EAE3B,IAAID,QAAQ,CAACrB,MAAM,KAAKsB,QAAQ,CAACtB,MAAM,EAAE,OAAO,KAAK;AAErD,EAAA,MAAML,QAAQ,GAAGe,yBAAyB,CAACW,QAAQ,CAAC;AACpD,EAAA,MAAMzB,QAAQ,GAAGc,yBAAyB,CAACY,QAAQ,CAAC;EAEpD,OAAO3B,QAAQ,CAACW,KAAK,CAAC,CAACiB,OAAO,EAAEC,KAAK,KAAI;AACvC,IAAA,MAAMC,OAAO,GAAG7B,QAAQ,CAAC4B,KAAK,CAAC;AAC/B,IAAA,OAAO9B,eAAe,CAAC6B,OAAO,EAAEE,OAAO,CAAC;AAC1C,GAAC,CAAC;AACJ;;;;"}
~~~

## node_modules\embla-carousel-reactive-utils\esm\index.d.ts

~~~ts
export { canUseDOM, areOptionsEqual, sortAndMapPluginToOptions, arePluginsEqual } from './components/utils.js';

~~~

## node_modules\embla-carousel-reactive-utils\esm\package.json

~~~json
{
  "name": "embla-carousel-reactive-utils",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "Reactive utilities for Embla Carousel",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel-reactive-utils*",
    "components/**/*",
    "index.d.ts"
  ],
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "peerDependencies": {
    "embla-carousel": "8.6.0"
  },
  "module": "embla-carousel-reactive-utils.esm.js",
  "type": "module"
}

~~~

## node_modules\embla-carousel-reactive-utils\index.d.ts

~~~ts
export { canUseDOM, areOptionsEqual, sortAndMapPluginToOptions, arePluginsEqual } from './components/utils';

~~~

## node_modules\embla-carousel-reactive-utils\package.json

~~~json
{
  "name": "embla-carousel-reactive-utils",
  "version": "8.6.0",
  "author": "David Jerleke",
  "description": "Reactive utilities for Embla Carousel",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/davidjerleke/embla-carousel"
  },
  "bugs": {
    "url": "https://github.com/davidjerleke/embla-carousel/issues"
  },
  "homepage": "https://www.embla-carousel.com",
  "license": "MIT",
  "keywords": [
    "slider",
    "carousel",
    "slideshow",
    "gallery",
    "lightweight",
    "touch",
    "javascript",
    "typescript",
    "react",
    "vue",
    "svelte",
    "solid"
  ],
  "main": "embla-carousel-reactive-utils.umd.js",
  "unpkg": "embla-carousel-reactive-utils.umd.js",
  "module": "./esm/embla-carousel-reactive-utils.esm.js",
  "types": "index.d.ts",
  "sideEffects": false,
  "files": [
    "embla-carousel-reactive-utils*",
    "components/**/*",
    "index.d.ts",
    "esm/**/*",
    "cjs/**/*"
  ],
  "scripts": {
    "test": "jest --config jest.config.js",
    "build": "rollup --bundleConfigAsCjs -c",
    "start": "rollup --bundleConfigAsCjs -c --watch --environment BUILD:development",
    "eslint:report": "eslint \"src/**/*.{js,tsx,ts}\""
  },
  "devDependencies": {
    "@types/jest": "^29.5.6",
    "@typescript-eslint/eslint-plugin": "^6.9.0",
    "@typescript-eslint/parser": "^6.9.0",
    "eslint": "^8.52.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-plugin-prettier": "^4.0.0",
    "jest": "^29.5.0",
    "jest-environment-jsdom": "^29.5.0",
    "prettier": "2.8.8",
    "rollup": "^4.22.4",
    "ts-jest": "^29.1.1",
    "typescript": "^5.2.2"
  },
  "peerDependencies": {
    "embla-carousel": "8.6.0"
  },
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "import": {
        "types": "./esm/index.d.ts",
        "default": "./esm/embla-carousel-reactive-utils.esm.js"
      },
      "require": {
        "types": "./cjs/index.d.ts",
        "default": "./cjs/embla-carousel-reactive-utils.cjs.js"
      }
    }
  }
}
~~~

## node_modules\embla-carousel-reactive-utils\README.md

~~~md
<br />
<div align="center">
  <p align="center">
    <a href="https://www.embla-carousel.com/"><img width="100" height="100" src="https://www.embla-carousel.com/embla-logo.svg" alt="Embla Carousel">
    </a>
  </p>

  <p align="center">
    <a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/npm/l/embla-carousel?color=%238ab4f8"></a>
    <a href="https://www.npmjs.com/package/embla-carousel-reactive-utils"><img src="https://img.shields.io/npm/v/embla-carousel-reactive-utils.svg?color=%23c1a8e2"></a>
    <a href="https://github.com/davidjerleke/embla-carousel/actions?query=workflow%3A%22Continuous+Integration%22"><img src="https://img.shields.io/github/actions/workflow/status/davidjerleke/embla-carousel/cd.yml?color=%238ab4f8"></a>
    <a href="https://prettier.io"><img src="https://img.shields.io/badge/code_style-prettier-ff69b4.svg?color=%23c1a8e2"></a>
    <a href="https://bundlephobia.com/result?p=embla-carousel-reactive-utils@latest"><img src="https://img.shields.io/bundlephobia/minzip/embla-carousel-reactive-utils?color=%238ab4f8&label=gzip%20size">
    </a>
  </p>

  <strong>
    <h2 align="center">Embla Carousel Reactive Utils</h2>
  </strong>

  <p align="center">
    <strong>Embla Carousel</strong> is a bare bones carousel library with great fluid motion and awesome swipe precision. It's library agnostic, dependency free and 100% open source.
  </p>

  <br>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/examples/predefined/">Examples</a>&nbsp;</code>
    </strong>
  </p>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/examples/generator/">Generator</a>&nbsp;</code>
    </strong>
  </p>

  <p align="center">
    <strong>
      <code>&nbsp;<a href="https://www.embla-carousel.com/get-started/#choose-installation-type">Installation</a>&nbsp;</code>
    </strong>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Ready for</h2>
  </strong>
  
  <p align="center">
    <a href="https://www.embla-carousel.com/get-started/module/">
      <img src="https://www.embla-carousel.com/javascript-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/module/">
      <img src="https://www.embla-carousel.com/typescript-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/react/">
      <img src="https://www.embla-carousel.com/react-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/vue/">
      <img src="https://www.embla-carousel.com/vue-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/svelte/">
      <img src="https://www.embla-carousel.com/svelte-logo.svg" width="40" height="40" />
    </a>
    <a href="https://www.embla-carousel.com/get-started/solid/">
      <img src="https://www.embla-carousel.com/solid-logo.svg" width="40" height="40" />
    </a>
    <a href="https://github.com/donaldxdonald/embla-carousel-angular">
      <img src="https://www.embla-carousel.com/angular-logo.svg" width="40" height="40" />
    </a>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Contributors</h2>
  </strong>
  <p align="center">
    Thank you to all contributors for making <a href="https://www.embla-carousel.com/">Embla Carousel</a> awesome! <a href="https://github.com/davidjerleke/embla-carousel/blob/master/CONTRIBUTING.md">Contributions</a> are welcome.
  </p>
  <p align="center">
    <a href="https://github.com/davidjerleke">
      <img src="https://avatars2.githubusercontent.com/u/11529148?s=120&v=4" title="davidjerleke" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Ronit-gurjar">
      <img src="https://avatars2.githubusercontent.com/u/92150685?s=120&v=4" title="Ronit-gurjar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/zaaakher">
      <img src="https://avatars2.githubusercontent.com/u/46135573?s=120&v=4" title="zaaakher" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/xiel">
      <img src="https://avatars2.githubusercontent.com/u/615522?s=120&v=4" title="xiel" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/javiergonzalezGenially">
      <img src="https://avatars2.githubusercontent.com/u/78730098?s=120&v=4" title="javiergonzalezGenially" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/meirroth">
      <img src="https://avatars2.githubusercontent.com/u/12494197?s=120&v=4" title="meirroth" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/hamidrezahanafi">
      <img src="https://avatars2.githubusercontent.com/u/91487491?s=120&v=4" title="hamidrezahanafi" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/negezor">
      <img src="https://avatars2.githubusercontent.com/u/9392723?s=120&v=4" title="negezor" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/th-km">
      <img src="https://avatars2.githubusercontent.com/u/35410212?s=120&v=4" title="th-km" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/openscript">
      <img src="https://avatars2.githubusercontent.com/u/1105080?s=120&v=4" title="openscript" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/nwidynski">
      <img src="https://avatars2.githubusercontent.com/u/25958801?s=120&v=4" title="nwidynski" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/wopian">
      <img src="https://avatars2.githubusercontent.com/u/3440094?s=120&v=4" title="wopian" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/horseeyephil">
      <img src="https://avatars2.githubusercontent.com/u/32337092?s=120&v=4" title="horseeyephil" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/pipisasa">
      <img src="https://avatars2.githubusercontent.com/u/54534600?s=120&v=4" title="pipisasa" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ranno-lauri">
      <img src="https://avatars2.githubusercontent.com/u/87007115?s=120&v=4" title="ranno-lauri" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ruijdacd">
      <img src="https://avatars2.githubusercontent.com/u/9107610?s=120&v=4" title="ruijdacd" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/rojadesign">
      <img src="https://avatars2.githubusercontent.com/u/35687281?s=120&v=4" title="rojadesign" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sadeghbarati">
      <img src="https://avatars2.githubusercontent.com/u/17789047?s=120&v=4" title="sadeghbarati" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/S-Shingler">
      <img src="https://avatars2.githubusercontent.com/u/48463809?s=120&v=4" title="S-Shingler" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Yonom">
      <img src="https://avatars2.githubusercontent.com/u/1394504?s=120&v=4" title="Yonom" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/smultar">
      <img src="https://avatars2.githubusercontent.com/u/6223536?s=120&v=4" title="smultar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/dev-suraj-kumar">
      <img src="https://avatars2.githubusercontent.com/u/184739775?s=120&v=4" title="dev-suraj-kumar" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Matoseb">
      <img src="https://avatars2.githubusercontent.com/u/24431250?s=120&v=4" title="Matoseb" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/tlo-johnson">
      <img src="https://avatars2.githubusercontent.com/u/8763144?s=120&v=4" title="tlo-johnson" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/yasuhiro-yamamoto">
      <img src="https://avatars2.githubusercontent.com/u/25109330?s=120&v=4" title="yasuhiro-yamamoto" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/anzbert">
      <img src="https://avatars2.githubusercontent.com/u/38823700?s=120&v=4" title="anzbert" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sarussss">
      <img src="https://avatars2.githubusercontent.com/u/15656996?s=120&v=4" title="sarussss" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/silllli">
      <img src="https://avatars2.githubusercontent.com/u/9334305?s=120&v=4" title="silllli" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/nikrowell">
      <img src="https://avatars2.githubusercontent.com/u/260039?s=120&v=4" title="nikrowell" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/mujahidfa">
      <img src="https://avatars2.githubusercontent.com/u/17759705?s=120&v=4" title="mujahidfa" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/Mitch-At-Work">
      <img src="https://avatars2.githubusercontent.com/u/99835933?s=120&v=4" title="Mitch-At-Work" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/romellem">
      <img src="https://avatars2.githubusercontent.com/u/8504000?s=120&v=4" title="romellem" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/junlarsen">
      <img src="https://avatars2.githubusercontent.com/u/42585241?s=120&v=4" title="junlarsen" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/LucasMariniFalbo">
      <img src="https://avatars2.githubusercontent.com/u/9245477?s=120&v=4" title="LucasMariniFalbo" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/LiamMartens">
      <img src="https://avatars2.githubusercontent.com/u/5265324?s=120&v=4" title="LiamMartens" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/S1r-Lanzelot">
      <img src="https://avatars2.githubusercontent.com/u/4487160?s=120&v=4" title="S1r-Lanzelot" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/ishaqibrahimbot">
      <img src="https://avatars2.githubusercontent.com/u/74908398?s=120&v=4" title="ishaqibrahimbot" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/fcasibu">
      <img src="https://avatars2.githubusercontent.com/u/75290989?s=120&v=4" title="fcasibu" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/cundd">
      <img src="https://avatars2.githubusercontent.com/u/743122?s=120&v=4" title="cundd" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/sedlukha">
      <img src="https://avatars2.githubusercontent.com/u/14075940?s=120&v=4" title="sedlukha" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/allen-garvey">
      <img src="https://avatars2.githubusercontent.com/u/9314727?s=120&v=4" title="allen-garvey" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/lesha1201">
      <img src="https://avatars2.githubusercontent.com/u/10157660?s=120&v=4" title="lesha1201" width="50" height="50" style="max-width: 100%" />
    </a><a href="https://github.com/SaizFerri">
      <img src="https://avatars2.githubusercontent.com/u/19834971?s=120&v=4" title="SaizFerri" width="50" height="50" style="max-width: 100%" />
    </a>
  </p>
</div>

<br>

<div align="center">
  <strong>
    <h2 align="center">Special Thanks</h2>
  </strong>
  <p align="center">
    <sup>
      <a href="https://github.com/gunnarx2">gunnarx2</a> - React wrapper <a href="https://www.embla-carousel.com/get-started/react/">useEmblaCarousel</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/LiamMartens">LiamMartens</a> - Solid wrapper <a href="https://www.embla-carousel.com/get-started/solid/">createEmblaCarousel</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/donaldxdonald">donaldxdonald</a>, <a href="https://github.com/zip-fa">zip-fa</a>, <a href="https://github.com/JeanMeche">JeanMeche</a> - Angular wrapper <a href="https://github.com/donaldxdonald/embla-carousel-angular?tab=readme-ov-file#installation">EmblaCarouselDirective</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/xiel">xiel</a> - Plugin <a href="https://github.com/xiel/embla-carousel-wheel-gestures">Embla Carousel Wheel Gestures</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/zaaakher">zaaakher</a> - Contributing <a href="https://github.com/davidjerleke/embla-carousel/blob/master/CONTRIBUTING.md">guidelines</a>.
    </sup>
    <br>
    <sup>
      <a href="https://github.com/sarussss">sarussss</a> - Answering questions.
    </sup>
  </p>
</div>

<br>

<h2 align="center">Open Source</h2>

<p align="center">
  Embla is <a href="https://github.com/davidjerleke/embla-carousel/blob/master/LICENSE">MIT licensed</a> ?뮇.<br><br>
  <sup>Embla Carousel - Copyright 짤 2019-present.</sup><br />
  <sup>Package created by David Jerleke.</sup>
</p>

<p align="center">
  <strong>쨌 쨌 쨌</strong>
</p>

<p align="center">
  Thanks <a href="https://www.browserstack.com">BrowserStack</a>.
</p>

<p align="center">
  <a href="https://www.browserstack.com">
    <img src="https://www.embla-carousel.com/browserstack-logo.svg" width="45" height="45" />
    </a>
</p>

~~~

## node_modules\esbuild\bin\esbuild

~~~text
#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// lib/npm/node-platform.ts
var fs = require("fs");
var os = require("os");
var path = require("path");
var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
var packageDarwin_arm64 = "@esbuild/darwin-arm64";
var packageDarwin_x64 = "@esbuild/darwin-x64";
var knownWindowsPackages = {
  "win32 arm64 LE": "@esbuild/win32-arm64",
  "win32 ia32 LE": "@esbuild/win32-ia32",
  "win32 x64 LE": "@esbuild/win32-x64"
};
var knownUnixlikePackages = {
  "aix ppc64 BE": "@esbuild/aix-ppc64",
  "android arm64 LE": "@esbuild/android-arm64",
  "darwin arm64 LE": "@esbuild/darwin-arm64",
  "darwin x64 LE": "@esbuild/darwin-x64",
  "freebsd arm64 LE": "@esbuild/freebsd-arm64",
  "freebsd x64 LE": "@esbuild/freebsd-x64",
  "linux arm LE": "@esbuild/linux-arm",
  "linux arm64 LE": "@esbuild/linux-arm64",
  "linux ia32 LE": "@esbuild/linux-ia32",
  "linux mips64el LE": "@esbuild/linux-mips64el",
  "linux ppc64 LE": "@esbuild/linux-ppc64",
  "linux riscv64 LE": "@esbuild/linux-riscv64",
  "linux s390x BE": "@esbuild/linux-s390x",
  "linux x64 LE": "@esbuild/linux-x64",
  "linux loong64 LE": "@esbuild/linux-loong64",
  "netbsd arm64 LE": "@esbuild/netbsd-arm64",
  "netbsd x64 LE": "@esbuild/netbsd-x64",
  "openbsd arm64 LE": "@esbuild/openbsd-arm64",
  "openbsd x64 LE": "@esbuild/openbsd-x64",
  "sunos x64 LE": "@esbuild/sunos-x64"
};
var knownWebAssemblyFallbackPackages = {
  "android arm LE": "@esbuild/android-arm",
  "android x64 LE": "@esbuild/android-x64",
  "openharmony arm64 LE": "@esbuild/openharmony-arm64"
};
function pkgAndSubpathForCurrentPlatform() {
  let pkg;
  let subpath;
  let isWASM2 = false;
  let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
  if (platformKey in knownWindowsPackages) {
    pkg = knownWindowsPackages[platformKey];
    subpath = "esbuild.exe";
  } else if (platformKey in knownUnixlikePackages) {
    pkg = knownUnixlikePackages[platformKey];
    subpath = "bin/esbuild";
  } else if (platformKey in knownWebAssemblyFallbackPackages) {
    pkg = knownWebAssemblyFallbackPackages[platformKey];
    subpath = "bin/esbuild";
    isWASM2 = true;
  } else {
    throw new Error(`Unsupported platform: ${platformKey}`);
  }
  return { pkg, subpath, isWASM: isWASM2 };
}
function pkgForSomeOtherPlatform() {
  const libMainJS = require.resolve("esbuild");
  const nodeModulesDirectory = path.dirname(path.dirname(path.dirname(libMainJS)));
  if (path.basename(nodeModulesDirectory) === "node_modules") {
    for (const unixKey in knownUnixlikePackages) {
      try {
        const pkg = knownUnixlikePackages[unixKey];
        if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
      } catch {
      }
    }
    for (const windowsKey in knownWindowsPackages) {
      try {
        const pkg = knownWindowsPackages[windowsKey];
        if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
      } catch {
      }
    }
  }
  return null;
}
function downloadedBinPath(pkg, subpath) {
  const esbuildLibDir = path.dirname(require.resolve("esbuild"));
  return path.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
}
function generateBinPath() {
  if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
    if (!fs.existsSync(ESBUILD_BINARY_PATH)) {
      console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
    } else {
      return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
    }
  }
  const { pkg, subpath, isWASM: isWASM2 } = pkgAndSubpathForCurrentPlatform();
  let binPath2;
  try {
    binPath2 = require.resolve(`${pkg}/${subpath}`);
  } catch (e) {
    binPath2 = downloadedBinPath(pkg, subpath);
    if (!fs.existsSync(binPath2)) {
      try {
        require.resolve(pkg);
      } catch {
        const otherPkg = pkgForSomeOtherPlatform();
        if (otherPkg) {
          let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
          if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
            suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
          }
          throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
        }
        throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
      }
      throw e;
    }
  }
  if (/\.zip\//.test(binPath2)) {
    let pnpapi;
    try {
      pnpapi = require("pnpapi");
    } catch (e) {
    }
    if (pnpapi) {
      const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
      const binTargetPath = path.join(
        root,
        "node_modules",
        ".cache",
        "esbuild",
        `pnpapi-${pkg.replace("/", "-")}-${"0.25.12"}-${path.basename(subpath)}`
      );
      if (!fs.existsSync(binTargetPath)) {
        fs.mkdirSync(path.dirname(binTargetPath), { recursive: true });
        fs.copyFileSync(binPath2, binTargetPath);
        fs.chmodSync(binTargetPath, 493);
      }
      return { binPath: binTargetPath, isWASM: isWASM2 };
    }
  }
  return { binPath: binPath2, isWASM: isWASM2 };
}

// lib/npm/node-shim.ts
var { binPath, isWASM } = generateBinPath();
if (isWASM) {
  require("child_process").execFileSync("node", [binPath].concat(process.argv.slice(2)), { stdio: "inherit" });
} else {
  require("child_process").execFileSync(binPath, process.argv.slice(2), { stdio: "inherit" });
}

~~~

## node_modules\esbuild\install.js

~~~js
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// lib/npm/node-platform.ts
var fs = require("fs");
var os = require("os");
var path = require("path");
var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
var knownWindowsPackages = {
  "win32 arm64 LE": "@esbuild/win32-arm64",
  "win32 ia32 LE": "@esbuild/win32-ia32",
  "win32 x64 LE": "@esbuild/win32-x64"
};
var knownUnixlikePackages = {
  "aix ppc64 BE": "@esbuild/aix-ppc64",
  "android arm64 LE": "@esbuild/android-arm64",
  "darwin arm64 LE": "@esbuild/darwin-arm64",
  "darwin x64 LE": "@esbuild/darwin-x64",
  "freebsd arm64 LE": "@esbuild/freebsd-arm64",
  "freebsd x64 LE": "@esbuild/freebsd-x64",
  "linux arm LE": "@esbuild/linux-arm",
  "linux arm64 LE": "@esbuild/linux-arm64",
  "linux ia32 LE": "@esbuild/linux-ia32",
  "linux mips64el LE": "@esbuild/linux-mips64el",
  "linux ppc64 LE": "@esbuild/linux-ppc64",
  "linux riscv64 LE": "@esbuild/linux-riscv64",
  "linux s390x BE": "@esbuild/linux-s390x",
  "linux x64 LE": "@esbuild/linux-x64",
  "linux loong64 LE": "@esbuild/linux-loong64",
  "netbsd arm64 LE": "@esbuild/netbsd-arm64",
  "netbsd x64 LE": "@esbuild/netbsd-x64",
  "openbsd arm64 LE": "@esbuild/openbsd-arm64",
  "openbsd x64 LE": "@esbuild/openbsd-x64",
  "sunos x64 LE": "@esbuild/sunos-x64"
};
var knownWebAssemblyFallbackPackages = {
  "android arm LE": "@esbuild/android-arm",
  "android x64 LE": "@esbuild/android-x64",
  "openharmony arm64 LE": "@esbuild/openharmony-arm64"
};
function pkgAndSubpathForCurrentPlatform() {
  let pkg;
  let subpath;
  let isWASM = false;
  let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
  if (platformKey in knownWindowsPackages) {
    pkg = knownWindowsPackages[platformKey];
    subpath = "esbuild.exe";
  } else if (platformKey in knownUnixlikePackages) {
    pkg = knownUnixlikePackages[platformKey];
    subpath = "bin/esbuild";
  } else if (platformKey in knownWebAssemblyFallbackPackages) {
    pkg = knownWebAssemblyFallbackPackages[platformKey];
    subpath = "bin/esbuild";
    isWASM = true;
  } else {
    throw new Error(`Unsupported platform: ${platformKey}`);
  }
  return { pkg, subpath, isWASM };
}
function downloadedBinPath(pkg, subpath) {
  const esbuildLibDir = path.dirname(require.resolve("esbuild"));
  return path.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
}

// lib/npm/node-install.ts
var fs2 = require("fs");
var os2 = require("os");
var path2 = require("path");
var zlib = require("zlib");
var https = require("https");
var child_process = require("child_process");
var versionFromPackageJSON = require(path2.join(__dirname, "package.json")).version;
var toPath = path2.join(__dirname, "bin", "esbuild");
var isToPathJS = true;
function validateBinaryVersion(...command) {
  command.push("--version");
  let stdout;
  try {
    stdout = child_process.execFileSync(command.shift(), command, {
      // Without this, this install script strangely crashes with the error
      // "EACCES: permission denied, write" but only on Ubuntu Linux when node is
      // installed from the Snap Store. This is not a problem when you download
      // the official version of node. The problem appears to be that stderr
      // (i.e. file descriptor 2) isn't writable?
      //
      // More info:
      // - https://snapcraft.io/ (what the Snap Store is)
      // - https://nodejs.org/dist/ (download the official version of node)
      // - https://github.com/evanw/esbuild/issues/1711#issuecomment-1027554035
      //
      stdio: "pipe"
    }).toString().trim();
  } catch (err) {
    if (os2.platform() === "darwin" && /_SecTrustEvaluateWithError/.test(err + "")) {
      let os3 = "this version of macOS";
      try {
        os3 = "macOS " + child_process.execFileSync("sw_vers", ["-productVersion"]).toString().trim();
      } catch {
      }
      throw new Error(`The "esbuild" package cannot be installed because ${os3} is too outdated.

The Go compiler (which esbuild relies on) no longer supports ${os3},
which means the "esbuild" binary executable can't be run. You can either:

  * Update your version of macOS to one that the Go compiler supports
  * Use the "esbuild-wasm" package instead of the "esbuild" package
  * Build esbuild yourself using an older version of the Go compiler
`);
    }
    throw err;
  }
  if (stdout !== versionFromPackageJSON) {
    throw new Error(`Expected ${JSON.stringify(versionFromPackageJSON)} but got ${JSON.stringify(stdout)}`);
  }
}
function isYarn() {
  const { npm_config_user_agent } = process.env;
  if (npm_config_user_agent) {
    return /\byarn\//.test(npm_config_user_agent);
  }
  return false;
}
function fetch(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => {
      if ((res.statusCode === 301 || res.statusCode === 302) && res.headers.location)
        return fetch(res.headers.location).then(resolve, reject);
      if (res.statusCode !== 200)
        return reject(new Error(`Server responded with ${res.statusCode}`));
      let chunks = [];
      res.on("data", (chunk) => chunks.push(chunk));
      res.on("end", () => resolve(Buffer.concat(chunks)));
    }).on("error", reject);
  });
}
function extractFileFromTarGzip(buffer, subpath) {
  try {
    buffer = zlib.unzipSync(buffer);
  } catch (err) {
    throw new Error(`Invalid gzip data in archive: ${err && err.message || err}`);
  }
  let str = (i, n) => String.fromCharCode(...buffer.subarray(i, i + n)).replace(/\0.*$/, "");
  let offset = 0;
  subpath = `package/${subpath}`;
  while (offset < buffer.length) {
    let name = str(offset, 100);
    let size = parseInt(str(offset + 124, 12), 8);
    offset += 512;
    if (!isNaN(size)) {
      if (name === subpath) return buffer.subarray(offset, offset + size);
      offset += size + 511 & ~511;
    }
  }
  throw new Error(`Could not find ${JSON.stringify(subpath)} in archive`);
}
function installUsingNPM(pkg, subpath, binPath) {
  const env = { ...process.env, npm_config_global: void 0 };
  const esbuildLibDir = path2.dirname(require.resolve("esbuild"));
  const installDir = path2.join(esbuildLibDir, "npm-install");
  fs2.mkdirSync(installDir);
  try {
    fs2.writeFileSync(path2.join(installDir, "package.json"), "{}");
    child_process.execSync(
      `npm install --loglevel=error --prefer-offline --no-audit --progress=false ${pkg}@${versionFromPackageJSON}`,
      { cwd: installDir, stdio: "pipe", env }
    );
    const installedBinPath = path2.join(installDir, "node_modules", pkg, subpath);
    fs2.renameSync(installedBinPath, binPath);
  } finally {
    try {
      removeRecursive(installDir);
    } catch {
    }
  }
}
function removeRecursive(dir) {
  for (const entry of fs2.readdirSync(dir)) {
    const entryPath = path2.join(dir, entry);
    let stats;
    try {
      stats = fs2.lstatSync(entryPath);
    } catch {
      continue;
    }
    if (stats.isDirectory()) removeRecursive(entryPath);
    else fs2.unlinkSync(entryPath);
  }
  fs2.rmdirSync(dir);
}
function applyManualBinaryPathOverride(overridePath) {
  const pathString = JSON.stringify(overridePath);
  fs2.writeFileSync(toPath, `#!/usr/bin/env node
require('child_process').execFileSync(${pathString}, process.argv.slice(2), { stdio: 'inherit' });
`);
  const libMain = path2.join(__dirname, "lib", "main.js");
  const code = fs2.readFileSync(libMain, "utf8");
  fs2.writeFileSync(libMain, `var ESBUILD_BINARY_PATH = ${pathString};
${code}`);
}
function maybeOptimizePackage(binPath) {
  const { isWASM } = pkgAndSubpathForCurrentPlatform();
  if (os2.platform() !== "win32" && !isYarn() && !isWASM) {
    const tempPath = path2.join(__dirname, "bin-esbuild");
    try {
      fs2.linkSync(binPath, tempPath);
      fs2.renameSync(tempPath, toPath);
      isToPathJS = false;
      fs2.unlinkSync(tempPath);
    } catch {
    }
  }
}
async function downloadDirectlyFromNPM(pkg, subpath, binPath) {
  const url = `https://registry.npmjs.org/${pkg}/-/${pkg.replace("@esbuild/", "")}-${versionFromPackageJSON}.tgz`;
  console.error(`[esbuild] Trying to download ${JSON.stringify(url)}`);
  try {
    fs2.writeFileSync(binPath, extractFileFromTarGzip(await fetch(url), subpath));
    fs2.chmodSync(binPath, 493);
  } catch (e) {
    console.error(`[esbuild] Failed to download ${JSON.stringify(url)}: ${e && e.message || e}`);
    throw e;
  }
}
async function checkAndPreparePackage() {
  if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
    if (!fs2.existsSync(ESBUILD_BINARY_PATH)) {
      console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
    } else {
      applyManualBinaryPathOverride(ESBUILD_BINARY_PATH);
      return;
    }
  }
  const { pkg, subpath } = pkgAndSubpathForCurrentPlatform();
  let binPath;
  try {
    binPath = require.resolve(`${pkg}/${subpath}`);
  } catch (e) {
    console.error(`[esbuild] Failed to find package "${pkg}" on the file system

This can happen if you use the "--no-optional" flag. The "optionalDependencies"
package.json feature is used by esbuild to install the correct binary executable
for your current platform. This install script will now attempt to work around
this. If that fails, you need to remove the "--no-optional" flag to use esbuild.
`);
    binPath = downloadedBinPath(pkg, subpath);
    try {
      console.error(`[esbuild] Trying to install package "${pkg}" using npm`);
      installUsingNPM(pkg, subpath, binPath);
    } catch (e2) {
      console.error(`[esbuild] Failed to install package "${pkg}" using npm: ${e2 && e2.message || e2}`);
      try {
        await downloadDirectlyFromNPM(pkg, subpath, binPath);
      } catch (e3) {
        throw new Error(`Failed to install package "${pkg}"`);
      }
    }
  }
  maybeOptimizePackage(binPath);
}
checkAndPreparePackage().then(() => {
  if (isToPathJS) {
    validateBinaryVersion(process.execPath, toPath);
  } else {
    validateBinaryVersion(toPath);
  }
});

~~~

## node_modules\esbuild\lib\main.d.ts

~~~ts
export type Platform = 'browser' | 'node' | 'neutral'
export type Format = 'iife' | 'cjs' | 'esm'
export type Loader = 'base64' | 'binary' | 'copy' | 'css' | 'dataurl' | 'default' | 'empty' | 'file' | 'js' | 'json' | 'jsx' | 'local-css' | 'text' | 'ts' | 'tsx'
export type LogLevel = 'verbose' | 'debug' | 'info' | 'warning' | 'error' | 'silent'
export type Charset = 'ascii' | 'utf8'
export type Drop = 'console' | 'debugger'
export type AbsPaths = 'code' | 'log' | 'metafile'

interface CommonOptions {
  /** Documentation: https://esbuild.github.io/api/#sourcemap */
  sourcemap?: boolean | 'linked' | 'inline' | 'external' | 'both'
  /** Documentation: https://esbuild.github.io/api/#legal-comments */
  legalComments?: 'none' | 'inline' | 'eof' | 'linked' | 'external'
  /** Documentation: https://esbuild.github.io/api/#source-root */
  sourceRoot?: string
  /** Documentation: https://esbuild.github.io/api/#sources-content */
  sourcesContent?: boolean

  /** Documentation: https://esbuild.github.io/api/#format */
  format?: Format
  /** Documentation: https://esbuild.github.io/api/#global-name */
  globalName?: string
  /** Documentation: https://esbuild.github.io/api/#target */
  target?: string | string[]
  /** Documentation: https://esbuild.github.io/api/#supported */
  supported?: Record<string, boolean>
  /** Documentation: https://esbuild.github.io/api/#platform */
  platform?: Platform

  /** Documentation: https://esbuild.github.io/api/#mangle-props */
  mangleProps?: RegExp
  /** Documentation: https://esbuild.github.io/api/#mangle-props */
  reserveProps?: RegExp
  /** Documentation: https://esbuild.github.io/api/#mangle-props */
  mangleQuoted?: boolean
  /** Documentation: https://esbuild.github.io/api/#mangle-props */
  mangleCache?: Record<string, string | false>
  /** Documentation: https://esbuild.github.io/api/#drop */
  drop?: Drop[]
  /** Documentation: https://esbuild.github.io/api/#drop-labels */
  dropLabels?: string[]
  /** Documentation: https://esbuild.github.io/api/#minify */
  minify?: boolean
  /** Documentation: https://esbuild.github.io/api/#minify */
  minifyWhitespace?: boolean
  /** Documentation: https://esbuild.github.io/api/#minify */
  minifyIdentifiers?: boolean
  /** Documentation: https://esbuild.github.io/api/#minify */
  minifySyntax?: boolean
  /** Documentation: https://esbuild.github.io/api/#line-limit */
  lineLimit?: number
  /** Documentation: https://esbuild.github.io/api/#charset */
  charset?: Charset
  /** Documentation: https://esbuild.github.io/api/#tree-shaking */
  treeShaking?: boolean
  /** Documentation: https://esbuild.github.io/api/#ignore-annotations */
  ignoreAnnotations?: boolean

  /** Documentation: https://esbuild.github.io/api/#jsx */
  jsx?: 'transform' | 'preserve' | 'automatic'
  /** Documentation: https://esbuild.github.io/api/#jsx-factory */
  jsxFactory?: string
  /** Documentation: https://esbuild.github.io/api/#jsx-fragment */
  jsxFragment?: string
  /** Documentation: https://esbuild.github.io/api/#jsx-import-source */
  jsxImportSource?: string
  /** Documentation: https://esbuild.github.io/api/#jsx-development */
  jsxDev?: boolean
  /** Documentation: https://esbuild.github.io/api/#jsx-side-effects */
  jsxSideEffects?: boolean

  /** Documentation: https://esbuild.github.io/api/#define */
  define?: { [key: string]: string }
  /** Documentation: https://esbuild.github.io/api/#pure */
  pure?: string[]
  /** Documentation: https://esbuild.github.io/api/#keep-names */
  keepNames?: boolean

  /** Documentation: https://esbuild.github.io/api/#abs-paths */
  absPaths?: AbsPaths[]
  /** Documentation: https://esbuild.github.io/api/#color */
  color?: boolean
  /** Documentation: https://esbuild.github.io/api/#log-level */
  logLevel?: LogLevel
  /** Documentation: https://esbuild.github.io/api/#log-limit */
  logLimit?: number
  /** Documentation: https://esbuild.github.io/api/#log-override */
  logOverride?: Record<string, LogLevel>

  /** Documentation: https://esbuild.github.io/api/#tsconfig-raw */
  tsconfigRaw?: string | TsconfigRaw
}

export interface TsconfigRaw {
  compilerOptions?: {
    alwaysStrict?: boolean
    baseUrl?: string
    experimentalDecorators?: boolean
    importsNotUsedAsValues?: 'remove' | 'preserve' | 'error'
    jsx?: 'preserve' | 'react-native' | 'react' | 'react-jsx' | 'react-jsxdev'
    jsxFactory?: string
    jsxFragmentFactory?: string
    jsxImportSource?: string
    paths?: Record<string, string[]>
    preserveValueImports?: boolean
    strict?: boolean
    target?: string
    useDefineForClassFields?: boolean
    verbatimModuleSyntax?: boolean
  }
}

export interface BuildOptions extends CommonOptions {
  /** Documentation: https://esbuild.github.io/api/#bundle */
  bundle?: boolean
  /** Documentation: https://esbuild.github.io/api/#splitting */
  splitting?: boolean
  /** Documentation: https://esbuild.github.io/api/#preserve-symlinks */
  preserveSymlinks?: boolean
  /** Documentation: https://esbuild.github.io/api/#outfile */
  outfile?: string
  /** Documentation: https://esbuild.github.io/api/#metafile */
  metafile?: boolean
  /** Documentation: https://esbuild.github.io/api/#outdir */
  outdir?: string
  /** Documentation: https://esbuild.github.io/api/#outbase */
  outbase?: string
  /** Documentation: https://esbuild.github.io/api/#external */
  external?: string[]
  /** Documentation: https://esbuild.github.io/api/#packages */
  packages?: 'bundle' | 'external'
  /** Documentation: https://esbuild.github.io/api/#alias */
  alias?: Record<string, string>
  /** Documentation: https://esbuild.github.io/api/#loader */
  loader?: { [ext: string]: Loader }
  /** Documentation: https://esbuild.github.io/api/#resolve-extensions */
  resolveExtensions?: string[]
  /** Documentation: https://esbuild.github.io/api/#main-fields */
  mainFields?: string[]
  /** Documentation: https://esbuild.github.io/api/#conditions */
  conditions?: string[]
  /** Documentation: https://esbuild.github.io/api/#write */
  write?: boolean
  /** Documentation: https://esbuild.github.io/api/#allow-overwrite */
  allowOverwrite?: boolean
  /** Documentation: https://esbuild.github.io/api/#tsconfig */
  tsconfig?: string
  /** Documentation: https://esbuild.github.io/api/#out-extension */
  outExtension?: { [ext: string]: string }
  /** Documentation: https://esbuild.github.io/api/#public-path */
  publicPath?: string
  /** Documentation: https://esbuild.github.io/api/#entry-names */
  entryNames?: string
  /** Documentation: https://esbuild.github.io/api/#chunk-names */
  chunkNames?: string
  /** Documentation: https://esbuild.github.io/api/#asset-names */
  assetNames?: string
  /** Documentation: https://esbuild.github.io/api/#inject */
  inject?: string[]
  /** Documentation: https://esbuild.github.io/api/#banner */
  banner?: { [type: string]: string }
  /** Documentation: https://esbuild.github.io/api/#footer */
  footer?: { [type: string]: string }
  /** Documentation: https://esbuild.github.io/api/#entry-points */
  entryPoints?: (string | { in: string, out: string })[] | Record<string, string>
  /** Documentation: https://esbuild.github.io/api/#stdin */
  stdin?: StdinOptions
  /** Documentation: https://esbuild.github.io/plugins/ */
  plugins?: Plugin[]
  /** Documentation: https://esbuild.github.io/api/#working-directory */
  absWorkingDir?: string
  /** Documentation: https://esbuild.github.io/api/#node-paths */
  nodePaths?: string[]; // The "NODE_PATH" variable from Node.js
}

export interface StdinOptions {
  contents: string | Uint8Array
  resolveDir?: string
  sourcefile?: string
  loader?: Loader
}

export interface Message {
  id: string
  pluginName: string
  text: string
  location: Location | null
  notes: Note[]

  /**
   * Optional user-specified data that is passed through unmodified. You can
   * use this to stash the original error, for example.
   */
  detail: any
}

export interface Note {
  text: string
  location: Location | null
}

export interface Location {
  file: string
  namespace: string
  /** 1-based */
  line: number
  /** 0-based, in bytes */
  column: number
  /** in bytes */
  length: number
  lineText: string
  suggestion: string
}

export interface OutputFile {
  path: string
  contents: Uint8Array
  hash: string
  /** "contents" as text (changes automatically with "contents") */
  readonly text: string
}

export interface BuildResult<ProvidedOptions extends BuildOptions = BuildOptions> {
  errors: Message[]
  warnings: Message[]
  /** Only when "write: false" */
  outputFiles: OutputFile[] | (ProvidedOptions['write'] extends false ? never : undefined)
  /** Only when "metafile: true" */
  metafile: Metafile | (ProvidedOptions['metafile'] extends true ? never : undefined)
  /** Only when "mangleCache" is present */
  mangleCache: Record<string, string | false> | (ProvidedOptions['mangleCache'] extends Object ? never : undefined)
}

export interface BuildFailure extends Error {
  errors: Message[]
  warnings: Message[]
}

/** Documentation: https://esbuild.github.io/api/#serve-arguments */
export interface ServeOptions {
  port?: number
  host?: string
  servedir?: string
  keyfile?: string
  certfile?: string
  fallback?: string
  cors?: CORSOptions
  onRequest?: (args: ServeOnRequestArgs) => void
}

/** Documentation: https://esbuild.github.io/api/#cors */
export interface CORSOptions {
  origin?: string | string[]
}

export interface ServeOnRequestArgs {
  remoteAddress: string
  method: string
  path: string
  status: number
  /** The time to generate the response, not to send it */
  timeInMS: number
}

/** Documentation: https://esbuild.github.io/api/#serve-return-values */
export interface ServeResult {
  port: number
  hosts: string[]
}

export interface TransformOptions extends CommonOptions {
  /** Documentation: https://esbuild.github.io/api/#sourcefile */
  sourcefile?: string
  /** Documentation: https://esbuild.github.io/api/#loader */
  loader?: Loader
  /** Documentation: https://esbuild.github.io/api/#banner */
  banner?: string
  /** Documentation: https://esbuild.github.io/api/#footer */
  footer?: string
}

export interface TransformResult<ProvidedOptions extends TransformOptions = TransformOptions> {
  code: string
  map: string
  warnings: Message[]
  /** Only when "mangleCache" is present */
  mangleCache: Record<string, string | false> | (ProvidedOptions['mangleCache'] extends Object ? never : undefined)
  /** Only when "legalComments" is "external" */
  legalComments: string | (ProvidedOptions['legalComments'] extends 'external' ? never : undefined)
}

export interface TransformFailure extends Error {
  errors: Message[]
  warnings: Message[]
}

export interface Plugin {
  name: string
  setup: (build: PluginBuild) => (void | Promise<void>)
}

export interface PluginBuild {
  /** Documentation: https://esbuild.github.io/plugins/#build-options */
  initialOptions: BuildOptions

  /** Documentation: https://esbuild.github.io/plugins/#resolve */
  resolve(path: string, options?: ResolveOptions): Promise<ResolveResult>

  /** Documentation: https://esbuild.github.io/plugins/#on-start */
  onStart(callback: () =>
    (OnStartResult | null | void | Promise<OnStartResult | null | void>)): void

  /** Documentation: https://esbuild.github.io/plugins/#on-end */
  onEnd(callback: (result: BuildResult) =>
    (OnEndResult | null | void | Promise<OnEndResult | null | void>)): void

  /** Documentation: https://esbuild.github.io/plugins/#on-resolve */
  onResolve(options: OnResolveOptions, callback: (args: OnResolveArgs) =>
    (OnResolveResult | null | undefined | Promise<OnResolveResult | null | undefined>)): void

  /** Documentation: https://esbuild.github.io/plugins/#on-load */
  onLoad(options: OnLoadOptions, callback: (args: OnLoadArgs) =>
    (OnLoadResult | null | undefined | Promise<OnLoadResult | null | undefined>)): void

  /** Documentation: https://esbuild.github.io/plugins/#on-dispose */
  onDispose(callback: () => void): void

  // This is a full copy of the esbuild library in case you need it
  esbuild: {
    context: typeof context,
    build: typeof build,
    buildSync: typeof buildSync,
    transform: typeof transform,
    transformSync: typeof transformSync,
    formatMessages: typeof formatMessages,
    formatMessagesSync: typeof formatMessagesSync,
    analyzeMetafile: typeof analyzeMetafile,
    analyzeMetafileSync: typeof analyzeMetafileSync,
    initialize: typeof initialize,
    version: typeof version,
  }
}

/** Documentation: https://esbuild.github.io/plugins/#resolve-options */
export interface ResolveOptions {
  pluginName?: string
  importer?: string
  namespace?: string
  resolveDir?: string
  kind?: ImportKind
  pluginData?: any
  with?: Record<string, string>
}

/** Documentation: https://esbuild.github.io/plugins/#resolve-results */
export interface ResolveResult {
  errors: Message[]
  warnings: Message[]

  path: string
  external: boolean
  sideEffects: boolean
  namespace: string
  suffix: string
  pluginData: any
}

export interface OnStartResult {
  errors?: PartialMessage[]
  warnings?: PartialMessage[]
}

export interface OnEndResult {
  errors?: PartialMessage[]
  warnings?: PartialMessage[]
}

/** Documentation: https://esbuild.github.io/plugins/#on-resolve-options */
export interface OnResolveOptions {
  filter: RegExp
  namespace?: string
}

/** Documentation: https://esbuild.github.io/plugins/#on-resolve-arguments */
export interface OnResolveArgs {
  path: string
  importer: string
  namespace: string
  resolveDir: string
  kind: ImportKind
  pluginData: any
  with: Record<string, string>
}

export type ImportKind =
  | 'entry-point'

  // JS
  | 'import-statement'
  | 'require-call'
  | 'dynamic-import'
  | 'require-resolve'

  // CSS
  | 'import-rule'
  | 'composes-from'
  | 'url-token'

/** Documentation: https://esbuild.github.io/plugins/#on-resolve-results */
export interface OnResolveResult {
  pluginName?: string

  errors?: PartialMessage[]
  warnings?: PartialMessage[]

  path?: string
  external?: boolean
  sideEffects?: boolean
  namespace?: string
  suffix?: string
  pluginData?: any

  watchFiles?: string[]
  watchDirs?: string[]
}

/** Documentation: https://esbuild.github.io/plugins/#on-load-options */
export interface OnLoadOptions {
  filter: RegExp
  namespace?: string
}

/** Documentation: https://esbuild.github.io/plugins/#on-load-arguments */
export interface OnLoadArgs {
  path: string
  namespace: string
  suffix: string
  pluginData: any
  with: Record<string, string>
}

/** Documentation: https://esbuild.github.io/plugins/#on-load-results */
export interface OnLoadResult {
  pluginName?: string

  errors?: PartialMessage[]
  warnings?: PartialMessage[]

  contents?: string | Uint8Array
  resolveDir?: string
  loader?: Loader
  pluginData?: any

  watchFiles?: string[]
  watchDirs?: string[]
}

export interface PartialMessage {
  id?: string
  pluginName?: string
  text?: string
  location?: Partial<Location> | null
  notes?: PartialNote[]
  detail?: any
}

export interface PartialNote {
  text?: string
  location?: Partial<Location> | null
}

/** Documentation: https://esbuild.github.io/api/#metafile */
export interface Metafile {
  inputs: {
    [path: string]: {
      bytes: number
      imports: {
        path: string
        kind: ImportKind
        external?: boolean
        original?: string
        with?: Record<string, string>
      }[]
      format?: 'cjs' | 'esm'
      with?: Record<string, string>
    }
  }
  outputs: {
    [path: string]: {
      bytes: number
      inputs: {
        [path: string]: {
          bytesInOutput: number
        }
      }
      imports: {
        path: string
        kind: ImportKind | 'file-loader'
        external?: boolean
      }[]
      exports: string[]
      entryPoint?: string
      cssBundle?: string
    }
  }
}

export interface FormatMessagesOptions {
  kind: 'error' | 'warning'
  color?: boolean
  terminalWidth?: number
}

export interface AnalyzeMetafileOptions {
  color?: boolean
  verbose?: boolean
}

/** Documentation: https://esbuild.github.io/api/#watch-arguments */
export interface WatchOptions {
  delay?: number // In milliseconds
}

export interface BuildContext<ProvidedOptions extends BuildOptions = BuildOptions> {
  /** Documentation: https://esbuild.github.io/api/#rebuild */
  rebuild(): Promise<BuildResult<ProvidedOptions>>

  /** Documentation: https://esbuild.github.io/api/#watch */
  watch(options?: WatchOptions): Promise<void>

  /** Documentation: https://esbuild.github.io/api/#serve */
  serve(options?: ServeOptions): Promise<ServeResult>

  cancel(): Promise<void>
  dispose(): Promise<void>
}

// This is a TypeScript type-level function which replaces any keys in "In"
// that aren't in "Out" with "never". We use this to reject properties with
// typos in object literals. See: https://stackoverflow.com/questions/49580725
type SameShape<Out, In extends Out> = In & { [Key in Exclude<keyof In, keyof Out>]: never }

/**
 * This function invokes the "esbuild" command-line tool for you. It returns a
 * promise that either resolves with a "BuildResult" object or rejects with a
 * "BuildFailure" object.
 *
 * - Works in node: yes
 * - Works in browser: yes
 *
 * Documentation: https://esbuild.github.io/api/#build
 */
export declare function build<T extends BuildOptions>(options: SameShape<BuildOptions, T>): Promise<BuildResult<T>>

/**
 * This is the advanced long-running form of "build" that supports additional
 * features such as watch mode and a local development server.
 *
 * - Works in node: yes
 * - Works in browser: no
 *
 * Documentation: https://esbuild.github.io/api/#build
 */
export declare function context<T extends BuildOptions>(options: SameShape<BuildOptions, T>): Promise<BuildContext<T>>

/**
 * This function transforms a single JavaScript file. It can be used to minify
 * JavaScript, convert TypeScript/JSX to JavaScript, or convert newer JavaScript
 * to older JavaScript. It returns a promise that is either resolved with a
 * "TransformResult" object or rejected with a "TransformFailure" object.
 *
 * - Works in node: yes
 * - Works in browser: yes
 *
 * Documentation: https://esbuild.github.io/api/#transform
 */
export declare function transform<T extends TransformOptions>(input: string | Uint8Array, options?: SameShape<TransformOptions, T>): Promise<TransformResult<T>>

/**
 * Converts log messages to formatted message strings suitable for printing in
 * the terminal. This allows you to reuse the built-in behavior of esbuild's
 * log message formatter. This is a batch-oriented API for efficiency.
 *
 * - Works in node: yes
 * - Works in browser: yes
 */
export declare function formatMessages(messages: PartialMessage[], options: FormatMessagesOptions): Promise<string[]>

/**
 * Pretty-prints an analysis of the metafile JSON to a string. This is just for
 * convenience to be able to match esbuild's pretty-printing exactly. If you want
 * to customize it, you can just inspect the data in the metafile yourself.
 *
 * - Works in node: yes
 * - Works in browser: yes
 *
 * Documentation: https://esbuild.github.io/api/#analyze
 */
export declare function analyzeMetafile(metafile: Metafile | string, options?: AnalyzeMetafileOptions): Promise<string>

/**
 * A synchronous version of "build".
 *
 * - Works in node: yes
 * - Works in browser: no
 *
 * Documentation: https://esbuild.github.io/api/#build
 */
export declare function buildSync<T extends BuildOptions>(options: SameShape<BuildOptions, T>): BuildResult<T>

/**
 * A synchronous version of "transform".
 *
 * - Works in node: yes
 * - Works in browser: no
 *
 * Documentation: https://esbuild.github.io/api/#transform
 */
export declare function transformSync<T extends TransformOptions>(input: string | Uint8Array, options?: SameShape<TransformOptions, T>): TransformResult<T>

/**
 * A synchronous version of "formatMessages".
 *
 * - Works in node: yes
 * - Works in browser: no
 */
export declare function formatMessagesSync(messages: PartialMessage[], options: FormatMessagesOptions): string[]

/**
 * A synchronous version of "analyzeMetafile".
 *
 * - Works in node: yes
 * - Works in browser: no
 *
 * Documentation: https://esbuild.github.io/api/#analyze
 */
export declare function analyzeMetafileSync(metafile: Metafile | string, options?: AnalyzeMetafileOptions): string

/**
 * This configures the browser-based version of esbuild. It is necessary to
 * call this first and wait for the returned promise to be resolved before
 * making other API calls when using esbuild in the browser.
 *
 * - Works in node: yes
 * - Works in browser: yes ("options" is required)
 *
 * Documentation: https://esbuild.github.io/api/#browser
 */
export declare function initialize(options: InitializeOptions): Promise<void>

export interface InitializeOptions {
  /**
   * The URL of the "esbuild.wasm" file. This must be provided when running
   * esbuild in the browser.
   */
  wasmURL?: string | URL

  /**
   * The result of calling "new WebAssembly.Module(buffer)" where "buffer"
   * is a typed array or ArrayBuffer containing the binary code of the
   * "esbuild.wasm" file.
   *
   * You can use this as an alternative to "wasmURL" for environments where it's
   * not possible to download the WebAssembly module.
   */
  wasmModule?: WebAssembly.Module

  /**
   * By default esbuild runs the WebAssembly-based browser API in a web worker
   * to avoid blocking the UI thread. This can be disabled by setting "worker"
   * to false.
   */
  worker?: boolean
}

export let version: string

// Call this function to terminate esbuild's child process. The child process
// is not terminated and re-created after each API call because it's more
// efficient to keep it around when there are multiple API calls.
//
// In node this happens automatically before the parent node process exits. So
// you only need to call this if you know you will not make any more esbuild
// API calls and you want to clean up resources.
//
// Unlike node, Deno lacks the necessary APIs to clean up child processes
// automatically. You must manually call stop() in Deno when you're done
// using esbuild or Deno will continue running forever.
//
// Another reason you might want to call this is if you are using esbuild from
// within a Deno test. Deno fails tests that create a child process without
// killing it before the test ends, so you have to call this function (and
// await the returned promise) in every Deno test that uses esbuild.
export declare function stop(): Promise<void>

// Note: These declarations exist to avoid type errors when you omit "dom" from
// "lib" in your "tsconfig.json" file. TypeScript confusingly declares the
// global "WebAssembly" type in "lib.dom.d.ts" even though it has nothing to do
// with the browser DOM and is present in many non-browser JavaScript runtimes
// (e.g. node and deno). Declaring it here allows esbuild's API to be used in
// these scenarios.
//
// There's an open issue about getting this problem corrected (although these
// declarations will need to remain even if this is fixed for backward
// compatibility with older TypeScript versions):
//
//   https://github.com/microsoft/TypeScript-DOM-lib-generator/issues/826
//
declare global {
  namespace WebAssembly {
    interface Module {
    }
  }
  interface URL {
  }
}

~~~

## node_modules\esbuild\lib\main.js

~~~js
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/npm/node.ts
var node_exports = {};
__export(node_exports, {
  analyzeMetafile: () => analyzeMetafile,
  analyzeMetafileSync: () => analyzeMetafileSync,
  build: () => build,
  buildSync: () => buildSync,
  context: () => context,
  default: () => node_default,
  formatMessages: () => formatMessages,
  formatMessagesSync: () => formatMessagesSync,
  initialize: () => initialize,
  stop: () => stop,
  transform: () => transform,
  transformSync: () => transformSync,
  version: () => version
});
module.exports = __toCommonJS(node_exports);

// lib/shared/stdio_protocol.ts
function encodePacket(packet) {
  let visit = (value) => {
    if (value === null) {
      bb.write8(0);
    } else if (typeof value === "boolean") {
      bb.write8(1);
      bb.write8(+value);
    } else if (typeof value === "number") {
      bb.write8(2);
      bb.write32(value | 0);
    } else if (typeof value === "string") {
      bb.write8(3);
      bb.write(encodeUTF8(value));
    } else if (value instanceof Uint8Array) {
      bb.write8(4);
      bb.write(value);
    } else if (value instanceof Array) {
      bb.write8(5);
      bb.write32(value.length);
      for (let item of value) {
        visit(item);
      }
    } else {
      let keys = Object.keys(value);
      bb.write8(6);
      bb.write32(keys.length);
      for (let key of keys) {
        bb.write(encodeUTF8(key));
        visit(value[key]);
      }
    }
  };
  let bb = new ByteBuffer();
  bb.write32(0);
  bb.write32(packet.id << 1 | +!packet.isRequest);
  visit(packet.value);
  writeUInt32LE(bb.buf, bb.len - 4, 0);
  return bb.buf.subarray(0, bb.len);
}
function decodePacket(bytes) {
  let visit = () => {
    switch (bb.read8()) {
      case 0:
        return null;
      case 1:
        return !!bb.read8();
      case 2:
        return bb.read32();
      case 3:
        return decodeUTF8(bb.read());
      case 4:
        return bb.read();
      case 5: {
        let count = bb.read32();
        let value2 = [];
        for (let i = 0; i < count; i++) {
          value2.push(visit());
        }
        return value2;
      }
      case 6: {
        let count = bb.read32();
        let value2 = {};
        for (let i = 0; i < count; i++) {
          value2[decodeUTF8(bb.read())] = visit();
        }
        return value2;
      }
      default:
        throw new Error("Invalid packet");
    }
  };
  let bb = new ByteBuffer(bytes);
  let id = bb.read32();
  let isRequest = (id & 1) === 0;
  id >>>= 1;
  let value = visit();
  if (bb.ptr !== bytes.length) {
    throw new Error("Invalid packet");
  }
  return { id, isRequest, value };
}
var ByteBuffer = class {
  constructor(buf = new Uint8Array(1024)) {
    this.buf = buf;
    this.len = 0;
    this.ptr = 0;
  }
  _write(delta) {
    if (this.len + delta > this.buf.length) {
      let clone = new Uint8Array((this.len + delta) * 2);
      clone.set(this.buf);
      this.buf = clone;
    }
    this.len += delta;
    return this.len - delta;
  }
  write8(value) {
    let offset = this._write(1);
    this.buf[offset] = value;
  }
  write32(value) {
    let offset = this._write(4);
    writeUInt32LE(this.buf, value, offset);
  }
  write(bytes) {
    let offset = this._write(4 + bytes.length);
    writeUInt32LE(this.buf, bytes.length, offset);
    this.buf.set(bytes, offset + 4);
  }
  _read(delta) {
    if (this.ptr + delta > this.buf.length) {
      throw new Error("Invalid packet");
    }
    this.ptr += delta;
    return this.ptr - delta;
  }
  read8() {
    return this.buf[this._read(1)];
  }
  read32() {
    return readUInt32LE(this.buf, this._read(4));
  }
  read() {
    let length = this.read32();
    let bytes = new Uint8Array(length);
    let ptr = this._read(bytes.length);
    bytes.set(this.buf.subarray(ptr, ptr + length));
    return bytes;
  }
};
var encodeUTF8;
var decodeUTF8;
var encodeInvariant;
if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
  let encoder = new TextEncoder();
  let decoder = new TextDecoder();
  encodeUTF8 = (text) => encoder.encode(text);
  decodeUTF8 = (bytes) => decoder.decode(bytes);
  encodeInvariant = 'new TextEncoder().encode("")';
} else if (typeof Buffer !== "undefined") {
  encodeUTF8 = (text) => Buffer.from(text);
  decodeUTF8 = (bytes) => {
    let { buffer, byteOffset, byteLength } = bytes;
    return Buffer.from(buffer, byteOffset, byteLength).toString();
  };
  encodeInvariant = 'Buffer.from("")';
} else {
  throw new Error("No UTF-8 codec found");
}
if (!(encodeUTF8("") instanceof Uint8Array))
  throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
function readUInt32LE(buffer, offset) {
  return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
}
function writeUInt32LE(buffer, value, offset) {
  buffer[offset++] = value;
  buffer[offset++] = value >> 8;
  buffer[offset++] = value >> 16;
  buffer[offset++] = value >> 24;
}

// lib/shared/common.ts
var quote = JSON.stringify;
var buildLogLevelDefault = "warning";
var transformLogLevelDefault = "silent";
function validateAndJoinStringArray(values, what) {
  const toJoin = [];
  for (const value of values) {
    validateStringValue(value, what);
    if (value.indexOf(",") >= 0) throw new Error(`Invalid ${what}: ${value}`);
    toJoin.push(value);
  }
  return toJoin.join(",");
}
var canBeAnything = () => null;
var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
var mustBeString = (value) => typeof value === "string" ? null : "a string";
var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
var mustBeValidPortNumber = (value) => typeof value === "number" && value === (value | 0) && value >= 0 && value <= 65535 ? null : "a valid port number";
var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
var mustBeArrayOfStrings = (value) => Array.isArray(value) && value.every((x) => typeof x === "string") ? null : "an array of strings";
var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
var mustBeStringOrArrayOfStrings = (value) => typeof value === "string" || Array.isArray(value) && value.every((x) => typeof x === "string") ? null : "a string or an array of strings";
var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
function getFlag(object, keys, key, mustBeFn) {
  let value = object[key];
  keys[key + ""] = true;
  if (value === void 0) return void 0;
  let mustBe = mustBeFn(value);
  if (mustBe !== null) throw new Error(`${quote(key)} must be ${mustBe}`);
  return value;
}
function checkForInvalidFlags(object, keys, where) {
  for (let key in object) {
    if (!(key in keys)) {
      throw new Error(`Invalid option ${where}: ${quote(key)}`);
    }
  }
}
function validateInitializeOptions(options) {
  let keys = /* @__PURE__ */ Object.create(null);
  let wasmURL = getFlag(options, keys, "wasmURL", mustBeStringOrURL);
  let wasmModule = getFlag(options, keys, "wasmModule", mustBeWebAssemblyModule);
  let worker = getFlag(options, keys, "worker", mustBeBoolean);
  checkForInvalidFlags(options, keys, "in initialize() call");
  return {
    wasmURL,
    wasmModule,
    worker
  };
}
function validateMangleCache(mangleCache) {
  let validated;
  if (mangleCache !== void 0) {
    validated = /* @__PURE__ */ Object.create(null);
    for (let key in mangleCache) {
      let value = mangleCache[key];
      if (typeof value === "string" || value === false) {
        validated[key] = value;
      } else {
        throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
      }
    }
  }
  return validated;
}
function pushLogFlags(flags, options, keys, isTTY2, logLevelDefault) {
  let color = getFlag(options, keys, "color", mustBeBoolean);
  let logLevel = getFlag(options, keys, "logLevel", mustBeString);
  let logLimit = getFlag(options, keys, "logLimit", mustBeInteger);
  if (color !== void 0) flags.push(`--color=${color}`);
  else if (isTTY2) flags.push(`--color=true`);
  flags.push(`--log-level=${logLevel || logLevelDefault}`);
  flags.push(`--log-limit=${logLimit || 0}`);
}
function validateStringValue(value, what, key) {
  if (typeof value !== "string") {
    throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
  }
  return value;
}
function pushCommonFlags(flags, options, keys) {
  let legalComments = getFlag(options, keys, "legalComments", mustBeString);
  let sourceRoot = getFlag(options, keys, "sourceRoot", mustBeString);
  let sourcesContent = getFlag(options, keys, "sourcesContent", mustBeBoolean);
  let target = getFlag(options, keys, "target", mustBeStringOrArrayOfStrings);
  let format = getFlag(options, keys, "format", mustBeString);
  let globalName = getFlag(options, keys, "globalName", mustBeString);
  let mangleProps = getFlag(options, keys, "mangleProps", mustBeRegExp);
  let reserveProps = getFlag(options, keys, "reserveProps", mustBeRegExp);
  let mangleQuoted = getFlag(options, keys, "mangleQuoted", mustBeBoolean);
  let minify = getFlag(options, keys, "minify", mustBeBoolean);
  let minifySyntax = getFlag(options, keys, "minifySyntax", mustBeBoolean);
  let minifyWhitespace = getFlag(options, keys, "minifyWhitespace", mustBeBoolean);
  let minifyIdentifiers = getFlag(options, keys, "minifyIdentifiers", mustBeBoolean);
  let lineLimit = getFlag(options, keys, "lineLimit", mustBeInteger);
  let drop = getFlag(options, keys, "drop", mustBeArrayOfStrings);
  let dropLabels = getFlag(options, keys, "dropLabels", mustBeArrayOfStrings);
  let charset = getFlag(options, keys, "charset", mustBeString);
  let treeShaking = getFlag(options, keys, "treeShaking", mustBeBoolean);
  let ignoreAnnotations = getFlag(options, keys, "ignoreAnnotations", mustBeBoolean);
  let jsx = getFlag(options, keys, "jsx", mustBeString);
  let jsxFactory = getFlag(options, keys, "jsxFactory", mustBeString);
  let jsxFragment = getFlag(options, keys, "jsxFragment", mustBeString);
  let jsxImportSource = getFlag(options, keys, "jsxImportSource", mustBeString);
  let jsxDev = getFlag(options, keys, "jsxDev", mustBeBoolean);
  let jsxSideEffects = getFlag(options, keys, "jsxSideEffects", mustBeBoolean);
  let define = getFlag(options, keys, "define", mustBeObject);
  let logOverride = getFlag(options, keys, "logOverride", mustBeObject);
  let supported = getFlag(options, keys, "supported", mustBeObject);
  let pure = getFlag(options, keys, "pure", mustBeArrayOfStrings);
  let keepNames = getFlag(options, keys, "keepNames", mustBeBoolean);
  let platform = getFlag(options, keys, "platform", mustBeString);
  let tsconfigRaw = getFlag(options, keys, "tsconfigRaw", mustBeStringOrObject);
  let absPaths = getFlag(options, keys, "absPaths", mustBeArrayOfStrings);
  if (legalComments) flags.push(`--legal-comments=${legalComments}`);
  if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);
  if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);
  if (target) flags.push(`--target=${validateAndJoinStringArray(Array.isArray(target) ? target : [target], "target")}`);
  if (format) flags.push(`--format=${format}`);
  if (globalName) flags.push(`--global-name=${globalName}`);
  if (platform) flags.push(`--platform=${platform}`);
  if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
  if (minify) flags.push("--minify");
  if (minifySyntax) flags.push("--minify-syntax");
  if (minifyWhitespace) flags.push("--minify-whitespace");
  if (minifyIdentifiers) flags.push("--minify-identifiers");
  if (lineLimit) flags.push(`--line-limit=${lineLimit}`);
  if (charset) flags.push(`--charset=${charset}`);
  if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);
  if (ignoreAnnotations) flags.push(`--ignore-annotations`);
  if (drop) for (let what of drop) flags.push(`--drop:${validateStringValue(what, "drop")}`);
  if (dropLabels) flags.push(`--drop-labels=${validateAndJoinStringArray(dropLabels, "drop label")}`);
  if (absPaths) flags.push(`--abs-paths=${validateAndJoinStringArray(absPaths, "abs paths")}`);
  if (mangleProps) flags.push(`--mangle-props=${jsRegExpToGoRegExp(mangleProps)}`);
  if (reserveProps) flags.push(`--reserve-props=${jsRegExpToGoRegExp(reserveProps)}`);
  if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);
  if (jsx) flags.push(`--jsx=${jsx}`);
  if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);
  if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);
  if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);
  if (jsxDev) flags.push(`--jsx-dev`);
  if (jsxSideEffects) flags.push(`--jsx-side-effects`);
  if (define) {
    for (let key in define) {
      if (key.indexOf("=") >= 0) throw new Error(`Invalid define: ${key}`);
      flags.push(`--define:${key}=${validateStringValue(define[key], "define", key)}`);
    }
  }
  if (logOverride) {
    for (let key in logOverride) {
      if (key.indexOf("=") >= 0) throw new Error(`Invalid log override: ${key}`);
      flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
    }
  }
  if (supported) {
    for (let key in supported) {
      if (key.indexOf("=") >= 0) throw new Error(`Invalid supported: ${key}`);
      const value = supported[key];
      if (typeof value !== "boolean") throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
      flags.push(`--supported:${key}=${value}`);
    }
  }
  if (pure) for (let fn of pure) flags.push(`--pure:${validateStringValue(fn, "pure")}`);
  if (keepNames) flags.push(`--keep-names`);
}
function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
  var _a2;
  let flags = [];
  let entries = [];
  let keys = /* @__PURE__ */ Object.create(null);
  let stdinContents = null;
  let stdinResolveDir = null;
  pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
  pushCommonFlags(flags, options, keys);
  let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
  let bundle = getFlag(options, keys, "bundle", mustBeBoolean);
  let splitting = getFlag(options, keys, "splitting", mustBeBoolean);
  let preserveSymlinks = getFlag(options, keys, "preserveSymlinks", mustBeBoolean);
  let metafile = getFlag(options, keys, "metafile", mustBeBoolean);
  let outfile = getFlag(options, keys, "outfile", mustBeString);
  let outdir = getFlag(options, keys, "outdir", mustBeString);
  let outbase = getFlag(options, keys, "outbase", mustBeString);
  let tsconfig = getFlag(options, keys, "tsconfig", mustBeString);
  let resolveExtensions = getFlag(options, keys, "resolveExtensions", mustBeArrayOfStrings);
  let nodePathsInput = getFlag(options, keys, "nodePaths", mustBeArrayOfStrings);
  let mainFields = getFlag(options, keys, "mainFields", mustBeArrayOfStrings);
  let conditions = getFlag(options, keys, "conditions", mustBeArrayOfStrings);
  let external = getFlag(options, keys, "external", mustBeArrayOfStrings);
  let packages = getFlag(options, keys, "packages", mustBeString);
  let alias = getFlag(options, keys, "alias", mustBeObject);
  let loader = getFlag(options, keys, "loader", mustBeObject);
  let outExtension = getFlag(options, keys, "outExtension", mustBeObject);
  let publicPath = getFlag(options, keys, "publicPath", mustBeString);
  let entryNames = getFlag(options, keys, "entryNames", mustBeString);
  let chunkNames = getFlag(options, keys, "chunkNames", mustBeString);
  let assetNames = getFlag(options, keys, "assetNames", mustBeString);
  let inject = getFlag(options, keys, "inject", mustBeArrayOfStrings);
  let banner = getFlag(options, keys, "banner", mustBeObject);
  let footer = getFlag(options, keys, "footer", mustBeObject);
  let entryPoints = getFlag(options, keys, "entryPoints", mustBeEntryPoints);
  let absWorkingDir = getFlag(options, keys, "absWorkingDir", mustBeString);
  let stdin = getFlag(options, keys, "stdin", mustBeObject);
  let write = (_a2 = getFlag(options, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
  let allowOverwrite = getFlag(options, keys, "allowOverwrite", mustBeBoolean);
  let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
  keys.plugins = true;
  checkForInvalidFlags(options, keys, `in ${callName}() call`);
  if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
  if (bundle) flags.push("--bundle");
  if (allowOverwrite) flags.push("--allow-overwrite");
  if (splitting) flags.push("--splitting");
  if (preserveSymlinks) flags.push("--preserve-symlinks");
  if (metafile) flags.push(`--metafile`);
  if (outfile) flags.push(`--outfile=${outfile}`);
  if (outdir) flags.push(`--outdir=${outdir}`);
  if (outbase) flags.push(`--outbase=${outbase}`);
  if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);
  if (packages) flags.push(`--packages=${packages}`);
  if (resolveExtensions) flags.push(`--resolve-extensions=${validateAndJoinStringArray(resolveExtensions, "resolve extension")}`);
  if (publicPath) flags.push(`--public-path=${publicPath}`);
  if (entryNames) flags.push(`--entry-names=${entryNames}`);
  if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);
  if (assetNames) flags.push(`--asset-names=${assetNames}`);
  if (mainFields) flags.push(`--main-fields=${validateAndJoinStringArray(mainFields, "main field")}`);
  if (conditions) flags.push(`--conditions=${validateAndJoinStringArray(conditions, "condition")}`);
  if (external) for (let name of external) flags.push(`--external:${validateStringValue(name, "external")}`);
  if (alias) {
    for (let old in alias) {
      if (old.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${old}`);
      flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
    }
  }
  if (banner) {
    for (let type in banner) {
      if (type.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${type}`);
      flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
    }
  }
  if (footer) {
    for (let type in footer) {
      if (type.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${type}`);
      flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
    }
  }
  if (inject) for (let path3 of inject) flags.push(`--inject:${validateStringValue(path3, "inject")}`);
  if (loader) {
    for (let ext in loader) {
      if (ext.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${ext}`);
      flags.push(`--loader:${ext}=${validateStringValue(loader[ext], "loader", ext)}`);
    }
  }
  if (outExtension) {
    for (let ext in outExtension) {
      if (ext.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${ext}`);
      flags.push(`--out-extension:${ext}=${validateStringValue(outExtension[ext], "out extension", ext)}`);
    }
  }
  if (entryPoints) {
    if (Array.isArray(entryPoints)) {
      for (let i = 0, n = entryPoints.length; i < n; i++) {
        let entryPoint = entryPoints[i];
        if (typeof entryPoint === "object" && entryPoint !== null) {
          let entryPointKeys = /* @__PURE__ */ Object.create(null);
          let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
          let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
          checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
          if (input === void 0) throw new Error('Missing property "in" for entry point at index ' + i);
          if (output === void 0) throw new Error('Missing property "out" for entry point at index ' + i);
          entries.push([output, input]);
        } else {
          entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
        }
      }
    } else {
      for (let key in entryPoints) {
        entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
      }
    }
  }
  if (stdin) {
    let stdinKeys = /* @__PURE__ */ Object.create(null);
    let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
    let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
    let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
    let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
    checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
    if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
    if (loader2) flags.push(`--loader=${loader2}`);
    if (resolveDir) stdinResolveDir = resolveDir;
    if (typeof contents === "string") stdinContents = encodeUTF8(contents);
    else if (contents instanceof Uint8Array) stdinContents = contents;
  }
  let nodePaths = [];
  if (nodePathsInput) {
    for (let value of nodePathsInput) {
      value += "";
      nodePaths.push(value);
    }
  }
  return {
    entries,
    flags,
    write,
    stdinContents,
    stdinResolveDir,
    absWorkingDir,
    nodePaths,
    mangleCache: validateMangleCache(mangleCache)
  };
}
function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
  let flags = [];
  let keys = /* @__PURE__ */ Object.create(null);
  pushLogFlags(flags, options, keys, isTTY2, logLevelDefault);
  pushCommonFlags(flags, options, keys);
  let sourcemap = getFlag(options, keys, "sourcemap", mustBeStringOrBoolean);
  let sourcefile = getFlag(options, keys, "sourcefile", mustBeString);
  let loader = getFlag(options, keys, "loader", mustBeString);
  let banner = getFlag(options, keys, "banner", mustBeString);
  let footer = getFlag(options, keys, "footer", mustBeString);
  let mangleCache = getFlag(options, keys, "mangleCache", mustBeObject);
  checkForInvalidFlags(options, keys, `in ${callName}() call`);
  if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
  if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
  if (loader) flags.push(`--loader=${loader}`);
  if (banner) flags.push(`--banner=${banner}`);
  if (footer) flags.push(`--footer=${footer}`);
  return {
    flags,
    mangleCache: validateMangleCache(mangleCache)
  };
}
function createChannel(streamIn) {
  const requestCallbacksByKey = {};
  const closeData = { didClose: false, reason: "" };
  let responseCallbacks = {};
  let nextRequestID = 0;
  let nextBuildKey = 0;
  let stdout = new Uint8Array(16 * 1024);
  let stdoutUsed = 0;
  let readFromStdout = (chunk) => {
    let limit = stdoutUsed + chunk.length;
    if (limit > stdout.length) {
      let swap = new Uint8Array(limit * 2);
      swap.set(stdout);
      stdout = swap;
    }
    stdout.set(chunk, stdoutUsed);
    stdoutUsed += chunk.length;
    let offset = 0;
    while (offset + 4 <= stdoutUsed) {
      let length = readUInt32LE(stdout, offset);
      if (offset + 4 + length > stdoutUsed) {
        break;
      }
      offset += 4;
      handleIncomingPacket(stdout.subarray(offset, offset + length));
      offset += length;
    }
    if (offset > 0) {
      stdout.copyWithin(0, offset, stdoutUsed);
      stdoutUsed -= offset;
    }
  };
  let afterClose = (error) => {
    closeData.didClose = true;
    if (error) closeData.reason = ": " + (error.message || error);
    const text = "The service was stopped" + closeData.reason;
    for (let id in responseCallbacks) {
      responseCallbacks[id](text, null);
    }
    responseCallbacks = {};
  };
  let sendRequest = (refs, value, callback) => {
    if (closeData.didClose) return callback("The service is no longer running" + closeData.reason, null);
    let id = nextRequestID++;
    responseCallbacks[id] = (error, response) => {
      try {
        callback(error, response);
      } finally {
        if (refs) refs.unref();
      }
    };
    if (refs) refs.ref();
    streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
  };
  let sendResponse = (id, value) => {
    if (closeData.didClose) throw new Error("The service is no longer running" + closeData.reason);
    streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
  };
  let handleRequest = async (id, request) => {
    try {
      if (request.command === "ping") {
        sendResponse(id, {});
        return;
      }
      if (typeof request.key === "number") {
        const requestCallbacks = requestCallbacksByKey[request.key];
        if (!requestCallbacks) {
          return;
        }
        const callback = requestCallbacks[request.command];
        if (callback) {
          await callback(id, request);
          return;
        }
      }
      throw new Error(`Invalid command: ` + request.command);
    } catch (e) {
      const errors = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
      try {
        sendResponse(id, { errors });
      } catch {
      }
    }
  };
  let isFirstPacket = true;
  let handleIncomingPacket = (bytes) => {
    if (isFirstPacket) {
      isFirstPacket = false;
      let binaryVersion = String.fromCharCode(...bytes);
      if (binaryVersion !== "0.25.12") {
        throw new Error(`Cannot start service: Host version "${"0.25.12"}" does not match binary version ${quote(binaryVersion)}`);
      }
      return;
    }
    let packet = decodePacket(bytes);
    if (packet.isRequest) {
      handleRequest(packet.id, packet.value);
    } else {
      let callback = responseCallbacks[packet.id];
      delete responseCallbacks[packet.id];
      if (packet.value.error) callback(packet.value.error, {});
      else callback(null, packet.value);
    }
  };
  let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
    let refCount = 0;
    const buildKey = nextBuildKey++;
    const requestCallbacks = {};
    const buildRefs = {
      ref() {
        if (++refCount === 1) {
          if (refs) refs.ref();
        }
      },
      unref() {
        if (--refCount === 0) {
          delete requestCallbacksByKey[buildKey];
          if (refs) refs.unref();
        }
      }
    };
    requestCallbacksByKey[buildKey] = requestCallbacks;
    buildRefs.ref();
    buildOrContextImpl(
      callName,
      buildKey,
      sendRequest,
      sendResponse,
      buildRefs,
      streamIn,
      requestCallbacks,
      options,
      isTTY2,
      defaultWD2,
      (err, res) => {
        try {
          callback(err, res);
        } finally {
          buildRefs.unref();
        }
      }
    );
  };
  let transform2 = ({ callName, refs, input, options, isTTY: isTTY2, fs: fs3, callback }) => {
    const details = createObjectStash();
    let start = (inputPath) => {
      try {
        if (typeof input !== "string" && !(input instanceof Uint8Array))
          throw new Error('The input to "transform" must be a string or a Uint8Array');
        let {
          flags,
          mangleCache
        } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
        let request = {
          command: "transform",
          flags,
          inputFS: inputPath !== null,
          input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
        };
        if (mangleCache) request.mangleCache = mangleCache;
        sendRequest(refs, request, (error, response) => {
          if (error) return callback(new Error(error), null);
          let errors = replaceDetailsInMessages(response.errors, details);
          let warnings = replaceDetailsInMessages(response.warnings, details);
          let outstanding = 1;
          let next = () => {
            if (--outstanding === 0) {
              let result = {
                warnings,
                code: response.code,
                map: response.map,
                mangleCache: void 0,
                legalComments: void 0
              };
              if ("legalComments" in response) result.legalComments = response == null ? void 0 : response.legalComments;
              if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;
              callback(null, result);
            }
          };
          if (errors.length > 0) return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
          if (response.codeFS) {
            outstanding++;
            fs3.readFile(response.code, (err, contents) => {
              if (err !== null) {
                callback(err, null);
              } else {
                response.code = contents;
                next();
              }
            });
          }
          if (response.mapFS) {
            outstanding++;
            fs3.readFile(response.map, (err, contents) => {
              if (err !== null) {
                callback(err, null);
              } else {
                response.map = contents;
                next();
              }
            });
          }
          next();
        });
      } catch (e) {
        let flags = [];
        try {
          pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
        } catch {
        }
        const error = extractErrorMessageV8(e, streamIn, details, void 0, "");
        sendRequest(refs, { command: "error", flags, error }, () => {
          error.detail = details.load(error.detail);
          callback(failureErrorWithLog("Transform failed", [error], []), null);
        });
      }
    };
    if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
      let next = start;
      start = () => fs3.writeFile(input, next);
    }
    start(null);
  };
  let formatMessages2 = ({ callName, refs, messages, options, callback }) => {
    if (!options) throw new Error(`Missing second argument in ${callName}() call`);
    let keys = {};
    let kind = getFlag(options, keys, "kind", mustBeString);
    let color = getFlag(options, keys, "color", mustBeBoolean);
    let terminalWidth = getFlag(options, keys, "terminalWidth", mustBeInteger);
    checkForInvalidFlags(options, keys, `in ${callName}() call`);
    if (kind === void 0) throw new Error(`Missing "kind" in ${callName}() call`);
    if (kind !== "error" && kind !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
    let request = {
      command: "format-msgs",
      messages: sanitizeMessages(messages, "messages", null, "", terminalWidth),
      isWarning: kind === "warning"
    };
    if (color !== void 0) request.color = color;
    if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;
    sendRequest(refs, request, (error, response) => {
      if (error) return callback(new Error(error), null);
      callback(null, response.messages);
    });
  };
  let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
    if (options === void 0) options = {};
    let keys = {};
    let color = getFlag(options, keys, "color", mustBeBoolean);
    let verbose = getFlag(options, keys, "verbose", mustBeBoolean);
    checkForInvalidFlags(options, keys, `in ${callName}() call`);
    let request = {
      command: "analyze-metafile",
      metafile
    };
    if (color !== void 0) request.color = color;
    if (verbose !== void 0) request.verbose = verbose;
    sendRequest(refs, request, (error, response) => {
      if (error) return callback(new Error(error), null);
      callback(null, response.result);
    });
  };
  return {
    readFromStdout,
    afterClose,
    service: {
      buildOrContext,
      transform: transform2,
      formatMessages: formatMessages2,
      analyzeMetafile: analyzeMetafile2
    }
  };
}
function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
  const details = createObjectStash();
  const isContext = callName === "context";
  const handleError = (e, pluginName) => {
    const flags = [];
    try {
      pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
    } catch {
    }
    const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
    sendRequest(refs, { command: "error", flags, error: message }, () => {
      message.detail = details.load(message.detail);
      callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
    });
  };
  let plugins;
  if (typeof options === "object") {
    const value = options.plugins;
    if (value !== void 0) {
      if (!Array.isArray(value)) return handleError(new Error(`"plugins" must be an array`), "");
      plugins = value;
    }
  }
  if (plugins && plugins.length > 0) {
    if (streamIn.isSync) return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
    handlePlugins(
      buildKey,
      sendRequest,
      sendResponse,
      refs,
      streamIn,
      requestCallbacks,
      options,
      plugins,
      details
    ).then(
      (result) => {
        if (!result.ok) return handleError(result.error, result.pluginName);
        try {
          buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
        } catch (e) {
          handleError(e, "");
        }
      },
      (e) => handleError(e, "")
    );
    return;
  }
  try {
    buildOrContextContinue(null, (result, done) => done([], []), () => {
    });
  } catch (e) {
    handleError(e, "");
  }
  function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
    const writeDefault = streamIn.hasFS;
    const {
      entries,
      flags,
      write,
      stdinContents,
      stdinResolveDir,
      absWorkingDir,
      nodePaths,
      mangleCache
    } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
    if (write && !streamIn.hasFS) throw new Error(`The "write" option is unavailable in this environment`);
    const request = {
      command: "build",
      key: buildKey,
      entries,
      flags,
      write,
      stdinContents,
      stdinResolveDir,
      absWorkingDir: absWorkingDir || defaultWD2,
      nodePaths,
      context: isContext
    };
    if (requestPlugins) request.plugins = requestPlugins;
    if (mangleCache) request.mangleCache = mangleCache;
    const buildResponseToResult = (response, callback2) => {
      const result = {
        errors: replaceDetailsInMessages(response.errors, details),
        warnings: replaceDetailsInMessages(response.warnings, details),
        outputFiles: void 0,
        metafile: void 0,
        mangleCache: void 0
      };
      const originalErrors = result.errors.slice();
      const originalWarnings = result.warnings.slice();
      if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);
      if (response.metafile) result.metafile = JSON.parse(response.metafile);
      if (response.mangleCache) result.mangleCache = response.mangleCache;
      if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
      runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
        if (originalErrors.length > 0 || onEndErrors.length > 0) {
          const error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
          return callback2(error, null, onEndErrors, onEndWarnings);
        }
        callback2(null, result, onEndErrors, onEndWarnings);
      });
    };
    let latestResultPromise;
    let provideLatestResult;
    if (isContext)
      requestCallbacks["on-end"] = (id, request2) => new Promise((resolve) => {
        buildResponseToResult(request2, (err, result, onEndErrors, onEndWarnings) => {
          const response = {
            errors: onEndErrors,
            warnings: onEndWarnings
          };
          if (provideLatestResult) provideLatestResult(err, result);
          latestResultPromise = void 0;
          provideLatestResult = void 0;
          sendResponse(id, response);
          resolve();
        });
      });
    sendRequest(refs, request, (error, response) => {
      if (error) return callback(new Error(error), null);
      if (!isContext) {
        return buildResponseToResult(response, (err, res) => {
          scheduleOnDisposeCallbacks();
          return callback(err, res);
        });
      }
      if (response.errors.length > 0) {
        return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
      }
      let didDispose = false;
      const result = {
        rebuild: () => {
          if (!latestResultPromise) latestResultPromise = new Promise((resolve, reject) => {
            let settlePromise;
            provideLatestResult = (err, result2) => {
              if (!settlePromise) settlePromise = () => err ? reject(err) : resolve(result2);
            };
            const triggerAnotherBuild = () => {
              const request2 = {
                command: "rebuild",
                key: buildKey
              };
              sendRequest(refs, request2, (error2, response2) => {
                if (error2) {
                  reject(new Error(error2));
                } else if (settlePromise) {
                  settlePromise();
                } else {
                  triggerAnotherBuild();
                }
              });
            };
            triggerAnotherBuild();
          });
          return latestResultPromise;
        },
        watch: (options2 = {}) => new Promise((resolve, reject) => {
          if (!streamIn.hasFS) throw new Error(`Cannot use the "watch" API in this environment`);
          const keys = {};
          const delay = getFlag(options2, keys, "delay", mustBeInteger);
          checkForInvalidFlags(options2, keys, `in watch() call`);
          const request2 = {
            command: "watch",
            key: buildKey
          };
          if (delay) request2.delay = delay;
          sendRequest(refs, request2, (error2) => {
            if (error2) reject(new Error(error2));
            else resolve(void 0);
          });
        }),
        serve: (options2 = {}) => new Promise((resolve, reject) => {
          if (!streamIn.hasFS) throw new Error(`Cannot use the "serve" API in this environment`);
          const keys = {};
          const port = getFlag(options2, keys, "port", mustBeValidPortNumber);
          const host = getFlag(options2, keys, "host", mustBeString);
          const servedir = getFlag(options2, keys, "servedir", mustBeString);
          const keyfile = getFlag(options2, keys, "keyfile", mustBeString);
          const certfile = getFlag(options2, keys, "certfile", mustBeString);
          const fallback = getFlag(options2, keys, "fallback", mustBeString);
          const cors = getFlag(options2, keys, "cors", mustBeObject);
          const onRequest = getFlag(options2, keys, "onRequest", mustBeFunction);
          checkForInvalidFlags(options2, keys, `in serve() call`);
          const request2 = {
            command: "serve",
            key: buildKey,
            onRequest: !!onRequest
          };
          if (port !== void 0) request2.port = port;
          if (host !== void 0) request2.host = host;
          if (servedir !== void 0) request2.servedir = servedir;
          if (keyfile !== void 0) request2.keyfile = keyfile;
          if (certfile !== void 0) request2.certfile = certfile;
          if (fallback !== void 0) request2.fallback = fallback;
          if (cors) {
            const corsKeys = {};
            const origin = getFlag(cors, corsKeys, "origin", mustBeStringOrArrayOfStrings);
            checkForInvalidFlags(cors, corsKeys, `on "cors" object`);
            if (Array.isArray(origin)) request2.corsOrigin = origin;
            else if (origin !== void 0) request2.corsOrigin = [origin];
          }
          sendRequest(refs, request2, (error2, response2) => {
            if (error2) return reject(new Error(error2));
            if (onRequest) {
              requestCallbacks["serve-request"] = (id, request3) => {
                onRequest(request3.args);
                sendResponse(id, {});
              };
            }
            resolve(response2);
          });
        }),
        cancel: () => new Promise((resolve) => {
          if (didDispose) return resolve();
          const request2 = {
            command: "cancel",
            key: buildKey
          };
          sendRequest(refs, request2, () => {
            resolve();
          });
        }),
        dispose: () => new Promise((resolve) => {
          if (didDispose) return resolve();
          didDispose = true;
          const request2 = {
            command: "dispose",
            key: buildKey
          };
          sendRequest(refs, request2, () => {
            resolve();
            scheduleOnDisposeCallbacks();
            refs.unref();
          });
        })
      };
      refs.ref();
      callback(null, result);
    });
  }
}
var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
  let onStartCallbacks = [];
  let onEndCallbacks = [];
  let onResolveCallbacks = {};
  let onLoadCallbacks = {};
  let onDisposeCallbacks = [];
  let nextCallbackID = 0;
  let i = 0;
  let requestPlugins = [];
  let isSetupDone = false;
  plugins = [...plugins];
  for (let item of plugins) {
    let keys = {};
    if (typeof item !== "object") throw new Error(`Plugin at index ${i} must be an object`);
    const name = getFlag(item, keys, "name", mustBeString);
    if (typeof name !== "string" || name === "") throw new Error(`Plugin at index ${i} is missing a name`);
    try {
      let setup = getFlag(item, keys, "setup", mustBeFunction);
      if (typeof setup !== "function") throw new Error(`Plugin is missing a setup function`);
      checkForInvalidFlags(item, keys, `on plugin ${quote(name)}`);
      let plugin = {
        name,
        onStart: false,
        onEnd: false,
        onResolve: [],
        onLoad: []
      };
      i++;
      let resolve = (path3, options = {}) => {
        if (!isSetupDone) throw new Error('Cannot call "resolve" before plugin setup has completed');
        if (typeof path3 !== "string") throw new Error(`The path to resolve must be a string`);
        let keys2 = /* @__PURE__ */ Object.create(null);
        let pluginName = getFlag(options, keys2, "pluginName", mustBeString);
        let importer = getFlag(options, keys2, "importer", mustBeString);
        let namespace = getFlag(options, keys2, "namespace", mustBeString);
        let resolveDir = getFlag(options, keys2, "resolveDir", mustBeString);
        let kind = getFlag(options, keys2, "kind", mustBeString);
        let pluginData = getFlag(options, keys2, "pluginData", canBeAnything);
        let importAttributes = getFlag(options, keys2, "with", mustBeObject);
        checkForInvalidFlags(options, keys2, "in resolve() call");
        return new Promise((resolve2, reject) => {
          const request = {
            command: "resolve",
            path: path3,
            key: buildKey,
            pluginName: name
          };
          if (pluginName != null) request.pluginName = pluginName;
          if (importer != null) request.importer = importer;
          if (namespace != null) request.namespace = namespace;
          if (resolveDir != null) request.resolveDir = resolveDir;
          if (kind != null) request.kind = kind;
          else throw new Error(`Must specify "kind" when calling "resolve"`);
          if (pluginData != null) request.pluginData = details.store(pluginData);
          if (importAttributes != null) request.with = sanitizeStringMap(importAttributes, "with");
          sendRequest(refs, request, (error, response) => {
            if (error !== null) reject(new Error(error));
            else resolve2({
              errors: replaceDetailsInMessages(response.errors, details),
              warnings: replaceDetailsInMessages(response.warnings, details),
              path: response.path,
              external: response.external,
              sideEffects: response.sideEffects,
              namespace: response.namespace,
              suffix: response.suffix,
              pluginData: details.load(response.pluginData)
            });
          });
        });
      };
      let promise = setup({
        initialOptions,
        resolve,
        onStart(callback) {
          let registeredText = `This error came from the "onStart" callback registered here:`;
          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
          onStartCallbacks.push({ name, callback, note: registeredNote });
          plugin.onStart = true;
        },
        onEnd(callback) {
          let registeredText = `This error came from the "onEnd" callback registered here:`;
          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
          onEndCallbacks.push({ name, callback, note: registeredNote });
          plugin.onEnd = true;
        },
        onResolve(options, callback) {
          let registeredText = `This error came from the "onResolve" callback registered here:`;
          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
          let keys2 = {};
          let filter = getFlag(options, keys2, "filter", mustBeRegExp);
          let namespace = getFlag(options, keys2, "namespace", mustBeString);
          checkForInvalidFlags(options, keys2, `in onResolve() call for plugin ${quote(name)}`);
          if (filter == null) throw new Error(`onResolve() call is missing a filter`);
          let id = nextCallbackID++;
          onResolveCallbacks[id] = { name, callback, note: registeredNote };
          plugin.onResolve.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
        },
        onLoad(options, callback) {
          let registeredText = `This error came from the "onLoad" callback registered here:`;
          let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
          let keys2 = {};
          let filter = getFlag(options, keys2, "filter", mustBeRegExp);
          let namespace = getFlag(options, keys2, "namespace", mustBeString);
          checkForInvalidFlags(options, keys2, `in onLoad() call for plugin ${quote(name)}`);
          if (filter == null) throw new Error(`onLoad() call is missing a filter`);
          let id = nextCallbackID++;
          onLoadCallbacks[id] = { name, callback, note: registeredNote };
          plugin.onLoad.push({ id, filter: jsRegExpToGoRegExp(filter), namespace: namespace || "" });
        },
        onDispose(callback) {
          onDisposeCallbacks.push(callback);
        },
        esbuild: streamIn.esbuild
      });
      if (promise) await promise;
      requestPlugins.push(plugin);
    } catch (e) {
      return { ok: false, error: e, pluginName: name };
    }
  }
  requestCallbacks["on-start"] = async (id, request) => {
    details.clear();
    let response = { errors: [], warnings: [] };
    await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
      try {
        let result = await callback();
        if (result != null) {
          if (typeof result !== "object") throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
          let keys = {};
          let errors = getFlag(result, keys, "errors", mustBeArray);
          let warnings = getFlag(result, keys, "warnings", mustBeArray);
          checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote(name)}`);
          if (errors != null) response.errors.push(...sanitizeMessages(errors, "errors", details, name, void 0));
          if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name, void 0));
        }
      } catch (e) {
        response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
      }
    }));
    sendResponse(id, response);
  };
  requestCallbacks["on-resolve"] = async (id, request) => {
    let response = {}, name = "", callback, note;
    for (let id2 of request.ids) {
      try {
        ({ name, callback, note } = onResolveCallbacks[id2]);
        let result = await callback({
          path: request.path,
          importer: request.importer,
          namespace: request.namespace,
          resolveDir: request.resolveDir,
          kind: request.kind,
          pluginData: details.load(request.pluginData),
          with: request.with
        });
        if (result != null) {
          if (typeof result !== "object") throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
          let keys = {};
          let pluginName = getFlag(result, keys, "pluginName", mustBeString);
          let path3 = getFlag(result, keys, "path", mustBeString);
          let namespace = getFlag(result, keys, "namespace", mustBeString);
          let suffix = getFlag(result, keys, "suffix", mustBeString);
          let external = getFlag(result, keys, "external", mustBeBoolean);
          let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
          let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
          let errors = getFlag(result, keys, "errors", mustBeArray);
          let warnings = getFlag(result, keys, "warnings", mustBeArray);
          let watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
          let watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
          checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote(name)}`);
          response.id = id2;
          if (pluginName != null) response.pluginName = pluginName;
          if (path3 != null) response.path = path3;
          if (namespace != null) response.namespace = namespace;
          if (suffix != null) response.suffix = suffix;
          if (external != null) response.external = external;
          if (sideEffects != null) response.sideEffects = sideEffects;
          if (pluginData != null) response.pluginData = details.store(pluginData);
          if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
          if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
          if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
          if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
          break;
        }
      } catch (e) {
        response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
        break;
      }
    }
    sendResponse(id, response);
  };
  requestCallbacks["on-load"] = async (id, request) => {
    let response = {}, name = "", callback, note;
    for (let id2 of request.ids) {
      try {
        ({ name, callback, note } = onLoadCallbacks[id2]);
        let result = await callback({
          path: request.path,
          namespace: request.namespace,
          suffix: request.suffix,
          pluginData: details.load(request.pluginData),
          with: request.with
        });
        if (result != null) {
          if (typeof result !== "object") throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
          let keys = {};
          let pluginName = getFlag(result, keys, "pluginName", mustBeString);
          let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
          let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
          let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
          let loader = getFlag(result, keys, "loader", mustBeString);
          let errors = getFlag(result, keys, "errors", mustBeArray);
          let warnings = getFlag(result, keys, "warnings", mustBeArray);
          let watchFiles = getFlag(result, keys, "watchFiles", mustBeArrayOfStrings);
          let watchDirs = getFlag(result, keys, "watchDirs", mustBeArrayOfStrings);
          checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote(name)}`);
          response.id = id2;
          if (pluginName != null) response.pluginName = pluginName;
          if (contents instanceof Uint8Array) response.contents = contents;
          else if (contents != null) response.contents = encodeUTF8(contents);
          if (resolveDir != null) response.resolveDir = resolveDir;
          if (pluginData != null) response.pluginData = details.store(pluginData);
          if (loader != null) response.loader = loader;
          if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name, void 0);
          if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
          if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
          if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
          break;
        }
      } catch (e) {
        response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
        break;
      }
    }
    sendResponse(id, response);
  };
  let runOnEndCallbacks = (result, done) => done([], []);
  if (onEndCallbacks.length > 0) {
    runOnEndCallbacks = (result, done) => {
      (async () => {
        const onEndErrors = [];
        const onEndWarnings = [];
        for (const { name, callback, note } of onEndCallbacks) {
          let newErrors;
          let newWarnings;
          try {
            const value = await callback(result);
            if (value != null) {
              if (typeof value !== "object") throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
              let keys = {};
              let errors = getFlag(value, keys, "errors", mustBeArray);
              let warnings = getFlag(value, keys, "warnings", mustBeArray);
              checkForInvalidFlags(value, keys, `from onEnd() callback in plugin ${quote(name)}`);
              if (errors != null) newErrors = sanitizeMessages(errors, "errors", details, name, void 0);
              if (warnings != null) newWarnings = sanitizeMessages(warnings, "warnings", details, name, void 0);
            }
          } catch (e) {
            newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];
          }
          if (newErrors) {
            onEndErrors.push(...newErrors);
            try {
              result.errors.push(...newErrors);
            } catch {
            }
          }
          if (newWarnings) {
            onEndWarnings.push(...newWarnings);
            try {
              result.warnings.push(...newWarnings);
            } catch {
            }
          }
        }
        done(onEndErrors, onEndWarnings);
      })();
    };
  }
  let scheduleOnDisposeCallbacks = () => {
    for (const cb of onDisposeCallbacks) {
      setTimeout(() => cb(), 0);
    }
  };
  isSetupDone = true;
  return {
    ok: true,
    requestPlugins,
    runOnEndCallbacks,
    scheduleOnDisposeCallbacks
  };
};
function createObjectStash() {
  const map = /* @__PURE__ */ new Map();
  let nextID = 0;
  return {
    clear() {
      map.clear();
    },
    load(id) {
      return map.get(id);
    },
    store(value) {
      if (value === void 0) return -1;
      const id = nextID++;
      map.set(id, value);
      return id;
    }
  };
}
function extractCallerV8(e, streamIn, ident) {
  let note;
  let tried = false;
  return () => {
    if (tried) return note;
    tried = true;
    try {
      let lines = (e.stack + "").split("\n");
      lines.splice(1, 1);
      let location = parseStackLinesV8(streamIn, lines, ident);
      if (location) {
        note = { text: e.message, location };
        return note;
      }
    } catch {
    }
  };
}
function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
  let text = "Internal error";
  let location = null;
  try {
    text = (e && e.message || e) + "";
  } catch {
  }
  try {
    location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
  } catch {
  }
  return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
}
function parseStackLinesV8(streamIn, lines, ident) {
  let at = "    at ";
  if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
    for (let i = 1; i < lines.length; i++) {
      let line = lines[i];
      if (!line.startsWith(at)) continue;
      line = line.slice(at.length);
      while (true) {
        let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
        if (match) {
          line = match[1];
          continue;
        }
        match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
        if (match) {
          line = match[1];
          continue;
        }
        match = /^(\S+):(\d+):(\d+)$/.exec(line);
        if (match) {
          let contents;
          try {
            contents = streamIn.readFileSync(match[1], "utf8");
          } catch {
            break;
          }
          let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
          let column = +match[3] - 1;
          let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
          return {
            file: match[1],
            namespace: "file",
            line: +match[2],
            column: encodeUTF8(lineText.slice(0, column)).length,
            length: encodeUTF8(lineText.slice(column, column + length)).length,
            lineText: lineText + "\n" + lines.slice(1).join("\n"),
            suggestion: ""
          };
        }
        break;
      }
    }
  }
  return null;
}
function failureErrorWithLog(text, errors, warnings) {
  let limit = 5;
  text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
    if (i === limit) return "\n...";
    if (!e.location) return `
error: ${e.text}`;
    let { file, line, column } = e.location;
    let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
    return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
  }).join("");
  let error = new Error(text);
  for (const [key, value] of [["errors", errors], ["warnings", warnings]]) {
    Object.defineProperty(error, key, {
      configurable: true,
      enumerable: true,
      get: () => value,
      set: (value2) => Object.defineProperty(error, key, {
        configurable: true,
        enumerable: true,
        value: value2
      })
    });
  }
  return error;
}
function replaceDetailsInMessages(messages, stash) {
  for (const message of messages) {
    message.detail = stash.load(message.detail);
  }
  return messages;
}
function sanitizeLocation(location, where, terminalWidth) {
  if (location == null) return null;
  let keys = {};
  let file = getFlag(location, keys, "file", mustBeString);
  let namespace = getFlag(location, keys, "namespace", mustBeString);
  let line = getFlag(location, keys, "line", mustBeInteger);
  let column = getFlag(location, keys, "column", mustBeInteger);
  let length = getFlag(location, keys, "length", mustBeInteger);
  let lineText = getFlag(location, keys, "lineText", mustBeString);
  let suggestion = getFlag(location, keys, "suggestion", mustBeString);
  checkForInvalidFlags(location, keys, where);
  if (lineText) {
    const relevantASCII = lineText.slice(
      0,
      (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)
    );
    if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
      lineText = relevantASCII;
    }
  }
  return {
    file: file || "",
    namespace: namespace || "",
    line: line || 0,
    column: column || 0,
    length: length || 0,
    lineText: lineText || "",
    suggestion: suggestion || ""
  };
}
function sanitizeMessages(messages, property, stash, fallbackPluginName, terminalWidth) {
  let messagesClone = [];
  let index = 0;
  for (const message of messages) {
    let keys = {};
    let id = getFlag(message, keys, "id", mustBeString);
    let pluginName = getFlag(message, keys, "pluginName", mustBeString);
    let text = getFlag(message, keys, "text", mustBeString);
    let location = getFlag(message, keys, "location", mustBeObjectOrNull);
    let notes = getFlag(message, keys, "notes", mustBeArray);
    let detail = getFlag(message, keys, "detail", canBeAnything);
    let where = `in element ${index} of "${property}"`;
    checkForInvalidFlags(message, keys, where);
    let notesClone = [];
    if (notes) {
      for (const note of notes) {
        let noteKeys = {};
        let noteText = getFlag(note, noteKeys, "text", mustBeString);
        let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
        checkForInvalidFlags(note, noteKeys, where);
        notesClone.push({
          text: noteText || "",
          location: sanitizeLocation(noteLocation, where, terminalWidth)
        });
      }
    }
    messagesClone.push({
      id: id || "",
      pluginName: pluginName || fallbackPluginName,
      text: text || "",
      location: sanitizeLocation(location, where, terminalWidth),
      notes: notesClone,
      detail: stash ? stash.store(detail) : -1
    });
    index++;
  }
  return messagesClone;
}
function sanitizeStringArray(values, property) {
  const result = [];
  for (const value of values) {
    if (typeof value !== "string") throw new Error(`${quote(property)} must be an array of strings`);
    result.push(value);
  }
  return result;
}
function sanitizeStringMap(map, property) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key in map) {
    const value = map[key];
    if (typeof value !== "string") throw new Error(`key ${quote(key)} in object ${quote(property)} must be a string`);
    result[key] = value;
  }
  return result;
}
function convertOutputFiles({ path: path3, contents, hash }) {
  let text = null;
  return {
    path: path3,
    contents,
    hash,
    get text() {
      const binary = this.contents;
      if (text === null || binary !== contents) {
        contents = binary;
        text = decodeUTF8(binary);
      }
      return text;
    }
  };
}
function jsRegExpToGoRegExp(regexp) {
  let result = regexp.source;
  if (regexp.flags) result = `(?${regexp.flags})${result}`;
  return result;
}

// lib/npm/node-platform.ts
var fs = require("fs");
var os = require("os");
var path = require("path");
var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
var packageDarwin_arm64 = "@esbuild/darwin-arm64";
var packageDarwin_x64 = "@esbuild/darwin-x64";
var knownWindowsPackages = {
  "win32 arm64 LE": "@esbuild/win32-arm64",
  "win32 ia32 LE": "@esbuild/win32-ia32",
  "win32 x64 LE": "@esbuild/win32-x64"
};
var knownUnixlikePackages = {
  "aix ppc64 BE": "@esbuild/aix-ppc64",
  "android arm64 LE": "@esbuild/android-arm64",
  "darwin arm64 LE": "@esbuild/darwin-arm64",
  "darwin x64 LE": "@esbuild/darwin-x64",
  "freebsd arm64 LE": "@esbuild/freebsd-arm64",
  "freebsd x64 LE": "@esbuild/freebsd-x64",
  "linux arm LE": "@esbuild/linux-arm",
  "linux arm64 LE": "@esbuild/linux-arm64",
  "linux ia32 LE": "@esbuild/linux-ia32",
  "linux mips64el LE": "@esbuild/linux-mips64el",
  "linux ppc64 LE": "@esbuild/linux-ppc64",
  "linux riscv64 LE": "@esbuild/linux-riscv64",
  "linux s390x BE": "@esbuild/linux-s390x",
  "linux x64 LE": "@esbuild/linux-x64",
  "linux loong64 LE": "@esbuild/linux-loong64",
  "netbsd arm64 LE": "@esbuild/netbsd-arm64",
  "netbsd x64 LE": "@esbuild/netbsd-x64",
  "openbsd arm64 LE": "@esbuild/openbsd-arm64",
  "openbsd x64 LE": "@esbuild/openbsd-x64",
  "sunos x64 LE": "@esbuild/sunos-x64"
};
var knownWebAssemblyFallbackPackages = {
  "android arm LE": "@esbuild/android-arm",
  "android x64 LE": "@esbuild/android-x64",
  "openharmony arm64 LE": "@esbuild/openharmony-arm64"
};
function pkgAndSubpathForCurrentPlatform() {
  let pkg;
  let subpath;
  let isWASM = false;
  let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
  if (platformKey in knownWindowsPackages) {
    pkg = knownWindowsPackages[platformKey];
    subpath = "esbuild.exe";
  } else if (platformKey in knownUnixlikePackages) {
    pkg = knownUnixlikePackages[platformKey];
    subpath = "bin/esbuild";
  } else if (platformKey in knownWebAssemblyFallbackPackages) {
    pkg = knownWebAssemblyFallbackPackages[platformKey];
    subpath = "bin/esbuild";
    isWASM = true;
  } else {
    throw new Error(`Unsupported platform: ${platformKey}`);
  }
  return { pkg, subpath, isWASM };
}
function pkgForSomeOtherPlatform() {
  const libMainJS = require.resolve("esbuild");
  const nodeModulesDirectory = path.dirname(path.dirname(path.dirname(libMainJS)));
  if (path.basename(nodeModulesDirectory) === "node_modules") {
    for (const unixKey in knownUnixlikePackages) {
      try {
        const pkg = knownUnixlikePackages[unixKey];
        if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
      } catch {
      }
    }
    for (const windowsKey in knownWindowsPackages) {
      try {
        const pkg = knownWindowsPackages[windowsKey];
        if (fs.existsSync(path.join(nodeModulesDirectory, pkg))) return pkg;
      } catch {
      }
    }
  }
  return null;
}
function downloadedBinPath(pkg, subpath) {
  const esbuildLibDir = path.dirname(require.resolve("esbuild"));
  return path.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
}
function generateBinPath() {
  if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
    if (!fs.existsSync(ESBUILD_BINARY_PATH)) {
      console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
    } else {
      return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
    }
  }
  const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
  let binPath;
  try {
    binPath = require.resolve(`${pkg}/${subpath}`);
  } catch (e) {
    binPath = downloadedBinPath(pkg, subpath);
    if (!fs.existsSync(binPath)) {
      try {
        require.resolve(pkg);
      } catch {
        const otherPkg = pkgForSomeOtherPlatform();
        if (otherPkg) {
          let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
          if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
            suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
          }
          throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
        }
        throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
      }
      throw e;
    }
  }
  if (/\.zip\//.test(binPath)) {
    let pnpapi;
    try {
      pnpapi = require("pnpapi");
    } catch (e) {
    }
    if (pnpapi) {
      const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
      const binTargetPath = path.join(
        root,
        "node_modules",
        ".cache",
        "esbuild",
        `pnpapi-${pkg.replace("/", "-")}-${"0.25.12"}-${path.basename(subpath)}`
      );
      if (!fs.existsSync(binTargetPath)) {
        fs.mkdirSync(path.dirname(binTargetPath), { recursive: true });
        fs.copyFileSync(binPath, binTargetPath);
        fs.chmodSync(binTargetPath, 493);
      }
      return { binPath: binTargetPath, isWASM };
    }
  }
  return { binPath, isWASM };
}

// lib/npm/node.ts
var child_process = require("child_process");
var crypto = require("crypto");
var path2 = require("path");
var fs2 = require("fs");
var os2 = require("os");
var tty = require("tty");
var worker_threads;
if (process.env.ESBUILD_WORKER_THREADS !== "0") {
  try {
    worker_threads = require("worker_threads");
  } catch {
  }
  let [major, minor] = process.versions.node.split(".");
  if (
    // <v12.17.0 does not work
    +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
  ) {
    worker_threads = void 0;
  }
}
var _a;
var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.25.12";
var esbuildCommandAndArgs = () => {
  if ((!ESBUILD_BINARY_PATH || false) && (path2.basename(__filename) !== "main.js" || path2.basename(__dirname) !== "lib")) {
    throw new Error(
      `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
    );
  }
  if (false) {
    return ["node", [path2.join(__dirname, "..", "bin", "esbuild")]];
  } else {
    const { binPath, isWASM } = generateBinPath();
    if (isWASM) {
      return ["node", [binPath]];
    } else {
      return [binPath, []];
    }
  }
};
var isTTY = () => tty.isatty(2);
var fsSync = {
  readFile(tempFile, callback) {
    try {
      let contents = fs2.readFileSync(tempFile, "utf8");
      try {
        fs2.unlinkSync(tempFile);
      } catch {
      }
      callback(null, contents);
    } catch (err) {
      callback(err, null);
    }
  },
  writeFile(contents, callback) {
    try {
      let tempFile = randomFileName();
      fs2.writeFileSync(tempFile, contents);
      callback(tempFile);
    } catch {
      callback(null);
    }
  }
};
var fsAsync = {
  readFile(tempFile, callback) {
    try {
      fs2.readFile(tempFile, "utf8", (err, contents) => {
        try {
          fs2.unlink(tempFile, () => callback(err, contents));
        } catch {
          callback(err, contents);
        }
      });
    } catch (err) {
      callback(err, null);
    }
  },
  writeFile(contents, callback) {
    try {
      let tempFile = randomFileName();
      fs2.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
    } catch {
      callback(null);
    }
  }
};
var version = "0.25.12";
var build = (options) => ensureServiceIsRunning().build(options);
var context = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
var transform = (input, options) => ensureServiceIsRunning().transform(input, options);
var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
var analyzeMetafile = (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options);
var buildSync = (options) => {
  if (worker_threads && !isInternalWorkerThread) {
    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
    return workerThreadService.buildSync(options);
  }
  let result;
  runServiceSync((service) => service.buildOrContext({
    callName: "buildSync",
    refs: null,
    options,
    isTTY: isTTY(),
    defaultWD,
    callback: (err, res) => {
      if (err) throw err;
      result = res;
    }
  }));
  return result;
};
var transformSync = (input, options) => {
  if (worker_threads && !isInternalWorkerThread) {
    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
    return workerThreadService.transformSync(input, options);
  }
  let result;
  runServiceSync((service) => service.transform({
    callName: "transformSync",
    refs: null,
    input,
    options: options || {},
    isTTY: isTTY(),
    fs: fsSync,
    callback: (err, res) => {
      if (err) throw err;
      result = res;
    }
  }));
  return result;
};
var formatMessagesSync = (messages, options) => {
  if (worker_threads && !isInternalWorkerThread) {
    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
    return workerThreadService.formatMessagesSync(messages, options);
  }
  let result;
  runServiceSync((service) => service.formatMessages({
    callName: "formatMessagesSync",
    refs: null,
    messages,
    options,
    callback: (err, res) => {
      if (err) throw err;
      result = res;
    }
  }));
  return result;
};
var analyzeMetafileSync = (metafile, options) => {
  if (worker_threads && !isInternalWorkerThread) {
    if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
    return workerThreadService.analyzeMetafileSync(metafile, options);
  }
  let result;
  runServiceSync((service) => service.analyzeMetafile({
    callName: "analyzeMetafileSync",
    refs: null,
    metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
    options,
    callback: (err, res) => {
      if (err) throw err;
      result = res;
    }
  }));
  return result;
};
var stop = () => {
  if (stopService) stopService();
  if (workerThreadService) workerThreadService.stop();
  return Promise.resolve();
};
var initializeWasCalled = false;
var initialize = (options) => {
  options = validateInitializeOptions(options || {});
  if (options.wasmURL) throw new Error(`The "wasmURL" option only works in the browser`);
  if (options.wasmModule) throw new Error(`The "wasmModule" option only works in the browser`);
  if (options.worker) throw new Error(`The "worker" option only works in the browser`);
  if (initializeWasCalled) throw new Error('Cannot call "initialize" more than once');
  ensureServiceIsRunning();
  initializeWasCalled = true;
  return Promise.resolve();
};
var defaultWD = process.cwd();
var longLivedService;
var stopService;
var ensureServiceIsRunning = () => {
  if (longLivedService) return longLivedService;
  let [command, args] = esbuildCommandAndArgs();
  let child = child_process.spawn(command, args.concat(`--service=${"0.25.12"}`, "--ping"), {
    windowsHide: true,
    stdio: ["pipe", "pipe", "inherit"],
    cwd: defaultWD
  });
  let { readFromStdout, afterClose, service } = createChannel({
    writeToStdin(bytes) {
      child.stdin.write(bytes, (err) => {
        if (err) afterClose(err);
      });
    },
    readFileSync: fs2.readFileSync,
    isSync: false,
    hasFS: true,
    esbuild: node_exports
  });
  child.stdin.on("error", afterClose);
  child.on("error", afterClose);
  const stdin = child.stdin;
  const stdout = child.stdout;
  stdout.on("data", readFromStdout);
  stdout.on("end", afterClose);
  stopService = () => {
    stdin.destroy();
    stdout.destroy();
    child.kill();
    initializeWasCalled = false;
    longLivedService = void 0;
    stopService = void 0;
  };
  let refCount = 0;
  child.unref();
  if (stdin.unref) {
    stdin.unref();
  }
  if (stdout.unref) {
    stdout.unref();
  }
  const refs = {
    ref() {
      if (++refCount === 1) child.ref();
    },
    unref() {
      if (--refCount === 0) child.unref();
    }
  };
  longLivedService = {
    build: (options) => new Promise((resolve, reject) => {
      service.buildOrContext({
        callName: "build",
        refs,
        options,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => err ? reject(err) : resolve(res)
      });
    }),
    context: (options) => new Promise((resolve, reject) => service.buildOrContext({
      callName: "context",
      refs,
      options,
      isTTY: isTTY(),
      defaultWD,
      callback: (err, res) => err ? reject(err) : resolve(res)
    })),
    transform: (input, options) => new Promise((resolve, reject) => service.transform({
      callName: "transform",
      refs,
      input,
      options: options || {},
      isTTY: isTTY(),
      fs: fsAsync,
      callback: (err, res) => err ? reject(err) : resolve(res)
    })),
    formatMessages: (messages, options) => new Promise((resolve, reject) => service.formatMessages({
      callName: "formatMessages",
      refs,
      messages,
      options,
      callback: (err, res) => err ? reject(err) : resolve(res)
    })),
    analyzeMetafile: (metafile, options) => new Promise((resolve, reject) => service.analyzeMetafile({
      callName: "analyzeMetafile",
      refs,
      metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
      options,
      callback: (err, res) => err ? reject(err) : resolve(res)
    }))
  };
  return longLivedService;
};
var runServiceSync = (callback) => {
  let [command, args] = esbuildCommandAndArgs();
  let stdin = new Uint8Array();
  let { readFromStdout, afterClose, service } = createChannel({
    writeToStdin(bytes) {
      if (stdin.length !== 0) throw new Error("Must run at most one command");
      stdin = bytes;
    },
    isSync: true,
    hasFS: true,
    esbuild: node_exports
  });
  callback(service);
  let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.25.12"}`), {
    cwd: defaultWD,
    windowsHide: true,
    input: stdin,
    // We don't know how large the output could be. If it's too large, the
    // command will fail with ENOBUFS. Reserve 16mb for now since that feels
    // like it should be enough. Also allow overriding this with an environment
    // variable.
    maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
  });
  readFromStdout(stdout);
  afterClose(null);
};
var randomFileName = () => {
  return path2.join(os2.tmpdir(), `esbuild-${crypto.randomBytes(32).toString("hex")}`);
};
var workerThreadService = null;
var startWorkerThreadService = (worker_threads2) => {
  let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
  let worker = new worker_threads2.Worker(__filename, {
    workerData: { workerPort, defaultWD, esbuildVersion: "0.25.12" },
    transferList: [workerPort],
    // From node's documentation: https://nodejs.org/api/worker_threads.html
    //
    //   Take care when launching worker threads from preload scripts (scripts loaded
    //   and run using the `-r` command line flag). Unless the `execArgv` option is
    //   explicitly set, new Worker threads automatically inherit the command line flags
    //   from the running process and will preload the same preload scripts as the main
    //   thread. If the preload script unconditionally launches a worker thread, every
    //   thread spawned will spawn another until the application crashes.
    //
    execArgv: []
  });
  let nextID = 0;
  let fakeBuildError = (text) => {
    let error = new Error(`Build failed with 1 error:
error: ${text}`);
    let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
    error.errors = errors;
    error.warnings = [];
    return error;
  };
  let validateBuildSyncOptions = (options) => {
    if (!options) return;
    let plugins = options.plugins;
    if (plugins && plugins.length > 0) throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
  };
  let applyProperties = (object, properties) => {
    for (let key in properties) {
      object[key] = properties[key];
    }
  };
  let runCallSync = (command, args) => {
    let id = nextID++;
    let sharedBuffer = new SharedArrayBuffer(8);
    let sharedBufferView = new Int32Array(sharedBuffer);
    let msg = { sharedBuffer, id, command, args };
    worker.postMessage(msg);
    let status = Atomics.wait(sharedBufferView, 0, 0);
    if (status !== "ok" && status !== "not-equal") throw new Error("Internal error: Atomics.wait() failed: " + status);
    let { message: { id: id2, resolve, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
    if (id !== id2) throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
    if (reject) {
      applyProperties(reject, properties);
      throw reject;
    }
    return resolve;
  };
  worker.unref();
  return {
    buildSync(options) {
      validateBuildSyncOptions(options);
      return runCallSync("build", [options]);
    },
    transformSync(input, options) {
      return runCallSync("transform", [input, options]);
    },
    formatMessagesSync(messages, options) {
      return runCallSync("formatMessages", [messages, options]);
    },
    analyzeMetafileSync(metafile, options) {
      return runCallSync("analyzeMetafile", [metafile, options]);
    },
    stop() {
      worker.terminate();
      workerThreadService = null;
    }
  };
};
var startSyncServiceWorker = () => {
  let workerPort = worker_threads.workerData.workerPort;
  let parentPort = worker_threads.parentPort;
  let extractProperties = (object) => {
    let properties = {};
    if (object && typeof object === "object") {
      for (let key in object) {
        properties[key] = object[key];
      }
    }
    return properties;
  };
  try {
    let service = ensureServiceIsRunning();
    defaultWD = worker_threads.workerData.defaultWD;
    parentPort.on("message", (msg) => {
      (async () => {
        let { sharedBuffer, id, command, args } = msg;
        let sharedBufferView = new Int32Array(sharedBuffer);
        try {
          switch (command) {
            case "build":
              workerPort.postMessage({ id, resolve: await service.build(args[0]) });
              break;
            case "transform":
              workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
              break;
            case "formatMessages":
              workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
              break;
            case "analyzeMetafile":
              workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
              break;
            default:
              throw new Error(`Invalid command: ${command}`);
          }
        } catch (reject) {
          workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
        }
        Atomics.add(sharedBufferView, 0, 1);
        Atomics.notify(sharedBufferView, 0, Infinity);
      })();
    });
  } catch (reject) {
    parentPort.on("message", (msg) => {
      let { sharedBuffer, id } = msg;
      let sharedBufferView = new Int32Array(sharedBuffer);
      workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
      Atomics.add(sharedBufferView, 0, 1);
      Atomics.notify(sharedBufferView, 0, Infinity);
    });
  }
};
if (isInternalWorkerThread) {
  startSyncServiceWorker();
}
var node_default = node_exports;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  analyzeMetafile,
  analyzeMetafileSync,
  build,
  buildSync,
  context,
  formatMessages,
  formatMessagesSync,
  initialize,
  stop,
  transform,
  transformSync,
  version
});

~~~

## node_modules\esbuild\LICENSE.md

~~~md
MIT License

Copyright (c) 2020 Evan Wallace

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

~~~

## node_modules\esbuild\package.json

~~~json
{
  "name": "esbuild",
  "version": "0.25.12",
  "description": "An extremely fast JavaScript and CSS bundler and minifier.",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/evanw/esbuild.git"
  },
  "scripts": {
    "postinstall": "node install.js"
  },
  "main": "lib/main.js",
  "types": "lib/main.d.ts",
  "engines": {
    "node": ">=18"
  },
  "bin": {
    "esbuild": "bin/esbuild"
  },
  "optionalDependencies": {
    "@esbuild/aix-ppc64": "0.25.12",
    "@esbuild/android-arm": "0.25.12",
    "@esbuild/android-arm64": "0.25.12",
    "@esbuild/android-x64": "0.25.12",
    "@esbuild/darwin-arm64": "0.25.12",
    "@esbuild/darwin-x64": "0.25.12",
    "@esbuild/freebsd-arm64": "0.25.12",
    "@esbuild/freebsd-x64": "0.25.12",
    "@esbuild/linux-arm": "0.25.12",
    "@esbuild/linux-arm64": "0.25.12",
    "@esbuild/linux-ia32": "0.25.12",
    "@esbuild/linux-loong64": "0.25.12",
    "@esbuild/linux-mips64el": "0.25.12",
    "@esbuild/linux-ppc64": "0.25.12",
    "@esbuild/linux-riscv64": "0.25.12",
    "@esbuild/linux-s390x": "0.25.12",
    "@esbuild/linux-x64": "0.25.12",
    "@esbuild/netbsd-arm64": "0.25.12",
    "@esbuild/netbsd-x64": "0.25.12",
    "@esbuild/openbsd-arm64": "0.25.12",
    "@esbuild/openbsd-x64": "0.25.12",
    "@esbuild/openharmony-arm64": "0.25.12",
    "@esbuild/sunos-x64": "0.25.12",
    "@esbuild/win32-arm64": "0.25.12",
    "@esbuild/win32-ia32": "0.25.12",
    "@esbuild/win32-x64": "0.25.12"
  },
  "license": "MIT"
}

~~~

## node_modules\esbuild\README.md

~~~md
# esbuild

This is a JavaScript bundler and minifier. See https://github.com/evanw/esbuild and the [JavaScript API documentation](https://esbuild.github.io/api/) for details.

~~~

## node_modules\fdir\dist\index.cjs

~~~cjs
//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
const path = __toESM(require("path"));
const fs = __toESM(require("fs"));

//#region src/utils.ts
function cleanPath(path$1) {
	let normalized = (0, path.normalize)(path$1);
	if (normalized.length > 1 && normalized[normalized.length - 1] === path.sep) normalized = normalized.substring(0, normalized.length - 1);
	return normalized;
}
const SLASHES_REGEX = /[\\/]/g;
function convertSlashes(path$1, separator) {
	return path$1.replace(SLASHES_REGEX, separator);
}
const WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
function isRootDirectory(path$1) {
	return path$1 === "/" || WINDOWS_ROOT_DIR_REGEX.test(path$1);
}
function normalizePath(path$1, options) {
	const { resolvePaths, normalizePath: normalizePath$1, pathSeparator } = options;
	const pathNeedsCleaning = process.platform === "win32" && path$1.includes("/") || path$1.startsWith(".");
	if (resolvePaths) path$1 = (0, path.resolve)(path$1);
	if (normalizePath$1 || pathNeedsCleaning) path$1 = cleanPath(path$1);
	if (path$1 === ".") return "";
	const needsSeperator = path$1[path$1.length - 1] !== pathSeparator;
	return convertSlashes(needsSeperator ? path$1 + pathSeparator : path$1, pathSeparator);
}

//#endregion
//#region src/api/functions/join-path.ts
function joinPathWithBasePath(filename, directoryPath) {
	return directoryPath + filename;
}
function joinPathWithRelativePath(root, options) {
	return function(filename, directoryPath) {
		const sameRoot = directoryPath.startsWith(root);
		if (sameRoot) return directoryPath.slice(root.length) + filename;
		else return convertSlashes((0, path.relative)(root, directoryPath), options.pathSeparator) + options.pathSeparator + filename;
	};
}
function joinPath(filename) {
	return filename;
}
function joinDirectoryPath(filename, directoryPath, separator) {
	return directoryPath + filename + separator;
}
function build$7(root, options) {
	const { relativePaths, includeBasePath } = options;
	return relativePaths && root ? joinPathWithRelativePath(root, options) : includeBasePath ? joinPathWithBasePath : joinPath;
}

//#endregion
//#region src/api/functions/push-directory.ts
function pushDirectoryWithRelativePath(root) {
	return function(directoryPath, paths) {
		paths.push(directoryPath.substring(root.length) || ".");
	};
}
function pushDirectoryFilterWithRelativePath(root) {
	return function(directoryPath, paths, filters) {
		const relativePath = directoryPath.substring(root.length) || ".";
		if (filters.every((filter) => filter(relativePath, true))) paths.push(relativePath);
	};
}
const pushDirectory = (directoryPath, paths) => {
	paths.push(directoryPath || ".");
};
const pushDirectoryFilter = (directoryPath, paths, filters) => {
	const path$1 = directoryPath || ".";
	if (filters.every((filter) => filter(path$1, true))) paths.push(path$1);
};
const empty$2 = () => {};
function build$6(root, options) {
	const { includeDirs, filters, relativePaths } = options;
	if (!includeDirs) return empty$2;
	if (relativePaths) return filters && filters.length ? pushDirectoryFilterWithRelativePath(root) : pushDirectoryWithRelativePath(root);
	return filters && filters.length ? pushDirectoryFilter : pushDirectory;
}

//#endregion
//#region src/api/functions/push-file.ts
const pushFileFilterAndCount = (filename, _paths, counts, filters) => {
	if (filters.every((filter) => filter(filename, false))) counts.files++;
};
const pushFileFilter = (filename, paths, _counts, filters) => {
	if (filters.every((filter) => filter(filename, false))) paths.push(filename);
};
const pushFileCount = (_filename, _paths, counts, _filters) => {
	counts.files++;
};
const pushFile = (filename, paths) => {
	paths.push(filename);
};
const empty$1 = () => {};
function build$5(options) {
	const { excludeFiles, filters, onlyCounts } = options;
	if (excludeFiles) return empty$1;
	if (filters && filters.length) return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
	else if (onlyCounts) return pushFileCount;
	else return pushFile;
}

//#endregion
//#region src/api/functions/get-array.ts
const getArray = (paths) => {
	return paths;
};
const getArrayGroup = () => {
	return [""].slice(0, 0);
};
function build$4(options) {
	return options.group ? getArrayGroup : getArray;
}

//#endregion
//#region src/api/functions/group-files.ts
const groupFiles = (groups, directory, files) => {
	groups.push({
		directory,
		files,
		dir: directory
	});
};
const empty = () => {};
function build$3(options) {
	return options.group ? groupFiles : empty;
}

//#endregion
//#region src/api/functions/resolve-symlink.ts
const resolveSymlinksAsync = function(path$1, state, callback$1) {
	const { queue, fs: fs$1, options: { suppressErrors } } = state;
	queue.enqueue();
	fs$1.realpath(path$1, (error, resolvedPath) => {
		if (error) return queue.dequeue(suppressErrors ? null : error, state);
		fs$1.stat(resolvedPath, (error$1, stat) => {
			if (error$1) return queue.dequeue(suppressErrors ? null : error$1, state);
			if (stat.isDirectory() && isRecursive(path$1, resolvedPath, state)) return queue.dequeue(null, state);
			callback$1(stat, resolvedPath);
			queue.dequeue(null, state);
		});
	});
};
const resolveSymlinks = function(path$1, state, callback$1) {
	const { queue, fs: fs$1, options: { suppressErrors } } = state;
	queue.enqueue();
	try {
		const resolvedPath = fs$1.realpathSync(path$1);
		const stat = fs$1.statSync(resolvedPath);
		if (stat.isDirectory() && isRecursive(path$1, resolvedPath, state)) return;
		callback$1(stat, resolvedPath);
	} catch (e) {
		if (!suppressErrors) throw e;
	}
};
function build$2(options, isSynchronous) {
	if (!options.resolveSymlinks || options.excludeSymlinks) return null;
	return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
}
function isRecursive(path$1, resolved, state) {
	if (state.options.useRealPaths) return isRecursiveUsingRealPaths(resolved, state);
	let parent = (0, path.dirname)(path$1);
	let depth = 1;
	while (parent !== state.root && depth < 2) {
		const resolvedPath = state.symlinks.get(parent);
		const isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
		if (isSameRoot) depth++;
		else parent = (0, path.dirname)(parent);
	}
	state.symlinks.set(path$1, resolved);
	return depth > 1;
}
function isRecursiveUsingRealPaths(resolved, state) {
	return state.visited.includes(resolved + state.options.pathSeparator);
}

//#endregion
//#region src/api/functions/invoke-callback.ts
const onlyCountsSync = (state) => {
	return state.counts;
};
const groupsSync = (state) => {
	return state.groups;
};
const defaultSync = (state) => {
	return state.paths;
};
const limitFilesSync = (state) => {
	return state.paths.slice(0, state.options.maxFiles);
};
const onlyCountsAsync = (state, error, callback$1) => {
	report(error, callback$1, state.counts, state.options.suppressErrors);
	return null;
};
const defaultAsync = (state, error, callback$1) => {
	report(error, callback$1, state.paths, state.options.suppressErrors);
	return null;
};
const limitFilesAsync = (state, error, callback$1) => {
	report(error, callback$1, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
	return null;
};
const groupsAsync = (state, error, callback$1) => {
	report(error, callback$1, state.groups, state.options.suppressErrors);
	return null;
};
function report(error, callback$1, output, suppressErrors) {
	if (error && !suppressErrors) callback$1(error, output);
	else callback$1(null, output);
}
function build$1(options, isSynchronous) {
	const { onlyCounts, group, maxFiles } = options;
	if (onlyCounts) return isSynchronous ? onlyCountsSync : onlyCountsAsync;
	else if (group) return isSynchronous ? groupsSync : groupsAsync;
	else if (maxFiles) return isSynchronous ? limitFilesSync : limitFilesAsync;
	else return isSynchronous ? defaultSync : defaultAsync;
}

//#endregion
//#region src/api/functions/walk-directory.ts
const readdirOpts = { withFileTypes: true };
const walkAsync = (state, crawlPath, directoryPath, currentDepth, callback$1) => {
	state.queue.enqueue();
	if (currentDepth < 0) return state.queue.dequeue(null, state);
	const { fs: fs$1 } = state;
	state.visited.push(crawlPath);
	state.counts.directories++;
	fs$1.readdir(crawlPath || ".", readdirOpts, (error, entries = []) => {
		callback$1(entries, directoryPath, currentDepth);
		state.queue.dequeue(state.options.suppressErrors ? null : error, state);
	});
};
const walkSync = (state, crawlPath, directoryPath, currentDepth, callback$1) => {
	const { fs: fs$1 } = state;
	if (currentDepth < 0) return;
	state.visited.push(crawlPath);
	state.counts.directories++;
	let entries = [];
	try {
		entries = fs$1.readdirSync(crawlPath || ".", readdirOpts);
	} catch (e) {
		if (!state.options.suppressErrors) throw e;
	}
	callback$1(entries, directoryPath, currentDepth);
};
function build(isSynchronous) {
	return isSynchronous ? walkSync : walkAsync;
}

//#endregion
//#region src/api/queue.ts
/**
* This is a custom stateless queue to track concurrent async fs calls.
* It increments a counter whenever a call is queued and decrements it
* as soon as it completes. When the counter hits 0, it calls onQueueEmpty.
*/
var Queue = class {
	count = 0;
	constructor(onQueueEmpty) {
		this.onQueueEmpty = onQueueEmpty;
	}
	enqueue() {
		this.count++;
		return this.count;
	}
	dequeue(error, output) {
		if (this.onQueueEmpty && (--this.count <= 0 || error)) {
			this.onQueueEmpty(error, output);
			if (error) {
				output.controller.abort();
				this.onQueueEmpty = void 0;
			}
		}
	}
};

//#endregion
//#region src/api/counter.ts
var Counter = class {
	_files = 0;
	_directories = 0;
	set files(num) {
		this._files = num;
	}
	get files() {
		return this._files;
	}
	set directories(num) {
		this._directories = num;
	}
	get directories() {
		return this._directories;
	}
	/**
	* @deprecated use `directories` instead
	*/
	/* c8 ignore next 3 */
	get dirs() {
		return this._directories;
	}
};

//#endregion
//#region src/api/aborter.ts
/**
* AbortController is not supported on Node 14 so we use this until we can drop
* support for Node 14.
*/
var Aborter = class {
	aborted = false;
	abort() {
		this.aborted = true;
	}
};

//#endregion
//#region src/api/walker.ts
var Walker = class {
	root;
	isSynchronous;
	state;
	joinPath;
	pushDirectory;
	pushFile;
	getArray;
	groupFiles;
	resolveSymlink;
	walkDirectory;
	callbackInvoker;
	constructor(root, options, callback$1) {
		this.isSynchronous = !callback$1;
		this.callbackInvoker = build$1(options, this.isSynchronous);
		this.root = normalizePath(root, options);
		this.state = {
			root: isRootDirectory(this.root) ? this.root : this.root.slice(0, -1),
			paths: [""].slice(0, 0),
			groups: [],
			counts: new Counter(),
			options,
			queue: new Queue((error, state) => this.callbackInvoker(state, error, callback$1)),
			symlinks: /* @__PURE__ */ new Map(),
			visited: [""].slice(0, 0),
			controller: new Aborter(),
			fs: options.fs || fs
		};
		this.joinPath = build$7(this.root, options);
		this.pushDirectory = build$6(this.root, options);
		this.pushFile = build$5(options);
		this.getArray = build$4(options);
		this.groupFiles = build$3(options);
		this.resolveSymlink = build$2(options, this.isSynchronous);
		this.walkDirectory = build(this.isSynchronous);
	}
	start() {
		this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
		this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
		return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
	}
	walk = (entries, directoryPath, depth) => {
		const { paths, options: { filters, resolveSymlinks: resolveSymlinks$1, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator }, controller } = this.state;
		if (controller.aborted || signal && signal.aborted || maxFiles && paths.length > maxFiles) return;
		const files = this.getArray(this.state.paths);
		for (let i = 0; i < entries.length; ++i) {
			const entry = entries[i];
			if (entry.isFile() || entry.isSymbolicLink() && !resolveSymlinks$1 && !excludeSymlinks) {
				const filename = this.joinPath(entry.name, directoryPath);
				this.pushFile(filename, files, this.state.counts, filters);
			} else if (entry.isDirectory()) {
				let path$1 = joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
				if (exclude && exclude(entry.name, path$1)) continue;
				this.pushDirectory(path$1, paths, filters);
				this.walkDirectory(this.state, path$1, path$1, depth - 1, this.walk);
			} else if (this.resolveSymlink && entry.isSymbolicLink()) {
				let path$1 = joinPathWithBasePath(entry.name, directoryPath);
				this.resolveSymlink(path$1, this.state, (stat, resolvedPath) => {
					if (stat.isDirectory()) {
						resolvedPath = normalizePath(resolvedPath, this.state.options);
						if (exclude && exclude(entry.name, useRealPaths ? resolvedPath : path$1 + pathSeparator)) return;
						this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path$1 + pathSeparator, depth - 1, this.walk);
					} else {
						resolvedPath = useRealPaths ? resolvedPath : path$1;
						const filename = (0, path.basename)(resolvedPath);
						const directoryPath$1 = normalizePath((0, path.dirname)(resolvedPath), this.state.options);
						resolvedPath = this.joinPath(filename, directoryPath$1);
						this.pushFile(resolvedPath, files, this.state.counts, filters);
					}
				});
			}
		}
		this.groupFiles(this.state.groups, directoryPath, files);
	};
};

//#endregion
//#region src/api/async.ts
function promise(root, options) {
	return new Promise((resolve$1, reject) => {
		callback(root, options, (err, output) => {
			if (err) return reject(err);
			resolve$1(output);
		});
	});
}
function callback(root, options, callback$1) {
	let walker = new Walker(root, options, callback$1);
	walker.start();
}

//#endregion
//#region src/api/sync.ts
function sync(root, options) {
	const walker = new Walker(root, options);
	return walker.start();
}

//#endregion
//#region src/builder/api-builder.ts
var APIBuilder = class {
	constructor(root, options) {
		this.root = root;
		this.options = options;
	}
	withPromise() {
		return promise(this.root, this.options);
	}
	withCallback(cb) {
		callback(this.root, this.options, cb);
	}
	sync() {
		return sync(this.root, this.options);
	}
};

//#endregion
//#region src/builder/index.ts
let pm = null;
/* c8 ignore next 6 */
try {
	require.resolve("picomatch");
	pm = require("picomatch");
} catch {}
var Builder = class {
	globCache = {};
	options = {
		maxDepth: Infinity,
		suppressErrors: true,
		pathSeparator: path.sep,
		filters: []
	};
	globFunction;
	constructor(options) {
		this.options = {
			...this.options,
			...options
		};
		this.globFunction = this.options.globFunction;
	}
	group() {
		this.options.group = true;
		return this;
	}
	withPathSeparator(separator) {
		this.options.pathSeparator = separator;
		return this;
	}
	withBasePath() {
		this.options.includeBasePath = true;
		return this;
	}
	withRelativePaths() {
		this.options.relativePaths = true;
		return this;
	}
	withDirs() {
		this.options.includeDirs = true;
		return this;
	}
	withMaxDepth(depth) {
		this.options.maxDepth = depth;
		return this;
	}
	withMaxFiles(limit) {
		this.options.maxFiles = limit;
		return this;
	}
	withFullPaths() {
		this.options.resolvePaths = true;
		this.options.includeBasePath = true;
		return this;
	}
	withErrors() {
		this.options.suppressErrors = false;
		return this;
	}
	withSymlinks({ resolvePaths = true } = {}) {
		this.options.resolveSymlinks = true;
		this.options.useRealPaths = resolvePaths;
		return this.withFullPaths();
	}
	withAbortSignal(signal) {
		this.options.signal = signal;
		return this;
	}
	normalize() {
		this.options.normalizePath = true;
		return this;
	}
	filter(predicate) {
		this.options.filters.push(predicate);
		return this;
	}
	onlyDirs() {
		this.options.excludeFiles = true;
		this.options.includeDirs = true;
		return this;
	}
	exclude(predicate) {
		this.options.exclude = predicate;
		return this;
	}
	onlyCounts() {
		this.options.onlyCounts = true;
		return this;
	}
	crawl(root) {
		return new APIBuilder(root || ".", this.options);
	}
	withGlobFunction(fn) {
		this.globFunction = fn;
		return this;
	}
	/**
	* @deprecated Pass options using the constructor instead:
	* ```ts
	* new fdir(options).crawl("/path/to/root");
	* ```
	* This method will be removed in v7.0
	*/
	/* c8 ignore next 4 */
	crawlWithOptions(root, options) {
		this.options = {
			...this.options,
			...options
		};
		return new APIBuilder(root || ".", this.options);
	}
	glob(...patterns) {
		if (this.globFunction) return this.globWithOptions(patterns);
		return this.globWithOptions(patterns, ...[{ dot: true }]);
	}
	globWithOptions(patterns, ...options) {
		const globFn = this.globFunction || pm;
		/* c8 ignore next 5 */
		if (!globFn) throw new Error("Please specify a glob function to use glob matching.");
		var isMatch = this.globCache[patterns.join("\0")];
		if (!isMatch) {
			isMatch = globFn(patterns, ...options);
			this.globCache[patterns.join("\0")] = isMatch;
		}
		this.options.filters.push((path$1) => isMatch(path$1));
		return this;
	}
};

//#endregion
exports.fdir = Builder;
~~~

## node_modules\fdir\dist\index.d.cts

~~~cts
/// <reference types="node" />
import * as nativeFs from "fs";
import picomatch from "picomatch";

//#region src/api/aborter.d.ts
/**
 * AbortController is not supported on Node 14 so we use this until we can drop
 * support for Node 14.
 */
declare class Aborter {
  aborted: boolean;
  abort(): void;
}
//#endregion
//#region src/api/queue.d.ts
type OnQueueEmptyCallback = (error: Error | null, output: WalkerState) => void;
/**
 * This is a custom stateless queue to track concurrent async fs calls.
 * It increments a counter whenever a call is queued and decrements it
 * as soon as it completes. When the counter hits 0, it calls onQueueEmpty.
 */
declare class Queue {
  private onQueueEmpty?;
  count: number;
  constructor(onQueueEmpty?: OnQueueEmptyCallback | undefined);
  enqueue(): number;
  dequeue(error: Error | null, output: WalkerState): void;
}
//#endregion
//#region src/types.d.ts
type Counts = {
  files: number;
  directories: number;
  /**
   * @deprecated use `directories` instead. Will be removed in v7.0.
   */
  dirs: number;
};
type Group = {
  directory: string;
  files: string[];
  /**
   * @deprecated use `directory` instead. Will be removed in v7.0.
   */
  dir: string;
};
type GroupOutput = Group[];
type OnlyCountsOutput = Counts;
type PathsOutput = string[];
type Output = OnlyCountsOutput | PathsOutput | GroupOutput;
type FSLike = {
  readdir: typeof nativeFs.readdir;
  readdirSync: typeof nativeFs.readdirSync;
  realpath: typeof nativeFs.realpath;
  realpathSync: typeof nativeFs.realpathSync;
  stat: typeof nativeFs.stat;
  statSync: typeof nativeFs.statSync;
};
type WalkerState = {
  root: string;
  paths: string[];
  groups: Group[];
  counts: Counts;
  options: Options;
  queue: Queue;
  controller: Aborter;
  fs: FSLike;
  symlinks: Map<string, string>;
  visited: string[];
};
type ResultCallback<TOutput extends Output> = (error: Error | null, output: TOutput) => void;
type FilterPredicate = (path: string, isDirectory: boolean) => boolean;
type ExcludePredicate = (dirName: string, dirPath: string) => boolean;
type PathSeparator = "/" | "\\";
type Options<TGlobFunction = unknown> = {
  includeBasePath?: boolean;
  includeDirs?: boolean;
  normalizePath?: boolean;
  maxDepth: number;
  maxFiles?: number;
  resolvePaths?: boolean;
  suppressErrors: boolean;
  group?: boolean;
  onlyCounts?: boolean;
  filters: FilterPredicate[];
  resolveSymlinks?: boolean;
  useRealPaths?: boolean;
  excludeFiles?: boolean;
  excludeSymlinks?: boolean;
  exclude?: ExcludePredicate;
  relativePaths?: boolean;
  pathSeparator: PathSeparator;
  signal?: AbortSignal;
  globFunction?: TGlobFunction;
  fs?: FSLike;
};
type GlobMatcher = (test: string) => boolean;
type GlobFunction = (glob: string | string[], ...params: unknown[]) => GlobMatcher;
type GlobParams<T> = T extends ((globs: string | string[], ...params: infer TParams extends unknown[]) => GlobMatcher) ? TParams : [];
//#endregion
//#region src/builder/api-builder.d.ts
declare class APIBuilder<TReturnType extends Output> {
  private readonly root;
  private readonly options;
  constructor(root: string, options: Options);
  withPromise(): Promise<TReturnType>;
  withCallback(cb: ResultCallback<TReturnType>): void;
  sync(): TReturnType;
}
//#endregion
//#region src/builder/index.d.ts
declare class Builder<TReturnType extends Output = PathsOutput, TGlobFunction = typeof picomatch> {
  private readonly globCache;
  private options;
  private globFunction?;
  constructor(options?: Partial<Options<TGlobFunction>>);
  group(): Builder<GroupOutput, TGlobFunction>;
  withPathSeparator(separator: "/" | "\\"): this;
  withBasePath(): this;
  withRelativePaths(): this;
  withDirs(): this;
  withMaxDepth(depth: number): this;
  withMaxFiles(limit: number): this;
  withFullPaths(): this;
  withErrors(): this;
  withSymlinks({
    resolvePaths
  }?: {
    resolvePaths?: boolean | undefined;
  }): this;
  withAbortSignal(signal: AbortSignal): this;
  normalize(): this;
  filter(predicate: FilterPredicate): this;
  onlyDirs(): this;
  exclude(predicate: ExcludePredicate): this;
  onlyCounts(): Builder<OnlyCountsOutput, TGlobFunction>;
  crawl(root?: string): APIBuilder<TReturnType>;
  withGlobFunction<TFunc>(fn: TFunc): Builder<TReturnType, TFunc>;
  /**
   * @deprecated Pass options using the constructor instead:
   * ```ts
   * new fdir(options).crawl("/path/to/root");
   * ```
   * This method will be removed in v7.0
   */
  crawlWithOptions(root: string, options: Partial<Options<TGlobFunction>>): APIBuilder<TReturnType>;
  glob(...patterns: string[]): Builder<TReturnType, TGlobFunction>;
  globWithOptions(patterns: string[]): Builder<TReturnType, TGlobFunction>;
  globWithOptions(patterns: string[], ...options: GlobParams<TGlobFunction>): Builder<TReturnType, TGlobFunction>;
}
//#endregion
//#region src/index.d.ts
type Fdir = typeof Builder;
//#endregion
export { Counts, ExcludePredicate, FSLike, Fdir, FilterPredicate, GlobFunction, GlobMatcher, GlobParams, Group, GroupOutput, OnlyCountsOutput, Options, Output, PathSeparator, PathsOutput, ResultCallback, WalkerState, Builder as fdir };
~~~

## node_modules\fdir\dist\index.d.mts

~~~mts
/// <reference types="node" />
import * as nativeFs from "fs";
import picomatch from "picomatch";

//#region src/api/aborter.d.ts
/**
 * AbortController is not supported on Node 14 so we use this until we can drop
 * support for Node 14.
 */
declare class Aborter {
  aborted: boolean;
  abort(): void;
}
//#endregion
//#region src/api/queue.d.ts
type OnQueueEmptyCallback = (error: Error | null, output: WalkerState) => void;
/**
 * This is a custom stateless queue to track concurrent async fs calls.
 * It increments a counter whenever a call is queued and decrements it
 * as soon as it completes. When the counter hits 0, it calls onQueueEmpty.
 */
declare class Queue {
  private onQueueEmpty?;
  count: number;
  constructor(onQueueEmpty?: OnQueueEmptyCallback | undefined);
  enqueue(): number;
  dequeue(error: Error | null, output: WalkerState): void;
}
//#endregion
//#region src/types.d.ts
type Counts = {
  files: number;
  directories: number;
  /**
   * @deprecated use `directories` instead. Will be removed in v7.0.
   */
  dirs: number;
};
type Group = {
  directory: string;
  files: string[];
  /**
   * @deprecated use `directory` instead. Will be removed in v7.0.
   */
  dir: string;
};
type GroupOutput = Group[];
type OnlyCountsOutput = Counts;
type PathsOutput = string[];
type Output = OnlyCountsOutput | PathsOutput | GroupOutput;
type FSLike = {
  readdir: typeof nativeFs.readdir;
  readdirSync: typeof nativeFs.readdirSync;
  realpath: typeof nativeFs.realpath;
  realpathSync: typeof nativeFs.realpathSync;
  stat: typeof nativeFs.stat;
  statSync: typeof nativeFs.statSync;
};
type WalkerState = {
  root: string;
  paths: string[];
  groups: Group[];
  counts: Counts;
  options: Options;
  queue: Queue;
  controller: Aborter;
  fs: FSLike;
  symlinks: Map<string, string>;
  visited: string[];
};
type ResultCallback<TOutput extends Output> = (error: Error | null, output: TOutput) => void;
type FilterPredicate = (path: string, isDirectory: boolean) => boolean;
type ExcludePredicate = (dirName: string, dirPath: string) => boolean;
type PathSeparator = "/" | "\\";
type Options<TGlobFunction = unknown> = {
  includeBasePath?: boolean;
  includeDirs?: boolean;
  normalizePath?: boolean;
  maxDepth: number;
  maxFiles?: number;
  resolvePaths?: boolean;
  suppressErrors: boolean;
  group?: boolean;
  onlyCounts?: boolean;
  filters: FilterPredicate[];
  resolveSymlinks?: boolean;
  useRealPaths?: boolean;
  excludeFiles?: boolean;
  excludeSymlinks?: boolean;
  exclude?: ExcludePredicate;
  relativePaths?: boolean;
  pathSeparator: PathSeparator;
  signal?: AbortSignal;
  globFunction?: TGlobFunction;
  fs?: FSLike;
};
type GlobMatcher = (test: string) => boolean;
type GlobFunction = (glob: string | string[], ...params: unknown[]) => GlobMatcher;
type GlobParams<T> = T extends ((globs: string | string[], ...params: infer TParams extends unknown[]) => GlobMatcher) ? TParams : [];
//#endregion
//#region src/builder/api-builder.d.ts
declare class APIBuilder<TReturnType extends Output> {
  private readonly root;
  private readonly options;
  constructor(root: string, options: Options);
  withPromise(): Promise<TReturnType>;
  withCallback(cb: ResultCallback<TReturnType>): void;
  sync(): TReturnType;
}
//#endregion
//#region src/builder/index.d.ts
declare class Builder<TReturnType extends Output = PathsOutput, TGlobFunction = typeof picomatch> {
  private readonly globCache;
  private options;
  private globFunction?;
  constructor(options?: Partial<Options<TGlobFunction>>);
  group(): Builder<GroupOutput, TGlobFunction>;
  withPathSeparator(separator: "/" | "\\"): this;
  withBasePath(): this;
  withRelativePaths(): this;
  withDirs(): this;
  withMaxDepth(depth: number): this;
  withMaxFiles(limit: number): this;
  withFullPaths(): this;
  withErrors(): this;
  withSymlinks({
    resolvePaths
  }?: {
    resolvePaths?: boolean | undefined;
  }): this;
  withAbortSignal(signal: AbortSignal): this;
  normalize(): this;
  filter(predicate: FilterPredicate): this;
  onlyDirs(): this;
  exclude(predicate: ExcludePredicate): this;
  onlyCounts(): Builder<OnlyCountsOutput, TGlobFunction>;
  crawl(root?: string): APIBuilder<TReturnType>;
  withGlobFunction<TFunc>(fn: TFunc): Builder<TReturnType, TFunc>;
  /**
   * @deprecated Pass options using the constructor instead:
   * ```ts
   * new fdir(options).crawl("/path/to/root");
   * ```
   * This method will be removed in v7.0
   */
  crawlWithOptions(root: string, options: Partial<Options<TGlobFunction>>): APIBuilder<TReturnType>;
  glob(...patterns: string[]): Builder<TReturnType, TGlobFunction>;
  globWithOptions(patterns: string[]): Builder<TReturnType, TGlobFunction>;
  globWithOptions(patterns: string[], ...options: GlobParams<TGlobFunction>): Builder<TReturnType, TGlobFunction>;
}
//#endregion
//#region src/index.d.ts
type Fdir = typeof Builder;
//#endregion
export { Counts, ExcludePredicate, FSLike, Fdir, FilterPredicate, GlobFunction, GlobMatcher, GlobParams, Group, GroupOutput, OnlyCountsOutput, Options, Output, PathSeparator, PathsOutput, ResultCallback, WalkerState, Builder as fdir };
~~~

## node_modules\fdir\dist\index.mjs

~~~mjs
import { createRequire } from "module";
import { basename, dirname, normalize, relative, resolve, sep } from "path";
import * as nativeFs from "fs";

//#region rolldown:runtime
var __require = /* @__PURE__ */ createRequire(import.meta.url);

//#endregion
//#region src/utils.ts
function cleanPath(path) {
	let normalized = normalize(path);
	if (normalized.length > 1 && normalized[normalized.length - 1] === sep) normalized = normalized.substring(0, normalized.length - 1);
	return normalized;
}
const SLASHES_REGEX = /[\\/]/g;
function convertSlashes(path, separator) {
	return path.replace(SLASHES_REGEX, separator);
}
const WINDOWS_ROOT_DIR_REGEX = /^[a-z]:[\\/]$/i;
function isRootDirectory(path) {
	return path === "/" || WINDOWS_ROOT_DIR_REGEX.test(path);
}
function normalizePath(path, options) {
	const { resolvePaths, normalizePath: normalizePath$1, pathSeparator } = options;
	const pathNeedsCleaning = process.platform === "win32" && path.includes("/") || path.startsWith(".");
	if (resolvePaths) path = resolve(path);
	if (normalizePath$1 || pathNeedsCleaning) path = cleanPath(path);
	if (path === ".") return "";
	const needsSeperator = path[path.length - 1] !== pathSeparator;
	return convertSlashes(needsSeperator ? path + pathSeparator : path, pathSeparator);
}

//#endregion
//#region src/api/functions/join-path.ts
function joinPathWithBasePath(filename, directoryPath) {
	return directoryPath + filename;
}
function joinPathWithRelativePath(root, options) {
	return function(filename, directoryPath) {
		const sameRoot = directoryPath.startsWith(root);
		if (sameRoot) return directoryPath.slice(root.length) + filename;
		else return convertSlashes(relative(root, directoryPath), options.pathSeparator) + options.pathSeparator + filename;
	};
}
function joinPath(filename) {
	return filename;
}
function joinDirectoryPath(filename, directoryPath, separator) {
	return directoryPath + filename + separator;
}
function build$7(root, options) {
	const { relativePaths, includeBasePath } = options;
	return relativePaths && root ? joinPathWithRelativePath(root, options) : includeBasePath ? joinPathWithBasePath : joinPath;
}

//#endregion
//#region src/api/functions/push-directory.ts
function pushDirectoryWithRelativePath(root) {
	return function(directoryPath, paths) {
		paths.push(directoryPath.substring(root.length) || ".");
	};
}
function pushDirectoryFilterWithRelativePath(root) {
	return function(directoryPath, paths, filters) {
		const relativePath = directoryPath.substring(root.length) || ".";
		if (filters.every((filter) => filter(relativePath, true))) paths.push(relativePath);
	};
}
const pushDirectory = (directoryPath, paths) => {
	paths.push(directoryPath || ".");
};
const pushDirectoryFilter = (directoryPath, paths, filters) => {
	const path = directoryPath || ".";
	if (filters.every((filter) => filter(path, true))) paths.push(path);
};
const empty$2 = () => {};
function build$6(root, options) {
	const { includeDirs, filters, relativePaths } = options;
	if (!includeDirs) return empty$2;
	if (relativePaths) return filters && filters.length ? pushDirectoryFilterWithRelativePath(root) : pushDirectoryWithRelativePath(root);
	return filters && filters.length ? pushDirectoryFilter : pushDirectory;
}

//#endregion
//#region src/api/functions/push-file.ts
const pushFileFilterAndCount = (filename, _paths, counts, filters) => {
	if (filters.every((filter) => filter(filename, false))) counts.files++;
};
const pushFileFilter = (filename, paths, _counts, filters) => {
	if (filters.every((filter) => filter(filename, false))) paths.push(filename);
};
const pushFileCount = (_filename, _paths, counts, _filters) => {
	counts.files++;
};
const pushFile = (filename, paths) => {
	paths.push(filename);
};
const empty$1 = () => {};
function build$5(options) {
	const { excludeFiles, filters, onlyCounts } = options;
	if (excludeFiles) return empty$1;
	if (filters && filters.length) return onlyCounts ? pushFileFilterAndCount : pushFileFilter;
	else if (onlyCounts) return pushFileCount;
	else return pushFile;
}

//#endregion
//#region src/api/functions/get-array.ts
const getArray = (paths) => {
	return paths;
};
const getArrayGroup = () => {
	return [""].slice(0, 0);
};
function build$4(options) {
	return options.group ? getArrayGroup : getArray;
}

//#endregion
//#region src/api/functions/group-files.ts
const groupFiles = (groups, directory, files) => {
	groups.push({
		directory,
		files,
		dir: directory
	});
};
const empty = () => {};
function build$3(options) {
	return options.group ? groupFiles : empty;
}

//#endregion
//#region src/api/functions/resolve-symlink.ts
const resolveSymlinksAsync = function(path, state, callback$1) {
	const { queue, fs, options: { suppressErrors } } = state;
	queue.enqueue();
	fs.realpath(path, (error, resolvedPath) => {
		if (error) return queue.dequeue(suppressErrors ? null : error, state);
		fs.stat(resolvedPath, (error$1, stat) => {
			if (error$1) return queue.dequeue(suppressErrors ? null : error$1, state);
			if (stat.isDirectory() && isRecursive(path, resolvedPath, state)) return queue.dequeue(null, state);
			callback$1(stat, resolvedPath);
			queue.dequeue(null, state);
		});
	});
};
const resolveSymlinks = function(path, state, callback$1) {
	const { queue, fs, options: { suppressErrors } } = state;
	queue.enqueue();
	try {
		const resolvedPath = fs.realpathSync(path);
		const stat = fs.statSync(resolvedPath);
		if (stat.isDirectory() && isRecursive(path, resolvedPath, state)) return;
		callback$1(stat, resolvedPath);
	} catch (e) {
		if (!suppressErrors) throw e;
	}
};
function build$2(options, isSynchronous) {
	if (!options.resolveSymlinks || options.excludeSymlinks) return null;
	return isSynchronous ? resolveSymlinks : resolveSymlinksAsync;
}
function isRecursive(path, resolved, state) {
	if (state.options.useRealPaths) return isRecursiveUsingRealPaths(resolved, state);
	let parent = dirname(path);
	let depth = 1;
	while (parent !== state.root && depth < 2) {
		const resolvedPath = state.symlinks.get(parent);
		const isSameRoot = !!resolvedPath && (resolvedPath === resolved || resolvedPath.startsWith(resolved) || resolved.startsWith(resolvedPath));
		if (isSameRoot) depth++;
		else parent = dirname(parent);
	}
	state.symlinks.set(path, resolved);
	return depth > 1;
}
function isRecursiveUsingRealPaths(resolved, state) {
	return state.visited.includes(resolved + state.options.pathSeparator);
}

//#endregion
//#region src/api/functions/invoke-callback.ts
const onlyCountsSync = (state) => {
	return state.counts;
};
const groupsSync = (state) => {
	return state.groups;
};
const defaultSync = (state) => {
	return state.paths;
};
const limitFilesSync = (state) => {
	return state.paths.slice(0, state.options.maxFiles);
};
const onlyCountsAsync = (state, error, callback$1) => {
	report(error, callback$1, state.counts, state.options.suppressErrors);
	return null;
};
const defaultAsync = (state, error, callback$1) => {
	report(error, callback$1, state.paths, state.options.suppressErrors);
	return null;
};
const limitFilesAsync = (state, error, callback$1) => {
	report(error, callback$1, state.paths.slice(0, state.options.maxFiles), state.options.suppressErrors);
	return null;
};
const groupsAsync = (state, error, callback$1) => {
	report(error, callback$1, state.groups, state.options.suppressErrors);
	return null;
};
function report(error, callback$1, output, suppressErrors) {
	if (error && !suppressErrors) callback$1(error, output);
	else callback$1(null, output);
}
function build$1(options, isSynchronous) {
	const { onlyCounts, group, maxFiles } = options;
	if (onlyCounts) return isSynchronous ? onlyCountsSync : onlyCountsAsync;
	else if (group) return isSynchronous ? groupsSync : groupsAsync;
	else if (maxFiles) return isSynchronous ? limitFilesSync : limitFilesAsync;
	else return isSynchronous ? defaultSync : defaultAsync;
}

//#endregion
//#region src/api/functions/walk-directory.ts
const readdirOpts = { withFileTypes: true };
const walkAsync = (state, crawlPath, directoryPath, currentDepth, callback$1) => {
	state.queue.enqueue();
	if (currentDepth < 0) return state.queue.dequeue(null, state);
	const { fs } = state;
	state.visited.push(crawlPath);
	state.counts.directories++;
	fs.readdir(crawlPath || ".", readdirOpts, (error, entries = []) => {
		callback$1(entries, directoryPath, currentDepth);
		state.queue.dequeue(state.options.suppressErrors ? null : error, state);
	});
};
const walkSync = (state, crawlPath, directoryPath, currentDepth, callback$1) => {
	const { fs } = state;
	if (currentDepth < 0) return;
	state.visited.push(crawlPath);
	state.counts.directories++;
	let entries = [];
	try {
		entries = fs.readdirSync(crawlPath || ".", readdirOpts);
	} catch (e) {
		if (!state.options.suppressErrors) throw e;
	}
	callback$1(entries, directoryPath, currentDepth);
};
function build(isSynchronous) {
	return isSynchronous ? walkSync : walkAsync;
}

//#endregion
//#region src/api/queue.ts
/**
* This is a custom stateless queue to track concurrent async fs calls.
* It increments a counter whenever a call is queued and decrements it
* as soon as it completes. When the counter hits 0, it calls onQueueEmpty.
*/
var Queue = class {
	count = 0;
	constructor(onQueueEmpty) {
		this.onQueueEmpty = onQueueEmpty;
	}
	enqueue() {
		this.count++;
		return this.count;
	}
	dequeue(error, output) {
		if (this.onQueueEmpty && (--this.count <= 0 || error)) {
			this.onQueueEmpty(error, output);
			if (error) {
				output.controller.abort();
				this.onQueueEmpty = void 0;
			}
		}
	}
};

//#endregion
//#region src/api/counter.ts
var Counter = class {
	_files = 0;
	_directories = 0;
	set files(num) {
		this._files = num;
	}
	get files() {
		return this._files;
	}
	set directories(num) {
		this._directories = num;
	}
	get directories() {
		return this._directories;
	}
	/**
	* @deprecated use `directories` instead
	*/
	/* c8 ignore next 3 */
	get dirs() {
		return this._directories;
	}
};

//#endregion
//#region src/api/aborter.ts
/**
* AbortController is not supported on Node 14 so we use this until we can drop
* support for Node 14.
*/
var Aborter = class {
	aborted = false;
	abort() {
		this.aborted = true;
	}
};

//#endregion
//#region src/api/walker.ts
var Walker = class {
	root;
	isSynchronous;
	state;
	joinPath;
	pushDirectory;
	pushFile;
	getArray;
	groupFiles;
	resolveSymlink;
	walkDirectory;
	callbackInvoker;
	constructor(root, options, callback$1) {
		this.isSynchronous = !callback$1;
		this.callbackInvoker = build$1(options, this.isSynchronous);
		this.root = normalizePath(root, options);
		this.state = {
			root: isRootDirectory(this.root) ? this.root : this.root.slice(0, -1),
			paths: [""].slice(0, 0),
			groups: [],
			counts: new Counter(),
			options,
			queue: new Queue((error, state) => this.callbackInvoker(state, error, callback$1)),
			symlinks: /* @__PURE__ */ new Map(),
			visited: [""].slice(0, 0),
			controller: new Aborter(),
			fs: options.fs || nativeFs
		};
		this.joinPath = build$7(this.root, options);
		this.pushDirectory = build$6(this.root, options);
		this.pushFile = build$5(options);
		this.getArray = build$4(options);
		this.groupFiles = build$3(options);
		this.resolveSymlink = build$2(options, this.isSynchronous);
		this.walkDirectory = build(this.isSynchronous);
	}
	start() {
		this.pushDirectory(this.root, this.state.paths, this.state.options.filters);
		this.walkDirectory(this.state, this.root, this.root, this.state.options.maxDepth, this.walk);
		return this.isSynchronous ? this.callbackInvoker(this.state, null) : null;
	}
	walk = (entries, directoryPath, depth) => {
		const { paths, options: { filters, resolveSymlinks: resolveSymlinks$1, excludeSymlinks, exclude, maxFiles, signal, useRealPaths, pathSeparator }, controller } = this.state;
		if (controller.aborted || signal && signal.aborted || maxFiles && paths.length > maxFiles) return;
		const files = this.getArray(this.state.paths);
		for (let i = 0; i < entries.length; ++i) {
			const entry = entries[i];
			if (entry.isFile() || entry.isSymbolicLink() && !resolveSymlinks$1 && !excludeSymlinks) {
				const filename = this.joinPath(entry.name, directoryPath);
				this.pushFile(filename, files, this.state.counts, filters);
			} else if (entry.isDirectory()) {
				let path = joinDirectoryPath(entry.name, directoryPath, this.state.options.pathSeparator);
				if (exclude && exclude(entry.name, path)) continue;
				this.pushDirectory(path, paths, filters);
				this.walkDirectory(this.state, path, path, depth - 1, this.walk);
			} else if (this.resolveSymlink && entry.isSymbolicLink()) {
				let path = joinPathWithBasePath(entry.name, directoryPath);
				this.resolveSymlink(path, this.state, (stat, resolvedPath) => {
					if (stat.isDirectory()) {
						resolvedPath = normalizePath(resolvedPath, this.state.options);
						if (exclude && exclude(entry.name, useRealPaths ? resolvedPath : path + pathSeparator)) return;
						this.walkDirectory(this.state, resolvedPath, useRealPaths ? resolvedPath : path + pathSeparator, depth - 1, this.walk);
					} else {
						resolvedPath = useRealPaths ? resolvedPath : path;
						const filename = basename(resolvedPath);
						const directoryPath$1 = normalizePath(dirname(resolvedPath), this.state.options);
						resolvedPath = this.joinPath(filename, directoryPath$1);
						this.pushFile(resolvedPath, files, this.state.counts, filters);
					}
				});
			}
		}
		this.groupFiles(this.state.groups, directoryPath, files);
	};
};

//#endregion
//#region src/api/async.ts
function promise(root, options) {
	return new Promise((resolve$1, reject) => {
		callback(root, options, (err, output) => {
			if (err) return reject(err);
			resolve$1(output);
		});
	});
}
function callback(root, options, callback$1) {
	let walker = new Walker(root, options, callback$1);
	walker.start();
}

//#endregion
//#region src/api/sync.ts
function sync(root, options) {
	const walker = new Walker(root, options);
	return walker.start();
}

//#endregion
//#region src/builder/api-builder.ts
var APIBuilder = class {
	constructor(root, options) {
		this.root = root;
		this.options = options;
	}
	withPromise() {
		return promise(this.root, this.options);
	}
	withCallback(cb) {
		callback(this.root, this.options, cb);
	}
	sync() {
		return sync(this.root, this.options);
	}
};

//#endregion
//#region src/builder/index.ts
let pm = null;
/* c8 ignore next 6 */
try {
	__require.resolve("picomatch");
	pm = __require("picomatch");
} catch {}
var Builder = class {
	globCache = {};
	options = {
		maxDepth: Infinity,
		suppressErrors: true,
		pathSeparator: sep,
		filters: []
	};
	globFunction;
	constructor(options) {
		this.options = {
			...this.options,
			...options
		};
		this.globFunction = this.options.globFunction;
	}
	group() {
		this.options.group = true;
		return this;
	}
	withPathSeparator(separator) {
		this.options.pathSeparator = separator;
		return this;
	}
	withBasePath() {
		this.options.includeBasePath = true;
		return this;
	}
	withRelativePaths() {
		this.options.relativePaths = true;
		return this;
	}
	withDirs() {
		this.options.includeDirs = true;
		return this;
	}
	withMaxDepth(depth) {
		this.options.maxDepth = depth;
		return this;
	}
	withMaxFiles(limit) {
		this.options.maxFiles = limit;
		return this;
	}
	withFullPaths() {
		this.options.resolvePaths = true;
		this.options.includeBasePath = true;
		return this;
	}
	withErrors() {
		this.options.suppressErrors = false;
		return this;
	}
	withSymlinks({ resolvePaths = true } = {}) {
		this.options.resolveSymlinks = true;
		this.options.useRealPaths = resolvePaths;
		return this.withFullPaths();
	}
	withAbortSignal(signal) {
		this.options.signal = signal;
		return this;
	}
	normalize() {
		this.options.normalizePath = true;
		return this;
	}
	filter(predicate) {
		this.options.filters.push(predicate);
		return this;
	}
	onlyDirs() {
		this.options.excludeFiles = true;
		this.options.includeDirs = true;
		return this;
	}
	exclude(predicate) {
		this.options.exclude = predicate;
		return this;
	}
	onlyCounts() {
		this.options.onlyCounts = true;
		return this;
	}
	crawl(root) {
		return new APIBuilder(root || ".", this.options);
	}
	withGlobFunction(fn) {
		this.globFunction = fn;
		return this;
	}
	/**
	* @deprecated Pass options using the constructor instead:
	* ```ts
	* new fdir(options).crawl("/path/to/root");
	* ```
	* This method will be removed in v7.0
	*/
	/* c8 ignore next 4 */
	crawlWithOptions(root, options) {
		this.options = {
			...this.options,
			...options
		};
		return new APIBuilder(root || ".", this.options);
	}
	glob(...patterns) {
		if (this.globFunction) return this.globWithOptions(patterns);
		return this.globWithOptions(patterns, ...[{ dot: true }]);
	}
	globWithOptions(patterns, ...options) {
		const globFn = this.globFunction || pm;
		/* c8 ignore next 5 */
		if (!globFn) throw new Error("Please specify a glob function to use glob matching.");
		var isMatch = this.globCache[patterns.join("\0")];
		if (!isMatch) {
			isMatch = globFn(patterns, ...options);
			this.globCache[patterns.join("\0")] = isMatch;
		}
		this.options.filters.push((path) => isMatch(path));
		return this;
	}
};

//#endregion
export { Builder as fdir };
~~~

## node_modules\fdir\LICENSE

~~~text
Copyright 2023 Abdullah Atta

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

~~~

## node_modules\fdir\package.json

~~~json
{
  "name": "fdir",
  "version": "6.5.0",
  "description": "The fastest directory crawler & globbing alternative to glob, fast-glob, & tiny-glob. Crawls 1m files in < 1s",
  "main": "./dist/index.cjs",
  "types": "./dist/index.d.cts",
  "type": "module",
  "scripts": {
    "prepublishOnly": "npm run test && npm run build",
    "build": "tsdown",
    "format": "prettier --write src __tests__ benchmarks",
    "test": "vitest run __tests__/",
    "test:coverage": "vitest run --coverage __tests__/",
    "test:watch": "vitest __tests__/",
    "bench": "ts-node benchmarks/benchmark.js",
    "bench:glob": "ts-node benchmarks/glob-benchmark.ts",
    "bench:fdir": "ts-node benchmarks/fdir-benchmark.ts",
    "release": "./scripts/release.sh"
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/thecodrr/fdir.git"
  },
  "keywords": [
    "util",
    "os",
    "sys",
    "fs",
    "walk",
    "crawler",
    "directory",
    "files",
    "io",
    "tiny-glob",
    "glob",
    "fast-glob",
    "speed",
    "javascript",
    "nodejs"
  ],
  "author": "thecodrr <thecodrr@protonmail.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/thecodrr/fdir/issues"
  },
  "homepage": "https://github.com/thecodrr/fdir#readme",
  "devDependencies": {
    "@types/glob": "^8.1.0",
    "@types/mock-fs": "^4.13.4",
    "@types/node": "^20.9.4",
    "@types/picomatch": "^4.0.0",
    "@types/tap": "^15.0.11",
    "@vitest/coverage-v8": "^0.34.6",
    "all-files-in-tree": "^1.1.2",
    "benny": "^3.7.1",
    "csv-to-markdown-table": "^1.3.1",
    "expect": "^29.7.0",
    "fast-glob": "^3.3.2",
    "fdir1": "npm:fdir@1.2.0",
    "fdir2": "npm:fdir@2.1.0",
    "fdir3": "npm:fdir@3.4.2",
    "fdir4": "npm:fdir@4.1.0",
    "fdir5": "npm:fdir@5.0.0",
    "fs-readdir-recursive": "^1.1.0",
    "get-all-files": "^4.1.0",
    "glob": "^10.3.10",
    "klaw-sync": "^6.0.0",
    "mock-fs": "^5.2.0",
    "picomatch": "^4.0.2",
    "prettier": "^3.5.3",
    "recur-readdir": "0.0.1",
    "recursive-files": "^1.0.2",
    "recursive-fs": "^2.1.0",
    "recursive-readdir": "^2.2.3",
    "rrdir": "^12.1.0",
    "systeminformation": "^5.21.17",
    "tiny-glob": "^0.2.9",
    "ts-node": "^10.9.1",
    "tsdown": "^0.12.5",
    "typescript": "^5.3.2",
    "vitest": "^0.34.6",
    "walk-sync": "^3.0.0"
  },
  "peerDependencies": {
    "picomatch": "^3 || ^4"
  },
  "peerDependenciesMeta": {
    "picomatch": {
      "optional": true
    }
  },
  "module": "./dist/index.mjs",
  "exports": {
    ".": {
      "import": "./dist/index.mjs",
      "require": "./dist/index.cjs"
    },
    "./package.json": "./package.json"
  }
}

~~~

## node_modules\fdir\README.md

~~~md
<p align="center">
<img src="https://github.com/thecodrr/fdir/raw/master/assets/fdir.gif" width="75%"/>

<h1 align="center">The Fastest Directory Crawler & Globber for NodeJS</h1>
<p align="center">
  <a href="https://www.npmjs.com/package/fdir"><img src="https://img.shields.io/npm/v/fdir?style=for-the-badge"/></a>
  <a href="https://www.npmjs.com/package/fdir"><img src="https://img.shields.io/npm/dw/fdir?style=for-the-badge"/></a>
  <a href="https://codeclimate.com/github/thecodrr/fdir/maintainability"><img src="https://img.shields.io/codeclimate/maintainability-percentage/thecodrr/fdir?style=for-the-badge"/></a>
  <a href="https://coveralls.io/github/thecodrr/fdir?branch=master"><img src="https://img.shields.io/coveralls/github/thecodrr/fdir?style=for-the-badge"/></a>
  <a href="https://www.npmjs.com/package/fdir"><img src="https://img.shields.io/bundlephobia/minzip/fdir?style=for-the-badge"/></a>
  <a href="https://www.producthunt.com/posts/fdir-every-millisecond-matters"><img src="https://img.shields.io/badge/ProductHunt-Upvote-red?style=for-the-badge&logo=product-hunt"/></a>
  <a href="https://dev.to/thecodrr/how-i-wrote-the-fastest-directory-crawler-ever-3p9c"><img src="https://img.shields.io/badge/dev.to-Read%20Blog-black?style=for-the-badge&logo=dev.to"/></a>
  <a href="./LICENSE"><img src="https://img.shields.io/github/license/thecodrr/fdir?style=for-the-badge"/></a>
</p>
</p>

??**The Fastest:** Nothing similar (in the NodeJS world) beats `fdir` in speed. It can easily crawl a directory containing **1 million files in < 1 second.**

?뮕 **Stupidly Easy:** `fdir` uses expressive Builder pattern to build the crawler increasing code readability.

?쨼 **Zero Dependencies\*:** `fdir` only uses NodeJS `fs` & `path` modules.

?빜 **Astonishingly Small:** < 2KB in size gzipped & minified.

?뼫 **Hackable:** Extending `fdir` is extremely simple now that the new Builder API is here. Feel free to experiment around.

_\* `picomatch` must be installed manually by the user to support globbing._

## ?쉪 Quickstart

### Installation

You can install using `npm`:

```sh
$ npm i fdir
```

or Yarn:

```sh
$ yarn add fdir
```

### Usage

```ts
import { fdir } from "fdir";

// create the builder
const api = new fdir().withFullPaths().crawl("path/to/dir");

// get all files in a directory synchronously
const files = api.sync();

// or asynchronously
api.withPromise().then((files) => {
  // do something with the result here.
});
```

## Documentation:

Documentation for all methods is available [here](/documentation.md).

## ?뱤 Benchmarks:

Please check the benchmark against the latest version [here](/BENCHMARKS.md).

## ?솋Used by:

`fdir` is downloaded over 200k+ times a week by projects around the world. Here's a list of some notable projects using `fdir` in production:

> Note: if you think your project should be here, feel free to open an issue. Notable is anything with a considerable amount of GitHub stars.

1. [rollup/plugins](https://github.com/rollup/plugins)
2. [SuperchupuDev/tinyglobby](https://github.com/SuperchupuDev/tinyglobby)
3. [pulumi/pulumi](https://github.com/pulumi/pulumi)
4. [dotenvx/dotenvx](https://github.com/dotenvx/dotenvx)
5. [mdn/yari](https://github.com/mdn/yari)
6. [streetwriters/notesnook](https://github.com/streetwriters/notesnook)
7. [imba/imba](https://github.com/imba/imba)
8. [moroshko/react-scanner](https://github.com/moroshko/react-scanner)
9. [netlify/build](https://github.com/netlify/build)
10. [yassinedoghri/astro-i18next](https://github.com/yassinedoghri/astro-i18next)
11. [selfrefactor/rambda](https://github.com/selfrefactor/rambda)
12. [whyboris/Video-Hub-App](https://github.com/whyboris/Video-Hub-App)

## ?┏ LICENSE

Copyright &copy; 2024 Abdullah Atta under MIT. [Read full text here.](https://github.com/thecodrr/fdir/raw/master/LICENSE)

~~~

## node_modules\get-nonce\CHANGELOG.md

~~~md
# 1.0.0 (2020-04-16)

~~~

## node_modules\get-nonce\dist\es2015\index.d.ts

~~~ts
export declare const setNonce: (nonce: string) => void;
export declare const getNonce: () => string | undefined;

~~~

## node_modules\get-nonce\dist\es2015\index.js

~~~js
var currentNonce;
export var setNonce = function (nonce) {
    currentNonce = nonce;
};
export var getNonce = function () {
    if (currentNonce) {
        return currentNonce;
    }
    if (typeof __webpack_nonce__ !== 'undefined') {
        return __webpack_nonce__;
    }
    return undefined;
};

~~~

## node_modules\get-nonce\dist\es5\index.d.ts

~~~ts
export declare const setNonce: (nonce: string) => void;
export declare const getNonce: () => string | undefined;

~~~

## node_modules\get-nonce\dist\es5\index.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var currentNonce;
exports.setNonce = function (nonce) {
    currentNonce = nonce;
};
exports.getNonce = function () {
    if (currentNonce) {
        return currentNonce;
    }
    if (typeof __webpack_nonce__ !== 'undefined') {
        return __webpack_nonce__;
    }
    return undefined;
};

~~~

## node_modules\get-nonce\LICENSE

~~~text
MIT License

Copyright (c) 2020 Anton Korzunov

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

~~~

## node_modules\get-nonce\package.json

~~~json
{
  "name": "get-nonce",
  "version": "1.0.1",
  "description": "returns nonce",
  "main": "dist/es5/index.js",
  "types": "dist/es5/index.d.ts",
  "sideEffects": false,
  "repository": "git@github.com:theKashey/get-nonce.git",
  "homepage": "https://github.com/theKashey/get-nonce",
  "author": "Anton Korzunov <thekashey@gmail.com>",
  "license": "MIT",
  "keywords": [
    "webpack",
    "nonce",
    "__webpack_nonce__"
  ],
  "devDependencies": {
    "@theuiteam/lib-builder": "^0.0.10",
    "@size-limit/preset-small-lib": "^2.1.6"
  },
  "module": "dist/es2015/index.js",
  "engines": {
    "node": ">=6"
  },
  "scripts": {
    "dev": "lib-builder dev",
    "test": "jest",
    "test:ci": "jest --runInBand --coverage",
    "build": "lib-builder build && yarn size:report",
    "release": "yarn build && yarn test",
    "size": "npx size-limit",
    "size:report": "npx size-limit --json > .size.json",
    "lint": "lib-builder lint",
    "format": "lib-builder format",
    "update": "lib-builder update",
    "docz:dev": "docz dev",
    "docz:build": "docz build",
    "prepublish": "yarn build && yarn changelog",
    "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s",
    "changelog:rewrite": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0"
  },
  "files": [
    "dist"
  ],
  "husky": {
    "hooks": {
      "pre-commit": "lint-staged"
    }
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "prettier --write",
      "tslint --fix",
      "git add"
    ],
    "*.{js,css,json,md}": [
      "prettier --write",
      "git add"
    ]
  },
  "prettier": {
    "printWidth": 120,
    "trailingComma": "es5",
    "tabWidth": 2,
    "semi": true,
    "singleQuote": true
  }
}

~~~

## node_modules\get-nonce\README.md

~~~md
# get-nonce

just returns a **nonce** (number used once). No batteries included in those 46 bytes of this library.

---

- ??build in `webpack` support via `__webpack_nonce__`

# API

- `getNonce(): string|undefined` - returns the current `nonce`
- `setNonce(newValue)` - set's nonce value

## Why?

Why we need a library to access `__webpack_nonce__`? Abstractions!

"I", as a library author, don't want to "predict" the platform "you" going to use.
"I", as well, want an easier way to test and control `nonce` value.

Like - `nonce` is supported out of the box only by webpack, what you are going to do?

This is why this "man-in-the-middle" was created.
Yep, think about `left-pad` :)

## Webpack

> https://webpack.js.org/guides/csp/

To activate the feature set a **webpack_nonce** variable needs to be included in your entry script.

```
__webpack_nonce__ = uuid(); // for example
```

Without `webpack` `__webpack_nonce__` is actually just a global variable,
which makes it actually bundler independent,
however "other bundlers" are able to replicate it only setting it as a global variable
(as here in tests) which violates a "secure" nature of `nonce`.

`get-nonce` is not global.

## Used in

- `react-style-singleton` <- `react-remove-scroll` <- `react-focus-on`

## Inspiration

- [this issue](https://github.com/theKashey/react-remove-scroll/issues/21)
- [styled-components](https://github.com/styled-components/styled-components/blob/147b0e9a1f10786551b13fd27452fcd5c678d5e0/packages/styled-components/src/utils/nonce.js)

# Licence

MIT

~~~

## node_modules\input-otp\dist\index.d.mts

~~~mts
import * as React$1 from 'react';

interface SlotProps {
    isActive: boolean;
    char: string | null;
    placeholderChar: string | null;
    hasFakeCaret: boolean;
}
interface RenderProps {
    slots: SlotProps[];
    isFocused: boolean;
    isHovering: boolean;
}
type OverrideProps<T, R> = Omit<T, keyof R> & R;
type OTPInputBaseProps = OverrideProps<React.InputHTMLAttributes<HTMLInputElement>, {
    value?: string;
    onChange?: (newValue: string) => unknown;
    maxLength: number;
    textAlign?: 'left' | 'center' | 'right';
    onComplete?: (...args: any[]) => unknown;
    pushPasswordManagerStrategy?: 'increase-width' | 'none';
    pasteTransformer?: (pasted: string) => string;
    containerClassName?: string;
    noScriptCSSFallback?: string | null;
}>;
type InputOTPRenderFn = (props: RenderProps) => React.ReactNode;
type OTPInputProps = OTPInputBaseProps & ({
    render: InputOTPRenderFn;
    children?: never;
} | {
    render?: never;
    children: React.ReactNode;
});

declare const OTPInputContext: React$1.Context<RenderProps>;
declare const OTPInput: React$1.ForwardRefExoticComponent<OTPInputProps & React$1.RefAttributes<HTMLInputElement>>;

declare const REGEXP_ONLY_DIGITS = "^\\d+$";
declare const REGEXP_ONLY_CHARS = "^[a-zA-Z]+$";
declare const REGEXP_ONLY_DIGITS_AND_CHARS = "^[a-zA-Z0-9]+$";

export { OTPInput, OTPInputContext, type OTPInputProps, REGEXP_ONLY_CHARS, REGEXP_ONLY_DIGITS, REGEXP_ONLY_DIGITS_AND_CHARS, type RenderProps, type SlotProps };

~~~

## node_modules\input-otp\dist\index.d.ts

~~~ts
import * as React$1 from 'react';

interface SlotProps {
    isActive: boolean;
    char: string | null;
    placeholderChar: string | null;
    hasFakeCaret: boolean;
}
interface RenderProps {
    slots: SlotProps[];
    isFocused: boolean;
    isHovering: boolean;
}
type OverrideProps<T, R> = Omit<T, keyof R> & R;
type OTPInputBaseProps = OverrideProps<React.InputHTMLAttributes<HTMLInputElement>, {
    value?: string;
    onChange?: (newValue: string) => unknown;
    maxLength: number;
    textAlign?: 'left' | 'center' | 'right';
    onComplete?: (...args: any[]) => unknown;
    pushPasswordManagerStrategy?: 'increase-width' | 'none';
    pasteTransformer?: (pasted: string) => string;
    containerClassName?: string;
    noScriptCSSFallback?: string | null;
}>;
type InputOTPRenderFn = (props: RenderProps) => React.ReactNode;
type OTPInputProps = OTPInputBaseProps & ({
    render: InputOTPRenderFn;
    children?: never;
} | {
    render?: never;
    children: React.ReactNode;
});

declare const OTPInputContext: React$1.Context<RenderProps>;
declare const OTPInput: React$1.ForwardRefExoticComponent<OTPInputProps & React$1.RefAttributes<HTMLInputElement>>;

declare const REGEXP_ONLY_DIGITS = "^\\d+$";
declare const REGEXP_ONLY_CHARS = "^[a-zA-Z]+$";
declare const REGEXP_ONLY_DIGITS_AND_CHARS = "^[a-zA-Z0-9]+$";

export { OTPInput, OTPInputContext, type OTPInputProps, REGEXP_ONLY_CHARS, REGEXP_ONLY_DIGITS, REGEXP_ONLY_DIGITS_AND_CHARS, type RenderProps, type SlotProps };

~~~

## node_modules\input-otp\dist\index.js

~~~js
var xt=Object.create;var $=Object.defineProperty,jt=Object.defineProperties,Lt=Object.getOwnPropertyDescriptor,Nt=Object.getOwnPropertyDescriptors,$t=Object.getOwnPropertyNames,U=Object.getOwnPropertySymbols,Ft=Object.getPrototypeOf,ot=Object.prototype.hasOwnProperty,bt=Object.prototype.propertyIsEnumerable;var St=(e,n,t)=>n in e?$(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Pt=(e,n)=>{for(var t in n||(n={}))ot.call(n,t)&&St(e,t,n[t]);if(U)for(var t of U(n))bt.call(n,t)&&St(e,t,n[t]);return e},ht=(e,n)=>jt(e,Nt(n));var _t=(e,n)=>{var t={};for(var i in e)ot.call(e,i)&&n.indexOf(i)<0&&(t[i]=e[i]);if(e!=null&&U)for(var i of U(e))n.indexOf(i)<0&&bt.call(e,i)&&(t[i]=e[i]);return t};var zt=(e,n)=>{for(var t in n)$(e,t,{get:n[t],enumerable:!0})},wt=(e,n,t,i)=>{if(n&&typeof n=="object"||typeof n=="function")for(let d of $t(n))!ot.call(e,d)&&d!==t&&$(e,d,{get:()=>n[d],enumerable:!(i=Lt(n,d))||i.enumerable});return e};var rt=(e,n,t)=>(t=e!=null?xt(Ft(e)):{},wt(n||!e||!e.__esModule?$(t,"default",{value:e,enumerable:!0}):t,e)),Vt=e=>wt($({},"__esModule",{value:!0}),e);var Qt={};zt(Qt,{OTPInput:()=>Dt,OTPInputContext:()=>yt,REGEXP_ONLY_CHARS:()=>Kt,REGEXP_ONLY_DIGITS:()=>qt,REGEXP_ONLY_DIGITS_AND_CHARS:()=>Jt});module.exports=Vt(Qt);var r=rt(require("react"));function Tt(e){let n=setTimeout(e,0),t=setTimeout(e,10),i=setTimeout(e,50);return[n,t,i]}var Z=rt(require("react"));function It(e){let n=Z.useRef();return Z.useEffect(()=>{n.current=e}),n.current}var b=rt(require("react")),Xt=18,Mt=40,Yt=`${Mt}px`,Ut=["[data-lastpass-icon-root]","com-1password-button","[data-dashlanecreated]",'[style$="2147483647 !important;"]'].join(",");function Ct({containerRef:e,inputRef:n,pushPasswordManagerStrategy:t,isFocused:i}){let[d,D]=b.useState(!1),[G,H]=b.useState(!1),[z,W]=b.useState(!1),q=b.useMemo(()=>t==="none"?!1:(t==="increase-width"||t==="experimental-no-flickering")&&d&&G,[d,G,t]),T=b.useCallback(()=>{let m=e.current,h=n.current;if(!m||!h||z||t==="none")return;let a=m,B=a.getBoundingClientRect().left+a.offsetWidth,A=a.getBoundingClientRect().top+a.offsetHeight/2,V=B-Xt,K=A;document.querySelectorAll(Ut).length===0&&document.elementFromPoint(V,K)===m||(D(!0),W(!0))},[e,n,z,t]);return b.useEffect(()=>{let m=e.current;if(!m||t==="none")return;function h(){let A=window.innerWidth-m.getBoundingClientRect().right;H(A>=Mt)}h();let a=setInterval(h,1e3);return()=>{clearInterval(a)}},[e,t]),b.useEffect(()=>{let m=i||document.activeElement===n.current;if(t==="none"||!m)return;let h=setTimeout(T,0),a=setTimeout(T,2e3),B=setTimeout(T,5e3),A=setTimeout(()=>{W(!0)},6e3);return()=>{clearTimeout(h),clearTimeout(a),clearTimeout(B),clearTimeout(A)}},[n,i,t,T]),{hasPWMBadge:d,willPushPWMBadge:q,PWM_BADGE_SPACE_WIDTH:Yt}}var yt=r.createContext({}),Dt=r.forwardRef((A,B)=>{var V=A,{value:e,onChange:n,maxLength:t,textAlign:i="left",pattern:d,placeholder:D,inputMode:G="numeric",onComplete:H,pushPasswordManagerStrategy:z="increase-width",pasteTransformer:W,containerClassName:q,noScriptCSSFallback:T=Zt,render:m,children:h}=V,a=_t(V,["value","onChange","maxLength","textAlign","pattern","placeholder","inputMode","onComplete","pushPasswordManagerStrategy","pasteTransformer","containerClassName","noScriptCSSFallback","render","children"]);var Y,ft,mt,pt,Rt;let[K,st]=r.useState(typeof a.defaultValue=="string"?a.defaultValue:""),l=e!=null?e:K,I=It(l),x=r.useCallback(o=>{n==null||n(o),st(o)},[n]),p=r.useMemo(()=>d?typeof d=="string"?new RegExp(d):d:null,[d]),u=r.useRef(null),J=r.useRef(null),Q=r.useRef({value:l,onChange:x,isIOS:typeof window!="undefined"&&((ft=(Y=window==null?void 0:window.CSS)==null?void 0:Y.supports)==null?void 0:ft.call(Y,"-webkit-touch-callout","none"))}),X=r.useRef({prev:[(mt=u.current)==null?void 0:mt.selectionStart,(pt=u.current)==null?void 0:pt.selectionEnd,(Rt=u.current)==null?void 0:Rt.selectionDirection]});r.useImperativeHandle(B,()=>u.current,[]),r.useEffect(()=>{let o=u.current,s=J.current;if(!o||!s)return;Q.current.value!==o.value&&Q.current.onChange(o.value),X.current.prev=[o.selectionStart,o.selectionEnd,o.selectionDirection];function f(){if(document.activeElement!==o){L(null),N(null);return}let c=o.selectionStart,P=o.selectionEnd,vt=o.selectionDirection,g=o.maxLength,C=o.value,_=X.current.prev,E=-1,S=-1,w;if(C.length!==0&&c!==null&&P!==null){let kt=c===P,Ot=c===C.length&&C.length<g;if(kt&&!Ot){let y=c;if(y===0)E=0,S=1,w="forward";else if(y===g)E=y-1,S=y,w="backward";else if(g>1&&C.length>1){let nt=0;if(_[0]!==null&&_[1]!==null){w=y<_[1]?"backward":"forward";let Gt=_[0]===_[1]&&_[0]<g;w==="backward"&&!Gt&&(nt=-1)}E=nt+y,S=nt+y+1}}E!==-1&&S!==-1&&E!==S&&u.current.setSelectionRange(E,S,w)}let gt=E!==-1?E:c,Et=S!==-1?S:P,At=w!=null?w:vt;L(gt),N(Et),X.current.prev=[gt,Et,At]}if(document.addEventListener("selectionchange",f,{capture:!0}),f(),document.activeElement===o&&tt(!0),!document.getElementById("input-otp-style")){let c=document.createElement("style");if(c.id="input-otp-style",document.head.appendChild(c),c.sheet){let P="background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";F(c.sheet,"[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"),F(c.sheet,`[data-input-otp]:autofill { ${P} }`),F(c.sheet,`[data-input-otp]:-webkit-autofill { ${P} }`),F(c.sheet,"@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"),F(c.sheet,"[data-input-otp] + * { pointer-events: all !important; }")}}let v=()=>{s&&s.style.setProperty("--root-height",`${o.clientHeight}px`)};v();let R=new ResizeObserver(v);return R.observe(o),()=>{document.removeEventListener("selectionchange",f,{capture:!0}),R.disconnect()}},[]);let[at,ct]=r.useState(!1),[j,tt]=r.useState(!1),[M,L]=r.useState(null),[k,N]=r.useState(null);r.useEffect(()=>{Tt(()=>{var v,R,c,P;(v=u.current)==null||v.dispatchEvent(new Event("input"));let o=(R=u.current)==null?void 0:R.selectionStart,s=(c=u.current)==null?void 0:c.selectionEnd,f=(P=u.current)==null?void 0:P.selectionDirection;o!==null&&s!==null&&(L(o),N(s),X.current.prev=[o,s,f])})},[l,j]),r.useEffect(()=>{I!==void 0&&l!==I&&I.length<t&&l.length===t&&(H==null||H(l))},[t,H,I,l]);let O=Ct({containerRef:J,inputRef:u,pushPasswordManagerStrategy:z,isFocused:j}),it=r.useCallback(o=>{let s=o.currentTarget.value.slice(0,t);if(s.length>0&&p&&!p.test(s)){o.preventDefault();return}typeof I=="string"&&s.length<I.length&&document.dispatchEvent(new Event("selectionchange")),x(s)},[t,x,I,p]),lt=r.useCallback(()=>{var o;if(u.current){let s=Math.min(u.current.value.length,t-1),f=u.current.value.length;(o=u.current)==null||o.setSelectionRange(s,f),L(s),N(f)}tt(!0)},[t]),ut=r.useCallback(o=>{var E,S;let s=u.current;if(!W&&(!Q.current.isIOS||!o.clipboardData||!s))return;let f=o.clipboardData.getData("text/plain"),v=W?W(f):f;o.preventDefault();let R=(E=u.current)==null?void 0:E.selectionStart,c=(S=u.current)==null?void 0:S.selectionEnd,g=(R!==c?l.slice(0,R)+v+l.slice(c):l.slice(0,R)+v+l.slice(R)).slice(0,t);if(g.length>0&&p&&!p.test(g))return;s.value=g,x(g);let C=Math.min(g.length,t-1),_=g.length;s.setSelectionRange(C,_),L(C),N(_)},[t,x,p,l]),Ht=r.useMemo(()=>({position:"relative",cursor:a.disabled?"default":"text",userSelect:"none",WebkitUserSelect:"none",pointerEvents:"none"}),[a.disabled]),dt=r.useMemo(()=>({position:"absolute",inset:0,width:O.willPushPWMBadge?`calc(100% + ${O.PWM_BADGE_SPACE_WIDTH})`:"100%",clipPath:O.willPushPWMBadge?`inset(0 ${O.PWM_BADGE_SPACE_WIDTH} 0 0)`:void 0,height:"100%",display:"flex",textAlign:i,opacity:"1",color:"transparent",pointerEvents:"all",background:"transparent",caretColor:"transparent",border:"0 solid transparent",outline:"0 solid transparent",boxShadow:"none",lineHeight:"1",letterSpacing:"-.5em",fontSize:"var(--root-height)",fontFamily:"monospace",fontVariantNumeric:"tabular-nums"}),[O.PWM_BADGE_SPACE_WIDTH,O.willPushPWMBadge,i]),Wt=r.useMemo(()=>r.createElement("input",ht(Pt({autoComplete:a.autoComplete||"one-time-code"},a),{"data-input-otp":!0,"data-input-otp-placeholder-shown":l.length===0||void 0,"data-input-otp-mss":M,"data-input-otp-mse":k,inputMode:G,pattern:p==null?void 0:p.source,"aria-placeholder":D,style:dt,maxLength:t,value:l,ref:u,onPaste:o=>{var s;ut(o),(s=a.onPaste)==null||s.call(a,o)},onChange:it,onMouseOver:o=>{var s;ct(!0),(s=a.onMouseOver)==null||s.call(a,o)},onMouseLeave:o=>{var s;ct(!1),(s=a.onMouseLeave)==null||s.call(a,o)},onFocus:o=>{var s;lt(),(s=a.onFocus)==null||s.call(a,o)},onBlur:o=>{var s;tt(!1),(s=a.onBlur)==null||s.call(a,o)}})),[it,lt,ut,G,dt,t,k,M,a,p==null?void 0:p.source,l]),et=r.useMemo(()=>({slots:Array.from({length:t}).map((o,s)=>{var c;let f=j&&M!==null&&k!==null&&(M===k&&s===M||s>=M&&s<k),v=l[s]!==void 0?l[s]:null,R=l[0]!==void 0?null:(c=D==null?void 0:D[s])!=null?c:null;return{char:v,placeholderChar:R,isActive:f,hasFakeCaret:f&&v===null}}),isFocused:j,isHovering:!a.disabled&&at}),[j,at,t,k,M,a.disabled,l]),Bt=r.useMemo(()=>m?m(et):r.createElement(yt.Provider,{value:et},h),[h,et,m]);return r.createElement(r.Fragment,null,T!==null&&r.createElement("noscript",null,r.createElement("style",null,T)),r.createElement("div",{ref:J,"data-input-otp-container":!0,style:Ht,className:q},Bt,r.createElement("div",{style:{position:"absolute",inset:0,pointerEvents:"none"}},Wt)))});Dt.displayName="Input";function F(e,n){try{e.insertRule(n)}catch(t){console.error("input-otp could not insert CSS rule:",n)}}var Zt=`
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;var qt="^\\d+$",Kt="^[a-zA-Z]+$",Jt="^[a-zA-Z0-9]+$";0&&(module.exports={OTPInput,OTPInputContext,REGEXP_ONLY_CHARS,REGEXP_ONLY_DIGITS,REGEXP_ONLY_DIGITS_AND_CHARS});
//# sourceMappingURL=index.js.map
~~~

## node_modules\input-otp\dist\index.js.map

~~~map
{"version":3,"sources":["../src/index.ts","../src/input.tsx","../src/sync-timeouts.ts","../src/use-previous.ts","../src/use-pwm-badge.tsx","../src/regexp.ts"],"sourcesContent":["export * from './input'\nexport * from './regexp'\nexport { OTPInputProps, SlotProps, RenderProps } from './types'\n","'use client'\n\nimport * as React from 'react'\n\nimport { syncTimeouts } from './sync-timeouts'\nimport { OTPInputProps, RenderProps } from './types'\nimport { usePrevious } from './use-previous'\nimport { usePasswordManagerBadge } from './use-pwm-badge'\n\nexport const OTPInputContext = React.createContext<RenderProps>(\n  {} as RenderProps,\n)\n\nexport const OTPInput = React.forwardRef<HTMLInputElement, OTPInputProps>(\n  (\n    {\n      value: uncheckedValue,\n      onChange: uncheckedOnChange,\n      maxLength,\n      textAlign = 'left',\n      pattern,\n      placeholder,\n      inputMode = 'numeric',\n      onComplete,\n      pushPasswordManagerStrategy = 'increase-width',\n      pasteTransformer,\n      containerClassName,\n      noScriptCSSFallback = NOSCRIPT_CSS_FALLBACK,\n\n      render,\n      children,\n\n      ...props\n    },\n    ref,\n  ) => {\n    // Only used when `value` state is not provided\n    const [internalValue, setInternalValue] = React.useState(\n      typeof props.defaultValue === 'string' ? props.defaultValue : '',\n    )\n\n    // Definitions\n    const value = uncheckedValue ?? internalValue\n    const previousValue = usePrevious(value)\n    const onChange = React.useCallback(\n      (newValue: string) => {\n        uncheckedOnChange?.(newValue)\n        setInternalValue(newValue)\n      },\n      [uncheckedOnChange],\n    )\n    const regexp = React.useMemo(\n      () =>\n        pattern\n          ? typeof pattern === 'string'\n            ? new RegExp(pattern)\n            : pattern\n          : null,\n      [pattern],\n    )\n\n    /** useRef */\n    const inputRef = React.useRef<HTMLInputElement>(null)\n    const containerRef = React.useRef<HTMLDivElement>(null)\n    const initialLoadRef = React.useRef({\n      value,\n      onChange,\n      isIOS:\n        typeof window !== 'undefined' &&\n        window?.CSS?.supports?.('-webkit-touch-callout', 'none'),\n    })\n    const inputMetadataRef = React.useRef<{\n      prev: [number | null, number | null, 'none' | 'forward' | 'backward']\n    }>({\n      prev: [\n        inputRef.current?.selectionStart,\n        inputRef.current?.selectionEnd,\n        inputRef.current?.selectionDirection,\n      ],\n    })\n    React.useImperativeHandle(ref, () => inputRef.current, [])\n    React.useEffect(() => {\n      const input = inputRef.current\n      const container = containerRef.current\n\n      if (!input || !container) {\n        return\n      }\n\n      // Sync input value\n      if (initialLoadRef.current.value !== input.value) {\n        initialLoadRef.current.onChange(input.value)\n      }\n\n      // Previous selection\n      inputMetadataRef.current.prev = [\n        input.selectionStart,\n        input.selectionEnd,\n        input.selectionDirection,\n      ]\n      function onDocumentSelectionChange() {\n        if (document.activeElement !== input) {\n          setMirrorSelectionStart(null)\n          setMirrorSelectionEnd(null)\n          return\n        }\n\n        // Aliases\n        const _s = input.selectionStart\n        const _e = input.selectionEnd\n        const _dir = input.selectionDirection\n        const _ml = input.maxLength\n        const _val = input.value\n        const _prev = inputMetadataRef.current.prev\n\n        // Algorithm\n        let start = -1\n        let end = -1\n        let direction: 'forward' | 'backward' | 'none' = undefined\n        if (_val.length !== 0 && _s !== null && _e !== null) {\n          const isSingleCaret = _s === _e\n          const isInsertMode = _s === _val.length && _val.length < _ml\n\n          if (isSingleCaret && !isInsertMode) {\n            const c = _s\n            if (c === 0) {\n              start = 0\n              end = 1\n              direction = 'forward'\n            } else if (c === _ml) {\n              start = c - 1\n              end = c\n              direction = 'backward'\n            } else if (_ml > 1 && _val.length > 1) {\n              let offset = 0\n              if (_prev[0] !== null && _prev[1] !== null) {\n                direction = c < _prev[1] ? 'backward' : 'forward'\n                const wasPreviouslyInserting =\n                  _prev[0] === _prev[1] && _prev[0] < _ml\n                if (direction === 'backward' && !wasPreviouslyInserting) {\n                  offset = -1\n                }\n              }\n\n              start = offset + c\n              end = offset + c + 1\n            }\n          }\n\n          if (start !== -1 && end !== -1 && start !== end) {\n            inputRef.current.setSelectionRange(start, end, direction)\n          }\n        }\n\n        // Finally, update the state\n        const s = start !== -1 ? start : _s\n        const e = end !== -1 ? end : _e\n        const dir = direction ?? _dir\n        setMirrorSelectionStart(s)\n        setMirrorSelectionEnd(e)\n        // Store the previous selection value\n        inputMetadataRef.current.prev = [s, e, dir]\n      }\n      document.addEventListener('selectionchange', onDocumentSelectionChange, {\n        capture: true,\n      })\n\n      // Set initial mirror state\n      onDocumentSelectionChange()\n      document.activeElement === input && setIsFocused(true)\n\n      // Apply needed styles\n      if (!document.getElementById('input-otp-style')) {\n        const styleEl = document.createElement('style')\n        styleEl.id = 'input-otp-style'\n        document.head.appendChild(styleEl)\n\n        if (styleEl.sheet) {\n          const autofillStyles =\n            'background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;'\n\n          safeInsertRule(\n            styleEl.sheet,\n            '[data-input-otp]::selection { background: transparent !important; color: transparent !important; }',\n          )\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp]:autofill { ${autofillStyles} }`,\n          )\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp]:-webkit-autofill { ${autofillStyles} }`,\n          )\n          // iOS\n          safeInsertRule(\n            styleEl.sheet,\n            `@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }`,\n          )\n          // PWM badges\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp] + * { pointer-events: all !important; }`,\n          )\n        }\n      }\n      // Track root height\n      const updateRootHeight = () => {\n        if (container) {\n          container.style.setProperty(\n            '--root-height',\n            `${input.clientHeight}px`,\n          )\n        }\n      }\n      updateRootHeight()\n      const resizeObserver = new ResizeObserver(updateRootHeight)\n      resizeObserver.observe(input)\n\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onDocumentSelectionChange,\n          { capture: true },\n        )\n        resizeObserver.disconnect()\n      }\n    }, [])\n\n    /** Mirrors for UI rendering purpose only */\n    const [isHoveringInput, setIsHoveringInput] = React.useState(false)\n    const [isFocused, setIsFocused] = React.useState(false)\n    const [mirrorSelectionStart, setMirrorSelectionStart] = React.useState<\n      number | null\n    >(null)\n    const [mirrorSelectionEnd, setMirrorSelectionEnd] = React.useState<\n      number | null\n    >(null)\n\n    /** Effects */\n    React.useEffect(() => {\n      syncTimeouts(() => {\n        // Forcefully remove :autofill state\n        inputRef.current?.dispatchEvent(new Event('input'))\n\n        // Update the selection state\n        const s = inputRef.current?.selectionStart\n        const e = inputRef.current?.selectionEnd\n        const dir = inputRef.current?.selectionDirection\n        if (s !== null && e !== null) {\n          setMirrorSelectionStart(s)\n          setMirrorSelectionEnd(e)\n          inputMetadataRef.current.prev = [s, e, dir]\n        }\n      })\n    }, [value, isFocused])\n\n    React.useEffect(() => {\n      if (previousValue === undefined) {\n        return\n      }\n\n      if (\n        value !== previousValue &&\n        previousValue.length < maxLength &&\n        value.length === maxLength\n      ) {\n        onComplete?.(value)\n      }\n    }, [maxLength, onComplete, previousValue, value])\n\n    const pwmb = usePasswordManagerBadge({\n      containerRef,\n      inputRef,\n      pushPasswordManagerStrategy,\n      isFocused,\n    })\n\n    /** Event handlers */\n    const _changeListener = React.useCallback(\n      (e: React.ChangeEvent<HTMLInputElement>) => {\n        const newValue = e.currentTarget.value.slice(0, maxLength)\n        if (newValue.length > 0 && regexp && !regexp.test(newValue)) {\n          e.preventDefault()\n          return\n        }\n        const maybeHasDeleted =\n          typeof previousValue === 'string' &&\n          newValue.length < previousValue.length\n        if (maybeHasDeleted) {\n          // Since cutting/deleting text doesn't trigger\n          // selectionchange event, we'll have to dispatch it manually.\n          // NOTE: The following line also triggers when cmd+A then pasting\n          // a value with smaller length, which is not ideal for performance.\n          document.dispatchEvent(new Event('selectionchange'))\n        }\n        onChange(newValue)\n      },\n      [maxLength, onChange, previousValue, regexp],\n    )\n    const _focusListener = React.useCallback(() => {\n      if (inputRef.current) {\n        const start = Math.min(inputRef.current.value.length, maxLength - 1)\n        const end = inputRef.current.value.length\n        inputRef.current?.setSelectionRange(start, end)\n        setMirrorSelectionStart(start)\n        setMirrorSelectionEnd(end)\n      }\n      setIsFocused(true)\n    }, [maxLength])\n    // Fix iOS pasting\n    const _pasteListener = React.useCallback(\n      (e: React.ClipboardEvent<HTMLInputElement>) => {\n        const input = inputRef.current\n        if (!pasteTransformer && (!initialLoadRef.current.isIOS || !e.clipboardData || !input)) {\n          return\n        }\n        \n        const _content = e.clipboardData.getData('text/plain')\n        const content = pasteTransformer\n          ? pasteTransformer(_content)\n          : _content\n        e.preventDefault()\n\n        const start = inputRef.current?.selectionStart\n        const end = inputRef.current?.selectionEnd\n\n        const isReplacing = start !== end\n\n        const newValueUncapped = isReplacing\n          ? value.slice(0, start) + content + value.slice(end) // Replacing\n          : value.slice(0, start) + content + value.slice(start) // Inserting\n        const newValue = newValueUncapped.slice(0, maxLength)\n\n        if (newValue.length > 0 && regexp && !regexp.test(newValue)) {\n          return\n        }\n\n        input.value = newValue\n        onChange(newValue)\n\n        const _start = Math.min(newValue.length, maxLength - 1)\n        const _end = newValue.length\n\n        input.setSelectionRange(_start, _end)\n        setMirrorSelectionStart(_start)\n        setMirrorSelectionEnd(_end)\n      },\n      [maxLength, onChange, regexp, value],\n    )\n\n    /** Styles */\n    const rootStyle = React.useMemo<React.CSSProperties>(\n      () => ({\n        position: 'relative',\n        cursor: props.disabled ? 'default' : 'text',\n        userSelect: 'none',\n        WebkitUserSelect: 'none',\n        pointerEvents: 'none',\n      }),\n      [props.disabled],\n    )\n\n    const inputStyle = React.useMemo<React.CSSProperties>(\n      () => ({\n        position: 'absolute',\n        inset: 0,\n        width: pwmb.willPushPWMBadge\n          ? `calc(100% + ${pwmb.PWM_BADGE_SPACE_WIDTH})`\n          : '100%',\n        clipPath: pwmb.willPushPWMBadge\n          ? `inset(0 ${pwmb.PWM_BADGE_SPACE_WIDTH} 0 0)`\n          : undefined,\n        height: '100%',\n        display: 'flex',\n        textAlign,\n        opacity: '1', // Mandatory for iOS hold-paste\n        color: 'transparent',\n        pointerEvents: 'all',\n        background: 'transparent',\n        caretColor: 'transparent',\n        border: '0 solid transparent',\n        outline: '0 solid transparent',\n        boxShadow: 'none',\n        lineHeight: '1',\n        letterSpacing: '-.5em',\n        fontSize: 'var(--root-height)',\n        fontFamily: 'monospace',\n        fontVariantNumeric: 'tabular-nums',\n        // letterSpacing: '-1em',\n        // transform: 'scale(1.5)',\n        // paddingRight: '100%',\n        // paddingBottom: '100%',\n        // debugging purposes\n        // inset: undefined,\n        // position: undefined,\n        // color: 'black',\n        // background: 'white',\n        // opacity: '1',\n        // caretColor: 'black',\n        // padding: '0',\n        // letterSpacing: 'unset',\n        // fontSize: 'unset',\n        // paddingInline: '.5rem',\n      }),\n      [pwmb.PWM_BADGE_SPACE_WIDTH, pwmb.willPushPWMBadge, textAlign],\n    )\n\n    /** Rendering */\n    const renderedInput = React.useMemo(\n      () => (\n        <input\n          autoComplete={props.autoComplete || 'one-time-code'}\n          {...props}\n          data-input-otp\n          data-input-otp-placeholder-shown={value.length === 0 || undefined}\n          data-input-otp-mss={mirrorSelectionStart}\n          data-input-otp-mse={mirrorSelectionEnd}\n          inputMode={inputMode}\n          pattern={regexp?.source}\n          aria-placeholder={placeholder}\n          style={inputStyle}\n          maxLength={maxLength}\n          value={value}\n          ref={inputRef}\n          onPaste={e => {\n            _pasteListener(e)\n            props.onPaste?.(e)\n          }}\n          onChange={_changeListener}\n          onMouseOver={e => {\n            setIsHoveringInput(true)\n            props.onMouseOver?.(e)\n          }}\n          onMouseLeave={e => {\n            setIsHoveringInput(false)\n            props.onMouseLeave?.(e)\n          }}\n          onFocus={e => {\n            _focusListener()\n            props.onFocus?.(e)\n          }}\n          onBlur={e => {\n            setIsFocused(false)\n            props.onBlur?.(e)\n          }}\n        />\n      ),\n      [\n        _changeListener,\n        _focusListener,\n        _pasteListener,\n        inputMode,\n        inputStyle,\n        maxLength,\n        mirrorSelectionEnd,\n        mirrorSelectionStart,\n        props,\n        regexp?.source,\n        value,\n      ],\n    )\n\n    const contextValue = React.useMemo<RenderProps>(() => {\n      return {\n        slots: Array.from({ length: maxLength }).map((_, slotIdx) => {\n          const isActive =\n            isFocused &&\n            mirrorSelectionStart !== null &&\n            mirrorSelectionEnd !== null &&\n            ((mirrorSelectionStart === mirrorSelectionEnd &&\n              slotIdx === mirrorSelectionStart) ||\n              (slotIdx >= mirrorSelectionStart && slotIdx < mirrorSelectionEnd))\n\n          const char = value[slotIdx] !== undefined ? value[slotIdx] : null\n          const placeholderChar = value[0] !== undefined ? null : placeholder?.[slotIdx] ?? null\n\n          return {\n            char,\n            placeholderChar,\n            isActive,\n            hasFakeCaret: isActive && char === null,\n          }\n        }),\n        isFocused,\n        isHovering: !props.disabled && isHoveringInput,\n      }\n    }, [\n      isFocused,\n      isHoveringInput,\n      maxLength,\n      mirrorSelectionEnd,\n      mirrorSelectionStart,\n      props.disabled,\n      value,\n    ])\n\n    const renderedChildren = React.useMemo(() => {\n      if (render) {\n        return render(contextValue)\n      }\n      return (\n        <OTPInputContext.Provider value={contextValue}>\n          {children}\n        </OTPInputContext.Provider>\n      )\n    }, [children, contextValue, render])\n\n    return (\n      <>\n        {noScriptCSSFallback !== null && (\n          <noscript>\n            <style>{noScriptCSSFallback}</style>\n          </noscript>\n        )}\n\n        <div\n          ref={containerRef}\n          data-input-otp-container\n          style={rootStyle}\n          className={containerClassName}\n        >\n          {renderedChildren}\n\n          <div\n            style={{\n              position: 'absolute',\n              inset: 0,\n              pointerEvents: 'none',\n            }}\n          >\n            {renderedInput}\n          </div>\n        </div>\n      </>\n    )\n  },\n)\nOTPInput.displayName = 'Input'\n\nfunction safeInsertRule(sheet: CSSStyleSheet, rule: string) {\n  try {\n    sheet.insertRule(rule)\n  } catch {\n    console.error('input-otp could not insert CSS rule:', rule)\n  }\n}\n\n// Decided to go with <noscript>\n// instead of `scripting` CSS media query\n// because it's a fallback for initial page load\n// and the <script> tag won't be loaded\n// unless the user has JS disabled.\nconst NOSCRIPT_CSS_FALLBACK = `\n[data-input-otp] {\n  --nojs-bg: white !important;\n  --nojs-fg: black !important;\n\n  background-color: var(--nojs-bg) !important;\n  color: var(--nojs-fg) !important;\n  caret-color: var(--nojs-fg) !important;\n  letter-spacing: .25em !important;\n  text-align: center !important;\n  border: 1px solid var(--nojs-fg) !important;\n  border-radius: 4px !important;\n  width: 100% !important;\n}\n@media (prefers-color-scheme: dark) {\n  [data-input-otp] {\n    --nojs-bg: black !important;\n    --nojs-fg: white !important;\n  }\n}`\n","export function syncTimeouts(cb: (...args: any[]) => unknown): number[] {\n  const t1 = setTimeout(cb, 0) // For faster machines\n  const t2 = setTimeout(cb, 1_0)\n  const t3 = setTimeout(cb, 5_0)\n  return [t1, t2, t3]\n}\n","import * as React from 'react'\n\nexport function usePrevious<T>(value: T) {\n  const ref = React.useRef<T>()\n  React.useEffect(() => {\n    ref.current = value\n  })\n  return ref.current\n}\n","import * as React from 'react'\nimport { OTPInputProps } from './types'\n\nconst PWM_BADGE_MARGIN_RIGHT = 18\nconst PWM_BADGE_SPACE_WIDTH_PX = 40\nconst PWM_BADGE_SPACE_WIDTH = `${PWM_BADGE_SPACE_WIDTH_PX}px` as const\n\nconst PASSWORD_MANAGERS_SELECTORS = [\n  '[data-lastpass-icon-root]', // LastPass\n  'com-1password-button', // 1Password\n  '[data-dashlanecreated]', // Dashlane\n  '[style$=\"2147483647 !important;\"]', // Bitwarden\n].join(',')\n\nexport function usePasswordManagerBadge({\n  containerRef,\n  inputRef,\n  pushPasswordManagerStrategy,\n  isFocused,\n}: {\n  containerRef: React.RefObject<HTMLDivElement>\n  inputRef: React.RefObject<HTMLInputElement>\n  pushPasswordManagerStrategy: OTPInputProps['pushPasswordManagerStrategy']\n  isFocused: boolean\n}) {\n  /** Password managers have a badge\n   *  and I'll use this state to push them\n   *  outside the input */\n  const [hasPWMBadge, setHasPWMBadge] = React.useState(false)\n  const [hasPWMBadgeSpace, setHasPWMBadgeSpace] = React.useState(false)\n  const [done, setDone] = React.useState(false)\n\n  const willPushPWMBadge = React.useMemo(() => {\n    if (pushPasswordManagerStrategy === 'none') {\n      return false\n    }\n\n    const increaseWidthCase =\n      (pushPasswordManagerStrategy === 'increase-width' ||\n        // TODO: remove 'experimental-no-flickering' support in 2.0.0\n        pushPasswordManagerStrategy === 'experimental-no-flickering') &&\n      hasPWMBadge &&\n      hasPWMBadgeSpace\n\n    return increaseWidthCase\n  }, [hasPWMBadge, hasPWMBadgeSpace, pushPasswordManagerStrategy])\n\n  const trackPWMBadge = React.useCallback(() => {\n    const container = containerRef.current\n    const input = inputRef.current\n    if (\n      !container ||\n      !input ||\n      done ||\n      pushPasswordManagerStrategy === 'none'\n    ) {\n      return\n    }\n\n    const elementToCompare = container\n\n    // Get the top right-center point of the container.\n    // That is usually where most password managers place their badge.\n    const rightCornerX =\n      elementToCompare.getBoundingClientRect().left +\n      elementToCompare.offsetWidth\n    const centereredY =\n      elementToCompare.getBoundingClientRect().top +\n      elementToCompare.offsetHeight / 2\n    const x = rightCornerX - PWM_BADGE_MARGIN_RIGHT\n    const y = centereredY\n\n    // Do an extra search to check for famous password managers\n    const pmws = document.querySelectorAll(PASSWORD_MANAGERS_SELECTORS)\n\n    // If no password manager is automatically detect,\n    // we'll try to dispatch document.elementFromPoint\n    // to identify badges\n    if (pmws.length === 0) {\n      const maybeBadgeEl = document.elementFromPoint(x, y)\n\n      // If the found element is the input itself,\n      // then we assume it's not a password manager badge.\n      // We are not sure. Most times that means there isn't a badge.\n      if (maybeBadgeEl === container) {\n        return\n      }\n    }\n\n    setHasPWMBadge(true)\n    setDone(true)\n  }, [containerRef, inputRef, done, pushPasswordManagerStrategy])\n\n  React.useEffect(() => {\n    const container = containerRef.current\n    if (!container || pushPasswordManagerStrategy === 'none') {\n      return\n    }\n\n    // Check if the PWM area is 100% visible\n    function checkHasSpace() {\n      const viewportWidth = window.innerWidth\n      const distanceToRightEdge =\n        viewportWidth - container.getBoundingClientRect().right\n      setHasPWMBadgeSpace(distanceToRightEdge >= PWM_BADGE_SPACE_WIDTH_PX)\n    }\n\n    checkHasSpace()\n    const interval = setInterval(checkHasSpace, 1000)\n\n    return () => {\n      clearInterval(interval)\n    }\n  }, [containerRef, pushPasswordManagerStrategy])\n\n  React.useEffect(() => {\n    const _isFocused = isFocused || document.activeElement === inputRef.current\n\n    if (pushPasswordManagerStrategy === 'none' || !_isFocused) {\n      return\n    }\n    const t1 = setTimeout(trackPWMBadge, 0)\n    const t2 = setTimeout(trackPWMBadge, 2000)\n    const t3 = setTimeout(trackPWMBadge, 5000)\n    const t4 = setTimeout(() => {\n      setDone(true)\n    }, 6000)\n    return () => {\n      clearTimeout(t1)\n      clearTimeout(t2)\n      clearTimeout(t3)\n      clearTimeout(t4)\n    }\n  }, [inputRef, isFocused, pushPasswordManagerStrategy, trackPWMBadge])\n\n  return { hasPWMBadge, willPushPWMBadge, PWM_BADGE_SPACE_WIDTH }\n}\n","export const REGEXP_ONLY_DIGITS = '^\\\\d+$'\nexport const REGEXP_ONLY_CHARS = '^[a-zA-Z]+$'\nexport const REGEXP_ONLY_DIGITS_AND_CHARS = '^[a-zA-Z0-9]+$'\n"],"mappings":"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","names":["src_exports","__export","OTPInput","OTPInputContext","REGEXP_ONLY_CHARS","REGEXP_ONLY_DIGITS","REGEXP_ONLY_DIGITS_AND_CHARS","__toCommonJS","React","syncTimeouts","cb","t1","t2","t3","React","usePrevious","value","ref","React","PWM_BADGE_MARGIN_RIGHT","PWM_BADGE_SPACE_WIDTH_PX","PWM_BADGE_SPACE_WIDTH","PASSWORD_MANAGERS_SELECTORS","usePasswordManagerBadge","containerRef","inputRef","pushPasswordManagerStrategy","isFocused","hasPWMBadge","setHasPWMBadge","hasPWMBadgeSpace","setHasPWMBadgeSpace","done","setDone","willPushPWMBadge","trackPWMBadge","container","input","elementToCompare","rightCornerX","centereredY","x","y","checkHasSpace","distanceToRightEdge","interval","_isFocused","t1","t2","t3","t4","OTPInputContext","OTPInput","_a","ref","_b","uncheckedValue","uncheckedOnChange","maxLength","textAlign","pattern","placeholder","inputMode","onComplete","pushPasswordManagerStrategy","pasteTransformer","containerClassName","noScriptCSSFallback","NOSCRIPT_CSS_FALLBACK","render","children","props","__objRest","_c","_d","_e","internalValue","setInternalValue","value","previousValue","usePrevious","onChange","newValue","regexp","inputRef","containerRef","initialLoadRef","inputMetadataRef","input","container","onDocumentSelectionChange","setMirrorSelectionStart","setMirrorSelectionEnd","_s","_dir","_ml","_val","_prev","start","end","direction","isSingleCaret","isInsertMode","c","offset","wasPreviouslyInserting","s","e","dir","setIsFocused","styleEl","autofillStyles","safeInsertRule","updateRootHeight","resizeObserver","isHoveringInput","setIsHoveringInput","isFocused","mirrorSelectionStart","mirrorSelectionEnd","syncTimeouts","pwmb","usePasswordManagerBadge","_changeListener","_focusListener","_pasteListener","_content","content","_start","_end","rootStyle","inputStyle","renderedInput","__spreadProps","__spreadValues","contextValue","_","slotIdx","isActive","char","placeholderChar","renderedChildren","sheet","rule","REGEXP_ONLY_DIGITS","REGEXP_ONLY_CHARS","REGEXP_ONLY_DIGITS_AND_CHARS"]}
~~~

## node_modules\input-otp\dist\index.mjs

~~~mjs
var Bt=Object.defineProperty,At=Object.defineProperties;var kt=Object.getOwnPropertyDescriptors;var Y=Object.getOwnPropertySymbols;var gt=Object.prototype.hasOwnProperty,Et=Object.prototype.propertyIsEnumerable;var vt=(r,s,e)=>s in r?Bt(r,s,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[s]=e,St=(r,s)=>{for(var e in s||(s={}))gt.call(s,e)&&vt(r,e,s[e]);if(Y)for(var e of Y(s))Et.call(s,e)&&vt(r,e,s[e]);return r},bt=(r,s)=>At(r,kt(s));var Pt=(r,s)=>{var e={};for(var u in r)gt.call(r,u)&&s.indexOf(u)<0&&(e[u]=r[u]);if(r!=null&&Y)for(var u of Y(r))s.indexOf(u)<0&&Et.call(r,u)&&(e[u]=r[u]);return e};import*as n from"react";function ht(r){let s=setTimeout(r,0),e=setTimeout(r,10),u=setTimeout(r,50);return[s,e,u]}import*as U from"react";function _t(r){let s=U.useRef();return U.useEffect(()=>{s.current=r}),s.current}import*as S from"react";var Ot=18,wt=40,Gt=`${wt}px`,xt=["[data-lastpass-icon-root]","com-1password-button","[data-dashlanecreated]",'[style$="2147483647 !important;"]'].join(",");function Tt({containerRef:r,inputRef:s,pushPasswordManagerStrategy:e,isFocused:u}){let[P,D]=S.useState(!1),[G,H]=S.useState(!1),[F,W]=S.useState(!1),Z=S.useMemo(()=>e==="none"?!1:(e==="increase-width"||e==="experimental-no-flickering")&&P&&G,[P,G,e]),T=S.useCallback(()=>{let f=r.current,h=s.current;if(!f||!h||F||e==="none")return;let a=f,B=a.getBoundingClientRect().left+a.offsetWidth,A=a.getBoundingClientRect().top+a.offsetHeight/2,z=B-Ot,q=A;document.querySelectorAll(xt).length===0&&document.elementFromPoint(z,q)===f||(D(!0),W(!0))},[r,s,F,e]);return S.useEffect(()=>{let f=r.current;if(!f||e==="none")return;function h(){let A=window.innerWidth-f.getBoundingClientRect().right;H(A>=wt)}h();let a=setInterval(h,1e3);return()=>{clearInterval(a)}},[r,e]),S.useEffect(()=>{let f=u||document.activeElement===s.current;if(e==="none"||!f)return;let h=setTimeout(T,0),a=setTimeout(T,2e3),B=setTimeout(T,5e3),A=setTimeout(()=>{W(!0)},6e3);return()=>{clearTimeout(h),clearTimeout(a),clearTimeout(B),clearTimeout(A)}},[s,u,e,T]),{hasPWMBadge:P,willPushPWMBadge:Z,PWM_BADGE_SPACE_WIDTH:Gt}}var jt=n.createContext({}),Lt=n.forwardRef((A,B)=>{var z=A,{value:r,onChange:s,maxLength:e,textAlign:u="left",pattern:P,placeholder:D,inputMode:G="numeric",onComplete:H,pushPasswordManagerStrategy:F="increase-width",pasteTransformer:W,containerClassName:Z,noScriptCSSFallback:T=Nt,render:f,children:h}=z,a=Pt(z,["value","onChange","maxLength","textAlign","pattern","placeholder","inputMode","onComplete","pushPasswordManagerStrategy","pasteTransformer","containerClassName","noScriptCSSFallback","render","children"]);var X,lt,ut,dt,ft;let[q,nt]=n.useState(typeof a.defaultValue=="string"?a.defaultValue:""),i=r!=null?r:q,I=_t(i),x=n.useCallback(t=>{s==null||s(t),nt(t)},[s]),m=n.useMemo(()=>P?typeof P=="string"?new RegExp(P):P:null,[P]),l=n.useRef(null),K=n.useRef(null),J=n.useRef({value:i,onChange:x,isIOS:typeof window!="undefined"&&((lt=(X=window==null?void 0:window.CSS)==null?void 0:X.supports)==null?void 0:lt.call(X,"-webkit-touch-callout","none"))}),V=n.useRef({prev:[(ut=l.current)==null?void 0:ut.selectionStart,(dt=l.current)==null?void 0:dt.selectionEnd,(ft=l.current)==null?void 0:ft.selectionDirection]});n.useImperativeHandle(B,()=>l.current,[]),n.useEffect(()=>{let t=l.current,o=K.current;if(!t||!o)return;J.current.value!==t.value&&J.current.onChange(t.value),V.current.prev=[t.selectionStart,t.selectionEnd,t.selectionDirection];function d(){if(document.activeElement!==t){L(null),N(null);return}let c=t.selectionStart,b=t.selectionEnd,mt=t.selectionDirection,v=t.maxLength,C=t.value,_=V.current.prev,g=-1,E=-1,w;if(C.length!==0&&c!==null&&b!==null){let Dt=c===b,Ht=c===C.length&&C.length<v;if(Dt&&!Ht){let y=c;if(y===0)g=0,E=1,w="forward";else if(y===v)g=y-1,E=y,w="backward";else if(v>1&&C.length>1){let et=0;if(_[0]!==null&&_[1]!==null){w=y<_[1]?"backward":"forward";let Wt=_[0]===_[1]&&_[0]<v;w==="backward"&&!Wt&&(et=-1)}g=et+y,E=et+y+1}}g!==-1&&E!==-1&&g!==E&&l.current.setSelectionRange(g,E,w)}let pt=g!==-1?g:c,Rt=E!==-1?E:b,yt=w!=null?w:mt;L(pt),N(Rt),V.current.prev=[pt,Rt,yt]}if(document.addEventListener("selectionchange",d,{capture:!0}),d(),document.activeElement===t&&Q(!0),!document.getElementById("input-otp-style")){let c=document.createElement("style");if(c.id="input-otp-style",document.head.appendChild(c),c.sheet){let b="background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;";$(c.sheet,"[data-input-otp]::selection { background: transparent !important; color: transparent !important; }"),$(c.sheet,`[data-input-otp]:autofill { ${b} }`),$(c.sheet,`[data-input-otp]:-webkit-autofill { ${b} }`),$(c.sheet,"@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }"),$(c.sheet,"[data-input-otp] + * { pointer-events: all !important; }")}}let R=()=>{o&&o.style.setProperty("--root-height",`${t.clientHeight}px`)};R();let p=new ResizeObserver(R);return p.observe(t),()=>{document.removeEventListener("selectionchange",d,{capture:!0}),p.disconnect()}},[]);let[ot,rt]=n.useState(!1),[j,Q]=n.useState(!1),[M,L]=n.useState(null),[k,N]=n.useState(null);n.useEffect(()=>{ht(()=>{var R,p,c,b;(R=l.current)==null||R.dispatchEvent(new Event("input"));let t=(p=l.current)==null?void 0:p.selectionStart,o=(c=l.current)==null?void 0:c.selectionEnd,d=(b=l.current)==null?void 0:b.selectionDirection;t!==null&&o!==null&&(L(t),N(o),V.current.prev=[t,o,d])})},[i,j]),n.useEffect(()=>{I!==void 0&&i!==I&&I.length<e&&i.length===e&&(H==null||H(i))},[e,H,I,i]);let O=Tt({containerRef:K,inputRef:l,pushPasswordManagerStrategy:F,isFocused:j}),st=n.useCallback(t=>{let o=t.currentTarget.value.slice(0,e);if(o.length>0&&m&&!m.test(o)){t.preventDefault();return}typeof I=="string"&&o.length<I.length&&document.dispatchEvent(new Event("selectionchange")),x(o)},[e,x,I,m]),at=n.useCallback(()=>{var t;if(l.current){let o=Math.min(l.current.value.length,e-1),d=l.current.value.length;(t=l.current)==null||t.setSelectionRange(o,d),L(o),N(d)}Q(!0)},[e]),ct=n.useCallback(t=>{var g,E;let o=l.current;if(!W&&(!J.current.isIOS||!t.clipboardData||!o))return;let d=t.clipboardData.getData("text/plain"),R=W?W(d):d;t.preventDefault();let p=(g=l.current)==null?void 0:g.selectionStart,c=(E=l.current)==null?void 0:E.selectionEnd,v=(p!==c?i.slice(0,p)+R+i.slice(c):i.slice(0,p)+R+i.slice(p)).slice(0,e);if(v.length>0&&m&&!m.test(v))return;o.value=v,x(v);let C=Math.min(v.length,e-1),_=v.length;o.setSelectionRange(C,_),L(C),N(_)},[e,x,m,i]),It=n.useMemo(()=>({position:"relative",cursor:a.disabled?"default":"text",userSelect:"none",WebkitUserSelect:"none",pointerEvents:"none"}),[a.disabled]),it=n.useMemo(()=>({position:"absolute",inset:0,width:O.willPushPWMBadge?`calc(100% + ${O.PWM_BADGE_SPACE_WIDTH})`:"100%",clipPath:O.willPushPWMBadge?`inset(0 ${O.PWM_BADGE_SPACE_WIDTH} 0 0)`:void 0,height:"100%",display:"flex",textAlign:u,opacity:"1",color:"transparent",pointerEvents:"all",background:"transparent",caretColor:"transparent",border:"0 solid transparent",outline:"0 solid transparent",boxShadow:"none",lineHeight:"1",letterSpacing:"-.5em",fontSize:"var(--root-height)",fontFamily:"monospace",fontVariantNumeric:"tabular-nums"}),[O.PWM_BADGE_SPACE_WIDTH,O.willPushPWMBadge,u]),Mt=n.useMemo(()=>n.createElement("input",bt(St({autoComplete:a.autoComplete||"one-time-code"},a),{"data-input-otp":!0,"data-input-otp-placeholder-shown":i.length===0||void 0,"data-input-otp-mss":M,"data-input-otp-mse":k,inputMode:G,pattern:m==null?void 0:m.source,"aria-placeholder":D,style:it,maxLength:e,value:i,ref:l,onPaste:t=>{var o;ct(t),(o=a.onPaste)==null||o.call(a,t)},onChange:st,onMouseOver:t=>{var o;rt(!0),(o=a.onMouseOver)==null||o.call(a,t)},onMouseLeave:t=>{var o;rt(!1),(o=a.onMouseLeave)==null||o.call(a,t)},onFocus:t=>{var o;at(),(o=a.onFocus)==null||o.call(a,t)},onBlur:t=>{var o;Q(!1),(o=a.onBlur)==null||o.call(a,t)}})),[st,at,ct,G,it,e,k,M,a,m==null?void 0:m.source,i]),tt=n.useMemo(()=>({slots:Array.from({length:e}).map((t,o)=>{var c;let d=j&&M!==null&&k!==null&&(M===k&&o===M||o>=M&&o<k),R=i[o]!==void 0?i[o]:null,p=i[0]!==void 0?null:(c=D==null?void 0:D[o])!=null?c:null;return{char:R,placeholderChar:p,isActive:d,hasFakeCaret:d&&R===null}}),isFocused:j,isHovering:!a.disabled&&ot}),[j,ot,e,k,M,a.disabled,i]),Ct=n.useMemo(()=>f?f(tt):n.createElement(jt.Provider,{value:tt},h),[h,tt,f]);return n.createElement(n.Fragment,null,T!==null&&n.createElement("noscript",null,n.createElement("style",null,T)),n.createElement("div",{ref:K,"data-input-otp-container":!0,style:It,className:Z},Ct,n.createElement("div",{style:{position:"absolute",inset:0,pointerEvents:"none"}},Mt)))});Lt.displayName="Input";function $(r,s){try{r.insertRule(s)}catch(e){console.error("input-otp could not insert CSS rule:",s)}}var Nt=`
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`;var Kt="^\\d+$",Jt="^[a-zA-Z]+$",Qt="^[a-zA-Z0-9]+$";export{Lt as OTPInput,jt as OTPInputContext,Jt as REGEXP_ONLY_CHARS,Kt as REGEXP_ONLY_DIGITS,Qt as REGEXP_ONLY_DIGITS_AND_CHARS};
//# sourceMappingURL=index.mjs.map
~~~

## node_modules\input-otp\dist\index.mjs.map

~~~map
{"version":3,"sources":["../src/input.tsx","../src/sync-timeouts.ts","../src/use-previous.ts","../src/use-pwm-badge.tsx","../src/regexp.ts"],"sourcesContent":["'use client'\n\nimport * as React from 'react'\n\nimport { syncTimeouts } from './sync-timeouts'\nimport { OTPInputProps, RenderProps } from './types'\nimport { usePrevious } from './use-previous'\nimport { usePasswordManagerBadge } from './use-pwm-badge'\n\nexport const OTPInputContext = React.createContext<RenderProps>(\n  {} as RenderProps,\n)\n\nexport const OTPInput = React.forwardRef<HTMLInputElement, OTPInputProps>(\n  (\n    {\n      value: uncheckedValue,\n      onChange: uncheckedOnChange,\n      maxLength,\n      textAlign = 'left',\n      pattern,\n      placeholder,\n      inputMode = 'numeric',\n      onComplete,\n      pushPasswordManagerStrategy = 'increase-width',\n      pasteTransformer,\n      containerClassName,\n      noScriptCSSFallback = NOSCRIPT_CSS_FALLBACK,\n\n      render,\n      children,\n\n      ...props\n    },\n    ref,\n  ) => {\n    // Only used when `value` state is not provided\n    const [internalValue, setInternalValue] = React.useState(\n      typeof props.defaultValue === 'string' ? props.defaultValue : '',\n    )\n\n    // Definitions\n    const value = uncheckedValue ?? internalValue\n    const previousValue = usePrevious(value)\n    const onChange = React.useCallback(\n      (newValue: string) => {\n        uncheckedOnChange?.(newValue)\n        setInternalValue(newValue)\n      },\n      [uncheckedOnChange],\n    )\n    const regexp = React.useMemo(\n      () =>\n        pattern\n          ? typeof pattern === 'string'\n            ? new RegExp(pattern)\n            : pattern\n          : null,\n      [pattern],\n    )\n\n    /** useRef */\n    const inputRef = React.useRef<HTMLInputElement>(null)\n    const containerRef = React.useRef<HTMLDivElement>(null)\n    const initialLoadRef = React.useRef({\n      value,\n      onChange,\n      isIOS:\n        typeof window !== 'undefined' &&\n        window?.CSS?.supports?.('-webkit-touch-callout', 'none'),\n    })\n    const inputMetadataRef = React.useRef<{\n      prev: [number | null, number | null, 'none' | 'forward' | 'backward']\n    }>({\n      prev: [\n        inputRef.current?.selectionStart,\n        inputRef.current?.selectionEnd,\n        inputRef.current?.selectionDirection,\n      ],\n    })\n    React.useImperativeHandle(ref, () => inputRef.current, [])\n    React.useEffect(() => {\n      const input = inputRef.current\n      const container = containerRef.current\n\n      if (!input || !container) {\n        return\n      }\n\n      // Sync input value\n      if (initialLoadRef.current.value !== input.value) {\n        initialLoadRef.current.onChange(input.value)\n      }\n\n      // Previous selection\n      inputMetadataRef.current.prev = [\n        input.selectionStart,\n        input.selectionEnd,\n        input.selectionDirection,\n      ]\n      function onDocumentSelectionChange() {\n        if (document.activeElement !== input) {\n          setMirrorSelectionStart(null)\n          setMirrorSelectionEnd(null)\n          return\n        }\n\n        // Aliases\n        const _s = input.selectionStart\n        const _e = input.selectionEnd\n        const _dir = input.selectionDirection\n        const _ml = input.maxLength\n        const _val = input.value\n        const _prev = inputMetadataRef.current.prev\n\n        // Algorithm\n        let start = -1\n        let end = -1\n        let direction: 'forward' | 'backward' | 'none' = undefined\n        if (_val.length !== 0 && _s !== null && _e !== null) {\n          const isSingleCaret = _s === _e\n          const isInsertMode = _s === _val.length && _val.length < _ml\n\n          if (isSingleCaret && !isInsertMode) {\n            const c = _s\n            if (c === 0) {\n              start = 0\n              end = 1\n              direction = 'forward'\n            } else if (c === _ml) {\n              start = c - 1\n              end = c\n              direction = 'backward'\n            } else if (_ml > 1 && _val.length > 1) {\n              let offset = 0\n              if (_prev[0] !== null && _prev[1] !== null) {\n                direction = c < _prev[1] ? 'backward' : 'forward'\n                const wasPreviouslyInserting =\n                  _prev[0] === _prev[1] && _prev[0] < _ml\n                if (direction === 'backward' && !wasPreviouslyInserting) {\n                  offset = -1\n                }\n              }\n\n              start = offset + c\n              end = offset + c + 1\n            }\n          }\n\n          if (start !== -1 && end !== -1 && start !== end) {\n            inputRef.current.setSelectionRange(start, end, direction)\n          }\n        }\n\n        // Finally, update the state\n        const s = start !== -1 ? start : _s\n        const e = end !== -1 ? end : _e\n        const dir = direction ?? _dir\n        setMirrorSelectionStart(s)\n        setMirrorSelectionEnd(e)\n        // Store the previous selection value\n        inputMetadataRef.current.prev = [s, e, dir]\n      }\n      document.addEventListener('selectionchange', onDocumentSelectionChange, {\n        capture: true,\n      })\n\n      // Set initial mirror state\n      onDocumentSelectionChange()\n      document.activeElement === input && setIsFocused(true)\n\n      // Apply needed styles\n      if (!document.getElementById('input-otp-style')) {\n        const styleEl = document.createElement('style')\n        styleEl.id = 'input-otp-style'\n        document.head.appendChild(styleEl)\n\n        if (styleEl.sheet) {\n          const autofillStyles =\n            'background: transparent !important; color: transparent !important; border-color: transparent !important; opacity: 0 !important; box-shadow: none !important; -webkit-box-shadow: none !important; -webkit-text-fill-color: transparent !important;'\n\n          safeInsertRule(\n            styleEl.sheet,\n            '[data-input-otp]::selection { background: transparent !important; color: transparent !important; }',\n          )\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp]:autofill { ${autofillStyles} }`,\n          )\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp]:-webkit-autofill { ${autofillStyles} }`,\n          )\n          // iOS\n          safeInsertRule(\n            styleEl.sheet,\n            `@supports (-webkit-touch-callout: none) { [data-input-otp] { letter-spacing: -.6em !important; font-weight: 100 !important; font-stretch: ultra-condensed; font-optical-sizing: none !important; left: -1px !important; right: 1px !important; } }`,\n          )\n          // PWM badges\n          safeInsertRule(\n            styleEl.sheet,\n            `[data-input-otp] + * { pointer-events: all !important; }`,\n          )\n        }\n      }\n      // Track root height\n      const updateRootHeight = () => {\n        if (container) {\n          container.style.setProperty(\n            '--root-height',\n            `${input.clientHeight}px`,\n          )\n        }\n      }\n      updateRootHeight()\n      const resizeObserver = new ResizeObserver(updateRootHeight)\n      resizeObserver.observe(input)\n\n      return () => {\n        document.removeEventListener(\n          'selectionchange',\n          onDocumentSelectionChange,\n          { capture: true },\n        )\n        resizeObserver.disconnect()\n      }\n    }, [])\n\n    /** Mirrors for UI rendering purpose only */\n    const [isHoveringInput, setIsHoveringInput] = React.useState(false)\n    const [isFocused, setIsFocused] = React.useState(false)\n    const [mirrorSelectionStart, setMirrorSelectionStart] = React.useState<\n      number | null\n    >(null)\n    const [mirrorSelectionEnd, setMirrorSelectionEnd] = React.useState<\n      number | null\n    >(null)\n\n    /** Effects */\n    React.useEffect(() => {\n      syncTimeouts(() => {\n        // Forcefully remove :autofill state\n        inputRef.current?.dispatchEvent(new Event('input'))\n\n        // Update the selection state\n        const s = inputRef.current?.selectionStart\n        const e = inputRef.current?.selectionEnd\n        const dir = inputRef.current?.selectionDirection\n        if (s !== null && e !== null) {\n          setMirrorSelectionStart(s)\n          setMirrorSelectionEnd(e)\n          inputMetadataRef.current.prev = [s, e, dir]\n        }\n      })\n    }, [value, isFocused])\n\n    React.useEffect(() => {\n      if (previousValue === undefined) {\n        return\n      }\n\n      if (\n        value !== previousValue &&\n        previousValue.length < maxLength &&\n        value.length === maxLength\n      ) {\n        onComplete?.(value)\n      }\n    }, [maxLength, onComplete, previousValue, value])\n\n    const pwmb = usePasswordManagerBadge({\n      containerRef,\n      inputRef,\n      pushPasswordManagerStrategy,\n      isFocused,\n    })\n\n    /** Event handlers */\n    const _changeListener = React.useCallback(\n      (e: React.ChangeEvent<HTMLInputElement>) => {\n        const newValue = e.currentTarget.value.slice(0, maxLength)\n        if (newValue.length > 0 && regexp && !regexp.test(newValue)) {\n          e.preventDefault()\n          return\n        }\n        const maybeHasDeleted =\n          typeof previousValue === 'string' &&\n          newValue.length < previousValue.length\n        if (maybeHasDeleted) {\n          // Since cutting/deleting text doesn't trigger\n          // selectionchange event, we'll have to dispatch it manually.\n          // NOTE: The following line also triggers when cmd+A then pasting\n          // a value with smaller length, which is not ideal for performance.\n          document.dispatchEvent(new Event('selectionchange'))\n        }\n        onChange(newValue)\n      },\n      [maxLength, onChange, previousValue, regexp],\n    )\n    const _focusListener = React.useCallback(() => {\n      if (inputRef.current) {\n        const start = Math.min(inputRef.current.value.length, maxLength - 1)\n        const end = inputRef.current.value.length\n        inputRef.current?.setSelectionRange(start, end)\n        setMirrorSelectionStart(start)\n        setMirrorSelectionEnd(end)\n      }\n      setIsFocused(true)\n    }, [maxLength])\n    // Fix iOS pasting\n    const _pasteListener = React.useCallback(\n      (e: React.ClipboardEvent<HTMLInputElement>) => {\n        const input = inputRef.current\n        if (!pasteTransformer && (!initialLoadRef.current.isIOS || !e.clipboardData || !input)) {\n          return\n        }\n        \n        const _content = e.clipboardData.getData('text/plain')\n        const content = pasteTransformer\n          ? pasteTransformer(_content)\n          : _content\n        e.preventDefault()\n\n        const start = inputRef.current?.selectionStart\n        const end = inputRef.current?.selectionEnd\n\n        const isReplacing = start !== end\n\n        const newValueUncapped = isReplacing\n          ? value.slice(0, start) + content + value.slice(end) // Replacing\n          : value.slice(0, start) + content + value.slice(start) // Inserting\n        const newValue = newValueUncapped.slice(0, maxLength)\n\n        if (newValue.length > 0 && regexp && !regexp.test(newValue)) {\n          return\n        }\n\n        input.value = newValue\n        onChange(newValue)\n\n        const _start = Math.min(newValue.length, maxLength - 1)\n        const _end = newValue.length\n\n        input.setSelectionRange(_start, _end)\n        setMirrorSelectionStart(_start)\n        setMirrorSelectionEnd(_end)\n      },\n      [maxLength, onChange, regexp, value],\n    )\n\n    /** Styles */\n    const rootStyle = React.useMemo<React.CSSProperties>(\n      () => ({\n        position: 'relative',\n        cursor: props.disabled ? 'default' : 'text',\n        userSelect: 'none',\n        WebkitUserSelect: 'none',\n        pointerEvents: 'none',\n      }),\n      [props.disabled],\n    )\n\n    const inputStyle = React.useMemo<React.CSSProperties>(\n      () => ({\n        position: 'absolute',\n        inset: 0,\n        width: pwmb.willPushPWMBadge\n          ? `calc(100% + ${pwmb.PWM_BADGE_SPACE_WIDTH})`\n          : '100%',\n        clipPath: pwmb.willPushPWMBadge\n          ? `inset(0 ${pwmb.PWM_BADGE_SPACE_WIDTH} 0 0)`\n          : undefined,\n        height: '100%',\n        display: 'flex',\n        textAlign,\n        opacity: '1', // Mandatory for iOS hold-paste\n        color: 'transparent',\n        pointerEvents: 'all',\n        background: 'transparent',\n        caretColor: 'transparent',\n        border: '0 solid transparent',\n        outline: '0 solid transparent',\n        boxShadow: 'none',\n        lineHeight: '1',\n        letterSpacing: '-.5em',\n        fontSize: 'var(--root-height)',\n        fontFamily: 'monospace',\n        fontVariantNumeric: 'tabular-nums',\n        // letterSpacing: '-1em',\n        // transform: 'scale(1.5)',\n        // paddingRight: '100%',\n        // paddingBottom: '100%',\n        // debugging purposes\n        // inset: undefined,\n        // position: undefined,\n        // color: 'black',\n        // background: 'white',\n        // opacity: '1',\n        // caretColor: 'black',\n        // padding: '0',\n        // letterSpacing: 'unset',\n        // fontSize: 'unset',\n        // paddingInline: '.5rem',\n      }),\n      [pwmb.PWM_BADGE_SPACE_WIDTH, pwmb.willPushPWMBadge, textAlign],\n    )\n\n    /** Rendering */\n    const renderedInput = React.useMemo(\n      () => (\n        <input\n          autoComplete={props.autoComplete || 'one-time-code'}\n          {...props}\n          data-input-otp\n          data-input-otp-placeholder-shown={value.length === 0 || undefined}\n          data-input-otp-mss={mirrorSelectionStart}\n          data-input-otp-mse={mirrorSelectionEnd}\n          inputMode={inputMode}\n          pattern={regexp?.source}\n          aria-placeholder={placeholder}\n          style={inputStyle}\n          maxLength={maxLength}\n          value={value}\n          ref={inputRef}\n          onPaste={e => {\n            _pasteListener(e)\n            props.onPaste?.(e)\n          }}\n          onChange={_changeListener}\n          onMouseOver={e => {\n            setIsHoveringInput(true)\n            props.onMouseOver?.(e)\n          }}\n          onMouseLeave={e => {\n            setIsHoveringInput(false)\n            props.onMouseLeave?.(e)\n          }}\n          onFocus={e => {\n            _focusListener()\n            props.onFocus?.(e)\n          }}\n          onBlur={e => {\n            setIsFocused(false)\n            props.onBlur?.(e)\n          }}\n        />\n      ),\n      [\n        _changeListener,\n        _focusListener,\n        _pasteListener,\n        inputMode,\n        inputStyle,\n        maxLength,\n        mirrorSelectionEnd,\n        mirrorSelectionStart,\n        props,\n        regexp?.source,\n        value,\n      ],\n    )\n\n    const contextValue = React.useMemo<RenderProps>(() => {\n      return {\n        slots: Array.from({ length: maxLength }).map((_, slotIdx) => {\n          const isActive =\n            isFocused &&\n            mirrorSelectionStart !== null &&\n            mirrorSelectionEnd !== null &&\n            ((mirrorSelectionStart === mirrorSelectionEnd &&\n              slotIdx === mirrorSelectionStart) ||\n              (slotIdx >= mirrorSelectionStart && slotIdx < mirrorSelectionEnd))\n\n          const char = value[slotIdx] !== undefined ? value[slotIdx] : null\n          const placeholderChar = value[0] !== undefined ? null : placeholder?.[slotIdx] ?? null\n\n          return {\n            char,\n            placeholderChar,\n            isActive,\n            hasFakeCaret: isActive && char === null,\n          }\n        }),\n        isFocused,\n        isHovering: !props.disabled && isHoveringInput,\n      }\n    }, [\n      isFocused,\n      isHoveringInput,\n      maxLength,\n      mirrorSelectionEnd,\n      mirrorSelectionStart,\n      props.disabled,\n      value,\n    ])\n\n    const renderedChildren = React.useMemo(() => {\n      if (render) {\n        return render(contextValue)\n      }\n      return (\n        <OTPInputContext.Provider value={contextValue}>\n          {children}\n        </OTPInputContext.Provider>\n      )\n    }, [children, contextValue, render])\n\n    return (\n      <>\n        {noScriptCSSFallback !== null && (\n          <noscript>\n            <style>{noScriptCSSFallback}</style>\n          </noscript>\n        )}\n\n        <div\n          ref={containerRef}\n          data-input-otp-container\n          style={rootStyle}\n          className={containerClassName}\n        >\n          {renderedChildren}\n\n          <div\n            style={{\n              position: 'absolute',\n              inset: 0,\n              pointerEvents: 'none',\n            }}\n          >\n            {renderedInput}\n          </div>\n        </div>\n      </>\n    )\n  },\n)\nOTPInput.displayName = 'Input'\n\nfunction safeInsertRule(sheet: CSSStyleSheet, rule: string) {\n  try {\n    sheet.insertRule(rule)\n  } catch {\n    console.error('input-otp could not insert CSS rule:', rule)\n  }\n}\n\n// Decided to go with <noscript>\n// instead of `scripting` CSS media query\n// because it's a fallback for initial page load\n// and the <script> tag won't be loaded\n// unless the user has JS disabled.\nconst NOSCRIPT_CSS_FALLBACK = `\n[data-input-otp] {\n  --nojs-bg: white !important;\n  --nojs-fg: black !important;\n\n  background-color: var(--nojs-bg) !important;\n  color: var(--nojs-fg) !important;\n  caret-color: var(--nojs-fg) !important;\n  letter-spacing: .25em !important;\n  text-align: center !important;\n  border: 1px solid var(--nojs-fg) !important;\n  border-radius: 4px !important;\n  width: 100% !important;\n}\n@media (prefers-color-scheme: dark) {\n  [data-input-otp] {\n    --nojs-bg: black !important;\n    --nojs-fg: white !important;\n  }\n}`\n","export function syncTimeouts(cb: (...args: any[]) => unknown): number[] {\n  const t1 = setTimeout(cb, 0) // For faster machines\n  const t2 = setTimeout(cb, 1_0)\n  const t3 = setTimeout(cb, 5_0)\n  return [t1, t2, t3]\n}\n","import * as React from 'react'\n\nexport function usePrevious<T>(value: T) {\n  const ref = React.useRef<T>()\n  React.useEffect(() => {\n    ref.current = value\n  })\n  return ref.current\n}\n","import * as React from 'react'\nimport { OTPInputProps } from './types'\n\nconst PWM_BADGE_MARGIN_RIGHT = 18\nconst PWM_BADGE_SPACE_WIDTH_PX = 40\nconst PWM_BADGE_SPACE_WIDTH = `${PWM_BADGE_SPACE_WIDTH_PX}px` as const\n\nconst PASSWORD_MANAGERS_SELECTORS = [\n  '[data-lastpass-icon-root]', // LastPass\n  'com-1password-button', // 1Password\n  '[data-dashlanecreated]', // Dashlane\n  '[style$=\"2147483647 !important;\"]', // Bitwarden\n].join(',')\n\nexport function usePasswordManagerBadge({\n  containerRef,\n  inputRef,\n  pushPasswordManagerStrategy,\n  isFocused,\n}: {\n  containerRef: React.RefObject<HTMLDivElement>\n  inputRef: React.RefObject<HTMLInputElement>\n  pushPasswordManagerStrategy: OTPInputProps['pushPasswordManagerStrategy']\n  isFocused: boolean\n}) {\n  /** Password managers have a badge\n   *  and I'll use this state to push them\n   *  outside the input */\n  const [hasPWMBadge, setHasPWMBadge] = React.useState(false)\n  const [hasPWMBadgeSpace, setHasPWMBadgeSpace] = React.useState(false)\n  const [done, setDone] = React.useState(false)\n\n  const willPushPWMBadge = React.useMemo(() => {\n    if (pushPasswordManagerStrategy === 'none') {\n      return false\n    }\n\n    const increaseWidthCase =\n      (pushPasswordManagerStrategy === 'increase-width' ||\n        // TODO: remove 'experimental-no-flickering' support in 2.0.0\n        pushPasswordManagerStrategy === 'experimental-no-flickering') &&\n      hasPWMBadge &&\n      hasPWMBadgeSpace\n\n    return increaseWidthCase\n  }, [hasPWMBadge, hasPWMBadgeSpace, pushPasswordManagerStrategy])\n\n  const trackPWMBadge = React.useCallback(() => {\n    const container = containerRef.current\n    const input = inputRef.current\n    if (\n      !container ||\n      !input ||\n      done ||\n      pushPasswordManagerStrategy === 'none'\n    ) {\n      return\n    }\n\n    const elementToCompare = container\n\n    // Get the top right-center point of the container.\n    // That is usually where most password managers place their badge.\n    const rightCornerX =\n      elementToCompare.getBoundingClientRect().left +\n      elementToCompare.offsetWidth\n    const centereredY =\n      elementToCompare.getBoundingClientRect().top +\n      elementToCompare.offsetHeight / 2\n    const x = rightCornerX - PWM_BADGE_MARGIN_RIGHT\n    const y = centereredY\n\n    // Do an extra search to check for famous password managers\n    const pmws = document.querySelectorAll(PASSWORD_MANAGERS_SELECTORS)\n\n    // If no password manager is automatically detect,\n    // we'll try to dispatch document.elementFromPoint\n    // to identify badges\n    if (pmws.length === 0) {\n      const maybeBadgeEl = document.elementFromPoint(x, y)\n\n      // If the found element is the input itself,\n      // then we assume it's not a password manager badge.\n      // We are not sure. Most times that means there isn't a badge.\n      if (maybeBadgeEl === container) {\n        return\n      }\n    }\n\n    setHasPWMBadge(true)\n    setDone(true)\n  }, [containerRef, inputRef, done, pushPasswordManagerStrategy])\n\n  React.useEffect(() => {\n    const container = containerRef.current\n    if (!container || pushPasswordManagerStrategy === 'none') {\n      return\n    }\n\n    // Check if the PWM area is 100% visible\n    function checkHasSpace() {\n      const viewportWidth = window.innerWidth\n      const distanceToRightEdge =\n        viewportWidth - container.getBoundingClientRect().right\n      setHasPWMBadgeSpace(distanceToRightEdge >= PWM_BADGE_SPACE_WIDTH_PX)\n    }\n\n    checkHasSpace()\n    const interval = setInterval(checkHasSpace, 1000)\n\n    return () => {\n      clearInterval(interval)\n    }\n  }, [containerRef, pushPasswordManagerStrategy])\n\n  React.useEffect(() => {\n    const _isFocused = isFocused || document.activeElement === inputRef.current\n\n    if (pushPasswordManagerStrategy === 'none' || !_isFocused) {\n      return\n    }\n    const t1 = setTimeout(trackPWMBadge, 0)\n    const t2 = setTimeout(trackPWMBadge, 2000)\n    const t3 = setTimeout(trackPWMBadge, 5000)\n    const t4 = setTimeout(() => {\n      setDone(true)\n    }, 6000)\n    return () => {\n      clearTimeout(t1)\n      clearTimeout(t2)\n      clearTimeout(t3)\n      clearTimeout(t4)\n    }\n  }, [inputRef, isFocused, pushPasswordManagerStrategy, trackPWMBadge])\n\n  return { hasPWMBadge, willPushPWMBadge, PWM_BADGE_SPACE_WIDTH }\n}\n","export const REGEXP_ONLY_DIGITS = '^\\\\d+$'\nexport const REGEXP_ONLY_CHARS = '^[a-zA-Z]+$'\nexport const REGEXP_ONLY_DIGITS_AND_CHARS = '^[a-zA-Z0-9]+$'\n"],"mappings":"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","names":["React","syncTimeouts","cb","t1","t2","t3","React","usePrevious","value","ref","React","PWM_BADGE_MARGIN_RIGHT","PWM_BADGE_SPACE_WIDTH_PX","PWM_BADGE_SPACE_WIDTH","PASSWORD_MANAGERS_SELECTORS","usePasswordManagerBadge","containerRef","inputRef","pushPasswordManagerStrategy","isFocused","hasPWMBadge","setHasPWMBadge","hasPWMBadgeSpace","setHasPWMBadgeSpace","done","setDone","willPushPWMBadge","trackPWMBadge","container","input","elementToCompare","rightCornerX","centereredY","x","y","checkHasSpace","distanceToRightEdge","interval","_isFocused","t1","t2","t3","t4","OTPInputContext","OTPInput","_a","ref","_b","uncheckedValue","uncheckedOnChange","maxLength","textAlign","pattern","placeholder","inputMode","onComplete","pushPasswordManagerStrategy","pasteTransformer","containerClassName","noScriptCSSFallback","NOSCRIPT_CSS_FALLBACK","render","children","props","__objRest","_c","_d","_e","internalValue","setInternalValue","value","previousValue","usePrevious","onChange","newValue","regexp","inputRef","containerRef","initialLoadRef","inputMetadataRef","input","container","onDocumentSelectionChange","setMirrorSelectionStart","setMirrorSelectionEnd","_s","_dir","_ml","_val","_prev","start","end","direction","isSingleCaret","isInsertMode","c","offset","wasPreviouslyInserting","s","e","dir","setIsFocused","styleEl","autofillStyles","safeInsertRule","updateRootHeight","resizeObserver","isHoveringInput","setIsHoveringInput","isFocused","mirrorSelectionStart","mirrorSelectionEnd","syncTimeouts","pwmb","usePasswordManagerBadge","_changeListener","_focusListener","_pasteListener","_content","content","_start","_end","rootStyle","inputStyle","renderedInput","__spreadProps","__spreadValues","contextValue","_","slotIdx","isActive","char","placeholderChar","renderedChildren","sheet","rule","REGEXP_ONLY_DIGITS","REGEXP_ONLY_CHARS","REGEXP_ONLY_DIGITS_AND_CHARS"]}
~~~

## node_modules\input-otp\package.json

~~~json
{
  "name": "input-otp",
  "version": "1.4.2",
  "author": "Guilherme Rodz <g@rodz.dev>",
  "description": "One-time password input component for React.",
  "license": "MIT",
  "homepage": "https://input-otp.rodz.dev/",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/guilhermerodz/input-otp.git",
    "directory": "packages/input-otp"
  },
  "bugs": {
    "url": "https://github.com/guilhermerodz/input-otp/issues"
  },
  "keywords": [
    "react",
    "otp",
    "input",
    "accessible"
  ],
  "main": "./dist/index.js",
  "module": "./dist/index.mjs",
  "types": "./dist/index.d.ts",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "module": "./dist/index.mjs",
      "import": "./dist/index.mjs",
      "require": "./dist/index.js",
      "default": "./dist/index.mjs"
    },
    "./package.json": "./package.json"
  },
  "scripts": {
    "type-check": "tsc --noEmit",
    "copy-readme": "cp ../../README.md ./README.md",
    "build": "run-s build:* copy-readme",
    "build:tsup": "tsup --dts --minify",
    "clean": "rimraf dist",
    "dev": "tsup --watch --dts",
    "lint": "run-p lint:*",
    "lint:eslint": "eslint src --ext .ts",
    "lint:eslint:fix": "eslint src --ext .ts --fix",
    "lint:format": "prettier --check \"src/**/*.ts\"",
    "lint:format:fix": "prettier --check \"src/**/*.ts\" --write",
    "lint:tsc": "tsc --project tsconfig.json --noEmit",
    "format": "prettier --write .",
    "release": "npm publish",
    "release:beta": "npm publish --tag beta"
  },
  "eslintConfig": {
    "root": true,
    "reportUnusedDisableDirectives": true,
    "ignorePatterns": [
      "**/build",
      "**/coverage",
      "**/dist"
    ],
    "parser": "@typescript-eslint/parser",
    "parserOptions": {
      "sourceType": "module",
      "ecmaVersion": 2020
    },
    "settings": {
      "import/parsers": {
        "@typescript-eslint/parser": [
          ".ts",
          ".tsx"
        ]
      },
      "import/resolver": {
        "typescript": true
      },
      "react": {
        "version": "detect"
      }
    },
    "plugins": [
      "@typescript-eslint",
      "import"
    ],
    "extends": [
      "plugin:react/jsx-runtime",
      "plugin:react-hooks/recommended",
      "eslint:recommended",
      "plugin:@typescript-eslint/recommended",
      "plugin:@typescript-eslint/stylistic",
      "plugin:import/recommended",
      "plugin:import/typescript",
      "prettier"
    ],
    "env": {
      "browser": true,
      "es2020": true
    },
    "rules": {
      "react/jsx-key": [
        "error",
        {
          "checkFragmentShorthand": true
        }
      ],
      "react-hooks/exhaustive-deps": "error",
      "@typescript-eslint/no-explicit-any": "off"
    }
  },
  "devDependencies": {
    "@types/react": "^18.2.55",
    "@types/react-dom": "^18.2.19",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.3.3"
  },
  "peerDependencies": {
    "react": "^16.8 || ^17.0 || ^18.0 || ^19.0.0 || ^19.0.0-rc",
    "react-dom": "^16.8 || ^17.0 || ^18.0 || ^19.0.0 || ^19.0.0-rc"
  }
}

~~~

## node_modules\input-otp\README.md

~~~md
# The only accessible & unstyled & full featured Input OTP component in the Web.

### OTP Input for React ?뵍 by [@guilhermerodz](https://twitter.com/guilherme_rodz)

https://github.com/guilhermerodz/input-otp/assets/10366880/753751f5-eda8-4145-a4b9-7ef51ca5e453

## Usage

```bash
npm install input-otp
```

Then import the component.

```diff
+'use client'
+import { OTPInput } from 'input-otp'

function MyForm() {
  return <form>
+   <OTPInput maxLength={6} render={({slots})  => (...)} />
  </form>
}
```

## Default example

The example below uses `tailwindcss` `@shadcn/ui` `tailwind-merge` `clsx`:

```tsx
'use client'
import { OTPInput, SlotProps } from 'input-otp'
<OTPInput
  maxLength={6}
  containerClassName="group flex items-center has-[:disabled]:opacity-30"
  render={({ slots }) => (
    <>
      <div className="flex">
        {slots.slice(0, 3).map((slot, idx) => (
          <Slot key={idx} {...slot} />
        ))}
      </div>

      <FakeDash />

      <div className="flex">
        {slots.slice(3).map((slot, idx) => (
          <Slot key={idx} {...slot} />
        ))}
      </div>
    </>
  )}
/>

// Feel free to copy. Uses @shadcn/ui tailwind colors.
function Slot(props: SlotProps) {
  return (
    <div
      className={cn(
        'relative w-10 h-14 text-[2rem]',
        'flex items-center justify-center',
        'transition-all duration-300',
        'border-border border-y border-r first:border-l first:rounded-l-md last:rounded-r-md',
        'group-hover:border-accent-foreground/20 group-focus-within:border-accent-foreground/20',
        'outline outline-0 outline-accent-foreground/20',
        { 'outline-4 outline-accent-foreground': props.isActive },
      )}
    >
      <div className="group-has-[input[data-input-otp-placeholder-shown]]:opacity-20">
        {props.char ?? props.placeholderChar}
      </div>
      {props.hasFakeCaret && <FakeCaret />}
    </div>
  )
}

// You can emulate a fake textbox caret!
function FakeCaret() {
  return (
    <div className="absolute pointer-events-none inset-0 flex items-center justify-center animate-caret-blink">
      <div className="w-px h-8 bg-white" />
    </div>
  )
}

// Inspired by Stripe's MFA input.
function FakeDash() {
  return (
    <div className="flex w-10 justify-center items-center">
      <div className="w-3 h-1 rounded-full bg-border" />
    </div>
  )
}

// tailwind.config.ts for the blinking caret animation.
const config = {
  theme: {
    extend: {
      keyframes: {
        'caret-blink': {
          '0%,70%,100%': { opacity: '1' },
          '20%,50%': { opacity: '0' },
        },
      },
      animation: {
        'caret-blink': 'caret-blink 1.2s ease-out infinite',
      },
    },
  },
}

// Small utility to merge class names.
import { clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

import type { ClassValue } from 'clsx'

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
```

## How it works

There's currently no native OTP/2FA/MFA input in HTML, which means people are either going with 1. a simple input design or 2. custom designs like this one.
This library works by rendering an invisible input as a sibling of the slots, contained by a `relative`ly positioned parent (the container root called _OTPInput_).

## Features

This is the most complete OTP input on the web. It's fully featured 

<details>
<summary>Supports iOS + Android copy-paste-cut</summary>

https://github.com/guilhermerodz/input-otp/assets/10366880/bdbdc96a-23da-4e89-bff8-990e6a1c4c23

</details>

<details>
<summary>Automatic OTP code retrieval from transport (e.g SMS)</summary>

By default, this input uses `autocomplete='one-time-code'` and it works as it's a single input. 

https://github.com/guilhermerodz/input-otp/assets/10366880/5705dac6-9159-443b-9c27-b52e93c60ea8

</details>

<details>
<summary>Supports screen readers (a11y)</summary>

Stripe was my first inspiration to build this library.

Take a look at Stripe's input. The screen reader does not behave like it normally should on a normal single input.
That's because Stripe's solution is to render a 1-digit input with "clone-divs" rendering a single char per div.

https://github.com/guilhermerodz/input-otp/assets/10366880/3d127aef-147c-4f28-9f6c-57a357a802d0

So we're rendering a single input with invisible/transparent colors instead.
The screen reader now gets to read it, but there is no appearance. Feel free to build whatever UI you want:

https://github.com/guilhermerodz/input-otp/assets/10366880/718710f0-2198-418c-8fa0-46c05ae5475d

</details>

<details>
<summary>Supports all keybindings</summary>

Should be able to support all keybindings of a common text input as it's an input.

https://github.com/guilhermerodz/input-otp/assets/10366880/185985c0-af64-48eb-92f9-2e59be9eb78f

</details>

<details>
<summary>Automatically optimizes for password managers</summary>


For password managers such as LastPass, 1Password, Dashlane or Bitwarden, `input-otp` will automatically detect them in the page and increase input width by ~40px to trick the password manager's browser extension and prevent the badge from rendering to the last/right slot of the input.

<img width="670" alt="image" src="https://github.com/guilhermerodz/input-otp/assets/10366880/9bb306ca-deff-4803-aa3d-148c594a540c">

- **This feature is optional and it's enabled by default. You can disable this optimization by adding `pushPasswordManagerStrategy="none"`.**
- **This feature does not cause visible layout shift.**

### Auto tracks if the input has space in the right side for the badge

https://github.com/guilhermerodz/input-otp/assets/10366880/bf01af88-1f82-463e-adf4-54a737a92f59

</details>

## API Reference

### OTPInput

The root container. Define settings for the input via props. Then, use the `render` prop to create the slots.

#### Props

```ts
type OTPInputProps = {
  // The number of slots
  maxLength: number

  // Render function creating the slots
  render: (props: RenderProps) => React.ReactElement
  // PS: Render prop is mandatory, except in cases
  // you'd like to consume the original Context API.
  // (search for Context in this docs)

  // The class name for the root container
  containerClassName?: string

  // Value state controlling the input
  value?: string
  // Setter for the controlled value (or callback for uncontrolled value)
  onChange?: (newValue: string) => unknown

  // Callback when the input is complete
  onComplete?: (...args: any[]) => unknown

  // Where is the text located within the input
  // Affects click-holding or long-press behavior
  // Default: 'left'
  textAlign?: 'left' | 'center' | 'right'

  // Virtual keyboard appearance on mobile
  // Default: 'numeric'
  inputMode?: 'numeric' | 'text' | 'decimal' | 'tel' | 'search' | 'email' | 'url'

  // Pro tip: input-otp export some patterns by default such as REGEXP_ONLY_DIGITS which you can import from the same library path
  // Example: import { REGEXP_ONLY_DIGITS } from 'input-otp';
  // Then use it as: <OTPInput pattern={REGEXP_ONLY_DIGITS}>
  pattern?: string

  // While rendering the input slot, you can access both the char and the placeholder, if there's one and it's active.
  placeholder?: string

  // Transfomer function that allows pasting, for example, "XXX-XXX" even though the input's regex/pattern doesn't allow hyphen and its max length is 6.
  // Example: (pasted) => pasted.replaceAll('-', '')
  pasteTransformer?: (pastedText: string) => string

  // Enabled by default, it's an optional
  // strategy for detecting Password Managers
  // in the page and then shifting their
  // badges to the right side, outside the input.
  pushPasswordManagerStrategy?:
    | 'increase-width'
    | 'none'

  // Enabled by default, it's an optional
  // fallback for pages without JS.
  // This is a CSS string. Write your own
  // rules that will be applied as soon as
  // <noscript> is parsed for no-js pages.
  // Use `null` to disable any no-js fallback (not recommended).
  // Default: `
  // [data-input-otp] {
  //   --nojs-bg: white !important;
  //   --nojs-fg: black !important;
  // 
  //   background-color: var(--nojs-bg) !important;
  //   color: var(--nojs-fg) !important;
  //   caret-color: var(--nojs-fg) !important;
  //   letter-spacing: .25em !important;
  //   text-align: center !important;
  //   border: 1px solid var(--nojs-fg) !important;
  //   border-radius: 4px !important;
  //   width: 100% !important;
  // }
  // @media (prefers-color-scheme: dark) {
  //   [data-input-otp] {
  //     --nojs-bg: black !important;
  //     --nojs-fg: white !important;
  //   }
  // }`
  noScriptCSSFallback?: string | null
}
```

## Examples

<details>
<summary>Automatic form submission on OTP completion</summary>

```tsx
export default function Page() {
  const formRef = useRef<HTMLFormElement>(null)
  const buttonRef = useRef<HTMLButtonElement>(null)

  return (
    <form ref={formRef}>
      <OTPInput
        // ... automatically submit the form
        onComplete={() => formRef.current?.submit()}
        // ... or focus the button like as you wish
        onComplete={() => buttonRef.current?.focus()}
      />

      <button ref={buttonRef}>Submit</button>
    </form>
  )
}
```
</details>

<details>
<summary>Automatically focus the input when the page loads</summary>

```tsx
export default function Page() {
  return (
    <form ref={formRef}>
      <OTPInput
        autoFocus
        // Pro tip: accepts all common HTML input props...
      />
    </form>
  )
}
```
</details>

<details>
<summary>Usage with react-hook-form</summary>
Just use it as a regular text input:

```tsx
const { register, handleSubmit } = useForm();
// Then register it like a text input
<InputOTP {...register("otp")} />
```

You can also use react-hook-form's Controller if needed:
```tsx
const { control } = useForm();
// Then control it like a text input
<Controller
  name="customOTP"
  control={control}
  defaultValue=""
  render={({ field }) => (
    <OTPInput
      {...field}
      label="Custom OTP"
    />
  )}
/>
```
</details>

## Caveats

<details>
<summary>[Workaround] If you want to block specific password manager/badges:</summary>

By default, `input-otp` handles password managers for you.
The password manager badges should be automatically shifted to the right side.

However, if you still want to block password managers, please disable the `pushPasswordManagerStrategy` and then manually block each PWM.

```diff
<OTPInput
  // First, disable library's built-in strategy
  // for shifting badges automatically
- pushPasswordManagerStrategy="increase-width"
+ pushPasswordManagerStrategy="none"
  // Then, manually add specifics attributes
  // your password manager docs
  // Example: block LastPass
+ data-lpignore="true" 
  // Example: block 1Password
+ data-1p-ignore="true"
/>
```
</details>

<details>
<summary>[Setting] If you want to customize the `noscript` CSS fallback</summary>

By default, `input-otp` handles cases where JS is not in the page by applying custom CSS styles.
If you do not like the fallback design and want to apply it to your own, just pass a prop:

```diff
// This is the default CSS fallback.
// Feel free to change it entirely and apply to your design system.
const NOSCRIPT_CSS_FALLBACK = `
[data-input-otp] {
  --nojs-bg: white !important;
  --nojs-fg: black !important;

  background-color: var(--nojs-bg) !important;
  color: var(--nojs-fg) !important;
  caret-color: var(--nojs-fg) !important;
  letter-spacing: .25em !important;
  text-align: center !important;
  border: 1px solid var(--nojs-fg) !important;
  border-radius: 4px !important;
  width: 100% !important;
}
@media (prefers-color-scheme: dark) {
  [data-input-otp] {
    --nojs-bg: black !important;
    --nojs-fg: white !important;
  }
}`

<OTPInput
  // Pass your own custom styles for when JS is disabled
+ noScriptCSSFallback={NOSCRIPT_CSS_FALLBACK}
/>
```
</details>

<details>
<summary>[Workaround] If you're experiencing an unwanted border on input focus:</summary>

```diff
<OTPInput
  // Add class to the input itself
+ className="focus-visible:ring-0"
  // Not the container
  containerClassName="..."
/>
```
</details>

<details>
<summary>[Not Recommended] If you want to centralize input text/selection, use the `textAlign` prop:</summary>

```diff
<OTPInput
  // customizable but not recommended
+ textAlign="center"
/>
```

NOTE: this also affects the selected caret position after a touch/click.

`textAlign="left"`
<img src="https://github.com/guilhermerodz/input-otp/assets/10366880/685a03df-2b69-4a36-b21c-e453f6098f79" width="300" />
<br>

`textAlign="center"`
<img src="https://github.com/guilhermerodz/input-otp/assets/10366880/e0f15b97-ceb8-40c8-96b7-fa3a8896379f" width="300" />
<br>

`textAlign="right"`
<img src="https://github.com/guilhermerodz/input-otp/assets/10366880/26697579-0e8b-4dad-8b85-3a036102e951" width="300" />
<br>

</details>

<details>
<summary>If you want to use Context props:</summary>

```diff
+import { OTPInputContext } from 'input-otp'

function MyForm() {
  return (
    <OTPInput
-     // First remove the `render` prop
-     render={...}
    >
      <OTPInputWrapper />
    </OTPInput>
  )
}

+function OTPInputWrapper() {
+ const inputContext = React.useContext(OTPInputContext)
+ return (
+   <>
+     {inputContext.slots.map((slot, idx) => (
+       <Slot key={idx} {...slot} />
+     ))}
+   </>
+ )
+}
```

NOTE: this also affects the selected caret position after a touch/click.

`textAlign="left"`
<img src="https://github.com/guilhermerodz/input-otp/assets/10366880/685a03df-2b69-4a36-b21c-e453f6098f79" width="300" />
<br>

`textAlign="center"`
<img src="https://github.com/guilhermerodz/input-otp/assets/10366880/e0f15b97-ceb8-40c8-96b7-fa3a8896379f" width="300" />
<br>

`textAlign="right"`
<img src="https://github.com/guilhermerodz/input-otp/assets/10366880/26697579-0e8b-4dad-8b85-3a036102e951" width="300" />
<br>

</details>

<details>
<summary>[DX] Add Tailwind autocomplete for `containerClassname` attribute in VS Code.</summary>

Add the following setting to your `.vscode/settings.json`:
```diff
{
  "tailwindCSS.classAttributes": [
    "class",
    "className",
+   ".*ClassName"
  ]
}
```
</details>

~~~

## node_modules\js-tokens\CHANGELOG.md

~~~md
### Version 4.0.0 (2018-01-28) ###

- Added: Support for ES2018. The only change needed was recognizing the `s`
  regex flag.
- Changed: _All_ tokens returned by the `matchToToken` function now have a
  `closed` property. It is set to `undefined` for the tokens where ?쐁losed??  doesn?셳 make sense. This means that all tokens objects have the same shape,
  which might improve performance.

These are the breaking changes:

- `'/a/s'.match(jsTokens)` no longer returns `['/', 'a', '/', 's']`, but
  `['/a/s']`. (There are of course other variations of this.)
- Code that rely on some token objects not having the `closed` property could
  now behave differently.


### Version 3.0.2 (2017-06-28) ###

- No code changes. Just updates to the readme.


### Version 3.0.1 (2017-01-30) ###

- Fixed: ES2015 unicode escapes with more than 6 hex digits are now matched
  correctly.


### Version 3.0.0 (2017-01-11) ###

This release contains one breaking change, that should [improve performance in
V8][v8-perf]:

> So how can you, as a JavaScript developer, ensure that your RegExps are fast?
> If you are not interested in hooking into RegExp internals, make sure that
> neither the RegExp instance, nor its prototype is modified in order to get the
> best performance:
>
> ```js
> var re = /./g;
> re.exec('');  // Fast path.
> re.new_property = 'slow';
> ```

This module used to export a single regex, with `.matchToToken` bolted
on, just like in the above example. This release changes the exports of
the module to avoid this issue.

Before:

```js
import jsTokens from "js-tokens"
// or:
var jsTokens = require("js-tokens")
var matchToToken = jsTokens.matchToToken
```

After:

```js
import jsTokens, {matchToToken} from "js-tokens"
// or:
var jsTokens = require("js-tokens").default
var matchToToken = require("js-tokens").matchToToken
```

[v8-perf]: http://v8project.blogspot.se/2017/01/speeding-up-v8-regular-expressions.html


### Version 2.0.0 (2016-06-19) ###

- Added: Support for ES2016. In other words, support for the `**` exponentiation
  operator.

These are the breaking changes:

- `'**'.match(jsTokens)` no longer returns `['*', '*']`, but `['**']`.
- `'**='.match(jsTokens)` no longer returns `['*', '*=']`, but `['**=']`.


### Version 1.0.3 (2016-03-27) ###

- Improved: Made the regex ever so slightly smaller.
- Updated: The readme.


### Version 1.0.2 (2015-10-18) ###

- Improved: Limited npm package contents for a smaller download. Thanks to
  @zertosh!


### Version 1.0.1 (2015-06-20) ###

- Fixed: Declared an undeclared variable.


### Version 1.0.0 (2015-02-26) ###

- Changed: Merged the 'operator' and 'punctuation' types into 'punctuator'. That
  type is now equivalent to the Punctuator token in the ECMAScript
  specification. (Backwards-incompatible change.)
- Fixed: A `-` followed by a number is now correctly matched as a punctuator
  followed by a number. It used to be matched as just a number, but there is no
  such thing as negative number literals. (Possibly backwards-incompatible
  change.)


### Version 0.4.1 (2015-02-21) ###

- Added: Support for the regex `u` flag.


### Version 0.4.0 (2015-02-21) ###

- Improved: `jsTokens.matchToToken` performance.
- Added: Support for octal and binary number literals.
- Added: Support for template strings.


### Version 0.3.1 (2015-01-06) ###

- Fixed: Support for unicode spaces. They used to be allowed in names (which is
  very confusing), and some unicode newlines were wrongly allowed in strings and
  regexes.


### Version 0.3.0 (2014-12-19) ###

- Changed: The `jsTokens.names` array has been replaced with the
  `jsTokens.matchToToken` function. The capturing groups of `jsTokens` are no
  longer part of the public API; instead use said function. See this [gist] for
  an example. (Backwards-incompatible change.)
- Changed: The empty string is now considered an ?쐇nvalid??token, instead an
  ?쐃mpty??token (its own group). (Backwards-incompatible change.)
- Removed: component support. (Backwards-incompatible change.)

[gist]: https://gist.github.com/lydell/be49dbf80c382c473004


### Version 0.2.0 (2014-06-19) ###

- Changed: Match ES6 function arrows (`=>`) as an operator, instead of its own
  category (?쐄unctionArrow??, for simplicity. (Backwards-incompatible change.)
- Added: ES6 splats (`...`) are now matched as an operator (instead of three
  punctuations). (Backwards-incompatible change.)


### Version 0.1.0 (2014-03-08) ###

- Initial release.

~~~

## node_modules\js-tokens\index.js

~~~js
// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
// License: MIT. (See LICENSE.)

Object.defineProperty(exports, "__esModule", {
  value: true
})

// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g

exports.matchToToken = function(match) {
  var token = {type: "invalid", value: match[0], closed: undefined}
       if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4])
  else if (match[ 5]) token.type = "comment"
  else if (match[ 6]) token.type = "comment", token.closed = !!match[7]
  else if (match[ 8]) token.type = "regex"
  else if (match[ 9]) token.type = "number"
  else if (match[10]) token.type = "name"
  else if (match[11]) token.type = "punctuator"
  else if (match[12]) token.type = "whitespace"
  return token
}

~~~

## node_modules\js-tokens\LICENSE

~~~text
The MIT License (MIT)

Copyright (c) 2014, 2015, 2016, 2017, 2018 Simon Lydell

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

~~~

## node_modules\js-tokens\package.json

~~~json
{
  "name": "js-tokens",
  "version": "4.0.0",
  "author": "Simon Lydell",
  "license": "MIT",
  "description": "A regex that tokenizes JavaScript.",
  "keywords": [
    "JavaScript",
    "js",
    "token",
    "tokenize",
    "regex"
  ],
  "files": [
    "index.js"
  ],
  "repository": "lydell/js-tokens",
  "scripts": {
    "test": "mocha --ui tdd",
    "esprima-compare": "node esprima-compare ./index.js everything.js/es5.js",
    "build": "node generate-index.js",
    "dev": "npm run build && npm test"
  },
  "devDependencies": {
    "coffeescript": "2.1.1",
    "esprima": "4.0.0",
    "everything.js": "1.0.3",
    "mocha": "5.0.0"
  }
}

~~~

## node_modules\js-tokens\README.md

~~~md
Overview [![Build Status](https://travis-ci.org/lydell/js-tokens.svg?branch=master)](https://travis-ci.org/lydell/js-tokens)
========

A regex that tokenizes JavaScript.

```js
var jsTokens = require("js-tokens").default

var jsString = "var foo=opts.foo;\n..."

jsString.match(jsTokens)
// ["var", " ", "foo", "=", "opts", ".", "foo", ";", "\n", ...]
```


Installation
============

`npm install js-tokens`

```js
import jsTokens from "js-tokens"
// or:
var jsTokens = require("js-tokens").default
```


Usage
=====

### `jsTokens` ###

A regex with the `g` flag that matches JavaScript tokens.

The regex _always_ matches, even invalid JavaScript and the empty string.

The next match is always directly after the previous.

### `var token = matchToToken(match)` ###

```js
import {matchToToken} from "js-tokens"
// or:
var matchToToken = require("js-tokens").matchToToken
```

Takes a `match` returned by `jsTokens.exec(string)`, and returns a `{type:
String, value: String}` object. The following types are available:

- string
- comment
- regex
- number
- name
- punctuator
- whitespace
- invalid

Multi-line comments and strings also have a `closed` property indicating if the
token was closed or not (see below).

Comments and strings both come in several flavors. To distinguish them, check if
the token starts with `//`, `/*`, `'`, `"` or `` ` ``.

Names are ECMAScript IdentifierNames, that is, including both identifiers and
keywords. You may use [is-keyword-js] to tell them apart.

Whitespace includes both line terminators and other whitespace.

[is-keyword-js]: https://github.com/crissdev/is-keyword-js


ECMAScript support
==================

The intention is to always support the latest ECMAScript version whose feature
set has been finalized.

If adding support for a newer version requires changes, a new version with a
major verion bump will be released.

Currently, ECMAScript 2018 is supported.


Invalid code handling
=====================

Unterminated strings are still matched as strings. JavaScript strings cannot
contain (unescaped) newlines, so unterminated strings simply end at the end of
the line. Unterminated template strings can contain unescaped newlines, though,
so they go on to the end of input.

Unterminated multi-line comments are also still matched as comments. They
simply go on to the end of the input.

Unterminated regex literals are likely matched as division and whatever is
inside the regex.

Invalid ASCII characters have their own capturing group.

Invalid non-ASCII characters are treated as names, to simplify the matching of
names (except unicode spaces which are treated as whitespace). Note: See also
the [ES2018](#es2018) section.

Regex literals may contain invalid regex syntax. They are still matched as
regex literals. They may also contain repeated regex flags, to keep the regex
simple.

Strings may contain invalid escape sequences.


Limitations
===========

Tokenizing JavaScript using regexes?봧n fact, _one single regex_?봶on?셳 be
perfect. But that?셲 not the point either.

You may compare jsTokens with [esprima] by using `esprima-compare.js`.
See `npm run esprima-compare`!

[esprima]: http://esprima.org/

### Template string interpolation ###

Template strings are matched as single tokens, from the starting `` ` `` to the
ending `` ` ``, including interpolations (whose tokens are not matched
individually).

Matching template string interpolations requires recursive balancing of `{` and
`}`?봲omething that JavaScript regexes cannot do. Only one level of nesting is
supported.

### Division and regex literals collision ###

Consider this example:

```js
var g = 9.82
var number = bar / 2/g

var regex = / 2/g
```

A human can easily understand that in the `number` line we?셱e dealing with
division, and in the `regex` line we?셱e dealing with a regex literal. How come?
Because humans can look at the whole code to put the `/` characters in context.
A JavaScript regex cannot. It only sees forwards. (Well, ES2018 regexes can also
look backwards. See the [ES2018](#es2018) section).

When the `jsTokens` regex scans throught the above, it will see the following
at the end of both the `number` and `regex` rows:

```js
/ 2/g
```

It is then impossible to know if that is a regex literal, or part of an
expression dealing with division.

Here is a similar case:

```js
foo /= 2/g
foo(/= 2/g)
```

The first line divides the `foo` variable with `2/g`. The second line calls the
`foo` function with the regex literal `/= 2/g`. Again, since `jsTokens` only
sees forwards, it cannot tell the two cases apart.

There are some cases where we _can_ tell division and regex literals apart,
though.

First off, we have the simple cases where there?셲 only one slash in the line:

```js
var foo = 2/g
foo /= 2
```

Regex literals cannot contain newlines, so the above cases are correctly
identified as division. Things are only problematic when there are more than
one non-comment slash in a single line.

Secondly, not every character is a valid regex flag.

```js
var number = bar / 2/e
```

The above example is also correctly identified as division, because `e` is not a
valid regex flag. I initially wanted to future-proof by allowing `[a-zA-Z]*`
(any letter) as flags, but it is not worth it since it increases the amount of
ambigous cases. So only the standard `g`, `m`, `i`, `y` and `u` flags are
allowed. This means that the above example will be identified as division as
long as you don?셳 rename the `e` variable to some permutation of `gmiyus` 1 to 6
characters long.

Lastly, we can look _forward_ for information.

- If the token following what looks like a regex literal is not valid after a
  regex literal, but is valid in a division expression, then the regex literal
  is treated as division instead. For example, a flagless regex cannot be
  followed by a string, number or name, but all of those three can be the
  denominator of a division.
- Generally, if what looks like a regex literal is followed by an operator, the
  regex literal is treated as division instead. This is because regexes are
  seldomly used with operators (such as `+`, `*`, `&&` and `==`), but division
  could likely be part of such an expression.

Please consult the regex source and the test cases for precise information on
when regex or division is matched (should you need to know). In short, you
could sum it up as:

If the end of a statement looks like a regex literal (even if it isn?셳), it
will be treated as one. Otherwise it should work as expected (if you write sane
code).

### ES2018 ###

ES2018 added some nice regex improvements to the language.

- [Unicode property escapes] should allow telling names and invalid non-ASCII
  characters apart without blowing up the regex size.
- [Lookbehind assertions] should allow matching telling division and regex
  literals apart in more cases.
- [Named capture groups] might simplify some things.

These things would be nice to do, but are not critical. They probably have to
wait until the oldest maintained Node.js LTS release supports those features.

[Unicode property escapes]: http://2ality.com/2017/07/regexp-unicode-property-escapes.html
[Lookbehind assertions]: http://2ality.com/2017/05/regexp-lookbehind-assertions.html
[Named capture groups]: http://2ality.com/2017/05/regexp-named-capture-groups.html


License
=======

[MIT](LICENSE).

~~~

## node_modules\loose-envify\cli.js

~~~js
#!/usr/bin/env node
'use strict';

var looseEnvify = require('./');
var fs = require('fs');

if (process.argv[2]) {
  fs.createReadStream(process.argv[2], {encoding: 'utf8'})
    .pipe(looseEnvify(process.argv[2]))
    .pipe(process.stdout);
} else {
  process.stdin.resume()
  process.stdin
    .pipe(looseEnvify(__filename))
    .pipe(process.stdout);
}

~~~

## node_modules\loose-envify\custom.js

~~~js
// envify compatibility
'use strict';

module.exports = require('./loose-envify');

~~~

## node_modules\loose-envify\index.js

~~~js
'use strict';

module.exports = require('./loose-envify')(process.env);

~~~

## node_modules\loose-envify\LICENSE

~~~text
The MIT License (MIT)

Copyright (c) 2015 Andres Suarez <zertosh@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

~~~

## node_modules\loose-envify\loose-envify.js

~~~js
'use strict';

var stream = require('stream');
var util = require('util');
var replace = require('./replace');

var jsonExtRe = /\.json$/;

module.exports = function(rootEnv) {
  rootEnv = rootEnv || process.env;
  return function (file, trOpts) {
    if (jsonExtRe.test(file)) {
      return stream.PassThrough();
    }
    var envs = trOpts ? [rootEnv, trOpts] : [rootEnv];
    return new LooseEnvify(envs);
  };
};

function LooseEnvify(envs) {
  stream.Transform.call(this);
  this._data = '';
  this._envs = envs;
}
util.inherits(LooseEnvify, stream.Transform);

LooseEnvify.prototype._transform = function(buf, enc, cb) {
  this._data += buf;
  cb();
};

LooseEnvify.prototype._flush = function(cb) {
  var replaced = replace(this._data, this._envs);
  this.push(replaced);
  cb();
};

~~~

## node_modules\loose-envify\package.json

~~~json
{
  "name": "loose-envify",
  "version": "1.4.0",
  "description": "Fast (and loose) selective `process.env` replacer using js-tokens instead of an AST",
  "keywords": [
    "environment",
    "variables",
    "browserify",
    "browserify-transform",
    "transform",
    "source",
    "configuration"
  ],
  "homepage": "https://github.com/zertosh/loose-envify",
  "license": "MIT",
  "author": "Andres Suarez <zertosh@gmail.com>",
  "main": "index.js",
  "bin": {
    "loose-envify": "cli.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/zertosh/loose-envify.git"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "dependencies": {
    "js-tokens": "^3.0.0 || ^4.0.0"
  },
  "devDependencies": {
    "browserify": "^13.1.1",
    "envify": "^3.4.0",
    "tap": "^8.0.0"
  }
}

~~~

## node_modules\loose-envify\README.md

~~~md
# loose-envify

[![Build Status](https://travis-ci.org/zertosh/loose-envify.svg?branch=master)](https://travis-ci.org/zertosh/loose-envify)

Fast (and loose) selective `process.env` replacer using [js-tokens](https://github.com/lydell/js-tokens) instead of an AST. Works just like [envify](https://github.com/hughsk/envify) but much faster.

## Gotchas

* Doesn't handle broken syntax.
* Doesn't look inside embedded expressions in template strings.
  - **this won't work:**
  ```js
  console.log(`the current env is ${process.env.NODE_ENV}`);
  ```
* Doesn't replace oddly-spaced or oddly-commented expressions.
  - **this won't work:**
  ```js
  console.log(process./*won't*/env./*work*/NODE_ENV);
  ```

## Usage/Options

loose-envify has the exact same interface as [envify](https://github.com/hughsk/envify), including the CLI.

## Benchmark

```
envify:

  $ for i in {1..5}; do node bench/bench.js 'envify'; done
  708ms
  727ms
  791ms
  719ms
  720ms

loose-envify:

  $ for i in {1..5}; do node bench/bench.js '../'; done
  51ms
  52ms
  52ms
  52ms
  52ms
```

~~~

## node_modules\loose-envify\replace.js

~~~js
'use strict';

var jsTokens = require('js-tokens').default;

var processEnvRe = /\bprocess\.env\.[_$a-zA-Z][$\w]+\b/;
var spaceOrCommentRe = /^(?:\s|\/[/*])/;

function replace(src, envs) {
  if (!processEnvRe.test(src)) {
    return src;
  }

  var out = [];
  var purge = envs.some(function(env) {
    return env._ && env._.indexOf('purge') !== -1;
  });

  jsTokens.lastIndex = 0
  var parts = src.match(jsTokens);

  for (var i = 0; i < parts.length; i++) {
    if (parts[i    ] === 'process' &&
        parts[i + 1] === '.' &&
        parts[i + 2] === 'env' &&
        parts[i + 3] === '.') {
      var prevCodeToken = getAdjacentCodeToken(-1, parts, i);
      var nextCodeToken = getAdjacentCodeToken(1, parts, i + 4);
      var replacement = getReplacementString(envs, parts[i + 4], purge);
      if (prevCodeToken !== '.' &&
          nextCodeToken !== '.' &&
          nextCodeToken !== '=' &&
          typeof replacement === 'string') {
        out.push(replacement);
        i += 4;
        continue;
      }
    }
    out.push(parts[i]);
  }

  return out.join('');
}

function getAdjacentCodeToken(dir, parts, i) {
  while (true) {
    var part = parts[i += dir];
    if (!spaceOrCommentRe.test(part)) {
      return part;
    }
  }
}

function getReplacementString(envs, name, purge) {
  for (var j = 0; j < envs.length; j++) {
    var env = envs[j];
    if (typeof env[name] !== 'undefined') {
      return JSON.stringify(env[name]);
    }
  }
  if (purge) {
    return 'undefined';
  }
}

module.exports = replace;

~~~

## node_modules\mitt\dist\mitt.js

~~~js
module.exports=function(n){return{all:n=n||new Map,on:function(e,t){var i=n.get(e);i?i.push(t):n.set(e,[t])},off:function(e,t){var i=n.get(e);i&&(t?i.splice(i.indexOf(t)>>>0,1):n.set(e,[]))},emit:function(e,t){var i=n.get(e);i&&i.slice().map(function(n){n(t)}),(i=n.get("*"))&&i.slice().map(function(n){n(e,t)})}}};
//# sourceMappingURL=mitt.js.map

~~~

## node_modules\mitt\dist\mitt.js.map

~~~map
{"version":3,"file":"mitt.js","sources":["../src/index.ts"],"sourcesContent":["export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n"],"names":["all","Map","on","type","handler","handlers","get","push","set","off","splice","indexOf","emit","evt","slice","map"],"mappings":"wBA8CCA,GAOA,MAAO,CAINA,IANDA,EAAMA,GAAO,IAAIC,IAchBC,YAA6BC,EAAWC,GACvC,IAAMC,EAAmDL,EAAKM,IAAIH,GAC9DE,EACHA,EAASE,KAAKH,GAEdJ,EAAKQ,IAAIL,EAAM,CAACC,KAWlBK,aAA8BN,EAAWC,GACxC,IAAMC,EAAmDL,EAAKM,IAAIH,GAC9DE,IACCD,EACHC,EAASK,OAAOL,EAASM,QAAQP,KAAa,EAAG,GAEjDJ,EAAKQ,IAAIL,EAAM,MAelBS,cAA+BT,EAAWU,GACzC,IAAIR,EAAWL,EAAKM,IAAIH,GACpBE,GACFA,EACCS,QACAC,IAAI,SAACX,GACLA,EAAQS,MAIXR,EAAWL,EAAKM,IAAI,OAElBD,EACCS,QACAC,IAAI,SAACX,GACLA,EAAQD,EAAMU"}
~~~

## node_modules\mitt\dist\mitt.mjs

~~~mjs
export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e)})}}}
//# sourceMappingURL=mitt.mjs.map

~~~

## node_modules\mitt\dist\mitt.mjs.map

~~~map
{"version":3,"file":"mitt.mjs","sources":["../src/index.ts"],"sourcesContent":["export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n"],"names":["all","Map","on","type","handler","handlers","get","push","set","off","splice","indexOf","emit","evt","slice","map"],"mappings":"wBA8CCA,GAOA,MAAO,CAINA,IANDA,EAAMA,GAAO,IAAIC,IAchBC,YAA6BC,EAAWC,GACvC,IAAMC,EAAmDL,EAAKM,IAAIH,GAC9DE,EACHA,EAASE,KAAKH,GAEdJ,EAAKQ,IAAIL,EAAM,CAACC,KAWlBK,aAA8BN,EAAWC,GACxC,IAAMC,EAAmDL,EAAKM,IAAIH,GAC9DE,IACCD,EACHC,EAASK,OAAOL,EAASM,QAAQP,KAAa,EAAG,GAEjDJ,EAAKQ,IAAIL,EAAM,MAelBS,cAA+BT,EAAWU,GACzC,IAAIR,EAAWL,EAAKM,IAAIH,GACpBE,GACFA,EACCS,QACAC,IAAI,SAACX,GACLA,EAAQS,MAIXR,EAAWL,EAAKM,IAAI,OAElBD,EACCS,QACAC,IAAI,SAACX,GACLA,EAAQD,EAAMU"}
~~~

## node_modules\mitt\dist\mitt.umd.js

~~~js
!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(e=e||self).mitt=n()}(this,function(){return function(e){return{all:e=e||new Map,on:function(n,t){var f=e.get(n);f?f.push(t):e.set(n,[t])},off:function(n,t){var f=e.get(n);f&&(t?f.splice(f.indexOf(t)>>>0,1):e.set(n,[]))},emit:function(n,t){var f=e.get(n);f&&f.slice().map(function(e){e(t)}),(f=e.get("*"))&&f.slice().map(function(e){e(n,t)})}}}});
//# sourceMappingURL=mitt.umd.js.map

~~~

## node_modules\mitt\dist\mitt.umd.js.map

~~~map
{"version":3,"file":"mitt.umd.js","sources":["../src/index.ts"],"sourcesContent":["export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = unknown> = (event: T) => void;\nexport type WildcardHandler<T = Record<string, unknown>> = (\n\ttype: keyof T,\n\tevent: T[keyof T]\n) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList<T = unknown> = Array<Handler<T>>;\nexport type WildCardEventHandlerList<T = Record<string, unknown>> = Array<\n\tWildcardHandler<T>\n>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<\n\tkeyof Events | '*',\n\tEventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>\n>;\n\nexport interface Emitter<Events extends Record<EventType, unknown>> {\n\tall: EventHandlerMap<Events>;\n\n\ton<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;\n\ton(type: '*', handler: WildcardHandler<Events>): void;\n\n\toff<Key extends keyof Events>(\n\t\ttype: Key,\n\t\thandler?: Handler<Events[Key]>\n\t): void;\n\toff(type: '*', handler: WildcardHandler<Events>): void;\n\n\temit<Key extends keyof Events>(type: Key, event: Events[Key]): void;\n\temit<Key extends keyof Events>(\n\t\ttype: undefined extends Events[Key] ? Key : never\n\t): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt<Events extends Record<EventType, unknown>>(\n\tall?: EventHandlerMap<Events>\n): Emitter<Events> {\n\ttype GenericEventHandler =\n\t\t| Handler<Events[keyof Events]>\n\t\t| WildcardHandler<Events>;\n\tall = all || new Map();\n\n\treturn {\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `'*'` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<Key extends keyof Events>(type: Key, handler: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.push(handler);\n\t\t\t} else {\n\t\t\t\tall!.set(type, [handler] as EventHandlerList<Events[keyof Events]>);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * If `handler` is omitted, all handlers of the given type are removed.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from (`'*'` to remove a wildcard handler)\n\t\t * @param {Function} [handler] Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<Key extends keyof Events>(type: Key, handler?: GenericEventHandler) {\n\t\t\tconst handlers: Array<GenericEventHandler> | undefined = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\tif (handler) {\n\t\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t\t} else {\n\t\t\t\t\tall!.set(type, []);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `'*'` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing '*' handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<Key extends keyof Events>(type: Key, evt?: Events[Key]) {\n\t\t\tlet handlers = all!.get(type);\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as EventHandlerList<Events[keyof Events]>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(evt!);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\thandlers = all!.get('*');\n\t\t\tif (handlers) {\n\t\t\t\t(handlers as WildCardEventHandlerList<Events>)\n\t\t\t\t\t.slice()\n\t\t\t\t\t.map((handler) => {\n\t\t\t\t\t\thandler(type, evt!);\n\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n}\n"],"names":["all","Map","on","type","handler","handlers","get","push","set","off","splice","indexOf","emit","evt","slice","map"],"mappings":"6LA8CCA,GAOA,MAAO,CAINA,IANDA,EAAMA,GAAO,IAAIC,IAchBC,YAA6BC,EAAWC,GACvC,IAAMC,EAAmDL,EAAKM,IAAIH,GAC9DE,EACHA,EAASE,KAAKH,GAEdJ,EAAKQ,IAAIL,EAAM,CAACC,KAWlBK,aAA8BN,EAAWC,GACxC,IAAMC,EAAmDL,EAAKM,IAAIH,GAC9DE,IACCD,EACHC,EAASK,OAAOL,EAASM,QAAQP,KAAa,EAAG,GAEjDJ,EAAKQ,IAAIL,EAAM,MAelBS,cAA+BT,EAAWU,GACzC,IAAIR,EAAWL,EAAKM,IAAIH,GACpBE,GACFA,EACCS,QACAC,IAAI,SAACX,GACLA,EAAQS,MAIXR,EAAWL,EAAKM,IAAI,OAElBD,EACCS,QACAC,IAAI,SAACX,GACLA,EAAQD,EAAMU"}
~~~

## node_modules\mitt\index.d.ts

~~~ts
export declare type EventType = string | symbol;
export declare type Handler<T = unknown> = (event: T) => void;
export declare type WildcardHandler<T = Record<string, unknown>> = (type: keyof T, event: T[keyof T]) => void;
export declare type EventHandlerList<T = unknown> = Array<Handler<T>>;
export declare type WildCardEventHandlerList<T = Record<string, unknown>> = Array<WildcardHandler<T>>;
export declare type EventHandlerMap<Events extends Record<EventType, unknown>> = Map<keyof Events | '*', EventHandlerList<Events[keyof Events]> | WildCardEventHandlerList<Events>>;
export interface Emitter<Events extends Record<EventType, unknown>> {
    all: EventHandlerMap<Events>;
    on<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): void;
    on(type: '*', handler: WildcardHandler<Events>): void;
    off<Key extends keyof Events>(type: Key, handler?: Handler<Events[Key]>): void;
    off(type: '*', handler: WildcardHandler<Events>): void;
    emit<Key extends keyof Events>(type: Key, event: Events[Key]): void;
    emit<Key extends keyof Events>(type: undefined extends Events[Key] ? Key : never): void;
}
/**
 * Mitt: Tiny (~200b) functional event emitter / pubsub.
 * @name mitt
 * @returns {Mitt}
 */
export default function mitt<Events extends Record<EventType, unknown>>(all?: EventHandlerMap<Events>): Emitter<Events>;

~~~

## node_modules\mitt\LICENSE

~~~text
MIT License

Copyright (c) 2021 Jason Miller

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

~~~

## node_modules\mitt\package.json

~~~json
{
  "name": "mitt",
  "version": "3.0.1",
  "description": "Tiny 200b functional Event Emitter / pubsub.",
  "module": "dist/mitt.mjs",
  "main": "dist/mitt.js",
  "jsnext:main": "dist/mitt.mjs",
  "umd:main": "dist/mitt.umd.js",
  "source": "src/index.ts",
  "typings": "index.d.ts",
  "exports": {
    "types": "./index.d.ts",
    "module": "./dist/mitt.mjs",
    "import": "./dist/mitt.mjs",
    "require": "./dist/mitt.js",
    "default": "./dist/mitt.mjs"
  },
  "scripts": {
    "test": "npm-run-all --silent typecheck lint mocha test-types",
    "mocha": "mocha test",
    "test-types": "tsc test/test-types-compilation.ts --noEmit --strict",
    "lint": "eslint src test --ext ts --ext js",
    "typecheck": "tsc --noEmit",
    "bundle": "microbundle -f es,cjs,umd",
    "build": "npm-run-all --silent clean -p bundle -s docs",
    "clean": "rimraf dist",
    "docs": "documentation readme src/index.ts --section API -q --parse-extension ts",
    "release": "npm run -s build -s && npm t && git commit -am $npm_package_version && git tag $npm_package_version && git push && git push --tags && npm publish"
  },
  "repository": "developit/mitt",
  "keywords": [
    "events",
    "eventemitter",
    "emitter",
    "pubsub"
  ],
  "homepage": "https://github.com/developit/mitt",
  "authors": [
    "Jason Miller <jason@developit.ca>"
  ],
  "license": "MIT",
  "files": [
    "dist",
    "index.d.ts"
  ],
  "mocha": {
    "extension": [
      "ts"
    ],
    "require": [
      "ts-node/register",
      "esm"
    ],
    "spec": [
      "test/*_test.ts"
    ]
  },
  "prettier": {
    "singleQuote": true,
    "trailingComma": "none"
  },
  "devDependencies": {
    "@types/chai": "^4.2.11",
    "@types/mocha": "^7.0.2",
    "@types/sinon": "^9.0.4",
    "@types/sinon-chai": "^3.2.4",
    "@typescript-eslint/eslint-plugin": "^5.61.0",
    "@typescript-eslint/parser": "^5.61.0",
    "chai": "^4.2.0",
    "documentation": "^14.0.2",
    "eslint": "^7.32.0",
    "eslint-config-developit": "^1.2.0",
    "eslint-plugin-compat": "^4.1.4",
    "esm": "^3.2.25",
    "microbundle": "^0.12.3",
    "mocha": "^8.0.1",
    "npm-run-all": "^4.1.5",
    "prettier": "^2.8.8",
    "rimraf": "^3.0.2",
    "sinon": "^9.0.2",
    "sinon-chai": "^3.5.0",
    "ts-node": "^10.9.1",
    "typescript": "^4.9.5"
  }
}

~~~

## node_modules\mitt\README.md

~~~md
<p align="center">
  <img src="https://i.imgur.com/BqsX9NT.png" width="300" height="300" alt="mitt">
  <br>
  <a href="https://www.npmjs.org/package/mitt"><img src="https://img.shields.io/npm/v/mitt.svg" alt="npm"></a>
  <img src="https://github.com/developit/mitt/workflows/CI/badge.svg" alt="build status">
  <a href="https://unpkg.com/mitt/dist/mitt.js"><img src="https://img.badgesize.io/https://unpkg.com/mitt/dist/mitt.js?compression=gzip" alt="gzip size"></a>
</p>

# Mitt

> Tiny 200b functional event emitter / pubsub.

-   **Microscopic:** weighs less than 200 bytes gzipped
-   **Useful:** a wildcard `"*"` event type listens to all events
-   **Familiar:** same names & ideas as [Node's EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)
-   **Functional:** methods don't rely on `this`
-   **Great Name:** somehow [mitt](https://npm.im/mitt) wasn't taken

Mitt was made for the browser, but works in any JavaScript runtime. It has no dependencies and supports IE9+.

## Table of Contents

-   [Install](#install)
-   [Usage](#usage)
-   [Examples & Demos](#examples--demos)
-   [API](#api)
-   [Contribute](#contribute)
-   [License](#license)

## Install

This project uses [node](http://nodejs.org) and [npm](https://npmjs.com). Go check them out if you don't have them locally installed.

```sh
$ npm install --save mitt
```

Then with a module bundler like [rollup](http://rollupjs.org/) or [webpack](https://webpack.js.org/), use as you would anything else:

```javascript
// using ES6 modules
import mitt from 'mitt'

// using CommonJS modules
var mitt = require('mitt')
```

The [UMD](https://github.com/umdjs/umd) build is also available on [unpkg](https://unpkg.com):

```html
<script src="https://unpkg.com/mitt/dist/mitt.umd.js"></script>
```

You can find the library on `window.mitt`.

## Usage

```js
import mitt from 'mitt'

const emitter = mitt()

// listen to an event
emitter.on('foo', e => console.log('foo', e) )

// listen to all events
emitter.on('*', (type, e) => console.log(type, e) )

// fire an event
emitter.emit('foo', { a: 'b' })

// clearing all events
emitter.all.clear()

// working with handler references:
function onFoo() {}
emitter.on('foo', onFoo)   // listen
emitter.off('foo', onFoo)  // unlisten
```

### Typescript

Set `"strict": true` in your tsconfig.json to get improved type inference for `mitt` instance methods.

```ts
import mitt from 'mitt';

type Events = {
  foo: string;
  bar?: number;
};

const emitter = mitt<Events>(); // inferred as Emitter<Events>

emitter.on('foo', (e) => {}); // 'e' has inferred type 'string'

emitter.emit('foo', 42); // Error: Argument of type 'number' is not assignable to parameter of type 'string'. (2345)
```

Alternatively, you can use the provided `Emitter` type:

```ts
import mitt, { Emitter } from 'mitt';

type Events = {
  foo: string;
  bar?: number;
};

const emitter: Emitter<Events> = mitt<Events>();
```

## Examples & Demos

<a href="http://codepen.io/developit/pen/rjMEwW?editors=0110">
  <b>Preact + Mitt Codepen Demo</b>
  <br>
  <img src="https://i.imgur.com/CjBgOfJ.png" width="278" alt="preact + mitt preview">
</a>

* * *

## API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

#### Table of Contents

-   [mitt](#mitt)
-   [all](#all)
-   [on](#on)
    -   [Parameters](#parameters)
-   [off](#off)
    -   [Parameters](#parameters-1)
-   [emit](#emit)
    -   [Parameters](#parameters-2)

### mitt

Mitt: Tiny (~200b) functional event emitter / pubsub.

Returns **Mitt** 

### all

A Map of event names to registered handler functions.

### on

Register an event handler for the given type.

#### Parameters

-   `type` **([string](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String) \| [symbol](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol))** Type of event to listen for, or `'*'` for all events
-   `handler` **[Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)** Function to call in response to given event

### off

Remove an event handler for the given type.
If `handler` is omitted, all handlers of the given type are removed.

#### Parameters

-   `type` **([string](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String) \| [symbol](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol))** Type of event to unregister `handler` from, or `'*'`
-   `handler` **[Function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/function)?** Handler function to remove

### emit

Invoke all handlers for the given type.
If present, `'*'` handlers are invoked after type-matched handlers.

Note: Manually firing '\*' handlers is not supported.

#### Parameters

-   `type` **([string](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String) \| [symbol](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Symbol))** The event type to invoke
-   `evt` **Any?** Any value (object is recommended and powerful), passed to each handler

## Contribute

First off, thanks for taking the time to contribute!
Now, take a moment to be sure your contributions make sense to everyone else.

### Reporting Issues

Found a problem? Want a new feature? First of all see if your issue or idea has [already been reported](../../issues).
If don't, just open a [new clear and descriptive issue](../../issues/new).

### Submitting pull requests

Pull requests are the greatest contributions, so be sure they are focused in scope, and do avoid unrelated commits.

-   Fork it!
-   Clone your fork: `git clone https://github.com/<your-username>/mitt`
-   Navigate to the newly cloned directory: `cd mitt`
-   Create a new branch for the new feature: `git checkout -b my-new-feature`
-   Install the tools necessary for development: `npm install`
-   Make your changes.
-   Commit your changes: `git commit -am 'Add some feature'`
-   Push to the branch: `git push origin my-new-feature`
-   Submit a pull request with full remarks documenting your changes.

## License

[MIT License](https://opensource.org/licenses/MIT) 짤 [Jason Miller](https://jasonformat.com/)

~~~

## node_modules\nanoid\async\index.browser.cjs

~~~cjs
let random = async bytes => crypto.getRandomValues(new Uint8Array(bytes))

let customAlphabet = (alphabet, defaultSize = 21) => {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  // `Math.clz32` is not used, because it is not available in browsers.
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.

  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.

  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).

  // `-~f => Math.ceil(f)` if f is a float
  // `-~i => i + 1` if i is an integer
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)

  return async (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = crypto.getRandomValues(new Uint8Array(step))
      // A compact alternative for `for (var i = 0; i < step; i++)`.
      let i = step | 0
      while (i--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[i] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}

let nanoid = async (size = 21) => {
  let id = ''
  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))

  // A compact alternative for `for (var i = 0; i < step; i++)`.
  while (size--) {
    // It is incorrect to use bytes exceeding the alphabet size.
    // The following mask reduces the random byte in the 0-255 value
    // range to the 0-63 value range. Therefore, adding hacks, such
    // as empty string fallback or magic numbers, is unneccessary because
    // the bitmask trims bytes down to the alphabet size.
    let byte = bytes[size] & 63
    if (byte < 36) {
      // `0-9a-z`
      id += byte.toString(36)
    } else if (byte < 62) {
      // `A-Z`
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte < 63) {
      id += '_'
    } else {
      id += '-'
    }
  }
  return id
}

module.exports = { nanoid, customAlphabet, random }

~~~

## node_modules\nanoid\async\index.browser.js

~~~js
let random = async bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customAlphabet = (alphabet, defaultSize = 21) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return async (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = crypto.getRandomValues(new Uint8Array(step))
      let i = step | 0
      while (i--) {
        id += alphabet[bytes[i] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let nanoid = async (size = 21) => {
  let id = ''
  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))
  while (size--) {
    let byte = bytes[size] & 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte < 63) {
      id += '_'
    } else {
      id += '-'
    }
  }
  return id
}
export { nanoid, customAlphabet, random }

~~~

## node_modules\nanoid\async\index.cjs

~~~cjs
let crypto = require('crypto')

let { urlAlphabet } = require('../url-alphabet/index.cjs')

// `crypto.randomFill()` is a little faster than `crypto.randomBytes()`,
// because it is possible to use in combination with `Buffer.allocUnsafe()`.
let random = bytes =>
  new Promise((resolve, reject) => {
    // `Buffer.allocUnsafe()` is faster because it doesn?셳 flush the memory.
    // Memory flushing is unnecessary since the buffer allocation itself resets
    // the memory with the new bytes.
    crypto.randomFill(Buffer.allocUnsafe(bytes), (err, buf) => {
      if (err) {
        reject(err)
      } else {
        resolve(buf)
      }
    })
  })

let customAlphabet = (alphabet, defaultSize = 21) => {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1
  // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.

  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.

  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).
  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)

  let tick = (id, size = defaultSize) =>
    random(step).then(bytes => {
      // A compact alternative for `for (var i = 0; i < step; i++)`.
      let i = step
      while (i--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[i] & mask] || ''
        if (id.length >= size) return id
      }
      return tick(id, size)
    })

  return size => tick('', size)
}

let nanoid = (size = 21) =>
  random((size |= 0)).then(bytes => {
    let id = ''
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    while (size--) {
      // It is incorrect to use bytes exceeding the alphabet size.
      // The following mask reduces the random byte in the 0-255 value
      // range to the 0-63 value range. Therefore, adding hacks, such
      // as empty string fallback or magic numbers, is unneccessary because
      // the bitmask trims bytes down to the alphabet size.
      id += urlAlphabet[bytes[size] & 63]
    }
    return id
  })

module.exports = { nanoid, customAlphabet, random }

~~~

## node_modules\nanoid\async\index.d.ts

~~~ts
/**
 * Generate secure URL-friendly unique ID. The non-blocking version.
 *
 * By default, the ID will have 21 symbols to have a collision probability
 * similar to UUID v4.
 *
 * ```js
 * import { nanoid } from 'nanoid/async'
 * nanoid().then(id => {
 *   model.id = id
 * })
 * ```
 *
 * @param size Size of the ID. The default size is 21.
 * @returns A promise with a random string.
 */
export function nanoid(size?: number): Promise<string>

/**
 * A low-level function.
 * Generate secure unique ID with custom alphabet. The non-blocking version.
 *
 * Alphabet must contain 256 symbols or less. Otherwise, the generator
 * will not be secure.
 *
 * @param alphabet Alphabet used to generate the ID.
 * @param defaultSize Size of the ID. The default size is 21.
 * @returns A function that returns a promise with a random string.
 *
 * ```js
 * import { customAlphabet } from 'nanoid/async'
 * const nanoid = customAlphabet('0123456789逵閨勻均畇筠?', 5)
 * nanoid().then(id => {
 *   model.id = id //=> "8?56逵"
 * })
 * ```
 */
export function customAlphabet(
  alphabet: string,
  defaultSize?: number
): (size?: number) => Promise<string>

/**
 * Generate an array of random bytes collected from hardware noise.
 *
 * ```js
 * import { random } from 'nanoid/async'
 * random(5).then(bytes => {
 *   bytes //=> [10, 67, 212, 67, 89]
 * })
 * ```
 *
 * @param bytes Size of the array.
 * @returns A promise with a random bytes array.
 */
export function random(bytes: number): Promise<Uint8Array>

~~~

## node_modules\nanoid\async\index.js

~~~js
import crypto from 'crypto'
import { urlAlphabet } from '../url-alphabet/index.js'
let random = bytes =>
  new Promise((resolve, reject) => {
    crypto.randomFill(Buffer.allocUnsafe(bytes), (err, buf) => {
      if (err) {
        reject(err)
      } else {
        resolve(buf)
      }
    })
  })
let customAlphabet = (alphabet, defaultSize = 21) => {
  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1
  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)
  let tick = (id, size = defaultSize) =>
    random(step).then(bytes => {
      let i = step
      while (i--) {
        id += alphabet[bytes[i] & mask] || ''
        if (id.length >= size) return id
      }
      return tick(id, size)
    })
  return size => tick('', size)
}
let nanoid = (size = 21) =>
  random((size |= 0)).then(bytes => {
    let id = ''
    while (size--) {
      id += urlAlphabet[bytes[size] & 63]
    }
    return id
  })
export { nanoid, customAlphabet, random }

~~~

## node_modules\nanoid\async\index.native.js

~~~js
import { getRandomBytesAsync } from 'expo-random'
import { urlAlphabet } from '../url-alphabet/index.js'
let random = getRandomBytesAsync
let customAlphabet = (alphabet, defaultSize = 21) => {
  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1
  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)
  let tick = (id, size = defaultSize) =>
    random(step).then(bytes => {
      let i = step
      while (i--) {
        id += alphabet[bytes[i] & mask] || ''
        if (id.length >= size) return id
      }
      return tick(id, size)
    })
  return size => tick('', size)
}
let nanoid = (size = 21) =>
  random((size |= 0)).then(bytes => {
    let id = ''
    while (size--) {
      id += urlAlphabet[bytes[size] & 63]
    }
    return id
  })
export { nanoid, customAlphabet, random }

~~~

## node_modules\nanoid\async\package.json

~~~json
{
  "type": "module",
  "main": "index.cjs",
  "module": "index.js",
  "react-native": {
    "./index.js": "./index.native.js"
  },
  "browser": {
    "./index.js": "./index.browser.js",
    "./index.cjs": "./index.browser.cjs"
  }
}
~~~

## node_modules\nanoid\bin\nanoid.cjs

~~~cjs
#!/usr/bin/env node

let { nanoid, customAlphabet } = require('..')

function print(msg) {
  process.stdout.write(msg + '\n')
}

function error(msg) {
  process.stderr.write(msg + '\n')
  process.exit(1)
}

if (process.argv.includes('--help') || process.argv.includes('-h')) {
  print(`
  Usage
    $ nanoid [options]

  Options
    -s, --size       Generated ID size
    -a, --alphabet   Alphabet to use
    -h, --help       Show this help

  Examples
    $ nanoid --s 15
    S9sBF77U6sDB8Yg

    $ nanoid --size 10 --alphabet abc
    bcabababca`)
  process.exit()
}

let alphabet, size
for (let i = 2; i < process.argv.length; i++) {
  let arg = process.argv[i]
  if (arg === '--size' || arg === '-s') {
    size = Number(process.argv[i + 1])
    i += 1
    if (Number.isNaN(size) || size <= 0) {
      error('Size must be positive integer')
    }
  } else if (arg === '--alphabet' || arg === '-a') {
    alphabet = process.argv[i + 1]
    i += 1
  } else {
    error('Unknown argument ' + arg)
  }
}

if (alphabet) {
  let customNanoid = customAlphabet(alphabet, size)
  print(customNanoid())
} else {
  print(nanoid(size))
}

~~~

## node_modules\nanoid\index.browser.cjs

~~~cjs
// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.

let { urlAlphabet } = require('./url-alphabet/index.cjs')

let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))

let customRandom = (alphabet, defaultSize, getRandom) => {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  // `Math.clz32` is not used, because it is not available in browsers.
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.

  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.

  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).

  // `-~f => Math.ceil(f)` if f is a float
  // `-~i => i + 1` if i is an integer
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)

  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      // A compact alternative for `for (var i = 0; i < step; i++)`.
      let j = step | 0
      while (j--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}

let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)

let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    // It is incorrect to use bytes exceeding the alphabet size.
    // The following mask reduces the random byte in the 0-255 value
    // range to the 0-63 value range. Therefore, adding hacks, such
    // as empty string fallback or magic numbers, is unneccessary because
    // the bitmask trims bytes down to the alphabet size.
    byte &= 63
    if (byte < 36) {
      // `0-9a-z`
      id += byte.toString(36)
    } else if (byte < 62) {
      // `A-Z`
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')

module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

~~~

## node_modules\nanoid\index.browser.js

~~~js
import { urlAlphabet } from './url-alphabet/index.js'
let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step | 0
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')
export { nanoid, customAlphabet, customRandom, urlAlphabet, random }

~~~

## node_modules\nanoid\index.cjs

~~~cjs
let crypto = require('crypto')

let { urlAlphabet } = require('./url-alphabet/index.cjs')

// It is best to make fewer, larger requests to the crypto module to
// avoid system call overhead. So, random numbers are generated in a
// pool. The pool is a Buffer that is larger than the initial random
// request size by this multiplier. The pool is enlarged if subsequent
// requests exceed the maximum buffer size.
const POOL_SIZE_MULTIPLIER = 128
let pool, poolOffset

let fillPool = bytes => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)
    crypto.randomFillSync(pool)
    poolOffset = 0
  } else if (poolOffset + bytes > pool.length) {
    crypto.randomFillSync(pool)
    poolOffset = 0
  }
  poolOffset += bytes
}

let random = bytes => {
  // `|=` convert `bytes` to number to prevent `valueOf` abusing and pool pollution
  fillPool((bytes |= 0))
  return pool.subarray(poolOffset - bytes, poolOffset)
}

let customRandom = (alphabet, defaultSize, getRandom) => {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1
  // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.

  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.

  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).
  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)

  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      // A compact alternative for `for (let i = 0; i < step; i++)`.
      let i = step
      while (i--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[i] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}

let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)

let nanoid = (size = 21) => {
  // `|=` convert `size` to number to prevent `valueOf` abusing and pool pollution
  fillPool((size |= 0))
  let id = ''
  // We are reading directly from the random pool to avoid creating new array
  for (let i = poolOffset - size; i < poolOffset; i++) {
    // It is incorrect to use bytes exceeding the alphabet size.
    // The following mask reduces the random byte in the 0-255 value
    // range to the 0-63 value range. Therefore, adding hacks, such
    // as empty string fallback or magic numbers, is unneccessary because
    // the bitmask trims bytes down to the alphabet size.
    id += urlAlphabet[pool[i] & 63]
  }
  return id
}

module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

~~~

## node_modules\nanoid\index.d.cts

~~~cts
/**
 * Generate secure URL-friendly unique ID.
 *
 * By default, the ID will have 21 symbols to have a collision probability
 * similar to UUID v4.
 *
 * ```js
 * import { nanoid } from 'nanoid'
 * model.id = nanoid() //=> "Uakgb_J5m9g-0JDMbcJqL"
 * ```
 *
 * @param size Size of the ID. The default size is 21.
 * @returns A random string.
 */
export function nanoid(size?: number): string

/**
 * Generate secure unique ID with custom alphabet.
 *
 * Alphabet must contain 256 symbols or less. Otherwise, the generator
 * will not be secure.
 *
 * @param alphabet Alphabet used to generate the ID.
 * @param defaultSize Size of the ID. The default size is 21.
 * @returns A random string generator.
 *
 * ```js
 * const { customAlphabet } = require('nanoid')
 * const nanoid = customAlphabet('0123456789逵閨勻均畇筠?', 5)
 * nanoid() //=> "8?56逵"
 * ```
 */
export function customAlphabet(
  alphabet: string,
  defaultSize?: number
): (size?: number) => string

/**
 * Generate unique ID with custom random generator and alphabet.
 *
 * Alphabet must contain 256 symbols or less. Otherwise, the generator
 * will not be secure.
 *
 * ```js
 * import { customRandom } from 'nanoid/format'
 *
 * const nanoid = customRandom('abcdef', 5, size => {
 *   const random = []
 *   for (let i = 0; i < size; i++) {
 *     random.push(randomByte())
 *   }
 *   return random
 * })
 *
 * nanoid() //=> "fbaef"
 * ```
 *
 * @param alphabet Alphabet used to generate a random string.
 * @param size Size of the random string.
 * @param random A random bytes generator.
 * @returns A random string generator.
 */
export function customRandom(
  alphabet: string,
  size: number,
  random: (bytes: number) => Uint8Array
): () => string

/**
 * URL safe symbols.
 *
 * ```js
 * import { urlAlphabet } from 'nanoid'
 * const nanoid = customAlphabet(urlAlphabet, 10)
 * nanoid() //=> "Uakgb_J5m9"
 * ```
 */
export const urlAlphabet: string

/**
 * Generate an array of random bytes collected from hardware noise.
 *
 * ```js
 * import { customRandom, random } from 'nanoid'
 * const nanoid = customRandom("abcdef", 5, random)
 * ```
 *
 * @param bytes Size of the array.
 * @returns An array of random bytes.
 */
export function random(bytes: number): Uint8Array

~~~

## node_modules\nanoid\index.d.ts

~~~ts
/**
 * Generate secure URL-friendly unique ID.
 *
 * By default, the ID will have 21 symbols to have a collision probability
 * similar to UUID v4.
 *
 * ```js
 * import { nanoid } from 'nanoid'
 * model.id = nanoid() //=> "Uakgb_J5m9g-0JDMbcJqL"
 * ```
 *
 * @param size Size of the ID. The default size is 21.
 * @returns A random string.
 */
export function nanoid(size?: number): string

/**
 * Generate secure unique ID with custom alphabet.
 *
 * Alphabet must contain 256 symbols or less. Otherwise, the generator
 * will not be secure.
 *
 * @param alphabet Alphabet used to generate the ID.
 * @param defaultSize Size of the ID. The default size is 21.
 * @returns A random string generator.
 *
 * ```js
 * const { customAlphabet } = require('nanoid')
 * const nanoid = customAlphabet('0123456789逵閨勻均畇筠?', 5)
 * nanoid() //=> "8?56逵"
 * ```
 */
export function customAlphabet(
  alphabet: string,
  defaultSize?: number
): (size?: number) => string

/**
 * Generate unique ID with custom random generator and alphabet.
 *
 * Alphabet must contain 256 symbols or less. Otherwise, the generator
 * will not be secure.
 *
 * ```js
 * import { customRandom } from 'nanoid/format'
 *
 * const nanoid = customRandom('abcdef', 5, size => {
 *   const random = []
 *   for (let i = 0; i < size; i++) {
 *     random.push(randomByte())
 *   }
 *   return random
 * })
 *
 * nanoid() //=> "fbaef"
 * ```
 *
 * @param alphabet Alphabet used to generate a random string.
 * @param size Size of the random string.
 * @param random A random bytes generator.
 * @returns A random string generator.
 */
export function customRandom(
  alphabet: string,
  size: number,
  random: (bytes: number) => Uint8Array
): () => string

/**
 * URL safe symbols.
 *
 * ```js
 * import { urlAlphabet } from 'nanoid'
 * const nanoid = customAlphabet(urlAlphabet, 10)
 * nanoid() //=> "Uakgb_J5m9"
 * ```
 */
export const urlAlphabet: string

/**
 * Generate an array of random bytes collected from hardware noise.
 *
 * ```js
 * import { customRandom, random } from 'nanoid'
 * const nanoid = customRandom("abcdef", 5, random)
 * ```
 *
 * @param bytes Size of the array.
 * @returns An array of random bytes.
 */
export function random(bytes: number): Uint8Array

~~~

## node_modules\nanoid\index.js

~~~js
import crypto from 'crypto'
import { urlAlphabet } from './url-alphabet/index.js'
const POOL_SIZE_MULTIPLIER = 128
let pool, poolOffset
let fillPool = bytes => {
  if (!pool || pool.length < bytes) {
    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)
    crypto.randomFillSync(pool)
    poolOffset = 0
  } else if (poolOffset + bytes > pool.length) {
    crypto.randomFillSync(pool)
    poolOffset = 0
  }
  poolOffset += bytes
}
let random = bytes => {
  fillPool((bytes |= 0))
  return pool.subarray(poolOffset - bytes, poolOffset)
}
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1
  let step = Math.ceil((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let i = step
      while (i--) {
        id += alphabet[bytes[i] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) => {
  fillPool((size |= 0))
  let id = ''
  for (let i = poolOffset - size; i < poolOffset; i++) {
    id += urlAlphabet[pool[i] & 63]
  }
  return id
}
export { nanoid, customAlphabet, customRandom, urlAlphabet, random }

~~~

## node_modules\nanoid\LICENSE

~~~text
The MIT License (MIT)

Copyright 2017 Andrey Sitnik <andrey@sitnik.ru>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

~~~

## node_modules\nanoid\nanoid.js

~~~js
export let nanoid=(t=21)=>crypto.getRandomValues(new Uint8Array(t)).reduce(((t,e)=>t+=(e&=63)<36?e.toString(36):e<62?(e-26).toString(36).toUpperCase():e<63?"_":"-"),"");
~~~

## node_modules\nanoid\non-secure\index.cjs

~~~cjs
// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'

let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    let i = size | 0
    while (i--) {
      // `| 0` is more compact and faster than `Math.floor()`.
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}

let nanoid = (size = 21) => {
  let id = ''
  // A compact alternative for `for (var i = 0; i < step; i++)`.
  let i = size | 0
  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}

module.exports = { nanoid, customAlphabet }

~~~

## node_modules\nanoid\non-secure\index.d.ts

~~~ts
/**
 * Generate URL-friendly unique ID. This method uses the non-secure
 * predictable random generator with bigger collision probability.
 *
 * ```js
 * import { nanoid } from 'nanoid/non-secure'
 * model.id = nanoid() //=> "Uakgb_J5m9g-0JDMbcJqL"
 * ```
 *
 * @param size Size of the ID. The default size is 21.
 * @returns A random string.
 */
export function nanoid(size?: number): string

/**
 * Generate a unique ID based on a custom alphabet.
 * This method uses the non-secure predictable random generator
 * with bigger collision probability.
 *
 * @param alphabet Alphabet used to generate the ID.
 * @param defaultSize Size of the ID. The default size is 21.
 * @returns A random string generator.
 *
 * ```js
 * import { customAlphabet } from 'nanoid/non-secure'
 * const nanoid = customAlphabet('0123456789逵閨勻均畇筠?', 5)
 * model.id = //=> "8?56逵"
 * ```
 */
export function customAlphabet(
  alphabet: string,
  defaultSize?: number
): (size?: number) => string

~~~

## node_modules\nanoid\non-secure\index.js

~~~js
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = ''
    let i = size | 0
    while (i--) {
      id += alphabet[(Math.random() * alphabet.length) | 0]
    }
    return id
  }
}
let nanoid = (size = 21) => {
  let id = ''
  let i = size | 0
  while (i--) {
    id += urlAlphabet[(Math.random() * 64) | 0]
  }
  return id
}
export { nanoid, customAlphabet }

~~~

## node_modules\nanoid\non-secure\package.json

~~~json
{
  "type": "module",
  "main": "index.cjs",
  "module": "index.js",
  "react-native": "index.js"
}
~~~

## node_modules\nanoid\package.json

~~~json
{
  "name": "nanoid",
  "version": "3.3.11",
  "description": "A tiny (116 bytes), secure URL-friendly unique string ID generator",
  "keywords": [
    "uuid",
    "random",
    "id",
    "url"
  ],
  "engines": {
    "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
  },
  "funding": [
    {
      "type": "github",
      "url": "https://github.com/sponsors/ai"
    }
  ],
  "author": "Andrey Sitnik <andrey@sitnik.ru>",
  "license": "MIT",
  "repository": "ai/nanoid",
  "browser": {
    "./index.js": "./index.browser.js",
    "./async/index.js": "./async/index.browser.js",
    "./async/index.cjs": "./async/index.browser.cjs",
    "./index.cjs": "./index.browser.cjs"
  },
  "react-native": "index.js",
  "bin": "./bin/nanoid.cjs",
  "sideEffects": false,
  "types": "./index.d.ts",
  "type": "module",
  "main": "index.cjs",
  "module": "index.js",
  "exports": {
    ".": {
      "react-native": "./index.browser.js",
      "browser": "./index.browser.js",
      "require": {
        "types": "./index.d.cts",
        "default": "./index.cjs"
      },
      "import": {
        "types": "./index.d.ts",
        "default": "./index.js"
      },
      "default": "./index.js"
    },
    "./package.json": "./package.json",
    "./async/package.json": "./async/package.json",
    "./async": {
      "browser": "./async/index.browser.js",
      "require": {
        "types": "./index.d.cts",
        "default": "./async/index.cjs"
      },
      "import": {
        "types": "./index.d.ts",
        "default": "./async/index.js"
      },
      "default": "./async/index.js"
    },
    "./non-secure/package.json": "./non-secure/package.json",
    "./non-secure": {
      "require": {
        "types": "./index.d.cts",
        "default": "./non-secure/index.cjs"
      },
      "import": {
        "types": "./index.d.ts",
        "default": "./non-secure/index.js"
      },
      "default": "./non-secure/index.js"
    },
    "./url-alphabet/package.json": "./url-alphabet/package.json",
    "./url-alphabet": {
      "require": {
        "types": "./index.d.cts",
        "default": "./url-alphabet/index.cjs"
      },
      "import": {
        "types": "./index.d.ts",
        "default": "./url-alphabet/index.js"
      },
      "default": "./url-alphabet/index.js"
    }
  }
}

~~~

## node_modules\nanoid\README.md

~~~md
# Nano ID

<img src="https://ai.github.io/nanoid/logo.svg" align="right"
     alt="Nano ID logo by Anton Lovchikov" width="180" height="94">

**English** | [????克龜橘](./README.ru.md) | [嶸鵝볞릎??(./README.zh-CN.md) | [Bahasa Indonesia](./README.id-ID.md)

A tiny, secure, URL-friendly, unique혻string ID혻generator for혻JavaScript.

> ?쏛n amazing level of senseless perfectionism,
> which is simply impossible not to respect.??
* **Small.** 130 bytes (minified and gzipped). No혻dependencies.
  [Size Limit] controls the size.
* **Fast.** It is 2 times faster than UUID.
* **Safe.** It uses hardware random generator. Can be used in clusters.
* **Short IDs.** It uses a혻larger alphabet than UUID (`A-Za-z0-9_-`).
  So ID size was reduced from혻36혻to혻21혻symbols.
* **Portable.** Nano ID was ported
  to [20 programming languages](#other-programming-languages).

```js
import { nanoid } from 'nanoid'
model.id = nanoid() //=> "V1StGXR8_Z5jdHi6B-myT"
```

Supports modern browsers, IE [with Babel], Node.js and React Native.

[online tool]: https://gitpod.io/#https://github.com/ai/nanoid/
[with Babel]:  https://developer.epages.com/blog/coding/how-to-transpile-node-modules-with-babel-and-webpack-in-a-monorepo/
[Size Limit]:  https://github.com/ai/size-limit

<a href="https://evilmartians.com/?utm_source=nanoid">
  <img src="https://evilmartians.com/badges/sponsored-by-evil-martians.svg"
       alt="Sponsored by Evil Martians" width="236" height="54">
</a>

## Docs
Read full docs **[here](https://github.com/ai/nanoid#readme)**.

~~~

## node_modules\nanoid\url-alphabet\index.cjs

~~~cjs
// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// Same as in non-secure/index.js
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'

module.exports = { urlAlphabet }

~~~

## node_modules\nanoid\url-alphabet\index.js

~~~js
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
export { urlAlphabet }

~~~

## node_modules\nanoid\url-alphabet\package.json

~~~json
{
  "type": "module",
  "main": "index.cjs",
  "module": "index.js",
  "react-native": "index.js"
}
~~~

## node_modules\picocolors\LICENSE

~~~text
ISC License

Copyright (c) 2021-2024 Oleksii Raspopov, Kostiantyn Denysov, Anton Verinov

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

~~~

## node_modules\picocolors\package.json

~~~json
{
  "name": "picocolors",
  "version": "1.1.1",
  "main": "./picocolors.js",
  "types": "./picocolors.d.ts",
  "browser": {
    "./picocolors.js": "./picocolors.browser.js"
  },
  "sideEffects": false,
  "description": "The tiniest and the fastest library for terminal output formatting with ANSI colors",
  "files": [
    "picocolors.*",
    "types.d.ts"
  ],
  "keywords": [
    "terminal",
    "colors",
    "formatting",
    "cli",
    "console"
  ],
  "author": "Alexey Raspopov",
  "repository": "alexeyraspopov/picocolors",
  "license": "ISC"
}

~~~

## node_modules\picocolors\picocolors.browser.js

~~~js
var x=String;
var create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};
module.exports=create();
module.exports.createColors = create;

~~~

## node_modules\picocolors\picocolors.d.ts

~~~ts
import { Colors } from "./types"

declare const picocolors: Colors & { createColors: (enabled?: boolean) => Colors }

export = picocolors

~~~

## node_modules\picocolors\picocolors.js

~~~js
let p = process || {}, argv = p.argv || [], env = p.env || {}
let isColorSupported =
	!(!!env.NO_COLOR || argv.includes("--no-color")) &&
	(!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || ((p.stdout || {}).isTTY && env.TERM !== "dumb") || !!env.CI)

let formatter = (open, close, replace = open) =>
	input => {
		let string = "" + input, index = string.indexOf(close, open.length)
		return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close
	}

let replaceClose = (string, close, replace, index) => {
	let result = "", cursor = 0
	do {
		result += string.substring(cursor, index) + replace
		cursor = index + close.length
		index = string.indexOf(close, cursor)
	} while (~index)
	return result + string.substring(cursor)
}

let createColors = (enabled = isColorSupported) => {
	let f = enabled ? formatter : () => String
	return {
		isColorSupported: enabled,
		reset: f("\x1b[0m", "\x1b[0m"),
		bold: f("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m"),
		dim: f("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m"),
		italic: f("\x1b[3m", "\x1b[23m"),
		underline: f("\x1b[4m", "\x1b[24m"),
		inverse: f("\x1b[7m", "\x1b[27m"),
		hidden: f("\x1b[8m", "\x1b[28m"),
		strikethrough: f("\x1b[9m", "\x1b[29m"),

		black: f("\x1b[30m", "\x1b[39m"),
		red: f("\x1b[31m", "\x1b[39m"),
		green: f("\x1b[32m", "\x1b[39m"),
		yellow: f("\x1b[33m", "\x1b[39m"),
		blue: f("\x1b[34m", "\x1b[39m"),
		magenta: f("\x1b[35m", "\x1b[39m"),
		cyan: f("\x1b[36m", "\x1b[39m"),
		white: f("\x1b[37m", "\x1b[39m"),
		gray: f("\x1b[90m", "\x1b[39m"),

		bgBlack: f("\x1b[40m", "\x1b[49m"),
		bgRed: f("\x1b[41m", "\x1b[49m"),
		bgGreen: f("\x1b[42m", "\x1b[49m"),
		bgYellow: f("\x1b[43m", "\x1b[49m"),
		bgBlue: f("\x1b[44m", "\x1b[49m"),
		bgMagenta: f("\x1b[45m", "\x1b[49m"),
		bgCyan: f("\x1b[46m", "\x1b[49m"),
		bgWhite: f("\x1b[47m", "\x1b[49m"),

		blackBright: f("\x1b[90m", "\x1b[39m"),
		redBright: f("\x1b[91m", "\x1b[39m"),
		greenBright: f("\x1b[92m", "\x1b[39m"),
		yellowBright: f("\x1b[93m", "\x1b[39m"),
		blueBright: f("\x1b[94m", "\x1b[39m"),
		magentaBright: f("\x1b[95m", "\x1b[39m"),
		cyanBright: f("\x1b[96m", "\x1b[39m"),
		whiteBright: f("\x1b[97m", "\x1b[39m"),

		bgBlackBright: f("\x1b[100m", "\x1b[49m"),
		bgRedBright: f("\x1b[101m", "\x1b[49m"),
		bgGreenBright: f("\x1b[102m", "\x1b[49m"),
		bgYellowBright: f("\x1b[103m", "\x1b[49m"),
		bgBlueBright: f("\x1b[104m", "\x1b[49m"),
		bgMagentaBright: f("\x1b[105m", "\x1b[49m"),
		bgCyanBright: f("\x1b[106m", "\x1b[49m"),
		bgWhiteBright: f("\x1b[107m", "\x1b[49m"),
	}
}

module.exports = createColors()
module.exports.createColors = createColors

~~~

## node_modules\picocolors\README.md

~~~md
# picocolors

The tiniest and the fastest library for terminal output formatting with ANSI colors.

```javascript
import pc from "picocolors"

console.log(
  pc.green(`How are ${pc.italic(`you`)} doing?`)
)
```

- **No dependencies.**
- **14 times** smaller and **2 times** faster than chalk.
- Used by popular tools like PostCSS, SVGO, Stylelint, and Browserslist.
- Node.js v6+ & browsers support. Support for both CJS and ESM projects.
- TypeScript type declarations included.
- [`NO_COLOR`](https://no-color.org/) friendly.

## Docs
Read **[full docs](https://github.com/alexeyraspopov/picocolors#readme)** on GitHub.

~~~

## node_modules\picocolors\types.d.ts

~~~ts
export type Formatter = (input: string | number | null | undefined) => string

export interface Colors {
	isColorSupported: boolean

	reset: Formatter
	bold: Formatter
	dim: Formatter
	italic: Formatter
	underline: Formatter
	inverse: Formatter
	hidden: Formatter
	strikethrough: Formatter

	black: Formatter
	red: Formatter
	green: Formatter
	yellow: Formatter
	blue: Formatter
	magenta: Formatter
	cyan: Formatter
	white: Formatter
	gray: Formatter

	bgBlack: Formatter
	bgRed: Formatter
	bgGreen: Formatter
	bgYellow: Formatter
	bgBlue: Formatter
	bgMagenta: Formatter
	bgCyan: Formatter
	bgWhite: Formatter

	blackBright: Formatter
	redBright: Formatter
	greenBright: Formatter
	yellowBright: Formatter
	blueBright: Formatter
	magentaBright: Formatter
	cyanBright: Formatter
	whiteBright: Formatter

	bgBlackBright: Formatter
	bgRedBright: Formatter
	bgGreenBright: Formatter
	bgYellowBright: Formatter
	bgBlueBright: Formatter
	bgMagentaBright: Formatter
	bgCyanBright: Formatter
	bgWhiteBright: Formatter
}

~~~

## node_modules\picomatch\index.js

~~~js
'use strict';

const pico = require('./lib/picomatch');
const utils = require('./lib/utils');

function picomatch(glob, options, returnState = false) {
  // default to os.platform()
  if (options && (options.windows === null || options.windows === undefined)) {
    // don't mutate the original options object
    options = { ...options, windows: utils.isWindows() };
  }

  return pico(glob, options, returnState);
}

Object.assign(picomatch, pico);
module.exports = picomatch;

~~~

## node_modules\picomatch\lib\constants.js

~~~js
'use strict';

const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;
const SEP = '/';

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR,
  SEP
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
  SEP: '\\'
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    __proto__: null,
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};

~~~

## node_modules\picomatch\lib\parse.js

~~~js
'use strict';

const constants = require('./constants');
const utils = require('./utils');

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(opts.windows);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.output = (prev.output || prev.value) + tok.value;
      prev.value += tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(opts.windows);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = opts => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;

~~~

## node_modules\picomatch\lib\picomatch.js

~~~js
'use strict';

const scan = require('./scan');
const parse = require('./parse');
const utils = require('./utils');
const constants = require('./constants');
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = opts.windows;
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(utils.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Compile a regular expression from the `state` object returned by the
 * [parse()](#parse) method.
 *
 * @param {Object} `state`
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.
 * @param {Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
 * @return {RegExp}
 * @api public
 */

picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${state.output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @param {Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
 * @param {Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let parsed = { negated: false, fastpaths: true };

  if (options.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    parsed.output = parse.fastpaths(input, options);
  }

  if (!parsed.output) {
    parsed = parse(input, options);
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;

~~~

## node_modules\picomatch\lib\scan.js

~~~js
'use strict';

const utils = require('./utils');
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = require('./constants');

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index === start) {
          negatedExtglob = true;
        }

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;
          break;
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated,
    negatedExtglob
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;

~~~

## node_modules\picomatch\lib\utils.js

~~~js
/*global navigator*/
'use strict';

const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = require('./constants');

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.isWindows = () => {
  if (typeof navigator !== 'undefined' && navigator.platform) {
    const platform = navigator.platform.toLowerCase();
    return platform === 'win32' || platform === 'windows';
  }

  if (typeof process !== 'undefined' && process.platform) {
    return process.platform === 'win32';
  }

  return false;
};

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};

exports.basename = (path, { windows } = {}) => {
  const segs = path.split(windows ? /[\\/]/ : '/');
  const last = segs[segs.length - 1];

  if (last === '') {
    return segs[segs.length - 2];
  }

  return last;
};

~~~

## node_modules\picomatch\LICENSE

~~~text
The MIT License (MIT)

Copyright (c) 2017-present, Jon Schlinkert.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

~~~

## node_modules\picomatch\package.json

~~~json
{
  "name": "picomatch",
  "description": "Blazing fast and accurate glob matcher written in JavaScript, with no dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.",
  "version": "4.0.3",
  "homepage": "https://github.com/micromatch/picomatch",
  "author": "Jon Schlinkert (https://github.com/jonschlinkert)",
  "funding": "https://github.com/sponsors/jonschlinkert",
  "repository": "micromatch/picomatch",
  "bugs": {
    "url": "https://github.com/micromatch/picomatch/issues"
  },
  "license": "MIT",
  "files": [
    "index.js",
    "posix.js",
    "lib"
  ],
  "sideEffects": false,
  "main": "index.js",
  "engines": {
    "node": ">=12"
  },
  "scripts": {
    "lint": "eslint --cache --cache-location node_modules/.cache/.eslintcache --report-unused-disable-directives --ignore-path .gitignore .",
    "mocha": "mocha --reporter dot",
    "test": "npm run lint && npm run mocha",
    "test:ci": "npm run test:cover",
    "test:cover": "nyc npm run mocha"
  },
  "devDependencies": {
    "eslint": "^8.57.0",
    "fill-range": "^7.0.1",
    "gulp-format-md": "^2.0.0",
    "mocha": "^10.4.0",
    "nyc": "^15.1.0",
    "time-require": "github:jonschlinkert/time-require"
  },
  "keywords": [
    "glob",
    "match",
    "picomatch"
  ],
  "nyc": {
    "reporter": [
      "html",
      "lcov",
      "text-summary"
    ]
  },
  "verb": {
    "toc": {
      "render": true,
      "method": "preWrite",
      "maxdepth": 3
    },
    "layout": "empty",
    "tasks": [
      "readme"
    ],
    "plugins": [
      "gulp-format-md"
    ],
    "lint": {
      "reflinks": true
    },
    "related": {
      "list": [
        "braces",
        "micromatch"
      ]
    },
    "reflinks": [
      "braces",
      "expand-brackets",
      "extglob",
      "fill-range",
      "micromatch",
      "minimatch",
      "nanomatch",
      "picomatch"
    ]
  }
}

~~~

## node_modules\picomatch\posix.js

~~~js
'use strict';

module.exports = require('./lib/picomatch');

~~~

## node_modules\picomatch\README.md

~~~md
<h1 align="center">Picomatch</h1>

<p align="center">
<a href="https://npmjs.org/package/picomatch">
<img src="https://img.shields.io/npm/v/picomatch.svg" alt="version">
</a>
<a href="https://github.com/micromatch/picomatch/actions?workflow=Tests">
<img src="https://github.com/micromatch/picomatch/workflows/Tests/badge.svg" alt="test status">
</a>
<a href="https://coveralls.io/github/micromatch/picomatch">
<img src="https://img.shields.io/coveralls/github/micromatch/picomatch/master.svg" alt="coverage status">
</a>
<a href="https://npmjs.org/package/picomatch">
<img src="https://img.shields.io/npm/dm/picomatch.svg" alt="downloads">
</a>
</p>

<br>
<br>

<p align="center">
<strong>Blazing fast and accurate glob matcher written in JavaScript.</strong></br>
<em>No dependencies and full support for standard and extended Bash glob features, including braces, extglobs, POSIX brackets, and regular expressions.</em>
</p>

<br>
<br>

## Why picomatch?

* **Lightweight** - No dependencies
* **Minimal** - Tiny API surface. Main export is a function that takes a glob pattern and returns a matcher function.
* **Fast** - Loads in about 2ms (that's several times faster than a [single frame of a HD movie](http://www.endmemo.com/sconvert/framespersecondframespermillisecond.php) at 60fps)
* **Performant** - Use the returned matcher function to speed up repeat matching (like when watching files)
* **Accurate matching** - Using wildcards (`*` and `?`), globstars (`**`) for nested directories, [advanced globbing](#advanced-globbing) with extglobs, braces, and POSIX brackets, and support for escaping special characters with `\` or quotes.
* **Well tested** - Thousands of unit tests

See the [library comparison](#library-comparisons) to other libraries.

<br>
<br>

## Table of Contents

<details><summary> Click to expand </summary>

- [Install](#install)
- [Usage](#usage)
- [API](#api)
  * [picomatch](#picomatch)
  * [.test](#test)
  * [.matchBase](#matchbase)
  * [.isMatch](#ismatch)
  * [.parse](#parse)
  * [.scan](#scan)
  * [.compileRe](#compilere)
  * [.makeRe](#makere)
  * [.toRegex](#toregex)
- [Options](#options)
  * [Picomatch options](#picomatch-options)
  * [Scan Options](#scan-options)
  * [Options Examples](#options-examples)
- [Globbing features](#globbing-features)
  * [Basic globbing](#basic-globbing)
  * [Advanced globbing](#advanced-globbing)
  * [Braces](#braces)
  * [Matching special characters as literals](#matching-special-characters-as-literals)
- [Library Comparisons](#library-comparisons)
- [Benchmarks](#benchmarks)
- [Philosophies](#philosophies)
- [About](#about)
  * [Author](#author)
  * [License](#license)

_(TOC generated by [verb](https://github.com/verbose/verb) using [markdown-toc](https://github.com/jonschlinkert/markdown-toc))_

</details>

<br>
<br>

## Install

Install with [npm](https://www.npmjs.com/):

```sh
npm install --save picomatch
```

<br>

## Usage

The main export is a function that takes a glob pattern and an options object and returns a function for matching strings.

```js
const pm = require('picomatch');
const isMatch = pm('*.js');

console.log(isMatch('abcd')); //=> false
console.log(isMatch('a.js')); //=> true
console.log(isMatch('a.md')); //=> false
console.log(isMatch('a/b.js')); //=> false
```

<br>

## API

### [picomatch](lib/picomatch.js#L31)

Creates a matcher function from one or more glob patterns. The returned function takes a string to match as its first argument, and returns true if the string is a match. The returned matcher function also takes a boolean as the second argument that, when true, returns an object with additional information.

**Params**

* `globs` **{String|Array}**: One or more glob patterns.
* `options` **{Object=}**
* `returns` **{Function=}**: Returns a matcher function.

**Example**

```js
const picomatch = require('picomatch');
// picomatch(glob[, options]);

const isMatch = picomatch('*.!(*a)');
console.log(isMatch('a.a')); //=> false
console.log(isMatch('a.b')); //=> true
```

**Example without node.js**

For environments without `node.js`, `picomatch/posix` provides you a dependency-free matcher, without automatic OS detection.

```js
const picomatch = require('picomatch/posix');
// the same API, defaulting to posix paths
const isMatch = picomatch('a/*');
console.log(isMatch('a\\b')); //=> false
console.log(isMatch('a/b')); //=> true

// you can still configure the matcher function to accept windows paths
const isMatch = picomatch('a/*', { options: windows });
console.log(isMatch('a\\b')); //=> true
console.log(isMatch('a/b')); //=> true
```

### [.test](lib/picomatch.js#L116)

Test `input` with the given `regex`. This is used by the main `picomatch()` function to test the input string.

**Params**

* `input` **{String}**: String to test.
* `regex` **{RegExp}**
* `returns` **{Object}**: Returns an object with matching info.

**Example**

```js
const picomatch = require('picomatch');
// picomatch.test(input, regex[, options]);

console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
// { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
```

### [.matchBase](lib/picomatch.js#L160)

Match the basename of a filepath.

**Params**

* `input` **{String}**: String to test.
* `glob` **{RegExp|String}**: Glob pattern or regex created by [.makeRe](#makeRe).
* `returns` **{Boolean}**

**Example**

```js
const picomatch = require('picomatch');
// picomatch.matchBase(input, glob[, options]);
console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
```

### [.isMatch](lib/picomatch.js#L182)

Returns true if **any** of the given glob `patterns` match the specified `string`.

**Params**

* **{String|Array}**: str The string to test.
* **{String|Array}**: patterns One or more glob patterns to use for matching.
* **{Object}**: See available [options](#options).
* `returns` **{Boolean}**: Returns true if any patterns match `str`

**Example**

```js
const picomatch = require('picomatch');
// picomatch.isMatch(string, patterns[, options]);

console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
```

### [.parse](lib/picomatch.js#L198)

Parse a glob pattern to create the source string for a regular expression.

**Params**

* `pattern` **{String}**
* `options` **{Object}**
* `returns` **{Object}**: Returns an object with useful properties and output to be used as a regex source string.

**Example**

```js
const picomatch = require('picomatch');
const result = picomatch.parse(pattern[, options]);
```

### [.scan](lib/picomatch.js#L230)

Scan a glob pattern to separate the pattern into segments.

**Params**

* `input` **{String}**: Glob pattern to scan.
* `options` **{Object}**
* `returns` **{Object}**: Returns an object with

**Example**

```js
const picomatch = require('picomatch');
// picomatch.scan(input[, options]);

const result = picomatch.scan('!./foo/*.js');
console.log(result);
{ prefix: '!./',
  input: '!./foo/*.js',
  start: 3,
  base: 'foo',
  glob: '*.js',
  isBrace: false,
  isBracket: false,
  isGlob: true,
  isExtglob: false,
  isGlobstar: false,
  negated: true }
```

### [.compileRe](lib/picomatch.js#L244)

Compile a regular expression from the `state` object returned by the
[parse()](#parse) method.

**Params**

* `state` **{Object}**
* `options` **{Object}**
* `returnOutput` **{Boolean}**: Intended for implementors, this argument allows you to return the raw output from the parser.
* `returnState` **{Boolean}**: Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.
* `returns` **{RegExp}**

### [.makeRe](lib/picomatch.js#L285)

Create a regular expression from a parsed glob pattern.

**Params**

* `state` **{String}**: The object returned from the `.parse` method.
* `options` **{Object}**
* `returnOutput` **{Boolean}**: Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.
* `returnState` **{Boolean}**: Implementors may use this argument to return the state from the parsed glob with the returned regular expression.
* `returns` **{RegExp}**: Returns a regex created from the given pattern.

**Example**

```js
const picomatch = require('picomatch');
const state = picomatch.parse('*.js');
// picomatch.compileRe(state[, options]);

console.log(picomatch.compileRe(state));
//=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
```

### [.toRegex](lib/picomatch.js#L320)

Create a regular expression from the given regex source string.

**Params**

* `source` **{String}**: Regular expression source string.
* `options` **{Object}**
* `returns` **{RegExp}**

**Example**

```js
const picomatch = require('picomatch');
// picomatch.toRegex(source[, options]);

const { output } = picomatch.parse('*.js');
console.log(picomatch.toRegex(output));
//=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
```

<br>

## Options

### Picomatch options

The following options may be used with the main `picomatch()` function or any of the methods on the picomatch API.

| **Option** | **Type** | **Default value** | **Description** |
| --- | --- | --- | --- |
| `basename`            | `boolean`      | `false`     | If set, then patterns without slashes will be matched against the basename of the path if it contains slashes.  For example, `a?b` would match the path `/xyz/123/acb`, but not `/xyz/acb/123`. |
| `bash`                | `boolean`      | `false`     | Follow bash matching rules more strictly - disallows backslashes as escape characters, and treats single stars as globstars (`**`). |
| `capture`             | `boolean`      | `undefined` | Return regex matches in supporting methods. |
| `contains`            | `boolean`      | `undefined` | Allows glob to match any part of the given string(s). |
| `cwd`                 | `string`       | `process.cwd()` | Current working directory. Used by `picomatch.split()` |
| `debug`               | `boolean`      | `undefined` | Debug regular expressions when an error is thrown. |
| `dot`                 | `boolean`      | `false`     | Enable dotfile matching. By default, dotfiles are ignored unless a `.` is explicitly defined in the pattern, or `options.dot` is true |
| `expandRange`         | `function`     | `undefined` | Custom function for expanding ranges in brace patterns, such as `{a..z}`. The function receives the range values as two arguments, and it must return a string to be used in the generated regex. It's recommended that returned strings be wrapped in parentheses. |
| `failglob`            | `boolean`      | `false`     | Throws an error if no matches are found. Based on the bash option of the same name. |
| `fastpaths`           | `boolean`      | `true`      | To speed up processing, full parsing is skipped for a handful common glob patterns. Disable this behavior by setting this option to `false`. |
| `flags`               | `string`      | `undefined` | Regex flags to use in the generated regex. If defined, the `nocase` option will be overridden. |
| [format](#optionsformat) | `function` | `undefined` | Custom function for formatting the returned string. This is useful for removing leading slashes, converting Windows paths to Posix paths, etc. |
| `ignore`              | `array\|string` | `undefined` | One or more glob patterns for excluding strings that should not be matched from the result. |
| `keepQuotes`          | `boolean`      | `false`     | Retain quotes in the generated regex, since quotes may also be used as an alternative to backslashes.  |
| `literalBrackets`     | `boolean`      | `undefined` | When `true`, brackets in the glob pattern will be escaped so that only literal brackets will be matched. |
| `matchBase`           | `boolean`      | `false`     | Alias for `basename` |
| `maxLength`           | `number`      | `65536`     | Limit the max length of the input string. An error is thrown if the input string is longer than this value. |
| `nobrace`             | `boolean`      | `false`     | Disable brace matching, so that `{a,b}` and `{1..3}` would be treated as literal characters. |
| `nobracket`           | `boolean`      | `undefined` | Disable matching with regex brackets. |
| `nocase`              | `boolean`      | `false`     | Make matching case-insensitive. Equivalent to the regex `i` flag. Note that this option is overridden by the `flags` option. |
| `nodupes`             | `boolean`      | `true`      | Deprecated, use `nounique` instead. This option will be removed in a future major release. By default duplicates are removed. Disable uniquification by setting this option to false. |
| `noext`               | `boolean`      | `false`     | Alias for `noextglob` |
| `noextglob`           | `boolean`      | `false`     | Disable support for matching with extglobs (like `+(a\|b)`) |
| `noglobstar`          | `boolean`      | `false`     | Disable support for matching nested directories with globstars (`**`) |
| `nonegate`            | `boolean`      | `false`     | Disable support for negating with leading `!` |
| `noquantifiers`       | `boolean`      | `false`     | Disable support for regex quantifiers (like `a{1,2}`) and treat them as brace patterns to be expanded. |
| [onIgnore](#optionsonIgnore) | `function` | `undefined` | Function to be called on ignored items. |
| [onMatch](#optionsonMatch) | `function` | `undefined` | Function to be called on matched items. |
| [onResult](#optionsonResult) | `function` | `undefined` | Function to be called on all items, regardless of whether or not they are matched or ignored. |
| `posix`               | `boolean`      | `false`     | Support POSIX character classes ("posix brackets"). |
| `posixSlashes`        | `boolean`      | `undefined` | Convert all slashes in file paths to forward slashes. This does not convert slashes in the glob pattern itself |
| `prepend`             | `boolean`      | `undefined` | String to prepend to the generated regex used for matching. |
| `regex`               | `boolean`      | `false`     | Use regular expression rules for `+` (instead of matching literal `+`), and for stars that follow closing parentheses or brackets (as in `)*` and `]*`). |
| `strictBrackets`      | `boolean`      | `undefined` | Throw an error if brackets, braces, or parens are imbalanced. |
| `strictSlashes`       | `boolean`      | `undefined` | When true, picomatch won't match trailing slashes with single stars. |
| `unescape`            | `boolean`      | `undefined` | Remove backslashes preceding escaped characters in the glob pattern. By default, backslashes are retained. |
| `unixify`             | `boolean`      | `undefined` | Alias for `posixSlashes`, for backwards compatibility. |
| `windows`             | `boolean`      | `false`     | Also accept backslashes as the path separator. |

### Scan Options

In addition to the main [picomatch options](#picomatch-options), the following options may also be used with the [.scan](#scan) method.

| **Option** | **Type** | **Default value** | **Description** |
| --- | --- | --- | --- |
| `tokens` | `boolean` | `false` | When `true`, the returned object will include an array of tokens (objects), representing each path "segment" in the scanned glob pattern |
| `parts` | `boolean` | `false` | When `true`, the returned object will include an array of strings representing each path "segment" in the scanned glob pattern. This is automatically enabled when `options.tokens` is true |

**Example**

```js
const picomatch = require('picomatch');
const result = picomatch.scan('!./foo/*.js', { tokens: true });
console.log(result);
// {
//   prefix: '!./',
//   input: '!./foo/*.js',
//   start: 3,
//   base: 'foo',
//   glob: '*.js',
//   isBrace: false,
//   isBracket: false,
//   isGlob: true,
//   isExtglob: false,
//   isGlobstar: false,
//   negated: true,
//   maxDepth: 2,
//   tokens: [
//     { value: '!./', depth: 0, isGlob: false, negated: true, isPrefix: true },
//     { value: 'foo', depth: 1, isGlob: false },
//     { value: '*.js', depth: 1, isGlob: true }
//   ],
//   slashes: [ 2, 6 ],
//   parts: [ 'foo', '*.js' ]
// }
```

<br>

### Options Examples

#### options.expandRange

**Type**: `function`

**Default**: `undefined`

Custom function for expanding ranges in brace patterns. The [fill-range](https://github.com/jonschlinkert/fill-range) library is ideal for this purpose, or you can use custom code to do whatever you need.

**Example**

The following example shows how to create a glob that matches a folder

```js
const fill = require('fill-range');
const regex = pm.makeRe('foo/{01..25}/bar', {
  expandRange(a, b) {
    return `(${fill(a, b, { toRegex: true })})`;
  }
});

console.log(regex);
//=> /^(?:foo\/((?:0[1-9]|1[0-9]|2[0-5]))\/bar)$/

console.log(regex.test('foo/00/bar'))  // false
console.log(regex.test('foo/01/bar'))  // true
console.log(regex.test('foo/10/bar')) // true
console.log(regex.test('foo/22/bar')) // true
console.log(regex.test('foo/25/bar')) // true
console.log(regex.test('foo/26/bar')) // false
```

#### options.format

**Type**: `function`

**Default**: `undefined`

Custom function for formatting strings before they're matched.

**Example**

```js
// strip leading './' from strings
const format = str => str.replace(/^\.\//, '');
const isMatch = picomatch('foo/*.js', { format });
console.log(isMatch('./foo/bar.js')); //=> true
```

#### options.onMatch

```js
const onMatch = ({ glob, regex, input, output }) => {
  console.log({ glob, regex, input, output });
};

const isMatch = picomatch('*', { onMatch });
isMatch('foo');
isMatch('bar');
isMatch('baz');
```

#### options.onIgnore

```js
const onIgnore = ({ glob, regex, input, output }) => {
  console.log({ glob, regex, input, output });
};

const isMatch = picomatch('*', { onIgnore, ignore: 'f*' });
isMatch('foo');
isMatch('bar');
isMatch('baz');
```

#### options.onResult

```js
const onResult = ({ glob, regex, input, output }) => {
  console.log({ glob, regex, input, output });
};

const isMatch = picomatch('*', { onResult, ignore: 'f*' });
isMatch('foo');
isMatch('bar');
isMatch('baz');
```

<br>
<br>

## Globbing features

* [Basic globbing](#basic-globbing) (Wildcard matching)
* [Advanced globbing](#advanced-globbing) (extglobs, posix brackets, brace matching)

### Basic globbing

| **Character** | **Description** |
| --- | --- |
| `*` | Matches any character zero or more times, excluding path separators. Does _not match_ path separators or hidden files or directories ("dotfiles"), unless explicitly enabled by setting the `dot` option to `true`. |
| `**` | Matches any character zero or more times, including path separators. Note that `**` will only match path separators (`/`, and `\\` with the `windows` option) when they are the only characters in a path segment. Thus, `foo**/bar` is equivalent to `foo*/bar`, and `foo/a**b/bar` is equivalent to `foo/a*b/bar`, and _more than two_ consecutive stars in a glob path segment are regarded as _a single star_. Thus, `foo/***/bar` is equivalent to `foo/*/bar`. |
| `?` | Matches any character excluding path separators one time. Does _not match_ path separators or leading dots.  |
| `[abc]` | Matches any characters inside the brackets. For example, `[abc]` would match the characters `a`, `b` or `c`, and nothing else. |

#### Matching behavior vs. Bash

Picomatch's matching features and expected results in unit tests are based on Bash's unit tests and the Bash 4.3 specification, with the following exceptions:

* Bash will match `foo/bar/baz` with `*`. Picomatch only matches nested directories with `**`.
* Bash greedily matches with negated extglobs. For example, Bash 4.3 says that `!(foo)*` should match `foo` and `foobar`, since the trailing `*` bracktracks to match the preceding pattern. This is very memory-inefficient, and IMHO, also incorrect. Picomatch would return `false` for both `foo` and `foobar`.

<br>

### Advanced globbing

* [extglobs](#extglobs)
* [POSIX brackets](#posix-brackets)
* [Braces](#brace-expansion)

#### Extglobs

| **Pattern** | **Description** |
| --- | --- |
| `@(pattern)` | Match _only one_ consecutive occurrence of `pattern` |
| `*(pattern)` | Match _zero or more_ consecutive occurrences of `pattern` |
| `+(pattern)` | Match _one or more_ consecutive occurrences of `pattern` |
| `?(pattern)` | Match _zero or **one**_ consecutive occurrences of `pattern` |
| `!(pattern)` | Match _anything but_ `pattern` |

**Examples**

```js
const pm = require('picomatch');

// *(pattern) matches ZERO or more of "pattern"
console.log(pm.isMatch('a', 'a*(z)')); // true
console.log(pm.isMatch('az', 'a*(z)')); // true
console.log(pm.isMatch('azzz', 'a*(z)')); // true

// +(pattern) matches ONE or more of "pattern"
console.log(pm.isMatch('a', 'a+(z)')); // false
console.log(pm.isMatch('az', 'a+(z)')); // true
console.log(pm.isMatch('azzz', 'a+(z)')); // true

// supports multiple extglobs
console.log(pm.isMatch('foo.bar', '!(foo).!(bar)')); // false

// supports nested extglobs
console.log(pm.isMatch('foo.bar', '!(!(foo)).!(!(bar))')); // true
```

#### POSIX brackets

POSIX classes are disabled by default. Enable this feature by setting the `posix` option to true.

**Enable POSIX bracket support**

```js
console.log(pm.makeRe('[[:word:]]+', { posix: true }));
//=> /^(?:(?=.)[A-Za-z0-9_]+\/?)$/
```

**Supported POSIX classes**

The following named POSIX bracket expressions are supported:

* `[:alnum:]` - Alphanumeric characters, equ `[a-zA-Z0-9]`
* `[:alpha:]` - Alphabetical characters, equivalent to `[a-zA-Z]`.
* `[:ascii:]` - ASCII characters, equivalent to `[\\x00-\\x7F]`.
* `[:blank:]` - Space and tab characters, equivalent to `[ \\t]`.
* `[:cntrl:]` - Control characters, equivalent to `[\\x00-\\x1F\\x7F]`.
* `[:digit:]` - Numerical digits, equivalent to `[0-9]`.
* `[:graph:]` - Graph characters, equivalent to `[\\x21-\\x7E]`.
* `[:lower:]` - Lowercase letters, equivalent to `[a-z]`.
* `[:print:]` - Print characters, equivalent to `[\\x20-\\x7E ]`.
* `[:punct:]` - Punctuation and symbols, equivalent to `[\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~]`.
* `[:space:]` - Extended space characters, equivalent to `[ \\t\\r\\n\\v\\f]`.
* `[:upper:]` - Uppercase letters, equivalent to `[A-Z]`.
* `[:word:]` -  Word characters (letters, numbers and underscores), equivalent to `[A-Za-z0-9_]`.
* `[:xdigit:]` - Hexadecimal digits, equivalent to `[A-Fa-f0-9]`.

See the [Bash Reference Manual](https://www.gnu.org/software/bash/manual/html_node/Pattern-Matching.html) for more information.

### Braces

Picomatch does not do brace expansion. For [brace expansion](https://www.gnu.org/software/bash/manual/html_node/Brace-Expansion.html) and advanced matching with braces, use [micromatch](https://github.com/micromatch/micromatch) instead. Picomatch has very basic support for braces.

### Matching special characters as literals

If you wish to match the following special characters in a filepath, and you want to use these characters in your glob pattern, they must be escaped with backslashes or quotes:

**Special Characters**

Some characters that are used for matching in regular expressions are also regarded as valid file path characters on some platforms.

To match any of the following characters as literals: `$^*+?()[]

Examples:

```js
console.log(pm.makeRe('foo/bar \\(1\\)'));
console.log(pm.makeRe('foo/bar \\(1\\)'));
```

<br>
<br>

## Library Comparisons

The following table shows which features are supported by [minimatch](https://github.com/isaacs/minimatch), [micromatch](https://github.com/micromatch/micromatch), [picomatch](https://github.com/micromatch/picomatch), [nanomatch](https://github.com/micromatch/nanomatch), [extglob](https://github.com/micromatch/extglob), [braces](https://github.com/micromatch/braces), and [expand-brackets](https://github.com/micromatch/expand-brackets).

| **Feature** | `minimatch` | `micromatch` | `picomatch` | `nanomatch` | `extglob` | `braces` | `expand-brackets` |
| --- | --- | --- | --- | --- | --- | --- | --- |
| Wildcard matching (`*?+`) | ??| ??| ??| ??| - | - | - |
| Advancing globbing        | ??| ??| ??| - | - | - | - |
| Brace _matching_          | ??| ??| ??| - | - | ??| - |
| Brace _expansion_         | ??| ??| - | - | - | ??| - |
| Extglobs                  | partial | ??| ??| - | ??| - | - |
| Posix brackets            | - | ??| ??| - | - | - | ??|
| Regular expression syntax | - | ??| ??| ??| ??| - | ??|
| File system operations    | - | - | - | - | - | - | - |

<br>
<br>

## Benchmarks

Performance comparison of picomatch and minimatch.

_(Pay special attention to the last three benchmarks. Minimatch freezes on long ranges.)_

```
# .makeRe star (*)
  picomatch x 4,449,159 ops/sec 짹0.24% (97 runs sampled)
  minimatch x 632,772 ops/sec 짹0.14% (98 runs sampled)

# .makeRe star; dot=true (*)
  picomatch x 3,500,079 ops/sec 짹0.26% (99 runs sampled)
  minimatch x 564,916 ops/sec 짹0.23% (96 runs sampled)

# .makeRe globstar (**)
  picomatch x 3,261,000 ops/sec 짹0.27% (98 runs sampled)
  minimatch x 1,664,766 ops/sec 짹0.20% (100 runs sampled)

# .makeRe globstars (**/**/**)
  picomatch x 3,284,469 ops/sec 짹0.18% (97 runs sampled)
  minimatch x 1,435,880 ops/sec 짹0.34% (95 runs sampled)

# .makeRe with leading star (*.txt)
  picomatch x 3,100,197 ops/sec 짹0.35% (99 runs sampled)
  minimatch x 428,347 ops/sec 짹0.42% (94 runs sampled)

# .makeRe - basic braces ({a,b,c}*.txt)
  picomatch x 443,578 ops/sec 짹1.33% (89 runs sampled)
  minimatch x 107,143 ops/sec 짹0.35% (94 runs sampled)

# .makeRe - short ranges ({a..z}*.txt)
  picomatch x 415,484 ops/sec 짹0.76% (96 runs sampled)
  minimatch x 14,299 ops/sec 짹0.26% (96 runs sampled)

# .makeRe - medium ranges ({1..100000}*.txt)
  picomatch x 395,020 ops/sec 짹0.87% (89 runs sampled)
  minimatch x 2 ops/sec 짹4.59% (10 runs sampled)

# .makeRe - long ranges ({1..10000000}*.txt)
  picomatch x 400,036 ops/sec 짹0.83% (90 runs sampled)
  minimatch (FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory)
```

<br>
<br>

## Philosophies

The goal of this library is to be blazing fast, without compromising on accuracy.

**Accuracy**

The number one of goal of this library is accuracy. However, it's not unusual for different glob implementations to have different rules for matching behavior, even with simple wildcard matching. It gets increasingly more complicated when combinations of different features are combined, like when extglobs are combined with globstars, braces, slashes, and so on: `!(**/{a,b,*/c})`.

Thus, given that there is no canonical glob specification to use as a single source of truth when differences of opinion arise regarding behavior, sometimes we have to implement our best judgement and rely on feedback from users to make improvements.

**Performance**

Although this library performs well in benchmarks, and in most cases it's faster than other popular libraries we benchmarked against, we will always choose accuracy over performance. It's not helpful to anyone if our library is faster at returning the wrong answer.

<br>
<br>

## About

<details>
<summary><strong>Contributing</strong></summary>

Pull requests and stars are always welcome. For bugs and feature requests, [please create an issue](../../issues/new).

Please read the [contributing guide](.github/contributing.md) for advice on opening issues, pull requests, and coding standards.

</details>

<details>
<summary><strong>Running Tests</strong></summary>

Running and reviewing unit tests is a great way to get familiarized with a library and its API. You can install dependencies and run tests with the following command:

```sh
npm install && npm test
```

</details>

<details>
<summary><strong>Building docs</strong></summary>

_(This project's readme.md is generated by [verb](https://github.com/verbose/verb-generate-readme), please don't edit the readme directly. Any changes to the readme must be made in the [.verb.md](.verb.md) readme template.)_

To generate the readme, run the following command:

```sh
npm install -g verbose/verb#dev verb-generate-readme && verb
```

</details>

### Author

**Jon Schlinkert**

* [GitHub Profile](https://github.com/jonschlinkert)
* [Twitter Profile](https://twitter.com/jonschlinkert)
* [LinkedIn Profile](https://linkedin.com/in/jonschlinkert)

### License

Copyright 짤 2017-present, [Jon Schlinkert](https://github.com/jonschlinkert).
Released under the [MIT License](LICENSE).

~~~

## node_modules\postcss\lib\at-rule.d.ts

~~~ts
import Container, {
  ContainerProps,
  ContainerWithChildren
} from './container.js'

declare namespace AtRule {
  export interface AtRuleRaws extends Record<string, unknown> {
    /**
     * The space symbols after the last child of the node to the end of the node.
     */
    after?: string

    /**
     * The space between the at-rule name and its parameters.
     */
    afterName?: string

    /**
     * The space symbols before the node. It also stores `*`
     * and `_` symbols before the declaration (IE hack).
     */
    before?: string

    /**
     * The symbols between the last parameter and `{` for rules.
     */
    between?: string

    /**
     * The rule?셲 selector with comments.
     */
    params?: {
      raw: string
      value: string
    }

    /**
     * Contains `true` if the last child has an (optional) semicolon.
     */
    semicolon?: boolean
  }

  export interface AtRuleProps extends ContainerProps {
    /** Name of the at-rule. */
    name: string
    /** Parameters following the name of the at-rule. */
    params?: number | string
    /** Information used to generate byte-to-byte equal node string as it was in the origin input. */
    raws?: AtRuleRaws
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { AtRule_ as default }
}

/**
 * Represents an at-rule.
 *
 * ```js
 * Once (root, { AtRule }) {
 *   let media = new AtRule({ name: 'media', params: 'print' })
 *   media.append(??
 *   root.append(media)
 * }
 * ```
 *
 * If it?셲 followed in the CSS by a `{}` block, this node will have
 * a nodes property representing its children.
 *
 * ```js
 * const root = postcss.parse('@charset "UTF-8"; @media print {}')
 *
 * const charset = root.first
 * charset.type  //=> 'atrule'
 * charset.nodes //=> undefined
 *
 * const media = root.last
 * media.nodes   //=> []
 * ```
 */
declare class AtRule_ extends Container {
  /**
   * An array containing the layer?셲 children.
   *
   * ```js
   * const root = postcss.parse('@layer example { a { color: black } }')
   * const layer = root.first
   * layer.nodes.length           //=> 1
   * layer.nodes[0].selector      //=> 'a'
   * ```
   *
   * Can be `undefinded` if the at-rule has no body.
   *
   * ```js
   * const root = postcss.parse('@layer a, b, c;')
   * const layer = root.first
   * layer.nodes //=> undefined
   * ```
   */
  nodes: Container['nodes'] | undefined
  parent: ContainerWithChildren | undefined

  raws: AtRule.AtRuleRaws
  type: 'atrule'
  /**
   * The at-rule?셲 name immediately follows the `@`.
   *
   * ```js
   * const root  = postcss.parse('@media print {}')
   * const media = root.first
   * media.name //=> 'media'
   * ```
   */
  get name(): string
  set name(value: string)

  /**
   * The at-rule?셲 parameters, the values that follow the at-rule?셲 name
   * but precede any `{}` block.
   *
   * ```js
   * const root  = postcss.parse('@media print, screen {}')
   * const media = root.first
   * media.params //=> 'print, screen'
   * ```
   */
  get params(): string

  set params(value: string)

  constructor(defaults?: AtRule.AtRuleProps)
  assign(overrides: AtRule.AtRuleProps | object): this
  clone(overrides?: Partial<AtRule.AtRuleProps>): this
  cloneAfter(overrides?: Partial<AtRule.AtRuleProps>): this
  cloneBefore(overrides?: Partial<AtRule.AtRuleProps>): this
}

declare class AtRule extends AtRule_ {}

export = AtRule

~~~

## node_modules\postcss\lib\at-rule.js

~~~js
'use strict'

let Container = require('./container')

class AtRule extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'atrule'
  }

  append(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.append(...children)
  }

  prepend(...children) {
    if (!this.proxyOf.nodes) this.nodes = []
    return super.prepend(...children)
  }
}

module.exports = AtRule
AtRule.default = AtRule

Container.registerAtRule(AtRule)

~~~

## node_modules\postcss\lib\comment.d.ts

~~~ts
import Container from './container.js'
import Node, { NodeProps } from './node.js'

declare namespace Comment {
  export interface CommentRaws extends Record<string, unknown> {
    /**
     * The space symbols before the node.
     */
    before?: string

    /**
     * The space symbols between `/*` and the comment?셲 text.
     */
    left?: string

    /**
     * The space symbols between the comment?셲 text.
     */
    right?: string
  }

  export interface CommentProps extends NodeProps {
    /** Information used to generate byte-to-byte equal node string as it was in the origin input. */
    raws?: CommentRaws
    /** Content of the comment. */
    text: string
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Comment_ as default }
}

/**
 * It represents a class that handles
 * [CSS comments](https://developer.mozilla.org/en-US/docs/Web/CSS/Comments)
 *
 * ```js
 * Once (root, { Comment }) {
 *   const note = new Comment({ text: 'Note: ?? })
 *   root.append(note)
 * }
 * ```
 *
 * Remember that CSS comments inside selectors, at-rule parameters,
 * or declaration values will be stored in the `raws` properties
 * explained above.
 */
declare class Comment_ extends Node {
  parent: Container | undefined
  raws: Comment.CommentRaws
  type: 'comment'
  /**
   * The comment's text.
   */
  get text(): string

  set text(value: string)

  constructor(defaults?: Comment.CommentProps)
  assign(overrides: Comment.CommentProps | object): this
  clone(overrides?: Partial<Comment.CommentProps>): this
  cloneAfter(overrides?: Partial<Comment.CommentProps>): this
  cloneBefore(overrides?: Partial<Comment.CommentProps>): this
}

declare class Comment extends Comment_ {}

export = Comment

~~~

## node_modules\postcss\lib\comment.js

~~~js
'use strict'

let Node = require('./node')

class Comment extends Node {
  constructor(defaults) {
    super(defaults)
    this.type = 'comment'
  }
}

module.exports = Comment
Comment.default = Comment

~~~

## node_modules\postcss\lib\container.d.ts

~~~ts
import AtRule from './at-rule.js'
import Comment from './comment.js'
import Declaration from './declaration.js'
import Node, { ChildNode, ChildProps, NodeProps } from './node.js'
import { Root } from './postcss.js'
import Rule from './rule.js'

declare namespace Container {
  export type ContainerWithChildren<Child extends Node = ChildNode> = {
    nodes: Child[]
  } & (
    | AtRule
    | Root
    | Rule
  )

  export interface ValueOptions {
    /**
     * String that?셲 used to narrow down values and speed up the regexp search.
     */
    fast?: string

    /**
     * An array of property names.
     */
    props?: readonly string[]
  }

  export interface ContainerProps extends NodeProps {
    nodes?: readonly (ChildProps | Node)[]
  }

  /**
   * All types that can be passed into container methods to create or add a new
   * child node.
   */
  export type NewChild =
    | ChildProps
    | Node
    | readonly ChildProps[]
    | readonly Node[]
    | readonly string[]
    | string
    | undefined

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Container_ as default }
}

/**
 * The `Root`, `AtRule`, and `Rule` container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 */
declare abstract class Container_<Child extends Node = ChildNode> extends Node {
  /**
   * An array containing the container?셲 children.
   *
   * ```js
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   * ```
   */
  nodes: Child[] | undefined

  /**
   * The container?셲 first child.
   *
   * ```js
   * rule.first === rules.nodes[0]
   * ```
   */
  get first(): Child | undefined

  /**
   * The container?셲 last child.
   *
   * ```js
   * rule.last === rule.nodes[rule.nodes.length - 1]
   * ```
   */
  get last(): Child | undefined
  /**
   * Inserts new nodes to the end of the container.
   *
   * ```js
   * const decl1 = new Declaration({ prop: 'color', value: 'black' })
   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   * ```
   *
   * @param nodes New nodes.
   * @return This node for methods chain.
   */
  append(...nodes: Container.NewChild[]): this
  assign(overrides: Container.ContainerProps | object): this
  clone(overrides?: Partial<Container.ContainerProps>): this

  cloneAfter(overrides?: Partial<Container.ContainerProps>): this

  cloneBefore(overrides?: Partial<Container.ContainerProps>): this
  /**
   * Iterates through the container?셲 immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the container?셲 immediate children.
   * If you need to recursively iterate through all the container?셲 descendant
   * nodes, use `Container#walk`.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * ```js
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */
  each(
    callback: (node: Child, index: number) => false | void
  ): false | undefined

  /**
   * Returns `true` if callback returns `true`
   * for all of the container?셲 children.
   *
   * ```js
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   * ```
   *
   * @param condition Iterator returns true or false.
   * @return Is every child pass condition.
   */
  every(
    condition: (node: Child, index: number, nodes: Child[]) => boolean
  ): boolean
  /**
   * Returns a `child`?셲 index within the `Container#nodes` array.
   *
   * ```js
   * rule.index( rule.nodes[2] ) //=> 2
   * ```
   *
   * @param child Child of the current container.
   * @return Child index.
   */
  index(child: Child | number): number

  /**
   * Insert new node after old node within the container.
   *
   * @param oldNode Child or child?셲 index.
   * @param newNode New node.
   * @return This node for methods chain.
   */
  insertAfter(oldNode: Child | number, newNode: Container.NewChild): this

  /**
   * Traverses the container?셲 descendant nodes, calling callback
   * for each comment node.
   *
   * Like `Container#each`, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * ```js
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */

  /**
   * Insert new node before old node within the container.
   *
   * ```js
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   * ```
   *
   * @param oldNode Child or child?셲 index.
   * @param newNode New node.
   * @return This node for methods chain.
   */
  insertBefore(oldNode: Child | number, newNode: Container.NewChild): this
  /**
   * Inserts new nodes to the start of the container.
   *
   * ```js
   * const decl1 = new Declaration({ prop: 'color', value: 'black' })
   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   * ```
   *
   * @param nodes New nodes.
   * @return This node for methods chain.
   */
  prepend(...nodes: Container.NewChild[]): this

  /**
   * Add child to the end of the node.
   *
   * ```js
   * rule.push(new Declaration({ prop: 'color', value: 'black' }))
   * ```
   *
   * @param child New node.
   * @return This node for methods chain.
   */
  push(child: Child): this

  /**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * ```js
   * rule.removeAll()
   * rule.nodes.length //=> 0
   * ```
   *
   * @return This node for methods chain.
   */
  removeAll(): this

  /**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * ```js
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   * ```
   *
   * @param child Child or child?셲 index.
   * @return This node for methods chain.
   */
  removeChild(child: Child | number): this

  replaceValues(
    pattern: RegExp | string,
    replaced: { (substring: string, ...args: any[]): string } | string
  ): this
  /**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * ```js
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   * ```
   *
   * @param pattern      Replace pattern.
   * @param {object} options             Options to speed up the search.
   * @param replaced   String to replace pattern or callback
   *                                     that returns a new value. The callback
   *                                     will receive the same arguments
   *                                     as those passed to a function parameter
   *                                     of `String#replace`.
   * @return This node for methods chain.
   */
  replaceValues(
    pattern: RegExp | string,
    options: Container.ValueOptions,
    replaced: { (substring: string, ...args: any[]): string } | string
  ): this

  /**
   * Returns `true` if callback returns `true` for (at least) one
   * of the container?셲 children.
   *
   * ```js
   * const hasPrefix = rule.some(i => i.prop[0] === '-')
   * ```
   *
   * @param condition Iterator returns true or false.
   * @return Is some child pass condition.
   */
  some(
    condition: (node: Child, index: number, nodes: Child[]) => boolean
  ): boolean

  /**
   * Traverses the container?셲 descendant nodes, calling callback
   * for each node.
   *
   * Like container.each(), this method is safe to use
   * if you are mutating arrays during iteration.
   *
   * If you only need to iterate through the container?셲 immediate children,
   * use `Container#each`.
   *
   * ```js
   * root.walk(node => {
   *   // Traverses all descendant nodes.
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return  Returns `false` if iteration was broke.
   */
  walk(
    callback: (node: ChildNode, index: number) => false | void
  ): false | undefined

  /**
   * Traverses the container?셲 descendant nodes, calling callback
   * for each at-rule node.
   *
   * If you pass a filter, iteration will only happen over at-rules
   * that have matching names.
   *
   * Like `Container#each`, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * ```js
   * root.walkAtRules(rule => {
   *   if (isOld(rule.name)) rule.remove()
   * })
   *
   * let first = false
   * root.walkAtRules('charset', rule => {
   *   if (!first) {
   *     first = true
   *   } else {
   *     rule.remove()
   *   }
   * })
   * ```
   *
   * @param name     String or regular expression to filter at-rules by name.
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */
  walkAtRules(
    nameFilter: RegExp | string,
    callback: (atRule: AtRule, index: number) => false | void
  ): false | undefined
  walkAtRules(
    callback: (atRule: AtRule, index: number) => false | void
  ): false | undefined

  walkComments(
    callback: (comment: Comment, indexed: number) => false | void
  ): false | undefined
  walkComments(
    callback: (comment: Comment, indexed: number) => false | void
  ): false | undefined

  /**
   * Traverses the container?셲 descendant nodes, calling callback
   * for each declaration node.
   *
   * If you pass a filter, iteration will only happen over declarations
   * with matching properties.
   *
   * ```js
   * root.walkDecls(decl => {
   *   checkPropertySupport(decl.prop)
   * })
   *
   * root.walkDecls('border-radius', decl => {
   *   decl.remove()
   * })
   *
   * root.walkDecls(/^background/, decl => {
   *   decl.value = takeFirstColorFromGradient(decl.value)
   * })
   * ```
   *
   * Like `Container#each`, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * @param prop     String or regular expression to filter declarations
   *                 by property name.
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */
  walkDecls(
    propFilter: RegExp | string,
    callback: (decl: Declaration, index: number) => false | void
  ): false | undefined
  walkDecls(
    callback: (decl: Declaration, index: number) => false | void
  ): false | undefined
  /**
   * Traverses the container?셲 descendant nodes, calling callback
   * for each rule node.
   *
   * If you pass a filter, iteration will only happen over rules
   * with matching selectors.
   *
   * Like `Container#each`, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * ```js
   * const selectors = []
   * root.walkRules(rule => {
   *   selectors.push(rule.selector)
   * })
   * console.log(`Your CSS uses ${ selectors.length } selectors`)
   * ```
   *
   * @param selector String or regular expression to filter rules by selector.
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */
  walkRules(
    selectorFilter: RegExp | string,
    callback: (rule: Rule, index: number) => false | void
  ): false | undefined
  walkRules(
    callback: (rule: Rule, index: number) => false | void
  ): false | undefined
  /**
   * An internal method that converts a {@link NewChild} into a list of actual
   * child nodes that can then be added to this container.
   *
   * This ensures that the nodes' parent is set to this container, that they use
   * the correct prototype chain, and that they're marked as dirty.
   *
   * @param mnodes The new node or nodes to add.
   * @param sample A node from whose raws the new node's `before` raw should be
   *               taken.
   * @param type   This should be set to `'prepend'` if the new nodes will be
   *               inserted at the beginning of the container.
   * @hidden
   */
  protected normalize(
    nodes: Container.NewChild,
    sample: Node | undefined,
    type?: 'prepend' | false
  ): Child[]
}

declare class Container<
  Child extends Node = ChildNode
> extends Container_<Child> {}

export = Container

~~~

## node_modules\postcss\lib\container.js

~~~js
'use strict'

let Comment = require('./comment')
let Declaration = require('./declaration')
let Node = require('./node')
let { isClean, my } = require('./symbols')

let AtRule, parse, Root, Rule

function cleanSource(nodes) {
  return nodes.map(i => {
    if (i.nodes) i.nodes = cleanSource(i.nodes)
    delete i.source
    return i
  })
}

function markTreeDirty(node) {
  node[isClean] = false
  if (node.proxyOf.nodes) {
    for (let i of node.proxyOf.nodes) {
      markTreeDirty(i)
    }
  }
}

class Container extends Node {
  get first() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[0]
  }

  get last() {
    if (!this.proxyOf.nodes) return undefined
    return this.proxyOf.nodes[this.proxyOf.nodes.length - 1]
  }

  append(...children) {
    for (let child of children) {
      let nodes = this.normalize(child, this.last)
      for (let node of nodes) this.proxyOf.nodes.push(node)
    }

    this.markDirty()

    return this
  }

  cleanRaws(keepBetween) {
    super.cleanRaws(keepBetween)
    if (this.nodes) {
      for (let node of this.nodes) node.cleanRaws(keepBetween)
    }
  }

  each(callback) {
    if (!this.proxyOf.nodes) return undefined
    let iterator = this.getIterator()

    let index, result
    while (this.indexes[iterator] < this.proxyOf.nodes.length) {
      index = this.indexes[iterator]
      result = callback(this.proxyOf.nodes[index], index)
      if (result === false) break

      this.indexes[iterator] += 1
    }

    delete this.indexes[iterator]
    return result
  }

  every(condition) {
    return this.nodes.every(condition)
  }

  getIterator() {
    if (!this.lastEach) this.lastEach = 0
    if (!this.indexes) this.indexes = {}

    this.lastEach += 1
    let iterator = this.lastEach
    this.indexes[iterator] = 0

    return iterator
  }

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (!node[prop]) {
          return node[prop]
        } else if (
          prop === 'each' ||
          (typeof prop === 'string' && prop.startsWith('walk'))
        ) {
          return (...args) => {
            return node[prop](
              ...args.map(i => {
                if (typeof i === 'function') {
                  return (child, index) => i(child.toProxy(), index)
                } else {
                  return i
                }
              })
            )
          }
        } else if (prop === 'every' || prop === 'some') {
          return cb => {
            return node[prop]((child, ...other) =>
              cb(child.toProxy(), ...other)
            )
          }
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else if (prop === 'nodes') {
          return node.nodes.map(i => i.toProxy())
        } else if (prop === 'first' || prop === 'last') {
          return node[prop].toProxy()
        } else {
          return node[prop]
        }
      },

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (prop === 'name' || prop === 'params' || prop === 'selector') {
          node.markDirty()
        }
        return true
      }
    }
  }

  index(child) {
    if (typeof child === 'number') return child
    if (child.proxyOf) child = child.proxyOf
    return this.proxyOf.nodes.indexOf(child)
  }

  insertAfter(exist, add) {
    let existIndex = this.index(exist)
    let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex < index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  insertBefore(exist, add) {
    let existIndex = this.index(exist)
    let type = existIndex === 0 ? 'prepend' : false
    let nodes = this.normalize(
      add,
      this.proxyOf.nodes[existIndex],
      type
    ).reverse()
    existIndex = this.index(exist)
    for (let node of nodes) this.proxyOf.nodes.splice(existIndex, 0, node)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (existIndex <= index) {
        this.indexes[id] = index + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  normalize(nodes, sample) {
    if (typeof nodes === 'string') {
      nodes = cleanSource(parse(nodes).nodes)
    } else if (typeof nodes === 'undefined') {
      nodes = []
    } else if (Array.isArray(nodes)) {
      nodes = nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type === 'root' && this.type !== 'document') {
      nodes = nodes.nodes.slice(0)
      for (let i of nodes) {
        if (i.parent) i.parent.removeChild(i, 'ignore')
      }
    } else if (nodes.type) {
      nodes = [nodes]
    } else if (nodes.prop) {
      if (typeof nodes.value === 'undefined') {
        throw new Error('Value field is missed in node creation')
      } else if (typeof nodes.value !== 'string') {
        nodes.value = String(nodes.value)
      }
      nodes = [new Declaration(nodes)]
    } else if (nodes.selector || nodes.selectors) {
      nodes = [new Rule(nodes)]
    } else if (nodes.name) {
      nodes = [new AtRule(nodes)]
    } else if (nodes.text) {
      nodes = [new Comment(nodes)]
    } else {
      throw new Error('Unknown node type in node creation')
    }

    let processed = nodes.map(i => {
      /* c8 ignore next */
      if (!i[my]) Container.rebuild(i)
      i = i.proxyOf
      if (i.parent) i.parent.removeChild(i)
      if (i[isClean]) markTreeDirty(i)

      if (!i.raws) i.raws = {}
      if (typeof i.raws.before === 'undefined') {
        if (sample && typeof sample.raws.before !== 'undefined') {
          i.raws.before = sample.raws.before.replace(/\S/g, '')
        }
      }
      i.parent = this.proxyOf
      return i
    })

    return processed
  }

  prepend(...children) {
    children = children.reverse()
    for (let child of children) {
      let nodes = this.normalize(child, this.first, 'prepend').reverse()
      for (let node of nodes) this.proxyOf.nodes.unshift(node)
      for (let id in this.indexes) {
        this.indexes[id] = this.indexes[id] + nodes.length
      }
    }

    this.markDirty()

    return this
  }

  push(child) {
    child.parent = this
    this.proxyOf.nodes.push(child)
    return this
  }

  removeAll() {
    for (let node of this.proxyOf.nodes) node.parent = undefined
    this.proxyOf.nodes = []

    this.markDirty()

    return this
  }

  removeChild(child) {
    child = this.index(child)
    this.proxyOf.nodes[child].parent = undefined
    this.proxyOf.nodes.splice(child, 1)

    let index
    for (let id in this.indexes) {
      index = this.indexes[id]
      if (index >= child) {
        this.indexes[id] = index - 1
      }
    }

    this.markDirty()

    return this
  }

  replaceValues(pattern, opts, callback) {
    if (!callback) {
      callback = opts
      opts = {}
    }

    this.walkDecls(decl => {
      if (opts.props && !opts.props.includes(decl.prop)) return
      if (opts.fast && !decl.value.includes(opts.fast)) return

      decl.value = decl.value.replace(pattern, callback)
    })

    this.markDirty()

    return this
  }

  some(condition) {
    return this.nodes.some(condition)
  }

  walk(callback) {
    return this.each((child, i) => {
      let result
      try {
        result = callback(child, i)
      } catch (e) {
        throw child.addToError(e)
      }
      if (result !== false && child.walk) {
        result = child.walk(callback)
      }

      return result
    })
  }

  walkAtRules(name, callback) {
    if (!callback) {
      callback = name
      return this.walk((child, i) => {
        if (child.type === 'atrule') {
          return callback(child, i)
        }
      })
    }
    if (name instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'atrule' && name.test(child.name)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'atrule' && child.name === name) {
        return callback(child, i)
      }
    })
  }

  walkComments(callback) {
    return this.walk((child, i) => {
      if (child.type === 'comment') {
        return callback(child, i)
      }
    })
  }

  walkDecls(prop, callback) {
    if (!callback) {
      callback = prop
      return this.walk((child, i) => {
        if (child.type === 'decl') {
          return callback(child, i)
        }
      })
    }
    if (prop instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'decl' && prop.test(child.prop)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'decl' && child.prop === prop) {
        return callback(child, i)
      }
    })
  }

  walkRules(selector, callback) {
    if (!callback) {
      callback = selector

      return this.walk((child, i) => {
        if (child.type === 'rule') {
          return callback(child, i)
        }
      })
    }
    if (selector instanceof RegExp) {
      return this.walk((child, i) => {
        if (child.type === 'rule' && selector.test(child.selector)) {
          return callback(child, i)
        }
      })
    }
    return this.walk((child, i) => {
      if (child.type === 'rule' && child.selector === selector) {
        return callback(child, i)
      }
    })
  }
}

Container.registerParse = dependant => {
  parse = dependant
}

Container.registerRule = dependant => {
  Rule = dependant
}

Container.registerAtRule = dependant => {
  AtRule = dependant
}

Container.registerRoot = dependant => {
  Root = dependant
}

module.exports = Container
Container.default = Container

/* c8 ignore start */
Container.rebuild = node => {
  if (node.type === 'atrule') {
    Object.setPrototypeOf(node, AtRule.prototype)
  } else if (node.type === 'rule') {
    Object.setPrototypeOf(node, Rule.prototype)
  } else if (node.type === 'decl') {
    Object.setPrototypeOf(node, Declaration.prototype)
  } else if (node.type === 'comment') {
    Object.setPrototypeOf(node, Comment.prototype)
  } else if (node.type === 'root') {
    Object.setPrototypeOf(node, Root.prototype)
  }

  node[my] = true

  if (node.nodes) {
    node.nodes.forEach(child => {
      Container.rebuild(child)
    })
  }
}
/* c8 ignore stop */

~~~

## node_modules\postcss\lib\css-syntax-error.d.ts

~~~ts
import { FilePosition } from './input.js'

declare namespace CssSyntaxError {
  /**
   * A position that is part of a range.
   */
  export interface RangePosition {
    /**
     * The column number in the input.
     */
    column: number

    /**
     * The line number in the input.
     */
    line: number
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { CssSyntaxError_ as default }
}

/**
 * The CSS parser throws this error for broken CSS.
 *
 * Custom parsers can throw this error for broken custom syntax using
 * the `Node#error` method.
 *
 * PostCSS will use the input source map to detect the original error location.
 * If you wrote a Sass file, compiled it to CSS and then parsed it with PostCSS,
 * PostCSS will show the original position in the Sass file.
 *
 * If you need the position in the PostCSS input
 * (e.g., to debug the previous compiler), use `error.input.file`.
 *
 * ```js
 * // Raising error from plugin
 * throw node.error('Unknown variable', { plugin: 'postcss-vars' })
 * ```
 *
 * ```js
 * // Catching and checking syntax error
 * try {
 *   postcss.parse('a{')
 * } catch (error) {
 *   if (error.name === 'CssSyntaxError') {
 *     error //=> CssSyntaxError
 *   }
 * }
 * ```
 */
declare class CssSyntaxError_ extends Error {
  /**
   * Source column of the error.
   *
   * ```js
   * error.column       //=> 1
   * error.input.column //=> 4
   * ```
   *
   * PostCSS will use the input source map to detect the original location.
   * If you need the position in the PostCSS input, use `error.input.column`.
   */
  column?: number

  /**
   * Source column of the error's end, exclusive. Provided if the error pertains
   * to a range.
   *
   * ```js
   * error.endColumn       //=> 1
   * error.input.endColumn //=> 4
   * ```
   *
   * PostCSS will use the input source map to detect the original location.
   * If you need the position in the PostCSS input, use `error.input.endColumn`.
   */
  endColumn?: number

  /**
   * Source line of the error's end, exclusive. Provided if the error pertains
   * to a range.
   *
   * ```js
   * error.endLine       //=> 3
   * error.input.endLine //=> 4
   * ```
   *
   * PostCSS will use the input source map to detect the original location.
   * If you need the position in the PostCSS input, use `error.input.endLine`.
   */
  endLine?: number

  /**
   * Absolute path to the broken file.
   *
   * ```js
   * error.file       //=> 'a.sass'
   * error.input.file //=> 'a.css'
   * ```
   *
   * PostCSS will use the input source map to detect the original location.
   * If you need the position in the PostCSS input, use `error.input.file`.
   */
  file?: string

  /**
   * Input object with PostCSS internal information
   * about input file. If input has source map
   * from previous tool, PostCSS will use origin
   * (for example, Sass) source. You can use this
   * object to get PostCSS input source.
   *
   * ```js
   * error.input.file //=> 'a.css'
   * error.file       //=> 'a.sass'
   * ```
   */
  input?: FilePosition

  /**
   * Source line of the error.
   *
   * ```js
   * error.line       //=> 2
   * error.input.line //=> 4
   * ```
   *
   * PostCSS will use the input source map to detect the original location.
   * If you need the position in the PostCSS input, use `error.input.line`.
   */
  line?: number

  /**
   * Full error text in the GNU error format
   * with plugin, file, line and column.
   *
   * ```js
   * error.message //=> 'a.css:1:1: Unclosed block'
   * ```
   */
  message: string

  /**
   * Always equal to `'CssSyntaxError'`. You should always check error type
   * by `error.name === 'CssSyntaxError'`
   * instead of `error instanceof CssSyntaxError`,
   * because npm could have several PostCSS versions.
   *
   * ```js
   * if (error.name === 'CssSyntaxError') {
   *   error //=> CssSyntaxError
   * }
   * ```
   */
  name: 'CssSyntaxError'

  /**
   * Plugin name, if error came from plugin.
   *
   * ```js
   * error.plugin //=> 'postcss-vars'
   * ```
   */
  plugin?: string

  /**
   * Error message.
   *
   * ```js
   * error.message //=> 'Unclosed block'
   * ```
   */
  reason: string

  /**
   * Source code of the broken file.
   *
   * ```js
   * error.source       //=> 'a { b {} }'
   * error.input.source //=> 'a b { }'
   * ```
   */
  source?: string

  stack: string

  /**
   * Instantiates a CSS syntax error. Can be instantiated for a single position
   * or for a range.
   * @param message        Error message.
   * @param lineOrStartPos If for a single position, the line number, or if for
   *                       a range, the inclusive start position of the error.
   * @param columnOrEndPos If for a single position, the column number, or if for
   *                       a range, the exclusive end position of the error.
   * @param source         Source code of the broken file.
   * @param file           Absolute path to the broken file.
   * @param plugin         PostCSS plugin name, if error came from plugin.
   */
  constructor(
    message: string,
    lineOrStartPos?: CssSyntaxError.RangePosition | number,
    columnOrEndPos?: CssSyntaxError.RangePosition | number,
    source?: string,
    file?: string,
    plugin?: string
  )

  /**
   * Returns a few lines of CSS source that caused the error.
   *
   * If the CSS has an input source map without `sourceContent`,
   * this method will return an empty string.
   *
   * ```js
   * error.showSourceCode() //=> "  4 | }
   *                        //      5 | a {
   *                        //    > 6 |   bad
   *                        //        |   ^
   *                        //      7 | }
   *                        //      8 | b {"
   * ```
   *
   * @param color Whether arrow will be colored red by terminal
   *              color codes. By default, PostCSS will detect
   *              color support by `process.stdout.isTTY`
   *              and `process.env.NODE_DISABLE_COLORS`.
   * @return Few lines of CSS source that caused the error.
   */
  showSourceCode(color?: boolean): string

  /**
   * Returns error position, message and source code of the broken part.
   *
   * ```js
   * error.toString() //=> "CssSyntaxError: app.css:1:1: Unclosed block
   *                  //    > 1 | a {
   *                  //        | ^"
   * ```
   *
   * @return Error position, message and source code.
   */
  toString(): string
}

declare class CssSyntaxError extends CssSyntaxError_ {}

export = CssSyntaxError

~~~

## node_modules\postcss\lib\css-syntax-error.js

~~~js
'use strict'

let pico = require('picocolors')

let terminalHighlight = require('./terminal-highlight')

class CssSyntaxError extends Error {
  constructor(message, line, column, source, file, plugin) {
    super(message)
    this.name = 'CssSyntaxError'
    this.reason = message

    if (file) {
      this.file = file
    }
    if (source) {
      this.source = source
    }
    if (plugin) {
      this.plugin = plugin
    }
    if (typeof line !== 'undefined' && typeof column !== 'undefined') {
      if (typeof line === 'number') {
        this.line = line
        this.column = column
      } else {
        this.line = line.line
        this.column = line.column
        this.endLine = column.line
        this.endColumn = column.column
      }
    }

    this.setMessage()

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CssSyntaxError)
    }
  }

  setMessage() {
    this.message = this.plugin ? this.plugin + ': ' : ''
    this.message += this.file ? this.file : '<css input>'
    if (typeof this.line !== 'undefined') {
      this.message += ':' + this.line + ':' + this.column
    }
    this.message += ': ' + this.reason
  }

  showSourceCode(color) {
    if (!this.source) return ''

    let css = this.source
    if (color == null) color = pico.isColorSupported

    let aside = text => text
    let mark = text => text
    let highlight = text => text
    if (color) {
      let { bold, gray, red } = pico.createColors(true)
      mark = text => bold(red(text))
      aside = text => gray(text)
      if (terminalHighlight) {
        highlight = text => terminalHighlight(text)
      }
    }

    let lines = css.split(/\r?\n/)
    let start = Math.max(this.line - 3, 0)
    let end = Math.min(this.line + 2, lines.length)
    let maxWidth = String(end).length

    return lines
      .slice(start, end)
      .map((line, index) => {
        let number = start + 1 + index
        let gutter = ' ' + (' ' + number).slice(-maxWidth) + ' | '
        if (number === this.line) {
          if (line.length > 160) {
            let padding = 20
            let subLineStart = Math.max(0, this.column - padding)
            let subLineEnd = Math.max(
              this.column + padding,
              this.endColumn + padding
            )
            let subLine = line.slice(subLineStart, subLineEnd)

            let spacing =
              aside(gutter.replace(/\d/g, ' ')) +
              line
                .slice(0, Math.min(this.column - 1, padding - 1))
                .replace(/[^\t]/g, ' ')

            return (
              mark('>') +
              aside(gutter) +
              highlight(subLine) +
              '\n ' +
              spacing +
              mark('^')
            )
          }

          let spacing =
            aside(gutter.replace(/\d/g, ' ')) +
            line.slice(0, this.column - 1).replace(/[^\t]/g, ' ')

          return (
            mark('>') +
            aside(gutter) +
            highlight(line) +
            '\n ' +
            spacing +
            mark('^')
          )
        }

        return ' ' + aside(gutter) + highlight(line)
      })
      .join('\n')
  }

  toString() {
    let code = this.showSourceCode()
    if (code) {
      code = '\n\n' + code + '\n'
    }
    return this.name + ': ' + this.message + code
  }
}

module.exports = CssSyntaxError
CssSyntaxError.default = CssSyntaxError

~~~

## node_modules\postcss\lib\declaration.d.ts

~~~ts
import { ContainerWithChildren } from './container.js'
import Node from './node.js'

declare namespace Declaration {
  export interface DeclarationRaws extends Record<string, unknown> {
    /**
     * The space symbols before the node. It also stores `*`
     * and `_` symbols before the declaration (IE hack).
     */
    before?: string

    /**
     * The symbols between the property and value for declarations.
     */
    between?: string

    /**
     * The content of the important statement, if it is not just `!important`.
     */
    important?: string

    /**
     * Declaration value with comments.
     */
    value?: {
      raw: string
      value: string
    }
  }

  export interface DeclarationProps {
    /** Whether the declaration has an `!important` annotation. */
    important?: boolean
    /** Name of the declaration. */
    prop: string
    /** Information used to generate byte-to-byte equal node string as it was in the origin input. */
    raws?: DeclarationRaws
    /** Value of the declaration. */
    value: string
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Declaration_ as default }
}

/**
 * It represents a class that handles
 * [CSS declarations](https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax#css_declarations)
 *
 * ```js
 * Once (root, { Declaration }) {
 *   const color = new Declaration({ prop: 'color', value: 'black' })
 *   root.append(color)
 * }
 * ```
 *
 * ```js
 * const root = postcss.parse('a { color: black }')
 * const decl = root.first?.first
 *
 * decl.type       //=> 'decl'
 * decl.toString() //=> ' color: black'
 * ```
 */
declare class Declaration_ extends Node {
  parent: ContainerWithChildren | undefined
  raws: Declaration.DeclarationRaws

  type: 'decl'

  /**
   * It represents a specificity of the declaration.
   *
   * If true, the CSS declaration will have an
   * [important](https://developer.mozilla.org/en-US/docs/Web/CSS/important)
   * specifier.
   *
   * ```js
   * const root = postcss.parse('a { color: black !important; color: red }')
   *
   * root.first.first.important //=> true
   * root.first.last.important  //=> undefined
   * ```
   */
  get important(): boolean
  set important(value: boolean)

  /**
   * The property name for a CSS declaration.
   *
   * ```js
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   *
   * decl.prop //=> 'color'
   * ```
   */
  get prop(): string

  set prop(value: string)

  /**
   * The property value for a CSS declaration.
   *
   * Any CSS comments inside the value string will be filtered out.
   * CSS comments present in the source value will be available in
   * the `raws` property.
   *
   * Assigning new `value` would ignore the comments in `raws`
   * property while compiling node to string.
   *
   * ```js
   * const root = postcss.parse('a { color: black }')
   * const decl = root.first.first
   *
   * decl.value //=> 'black'
   * ```
   */
  get value(): string
  set value(value: string)

  /**
   * It represents a getter that returns `true` if a declaration starts with
   * `--` or `$`, which are used to declare variables in CSS and SASS/SCSS.
   *
   * ```js
   * const root = postcss.parse(':root { --one: 1 }')
   * const one = root.first.first
   *
   * one.variable //=> true
   * ```
   *
   * ```js
   * const root = postcss.parse('$one: 1')
   * const one = root.first
   *
   * one.variable //=> true
   * ```
   */
  get variable(): boolean
  constructor(defaults?: Declaration.DeclarationProps)

  assign(overrides: Declaration.DeclarationProps | object): this
  clone(overrides?: Partial<Declaration.DeclarationProps>): this
  cloneAfter(overrides?: Partial<Declaration.DeclarationProps>): this
  cloneBefore(overrides?: Partial<Declaration.DeclarationProps>): this
}

declare class Declaration extends Declaration_ {}

export = Declaration

~~~

## node_modules\postcss\lib\declaration.js

~~~js
'use strict'

let Node = require('./node')

class Declaration extends Node {
  get variable() {
    return this.prop.startsWith('--') || this.prop[0] === '$'
  }

  constructor(defaults) {
    if (
      defaults &&
      typeof defaults.value !== 'undefined' &&
      typeof defaults.value !== 'string'
    ) {
      defaults = { ...defaults, value: String(defaults.value) }
    }
    super(defaults)
    this.type = 'decl'
  }
}

module.exports = Declaration
Declaration.default = Declaration

~~~

## node_modules\postcss\lib\document.d.ts

~~~ts
import Container, { ContainerProps } from './container.js'
import { ProcessOptions } from './postcss.js'
import Result from './result.js'
import Root from './root.js'

declare namespace Document {
  export interface DocumentProps extends ContainerProps {
    nodes?: readonly Root[]

    /**
     * Information to generate byte-to-byte equal node string as it was
     * in the origin input.
     *
     * Every parser saves its own properties.
     */
    raws?: Record<string, any>
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Document_ as default }
}

/**
 * Represents a file and contains all its parsed nodes.
 *
 * **Experimental:** some aspects of this node could change within minor
 * or patch version releases.
 *
 * ```js
 * const document = htmlParser(
 *   '<html><style>a{color:black}</style><style>b{z-index:2}</style>'
 * )
 * document.type         //=> 'document'
 * document.nodes.length //=> 2
 * ```
 */
declare class Document_ extends Container<Root> {
  nodes: Root[]
  parent: undefined
  type: 'document'

  constructor(defaults?: Document.DocumentProps)

  assign(overrides: Document.DocumentProps | object): this
  clone(overrides?: Partial<Document.DocumentProps>): this
  cloneAfter(overrides?: Partial<Document.DocumentProps>): this
  cloneBefore(overrides?: Partial<Document.DocumentProps>): this

  /**
   * Returns a `Result` instance representing the document?셲 CSS roots.
   *
   * ```js
   * const root1 = postcss.parse(css1, { from: 'a.css' })
   * const root2 = postcss.parse(css2, { from: 'b.css' })
   * const document = postcss.document()
   * document.append(root1)
   * document.append(root2)
   * const result = document.toResult({ to: 'all.css', map: true })
   * ```
   *
   * @param opts Options.
   * @return Result with current document?셲 CSS.
   */
  toResult(options?: ProcessOptions): Result
}

declare class Document extends Document_ {}

export = Document

~~~

## node_modules\postcss\lib\document.js

~~~js
'use strict'

let Container = require('./container')

let LazyResult, Processor

class Document extends Container {
  constructor(defaults) {
    // type needs to be passed to super, otherwise child roots won't be normalized correctly
    super({ type: 'document', ...defaults })

    if (!this.nodes) {
      this.nodes = []
    }
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)

    return lazy.stringify()
  }
}

Document.registerLazyResult = dependant => {
  LazyResult = dependant
}

Document.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Document
Document.default = Document

~~~

## node_modules\postcss\lib\fromJSON.d.ts

~~~ts
import { JSONHydrator } from './postcss.js'

interface FromJSON extends JSONHydrator {
  default: FromJSON
}

declare const fromJSON: FromJSON

export = fromJSON

~~~

## node_modules\postcss\lib\fromJSON.js

~~~js
'use strict'

let AtRule = require('./at-rule')
let Comment = require('./comment')
let Declaration = require('./declaration')
let Input = require('./input')
let PreviousMap = require('./previous-map')
let Root = require('./root')
let Rule = require('./rule')

function fromJSON(json, inputs) {
  if (Array.isArray(json)) return json.map(n => fromJSON(n))

  let { inputs: ownInputs, ...defaults } = json
  if (ownInputs) {
    inputs = []
    for (let input of ownInputs) {
      let inputHydrated = { ...input, __proto__: Input.prototype }
      if (inputHydrated.map) {
        inputHydrated.map = {
          ...inputHydrated.map,
          __proto__: PreviousMap.prototype
        }
      }
      inputs.push(inputHydrated)
    }
  }
  if (defaults.nodes) {
    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))
  }
  if (defaults.source) {
    let { inputId, ...source } = defaults.source
    defaults.source = source
    if (inputId != null) {
      defaults.source.input = inputs[inputId]
    }
  }
  if (defaults.type === 'root') {
    return new Root(defaults)
  } else if (defaults.type === 'decl') {
    return new Declaration(defaults)
  } else if (defaults.type === 'rule') {
    return new Rule(defaults)
  } else if (defaults.type === 'comment') {
    return new Comment(defaults)
  } else if (defaults.type === 'atrule') {
    return new AtRule(defaults)
  } else {
    throw new Error('Unknown node type: ' + json.type)
  }
}

module.exports = fromJSON
fromJSON.default = fromJSON

~~~

## node_modules\postcss\lib\input.d.ts

~~~ts
import { CssSyntaxError, ProcessOptions } from './postcss.js'
import PreviousMap from './previous-map.js'

declare namespace Input {
  export interface FilePosition {
    /**
     * Column of inclusive start position in source file.
     */
    column: number

    /**
     * Column of exclusive end position in source file.
     */
    endColumn?: number

    /**
     * Line of exclusive end position in source file.
     */
    endLine?: number

    /**
     * Offset of exclusive end position in source file.
     */
    endOffset?: number

    /**
     * Absolute path to the source file.
     */
    file?: string

    /**
     * Line of inclusive start position in source file.
     */
    line: number

    /**
     * Offset of inclusive start position in source file.
     */
    offset: number

    /**
     * Source code.
     */
    source?: string

    /**
     * URL for the source file.
     */
    url: string
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Input_ as default }
}

/**
 * Represents the source CSS.
 *
 * ```js
 * const root  = postcss.parse(css, { from: file })
 * const input = root.source.input
 * ```
 */
declare class Input_ {
  /**
   * Input CSS source.
   *
   * ```js
   * const input = postcss.parse('a{}', { from: file }).input
   * input.css //=> "a{}"
   * ```
   */
  css: string

  /**
   * Input source with support for non-CSS documents.
   *
   * ```js
   * const input = postcss.parse('a{}', { from: file, document: '<style>a {}</style>' }).input
   * input.document //=> "<style>a {}</style>"
   * input.css //=> "a{}"
   * ```
   */
  document: string

  /**
   * The absolute path to the CSS source file defined
   * with the `from` option.
   *
   * ```js
   * const root = postcss.parse(css, { from: 'a.css' })
   * root.source.input.file //=> '/home/ai/a.css'
   * ```
   */
  file?: string

  /**
   * The flag to indicate whether or not the source code has Unicode BOM.
   */
  hasBOM: boolean

  /**
   * The unique ID of the CSS source. It will be created if `from` option
   * is not provided (because PostCSS does not know the file path).
   *
   * ```js
   * const root = postcss.parse(css)
   * root.source.input.file //=> undefined
   * root.source.input.id   //=> "<input css 8LZeVF>"
   * ```
   */
  id?: string

  /**
   * The input source map passed from a compilation step before PostCSS
   * (for example, from Sass compiler).
   *
   * ```js
   * root.source.input.map.consumer().sources //=> ['a.sass']
   * ```
   */
  map: PreviousMap

  /**
   * The CSS source identifier. Contains `Input#file` if the user
   * set the `from` option, or `Input#id` if they did not.
   *
   * ```js
   * const root = postcss.parse(css, { from: 'a.css' })
   * root.source.input.from //=> "/home/ai/a.css"
   *
   * const root = postcss.parse(css)
   * root.source.input.from //=> "<input css 1>"
   * ```
   */
  get from(): string

  /**
   * @param css  Input CSS source.
   * @param opts Process options.
   */
  constructor(css: string, opts?: ProcessOptions)

  /**
   * Returns `CssSyntaxError` with information about the error and its position.
   */
  error(
    message: string,
    start:
      | {
          column: number
          line: number
        }
      | {
          offset: number
        },
    end:
      | {
          column: number
          line: number
        }
      | {
          offset: number
        },
    opts?: { plugin?: CssSyntaxError['plugin'] }
  ): CssSyntaxError
  error(
    message: string,
    line: number,
    column: number,
    opts?: { plugin?: CssSyntaxError['plugin'] }
  ): CssSyntaxError
  error(
    message: string,
    offset: number,
    opts?: { plugin?: CssSyntaxError['plugin'] }
  ): CssSyntaxError

  /**
   * Converts source line and column to offset.
   *
   * @param line   Source line.
   * @param column Source column.
   * @return Source offset.
   */
  fromLineAndColumn(line: number, column: number): number

  /**
   * Converts source offset to line and column.
   *
   * @param offset Source offset.
   */
  fromOffset(offset: number): { col: number; line: number } | null

  /**
   * Reads the input source map and returns a symbol position
   * in the input source (e.g., in a Sass file that was compiled
   * to CSS before being passed to PostCSS). Optionally takes an
   * end position, exclusive.
   *
   * ```js
   * root.source.input.origin(1, 1) //=> { file: 'a.css', line: 3, column: 1 }
   * root.source.input.origin(1, 1, 1, 4)
   * //=> { file: 'a.css', line: 3, column: 1, endLine: 3, endColumn: 4 }
   * ```
   *
   * @param line      Line for inclusive start position in input CSS.
   * @param column    Column for inclusive start position in input CSS.
   * @param endLine   Line for exclusive end position in input CSS.
   * @param endColumn Column for exclusive end position in input CSS.
   *
   * @return Position in input source.
   */
  origin(
    line: number,
    column: number,
    endLine?: number,
    endColumn?: number
  ): false | Input.FilePosition

  /** Converts this to a JSON-friendly object representation. */
  toJSON(): object
}

declare class Input extends Input_ {}

export = Input

~~~

## node_modules\postcss\lib\input.js

~~~js
'use strict'

let { nanoid } = require('nanoid/non-secure')
let { isAbsolute, resolve } = require('path')
let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')
let { fileURLToPath, pathToFileURL } = require('url')

let CssSyntaxError = require('./css-syntax-error')
let PreviousMap = require('./previous-map')
let terminalHighlight = require('./terminal-highlight')

let lineToIndexCache = Symbol('lineToIndexCache')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(resolve && isAbsolute)

function getLineToIndex(input) {
  if (input[lineToIndexCache]) return input[lineToIndexCache]
  let lines = input.css.split('\n')
  let lineToIndex = new Array(lines.length)
  let prevIndex = 0

  for (let i = 0, l = lines.length; i < l; i++) {
    lineToIndex[i] = prevIndex
    prevIndex += lines[i].length + 1
  }

  input[lineToIndexCache] = lineToIndex
  return lineToIndex
}

class Input {
  get from() {
    return this.file || this.id
  }

  constructor(css, opts = {}) {
    if (
      css === null ||
      typeof css === 'undefined' ||
      (typeof css === 'object' && !css.toString)
    ) {
      throw new Error(`PostCSS received ${css} instead of CSS string`)
    }

    this.css = css.toString()

    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
      this.hasBOM = true
      this.css = this.css.slice(1)
    } else {
      this.hasBOM = false
    }

    this.document = this.css
    if (opts.document) this.document = opts.document.toString()

    if (opts.from) {
      if (
        !pathAvailable ||
        /^\w+:\/\//.test(opts.from) ||
        isAbsolute(opts.from)
      ) {
        this.file = opts.from
      } else {
        this.file = resolve(opts.from)
      }
    }

    if (pathAvailable && sourceMapAvailable) {
      let map = new PreviousMap(this.css, opts)
      if (map.text) {
        this.map = map
        let file = map.consumer().file
        if (!this.file && file) this.file = this.mapResolve(file)
      }
    }

    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>'
    }
    if (this.map) this.map.file = this.from
  }

  error(message, line, column, opts = {}) {
    let endColumn, endLine, endOffset, offset, result

    if (line && typeof line === 'object') {
      let start = line
      let end = column
      if (typeof start.offset === 'number') {
        offset = start.offset
        let pos = this.fromOffset(offset)
        line = pos.line
        column = pos.col
      } else {
        line = start.line
        column = start.column
        offset = this.fromLineAndColumn(line, column)
      }
      if (typeof end.offset === 'number') {
        endOffset = end.offset
        let pos = this.fromOffset(endOffset)
        endLine = pos.line
        endColumn = pos.col
      } else {
        endLine = end.line
        endColumn = end.column
        endOffset = this.fromLineAndColumn(end.line, end.column)
      }
    } else if (!column) {
      offset = line
      let pos = this.fromOffset(offset)
      line = pos.line
      column = pos.col
    } else {
      offset = this.fromLineAndColumn(line, column)
    }

    let origin = this.origin(line, column, endLine, endColumn)
    if (origin) {
      result = new CssSyntaxError(
        message,
        origin.endLine === undefined
          ? origin.line
          : { column: origin.column, line: origin.line },
        origin.endLine === undefined
          ? origin.column
          : { column: origin.endColumn, line: origin.endLine },
        origin.source,
        origin.file,
        opts.plugin
      )
    } else {
      result = new CssSyntaxError(
        message,
        endLine === undefined ? line : { column, line },
        endLine === undefined ? column : { column: endColumn, line: endLine },
        this.css,
        this.file,
        opts.plugin
      )
    }

    result.input = { column, endColumn, endLine, endOffset, line, offset, source: this.css }
    if (this.file) {
      if (pathToFileURL) {
        result.input.url = pathToFileURL(this.file).toString()
      }
      result.input.file = this.file
    }

    return result
  }

  fromLineAndColumn(line, column) {
    let lineToIndex = getLineToIndex(this)
    let index = lineToIndex[line - 1]
    return index + column - 1
  }

  fromOffset(offset) {
    let lineToIndex = getLineToIndex(this)
    let lastLine = lineToIndex[lineToIndex.length - 1]

    let min = 0
    if (offset >= lastLine) {
      min = lineToIndex.length - 1
    } else {
      let max = lineToIndex.length - 2
      let mid
      while (min < max) {
        mid = min + ((max - min) >> 1)
        if (offset < lineToIndex[mid]) {
          max = mid - 1
        } else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1
        } else {
          min = mid
          break
        }
      }
    }
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    }
  }

  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file
    }
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
  }

  origin(line, column, endLine, endColumn) {
    if (!this.map) return false
    let consumer = this.map.consumer()

    let from = consumer.originalPositionFor({ column, line })
    if (!from.source) return false

    let to
    if (typeof endLine === 'number') {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine })
    }

    let fromUrl

    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL(from.source)
    } else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
      )
    }

    let result = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    }

    if (fromUrl.protocol === 'file:') {
      if (fileURLToPath) {
        result.file = fileURLToPath(fromUrl)
      } else {
        /* c8 ignore next 2 */
        throw new Error(`file: protocol is not available in this PostCSS build`)
      }
    }

    let source = consumer.sourceContentFor(from.source)
    if (source) result.source = source

    return result
  }

  toJSON() {
    let json = {}
    for (let name of ['hasBOM', 'css', 'file', 'id']) {
      if (this[name] != null) {
        json[name] = this[name]
      }
    }
    if (this.map) {
      json.map = { ...this.map }
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined
      }
    }
    return json
  }
}

module.exports = Input
Input.default = Input

if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input)
}

~~~

## node_modules\postcss\lib\lazy-result.d.ts

~~~ts
import Document from './document.js'
import { SourceMap } from './postcss.js'
import Processor from './processor.js'
import Result, { Message, ResultOptions } from './result.js'
import Root from './root.js'
import Warning from './warning.js'

declare namespace LazyResult {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { LazyResult_ as default }
}

/**
 * A Promise proxy for the result of PostCSS transformations.
 *
 * A `LazyResult` instance is returned by `Processor#process`.
 *
 * ```js
 * const lazy = postcss([autoprefixer]).process(css)
 * ```
 */
declare class LazyResult_<RootNode = Document | Root>
  implements PromiseLike<Result<RootNode>>
{
  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onRejected for each error thrown in any plugin.
   *
   * It implements standard Promise API.
   *
   * ```js
   * postcss([autoprefixer]).process(css).then(result => {
   *   console.log(result.css)
   * }).catch(error => {
   *   console.error(error)
   * })
   * ```
   */
  catch: Promise<Result<RootNode>>['catch']

  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls onFinally on any error or when all plugins will finish work.
   *
   * It implements standard Promise API.
   *
   * ```js
   * postcss([autoprefixer]).process(css).finally(() => {
   *   console.log('processing ended')
   * })
   * ```
   */
  finally: Promise<Result<RootNode>>['finally']

  /**
   * Processes input CSS through synchronous and asynchronous plugins
   * and calls `onFulfilled` with a Result instance. If a plugin throws
   * an error, the `onRejected` callback will be executed.
   *
   * It implements standard Promise API.
   *
   * ```js
   * postcss([autoprefixer]).process(css, { from: cssPath }).then(result => {
   *   console.log(result.css)
   * })
   * ```
   */
  then: Promise<Result<RootNode>>['then']

  /**
   * An alias for the `css` property. Use it with syntaxes
   * that generate non-CSS output.
   *
   * This property will only work with synchronous plugins.
   * If the processor contains any asynchronous plugins
   * it will throw an error.
   *
   * PostCSS runners should always use `LazyResult#then`.
   */
  get content(): string

  /**
   * Processes input CSS through synchronous plugins, converts `Root`
   * to a CSS string and returns `Result#css`.
   *
   * This property will only work with synchronous plugins.
   * If the processor contains any asynchronous plugins
   * it will throw an error.
   *
   * PostCSS runners should always use `LazyResult#then`.
   */
  get css(): string

  /**
   * Processes input CSS through synchronous plugins
   * and returns `Result#map`.
   *
   * This property will only work with synchronous plugins.
   * If the processor contains any asynchronous plugins
   * it will throw an error.
   *
   * PostCSS runners should always use `LazyResult#then`.
   */
  get map(): SourceMap

  /**
   * Processes input CSS through synchronous plugins
   * and returns `Result#messages`.
   *
   * This property will only work with synchronous plugins. If the processor
   * contains any asynchronous plugins it will throw an error.
   *
   * PostCSS runners should always use `LazyResult#then`.
   */
  get messages(): Message[]

  /**
   * Options from the `Processor#process` call.
   */
  get opts(): ResultOptions

  /**
   * Returns a `Processor` instance, which will be used
   * for CSS transformations.
   */
  get processor(): Processor

  /**
   * Processes input CSS through synchronous plugins
   * and returns `Result#root`.
   *
   * This property will only work with synchronous plugins. If the processor
   * contains any asynchronous plugins it will throw an error.
   *
   * PostCSS runners should always use `LazyResult#then`.
   */
  get root(): RootNode

  /**
   * Returns the default string description of an object.
   * Required to implement the Promise interface.
   */
  get [Symbol.toStringTag](): string

  /**
   * @param processor Processor used for this transformation.
   * @param css       CSS to parse and transform.
   * @param opts      Options from the `Processor#process` or `Root#toResult`.
   */
  constructor(processor: Processor, css: string, opts: ResultOptions)

  /**
   * Run plugin in async way and return `Result`.
   *
   * @return Result with output content.
   */
  async(): Promise<Result<RootNode>>

  /**
   * Run plugin in sync way and return `Result`.
   *
   * @return Result with output content.
   */
  sync(): Result<RootNode>

  /**
   * Alias for the `LazyResult#css` property.
   *
   * ```js
   * lazy + '' === lazy.css
   * ```
   *
   * @return Output CSS.
   */
  toString(): string

  /**
   * Processes input CSS through synchronous plugins
   * and calls `Result#warnings`.
   *
   * @return Warnings from plugins.
   */
  warnings(): Warning[]
}

declare class LazyResult<
  RootNode = Document | Root
> extends LazyResult_<RootNode> {}

export = LazyResult

~~~

## node_modules\postcss\lib\lazy-result.js

~~~js
'use strict'

let Container = require('./container')
let Document = require('./document')
let MapGenerator = require('./map-generator')
let parse = require('./parse')
let Result = require('./result')
let Root = require('./root')
let stringify = require('./stringify')
let { isClean, my } = require('./symbols')
let warnOnce = require('./warn-once')

const TYPE_TO_CLASS_NAME = {
  atrule: 'AtRule',
  comment: 'Comment',
  decl: 'Declaration',
  document: 'Document',
  root: 'Root',
  rule: 'Rule'
}

const PLUGIN_PROPS = {
  AtRule: true,
  AtRuleExit: true,
  Comment: true,
  CommentExit: true,
  Declaration: true,
  DeclarationExit: true,
  Document: true,
  DocumentExit: true,
  Once: true,
  OnceExit: true,
  postcssPlugin: true,
  prepare: true,
  Root: true,
  RootExit: true,
  Rule: true,
  RuleExit: true
}

const NOT_VISITORS = {
  Once: true,
  postcssPlugin: true,
  prepare: true
}

const CHILDREN = 0

function isPromise(obj) {
  return typeof obj === 'object' && typeof obj.then === 'function'
}

function getEvents(node) {
  let key = false
  let type = TYPE_TO_CLASS_NAME[node.type]
  if (node.type === 'decl') {
    key = node.prop.toLowerCase()
  } else if (node.type === 'atrule') {
    key = node.name.toLowerCase()
  }

  if (key && node.append) {
    return [
      type,
      type + '-' + key,
      CHILDREN,
      type + 'Exit',
      type + 'Exit-' + key
    ]
  } else if (key) {
    return [type, type + '-' + key, type + 'Exit', type + 'Exit-' + key]
  } else if (node.append) {
    return [type, CHILDREN, type + 'Exit']
  } else {
    return [type, type + 'Exit']
  }
}

function toStack(node) {
  let events
  if (node.type === 'document') {
    events = ['Document', CHILDREN, 'DocumentExit']
  } else if (node.type === 'root') {
    events = ['Root', CHILDREN, 'RootExit']
  } else {
    events = getEvents(node)
  }

  return {
    eventIndex: 0,
    events,
    iterator: 0,
    node,
    visitorIndex: 0,
    visitors: []
  }
}

function cleanMarks(node) {
  node[isClean] = false
  if (node.nodes) node.nodes.forEach(i => cleanMarks(i))
  return node
}

let postcss = {}

class LazyResult {
  get content() {
    return this.stringify().content
  }

  get css() {
    return this.stringify().css
  }

  get map() {
    return this.stringify().map
  }

  get messages() {
    return this.sync().messages
  }

  get opts() {
    return this.result.opts
  }

  get processor() {
    return this.result.processor
  }

  get root() {
    return this.sync().root
  }

  get [Symbol.toStringTag]() {
    return 'LazyResult'
  }

  constructor(processor, css, opts) {
    this.stringified = false
    this.processed = false

    let root
    if (
      typeof css === 'object' &&
      css !== null &&
      (css.type === 'root' || css.type === 'document')
    ) {
      root = cleanMarks(css)
    } else if (css instanceof LazyResult || css instanceof Result) {
      root = cleanMarks(css.root)
      if (css.map) {
        if (typeof opts.map === 'undefined') opts.map = {}
        if (!opts.map.inline) opts.map.inline = false
        opts.map.prev = css.map
      }
    } else {
      let parser = parse
      if (opts.syntax) parser = opts.syntax.parse
      if (opts.parser) parser = opts.parser
      if (parser.parse) parser = parser.parse

      try {
        root = parser(css, opts)
      } catch (error) {
        this.processed = true
        this.error = error
      }

      if (root && !root[my]) {
        /* c8 ignore next 2 */
        Container.rebuild(root)
      }
    }

    this.result = new Result(processor, root, opts)
    this.helpers = { ...postcss, postcss, result: this.result }
    this.plugins = this.processor.plugins.map(plugin => {
      if (typeof plugin === 'object' && plugin.prepare) {
        return { ...plugin, ...plugin.prepare(this.result) }
      } else {
        return plugin
      }
    })
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    if (this.processed) return Promise.resolve(this.result)
    if (!this.processing) {
      this.processing = this.runAsync()
    }
    return this.processing
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  getAsyncError() {
    throw new Error('Use process(css).then(cb) to work with async plugins')
  }

  handleError(error, node) {
    let plugin = this.result.lastPlugin
    try {
      if (node) node.addToError(error)
      this.error = error
      if (error.name === 'CssSyntaxError' && !error.plugin) {
        error.plugin = plugin.postcssPlugin
        error.setMessage()
      } else if (plugin.postcssVersion) {
        if (process.env.NODE_ENV !== 'production') {
          let pluginName = plugin.postcssPlugin
          let pluginVer = plugin.postcssVersion
          let runtimeVer = this.result.processor.version
          let a = pluginVer.split('.')
          let b = runtimeVer.split('.')

          if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
            // eslint-disable-next-line no-console
            console.error(
              'Unknown error from PostCSS plugin. Your current PostCSS ' +
                'version is ' +
                runtimeVer +
                ', but ' +
                pluginName +
                ' uses ' +
                pluginVer +
                '. Perhaps this is the source of the error below.'
            )
          }
        }
      }
    } catch (err) {
      /* c8 ignore next 3 */
      // eslint-disable-next-line no-console
      if (console && console.error) console.error(err)
    }
    return error
  }

  prepareVisitors() {
    this.listeners = {}
    let add = (plugin, type, cb) => {
      if (!this.listeners[type]) this.listeners[type] = []
      this.listeners[type].push([plugin, cb])
    }
    for (let plugin of this.plugins) {
      if (typeof plugin === 'object') {
        for (let event in plugin) {
          if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
            throw new Error(
              `Unknown event ${event} in ${plugin.postcssPlugin}. ` +
                `Try to update PostCSS (${this.processor.version} now).`
            )
          }
          if (!NOT_VISITORS[event]) {
            if (typeof plugin[event] === 'object') {
              for (let filter in plugin[event]) {
                if (filter === '*') {
                  add(plugin, event, plugin[event][filter])
                } else {
                  add(
                    plugin,
                    event + '-' + filter.toLowerCase(),
                    plugin[event][filter]
                  )
                }
              }
            } else if (typeof plugin[event] === 'function') {
              add(plugin, event, plugin[event])
            }
          }
        }
      }
    }
    this.hasListener = Object.keys(this.listeners).length > 0
  }

  async runAsync() {
    this.plugin = 0
    for (let i = 0; i < this.plugins.length; i++) {
      let plugin = this.plugins[i]
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        try {
          await promise
        } catch (error) {
          throw this.handleError(error)
        }
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        let stack = [toStack(root)]
        while (stack.length > 0) {
          let promise = this.visitTick(stack)
          if (isPromise(promise)) {
            try {
              await promise
            } catch (e) {
              let node = stack[stack.length - 1].node
              throw this.handleError(e, node)
            }
          }
        }
      }

      if (this.listeners.OnceExit) {
        for (let [plugin, visitor] of this.listeners.OnceExit) {
          this.result.lastPlugin = plugin
          try {
            if (root.type === 'document') {
              let roots = root.nodes.map(subRoot =>
                visitor(subRoot, this.helpers)
              )

              await Promise.all(roots)
            } else {
              await visitor(root, this.helpers)
            }
          } catch (e) {
            throw this.handleError(e)
          }
        }
      }
    }

    this.processed = true
    return this.stringify()
  }

  runOnRoot(plugin) {
    this.result.lastPlugin = plugin
    try {
      if (typeof plugin === 'object' && plugin.Once) {
        if (this.result.root.type === 'document') {
          let roots = this.result.root.nodes.map(root =>
            plugin.Once(root, this.helpers)
          )

          if (isPromise(roots[0])) {
            return Promise.all(roots)
          }

          return roots
        }

        return plugin.Once(this.result.root, this.helpers)
      } else if (typeof plugin === 'function') {
        return plugin(this.result.root, this.result)
      }
    } catch (error) {
      throw this.handleError(error)
    }
  }

  stringify() {
    if (this.error) throw this.error
    if (this.stringified) return this.result
    this.stringified = true

    this.sync()

    let opts = this.result.opts
    let str = stringify
    if (opts.syntax) str = opts.syntax.stringify
    if (opts.stringifier) str = opts.stringifier
    if (str.stringify) str = str.stringify

    let map = new MapGenerator(str, this.result.root, this.result.opts)
    let data = map.generate()
    this.result.css = data[0]
    this.result.map = data[1]

    return this.result
  }

  sync() {
    if (this.error) throw this.error
    if (this.processed) return this.result
    this.processed = true

    if (this.processing) {
      throw this.getAsyncError()
    }

    for (let plugin of this.plugins) {
      let promise = this.runOnRoot(plugin)
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }

    this.prepareVisitors()
    if (this.hasListener) {
      let root = this.result.root
      while (!root[isClean]) {
        root[isClean] = true
        this.walkSync(root)
      }
      if (this.listeners.OnceExit) {
        if (root.type === 'document') {
          for (let subRoot of root.nodes) {
            this.visitSync(this.listeners.OnceExit, subRoot)
          }
        } else {
          this.visitSync(this.listeners.OnceExit, root)
        }
      }
    }

    return this.result
  }

  then(onFulfilled, onRejected) {
    if (process.env.NODE_ENV !== 'production') {
      if (!('from' in this.opts)) {
        warnOnce(
          'Without `from` option PostCSS could generate wrong source map ' +
            'and will not find Browserslist config. Set it to CSS file path ' +
            'or to `undefined` to prevent this warning.'
        )
      }
    }
    return this.async().then(onFulfilled, onRejected)
  }

  toString() {
    return this.css
  }

  visitSync(visitors, node) {
    for (let [plugin, visitor] of visitors) {
      this.result.lastPlugin = plugin
      let promise
      try {
        promise = visitor(node, this.helpers)
      } catch (e) {
        throw this.handleError(e, node.proxyOf)
      }
      if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
        return true
      }
      if (isPromise(promise)) {
        throw this.getAsyncError()
      }
    }
  }

  visitTick(stack) {
    let visit = stack[stack.length - 1]
    let { node, visitors } = visit

    if (node.type !== 'root' && node.type !== 'document' && !node.parent) {
      stack.pop()
      return
    }

    if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
      let [plugin, visitor] = visitors[visit.visitorIndex]
      visit.visitorIndex += 1
      if (visit.visitorIndex === visitors.length) {
        visit.visitors = []
        visit.visitorIndex = 0
      }
      this.result.lastPlugin = plugin
      try {
        return visitor(node.toProxy(), this.helpers)
      } catch (e) {
        throw this.handleError(e, node)
      }
    }

    if (visit.iterator !== 0) {
      let iterator = visit.iterator
      let child
      while ((child = node.nodes[node.indexes[iterator]])) {
        node.indexes[iterator] += 1
        if (!child[isClean]) {
          child[isClean] = true
          stack.push(toStack(child))
          return
        }
      }
      visit.iterator = 0
      delete node.indexes[iterator]
    }

    let events = visit.events
    while (visit.eventIndex < events.length) {
      let event = events[visit.eventIndex]
      visit.eventIndex += 1
      if (event === CHILDREN) {
        if (node.nodes && node.nodes.length) {
          node[isClean] = true
          visit.iterator = node.getIterator()
        }
        return
      } else if (this.listeners[event]) {
        visit.visitors = this.listeners[event]
        return
      }
    }
    stack.pop()
  }

  walkSync(node) {
    node[isClean] = true
    let events = getEvents(node)
    for (let event of events) {
      if (event === CHILDREN) {
        if (node.nodes) {
          node.each(child => {
            if (!child[isClean]) this.walkSync(child)
          })
        }
      } else {
        let visitors = this.listeners[event]
        if (visitors) {
          if (this.visitSync(visitors, node.toProxy())) return
        }
      }
    }
  }

  warnings() {
    return this.sync().warnings()
  }
}

LazyResult.registerPostcss = dependant => {
  postcss = dependant
}

module.exports = LazyResult
LazyResult.default = LazyResult

Root.registerLazyResult(LazyResult)
Document.registerLazyResult(LazyResult)

~~~

## node_modules\postcss\lib\list.d.ts

~~~ts
declare namespace list {
  type List = {
    /**
     * Safely splits comma-separated values (such as those for `transition-*`
     * and `background` properties).
     *
     * ```js
     * Once (root, { list }) {
     *   list.comma('black, linear-gradient(white, black)')
     *   //=> ['black', 'linear-gradient(white, black)']
     * }
     * ```
     *
     * @param str Comma-separated values.
     * @return Split values.
     */
    comma(str: string): string[]

    default: List

    /**
     * Safely splits space-separated values (such as those for `background`,
     * `border-radius`, and other shorthand properties).
     *
     * ```js
     * Once (root, { list }) {
     *   list.space('1px calc(10% + 1px)') //=> ['1px', 'calc(10% + 1px)']
     * }
     * ```
     *
     * @param str Space-separated values.
     * @return Split values.
     */
    space(str: string): string[]

    /**
     * Safely splits values.
     *
     * ```js
     * Once (root, { list }) {
     *   list.split('1px calc(10% + 1px)', [' ', '\n', '\t']) //=> ['1px', 'calc(10% + 1px)']
     * }
     * ```
     *
     * @param string separated values.
     * @param separators array of separators.
     * @param last boolean indicator.
     * @return Split values.
     */
    split(
      string: string,
      separators: readonly string[],
      last: boolean
    ): string[]
  }
}

declare const list: list.List

export = list

~~~

## node_modules\postcss\lib\list.js

~~~js
'use strict'

let list = {
  comma(string) {
    return list.split(string, [','], true)
  },

  space(string) {
    let spaces = [' ', '\n', '\t']
    return list.split(string, spaces)
  },

  split(string, separators, last) {
    let array = []
    let current = ''
    let split = false

    let func = 0
    let inQuote = false
    let prevQuote = ''
    let escape = false

    for (let letter of string) {
      if (escape) {
        escape = false
      } else if (letter === '\\') {
        escape = true
      } else if (inQuote) {
        if (letter === prevQuote) {
          inQuote = false
        }
      } else if (letter === '"' || letter === "'") {
        inQuote = true
        prevQuote = letter
      } else if (letter === '(') {
        func += 1
      } else if (letter === ')') {
        if (func > 0) func -= 1
      } else if (func === 0) {
        if (separators.includes(letter)) split = true
      }

      if (split) {
        if (current !== '') array.push(current.trim())
        current = ''
        split = false
      } else {
        current += letter
      }
    }

    if (last || current !== '') array.push(current.trim())
    return array
  }
}

module.exports = list
list.default = list

~~~

## node_modules\postcss\lib\map-generator.js

~~~js
'use strict'

let { dirname, relative, resolve, sep } = require('path')
let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')
let { pathToFileURL } = require('url')

let Input = require('./input')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(dirname && resolve && relative && sep)

class MapGenerator {
  constructor(stringify, root, opts, cssString) {
    this.stringify = stringify
    this.mapOpts = opts.map || {}
    this.root = root
    this.opts = opts
    this.css = cssString
    this.originalCSS = cssString
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute

    this.memoizedFileURLs = new Map()
    this.memoizedPaths = new Map()
    this.memoizedURLs = new Map()
  }

  addAnnotation() {
    let content

    if (this.isInline()) {
      content =
        'data:application/json;base64,' + this.toBase64(this.map.toString())
    } else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation
    } else if (typeof this.mapOpts.annotation === 'function') {
      content = this.mapOpts.annotation(this.opts.to, this.root)
    } else {
      content = this.outputFile() + '.map'
    }
    let eol = '\n'
    if (this.css.includes('\r\n')) eol = '\r\n'

    this.css += eol + '/*# sourceMappingURL=' + content + ' */'
  }

  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file))
      let root = prev.root || dirname(prev.file)
      let map

      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text)
        if (map.sourcesContent) {
          map.sourcesContent = null
        }
      } else {
        map = prev.consumer()
      }

      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))
    }
  }

  clearAnnotation() {
    if (this.mapOpts.annotation === false) return

    if (this.root) {
      let node
      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i]
        if (node.type !== 'comment') continue
        if (node.text.startsWith('# sourceMappingURL=')) {
          this.root.removeChild(i)
        }
      }
    } else if (this.css) {
      this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, '')
    }
  }

  generate() {
    this.clearAnnotation()
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap()
    } else {
      let result = ''
      this.stringify(this.root, i => {
        result += i
      })
      return [result]
    }
  }

  generateMap() {
    if (this.root) {
      this.generateString()
    } else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer()
      prev.file = this.outputFile()
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      })
    } else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      })
      this.map.addMapping({
        generated: { column: 0, line: 1 },
        original: { column: 0, line: 1 },
        source: this.opts.from
          ? this.toUrl(this.path(this.opts.from))
          : '<no source>'
      })
    }

    if (this.isSourcesContent()) this.setSourcesContent()
    if (this.root && this.previous().length > 0) this.applyPrevMaps()
    if (this.isAnnotation()) this.addAnnotation()

    if (this.isInline()) {
      return [this.css]
    } else {
      return [this.css, this.map]
    }
  }

  generateString() {
    this.css = ''
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    })

    let line = 1
    let column = 1

    let noSource = '<no source>'
    let mapping = {
      generated: { column: 0, line: 0 },
      original: { column: 0, line: 0 },
      source: ''
    }

    let last, lines
    this.stringify(this.root, (str, node, type) => {
      this.css += str

      if (node && type !== 'end') {
        mapping.generated.line = line
        mapping.generated.column = column - 1
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node)
          mapping.original.line = node.source.start.line
          mapping.original.column = node.source.start.column - 1
          this.map.addMapping(mapping)
        } else {
          mapping.source = noSource
          mapping.original.line = 1
          mapping.original.column = 0
          this.map.addMapping(mapping)
        }
      }

      lines = str.match(/\n/g)
      if (lines) {
        line += lines.length
        last = str.lastIndexOf('\n')
        column = str.length - last
      } else {
        column += str.length
      }

      if (node && type !== 'start') {
        let p = node.parent || { raws: {} }
        let childless =
          node.type === 'decl' || (node.type === 'atrule' && !node.nodes)
        if (!childless || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node)
            mapping.original.line = node.source.end.line
            mapping.original.column = node.source.end.column - 1
            mapping.generated.line = line
            mapping.generated.column = column - 2
            this.map.addMapping(mapping)
          } else {
            mapping.source = noSource
            mapping.original.line = 1
            mapping.original.column = 0
            mapping.generated.line = line
            mapping.generated.column = column - 1
            this.map.addMapping(mapping)
          }
        }
      }
    })
  }

  isAnnotation() {
    if (this.isInline()) {
      return true
    }
    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation
    }
    if (this.previous().length) {
      return this.previous().some(i => i.annotation)
    }
    return true
  }

  isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline
    }

    let annotation = this.mapOpts.annotation
    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false
    }

    if (this.previous().length) {
      return this.previous().some(i => i.inline)
    }
    return true
  }

  isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map
    }
    return this.previous().length > 0
  }

  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent
    }
    if (this.previous().length) {
      return this.previous().some(i => i.withContent())
    }
    return true
  }

  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to)
    } else if (this.opts.from) {
      return this.path(this.opts.from)
    } else {
      return 'to.css'
    }
  }

  path(file) {
    if (this.mapOpts.absolute) return file
    if (file.charCodeAt(0) === 60 /* `<` */) return file
    if (/^\w+:\/\//.test(file)) return file
    let cached = this.memoizedPaths.get(file)
    if (cached) return cached

    let from = this.opts.to ? dirname(this.opts.to) : '.'

    if (typeof this.mapOpts.annotation === 'string') {
      from = dirname(resolve(from, this.mapOpts.annotation))
    }

    let path = relative(from, file)
    this.memoizedPaths.set(file, path)

    return path
  }

  previous() {
    if (!this.previousMaps) {
      this.previousMaps = []
      if (this.root) {
        this.root.walk(node => {
          if (node.source && node.source.input.map) {
            let map = node.source.input.map
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map)
            }
          }
        })
      } else {
        let input = new Input(this.originalCSS, this.opts)
        if (input.map) this.previousMaps.push(input.map)
      }
    }

    return this.previousMaps
  }

  setSourcesContent() {
    let already = {}
    if (this.root) {
      this.root.walk(node => {
        if (node.source) {
          let from = node.source.input.from
          if (from && !already[from]) {
            already[from] = true
            let fromUrl = this.usesFileUrls
              ? this.toFileUrl(from)
              : this.toUrl(this.path(from))
            this.map.setSourceContent(fromUrl, node.source.input.css)
          }
        }
      })
    } else if (this.css) {
      let from = this.opts.from
        ? this.toUrl(this.path(this.opts.from))
        : '<no source>'
      this.map.setSourceContent(from, this.css)
    }
  }

  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from)
    } else if (this.usesFileUrls) {
      return this.toFileUrl(node.source.input.from)
    } else {
      return this.toUrl(this.path(node.source.input.from))
    }
  }

  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64')
    } else {
      return window.btoa(unescape(encodeURIComponent(str)))
    }
  }

  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path)
    if (cached) return cached

    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString()
      this.memoizedFileURLs.set(path, fileURL)

      return fileURL
    } else {
      throw new Error(
        '`map.absolute` option is not available in this PostCSS build'
      )
    }
  }

  toUrl(path) {
    let cached = this.memoizedURLs.get(path)
    if (cached) return cached

    if (sep === '\\') {
      path = path.replace(/\\/g, '/')
    }

    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent)
    this.memoizedURLs.set(path, url)

    return url
  }
}

module.exports = MapGenerator

~~~

## node_modules\postcss\lib\node.d.ts

~~~ts
import AtRule = require('./at-rule.js')
import { AtRuleProps } from './at-rule.js'
import Comment, { CommentProps } from './comment.js'
import Container, { NewChild } from './container.js'
import CssSyntaxError from './css-syntax-error.js'
import Declaration, { DeclarationProps } from './declaration.js'
import Document from './document.js'
import Input from './input.js'
import { Stringifier, Syntax } from './postcss.js'
import Result from './result.js'
import Root from './root.js'
import Rule, { RuleProps } from './rule.js'
import Warning, { WarningOptions } from './warning.js'

declare namespace Node {
  export type ChildNode = AtRule.default | Comment | Declaration | Rule

  export type AnyNode =
    | AtRule.default
    | Comment
    | Declaration
    | Document
    | Root
    | Rule

  export type ChildProps =
    | AtRuleProps
    | CommentProps
    | DeclarationProps
    | RuleProps

  export interface Position {
    /**
     * Source line in file. In contrast to `offset` it starts from 1.
     */
    column: number

    /**
     * Source column in file.
     */
    line: number

    /**
     * Source offset in file. It starts from 0.
     */
    offset: number
  }

  export interface Range {
    /**
     * End position, exclusive.
     */
    end: Position

    /**
     * Start position, inclusive.
     */
    start: Position
  }

  /**
   * Source represents an interface for the {@link Node.source} property.
   */
  export interface Source {
    /**
     * The inclusive ending position for the source
     * code of a node.
     *
     * However, `end.offset` of a non `Root` node is the exclusive position.
     * See https://github.com/postcss/postcss/pull/1879 for details.
     *
     * ```js
     * const root = postcss.parse('a { color: black }')
     * const a = root.first
     * const color = a.first
     *
     * // The offset of `Root` node is the inclusive position
     * css.source.end   // { line: 1, column: 19, offset: 18 }
     *
     * // The offset of non `Root` node is the exclusive position
     * a.source.end     // { line: 1, column: 18, offset: 18 }
     * color.source.end // { line: 1, column: 16, offset: 16 }
     * ```
     */
    end?: Position

    /**
     * The source file from where a node has originated.
     */
    input: Input

    /**
     * The inclusive starting position for the source
     * code of a node.
     */
    start?: Position
  }

  /**
   * Interface represents an interface for an object received
   * as parameter by Node class constructor.
   */
  export interface NodeProps {
    source?: Source
  }

  export interface NodeErrorOptions {
    /**
     * An ending index inside a node's string that should be highlighted as
     * source of error.
     */
    endIndex?: number
    /**
     * An index inside a node's string that should be highlighted as source
     * of error.
     */
    index?: number
    /**
     * Plugin name that created this error. PostCSS will set it automatically.
     */
    plugin?: string
    /**
     * A word inside a node's string, that should be highlighted as source
     * of error.
     */
    word?: string
  }

  // eslint-disable-next-line @typescript-eslint/no-shadow
  class Node extends Node_ {}
  export { Node as default }
}

/**
 * It represents an abstract class that handles common
 * methods for other CSS abstract syntax tree nodes.
 *
 * Any node that represents CSS selector or value should
 * not extend the `Node` class.
 */
declare abstract class Node_ {
  /**
   * It represents parent of the current node.
   *
   * ```js
   * root.nodes[0].parent === root //=> true
   * ```
   */
  parent: Container | Document | undefined

  /**
   * It represents unnecessary whitespace and characters present
   * in the css source code.
   *
   * Information to generate byte-to-byte equal node string as it was
   * in the origin input.
   *
   * The properties of the raws object are decided by parser,
   * the default parser uses the following properties:
   *
   * * `before`: the space symbols before the node. It also stores `*`
   *   and `_` symbols before the declaration (IE hack).
   * * `after`: the space symbols after the last child of the node
   *   to the end of the node.
   * * `between`: the symbols between the property and value
   *   for declarations, selector and `{` for rules, or last parameter
   *   and `{` for at-rules.
   * * `semicolon`: contains true if the last child has
   *   an (optional) semicolon.
   * * `afterName`: the space between the at-rule name and its parameters.
   * * `left`: the space symbols between `/*` and the comment?셲 text.
   * * `right`: the space symbols between the comment?셲 text
   *   and <code>*&#47;</code>.
   * - `important`: the content of the important statement,
   *   if it is not just `!important`.
   *
   * PostCSS filters out the comments inside selectors, declaration values
   * and at-rule parameters but it stores the origin content in raws.
   *
   * ```js
   * const root = postcss.parse('a {\n  color:black\n}')
   * root.first.first.raws //=> { before: '\n  ', between: ':' }
   * ```
   */
  raws: any

  /**
   * It represents information related to origin of a node and is required
   * for generating source maps.
   *
   * The nodes that are created manually using the public APIs
   * provided by PostCSS will have `source` undefined and
   * will be absent in the source map.
   *
   * For this reason, the plugin developer should consider
   * duplicating nodes as the duplicate node will have the
   * same source as the original node by default or assign
   * source to a node created manually.
   *
   * ```js
   * decl.source.input.from //=> '/home/ai/source.css'
   * decl.source.start      //=> { line: 10, column: 2 }
   * decl.source.end        //=> { line: 10, column: 12 }
   * ```
   *
   * ```js
   * // Incorrect method, source not specified!
   * const prefixed = postcss.decl({
   *   prop: '-moz-' + decl.prop,
   *   value: decl.value
   * })
   *
   * // Correct method, source is inherited when duplicating.
   * const prefixed = decl.clone({
   *   prop: '-moz-' + decl.prop
   * })
   * ```
   *
   * ```js
   * if (atrule.name === 'add-link') {
   *   const rule = postcss.rule({
   *     selector: 'a',
   *     source: atrule.source
   *   })
   *
   *  atrule.parent.insertBefore(atrule, rule)
   * }
   * ```
   */
  source?: Node.Source

  /**
   * It represents type of a node in
   * an abstract syntax tree.
   *
   * A type of node helps in identification of a node
   * and perform operation based on it's type.
   *
   * ```js
   * const declaration = new Declaration({
   *   prop: 'color',
   *   value: 'black'
   * })
   *
   * declaration.type //=> 'decl'
   * ```
   */
  type: string

  constructor(defaults?: object)

  /**
   * Insert new node after current node to current node?셲 parent.
   *
   * Just alias for `node.parent.insertAfter(node, add)`.
   *
   * ```js
   * decl.after('color: black')
   * ```
   *
   * @param newNode New node.
   * @return This node for methods chain.
   */
  after(
    newNode: Node | Node.ChildProps | readonly Node[] | string | undefined
  ): this

  /**
   * It assigns properties to an existing node instance.
   *
   * ```js
   * decl.assign({ prop: 'word-wrap', value: 'break-word' })
   * ```
   *
   * @param overrides New properties to override the node.
   *
   * @return `this` for method chaining.
   */
  assign(overrides: object): this

  /**
   * Insert new node before current node to current node?셲 parent.
   *
   * Just alias for `node.parent.insertBefore(node, add)`.
   *
   * ```js
   * decl.before('content: ""')
   * ```
   *
   * @param newNode New node.
   * @return This node for methods chain.
   */
  before(
    newNode: Node | Node.ChildProps | readonly Node[] | string | undefined
  ): this

  /**
   * Clear the code style properties for the node and its children.
   *
   * ```js
   * node.raws.before  //=> ' '
   * node.cleanRaws()
   * node.raws.before  //=> undefined
   * ```
   *
   * @param keepBetween Keep the `raws.between` symbols.
   */
  cleanRaws(keepBetween?: boolean): void

  /**
   * It creates clone of an existing node, which includes all the properties
   * and their values, that includes `raws` but not `type`.
   *
   * ```js
   * decl.raws.before    //=> "\n  "
   * const cloned = decl.clone({ prop: '-moz-' + decl.prop })
   * cloned.raws.before  //=> "\n  "
   * cloned.toString()   //=> -moz-transform: scale(0)
   * ```
   *
   * @param overrides New properties to override in the clone.
   *
   * @return Duplicate of the node instance.
   */
  clone(overrides?: object): this

  /**
   * Shortcut to clone the node and insert the resulting cloned node
   * after the current node.
   *
   * @param overrides New properties to override in the clone.
   * @return New node.
   */
  cloneAfter(overrides?: object): this

  /**
   * Shortcut to clone the node and insert the resulting cloned node
   * before the current node.
   *
   * ```js
   * decl.cloneBefore({ prop: '-moz-' + decl.prop })
   * ```
   *
   * @param overrides Mew properties to override in the clone.
   *
   * @return New node
   */
  cloneBefore(overrides?: object): this

  /**
   * It creates an instance of the class `CssSyntaxError` and parameters passed
   * to this method are assigned to the error instance.
   *
   * The error instance will have description for the
   * error, original position of the node in the
   * source, showing line and column number.
   *
   * If any previous map is present, it would be used
   * to get original position of the source.
   *
   * The Previous Map here is referred to the source map
   * generated by previous compilation, example: Less,
   * Stylus and Sass.
   *
   * This method returns the error instance instead of
   * throwing it.
   *
   * ```js
   * if (!variables[name]) {
   *   throw decl.error(`Unknown variable ${name}`, { word: name })
   *   // CssSyntaxError: postcss-vars:a.sass:4:3: Unknown variable $black
   *   //   color: $black
   *   // a
   *   //          ^
   *   //   background: white
   * }
   * ```
   *
   * @param message Description for the error instance.
   * @param options Options for the error instance.
   *
   * @return Error instance is returned.
   */
  error(message: string, options?: Node.NodeErrorOptions): CssSyntaxError

  /**
   * Returns the next child of the node?셲 parent.
   * Returns `undefined` if the current node is the last child.
   *
   * ```js
   * if (comment.text === 'delete next') {
   *   const next = comment.next()
   *   if (next) {
   *     next.remove()
   *   }
   * }
   * ```
   *
   * @return Next node.
   */
  next(): Node.ChildNode | undefined

  /**
   * Get the position for a word or an index inside the node.
   *
   * @param opts Options.
   * @return Position.
   */
  positionBy(opts?: Pick<WarningOptions, 'index' | 'word'>): Node.Position

  /**
   * Convert string index to line/column.
   *
   * @param index The symbol number in the node?셲 string.
   * @return Symbol position in file.
   */
  positionInside(index: number): Node.Position

  /**
   * Returns the previous child of the node?셲 parent.
   * Returns `undefined` if the current node is the first child.
   *
   * ```js
   * const annotation = decl.prev()
   * if (annotation.type === 'comment') {
   *   readAnnotation(annotation.text)
   * }
   * ```
   *
   * @return Previous node.
   */
  prev(): Node.ChildNode | undefined

  /**
   * Get the range for a word or start and end index inside the node.
   * The start index is inclusive; the end index is exclusive.
   *
   * @param opts Options.
   * @return Range.
   */
  rangeBy(
    opts?: Pick<WarningOptions, 'end' | 'endIndex' | 'index' | 'start' | 'word'>
  ): Node.Range

  /**
   * Returns a `raws` value. If the node is missing
   * the code style property (because the node was manually built or cloned),
   * PostCSS will try to autodetect the code style property by looking
   * at other nodes in the tree.
   *
   * ```js
   * const root = postcss.parse('a { background: white }')
   * root.nodes[0].append({ prop: 'color', value: 'black' })
   * root.nodes[0].nodes[1].raws.before   //=> undefined
   * root.nodes[0].nodes[1].raw('before') //=> ' '
   * ```
   *
   * @param prop        Name of code style property.
   * @param defaultType Name of default value, it can be missed
   *                    if the value is the same as prop.
   * @return {string} Code style value.
   */
  raw(prop: string, defaultType?: string): string

  /**
   * It removes the node from its parent and deletes its parent property.
   *
   * ```js
   * if (decl.prop.match(/^-webkit-/)) {
   *   decl.remove()
   * }
   * ```
   *
   * @return `this` for method chaining.
   */
  remove(): this

  /**
   * Inserts node(s) before the current node and removes the current node.
   *
   * ```js
   * AtRule: {
   *   mixin: atrule => {
   *     atrule.replaceWith(mixinRules[atrule.params])
   *   }
   * }
   * ```
   *
   * @param nodes Mode(s) to replace current one.
   * @return Current node to methods chain.
   */
  replaceWith(...nodes: NewChild[]): this

  /**
   * Finds the Root instance of the node?셲 tree.
   *
   * ```js
   * root.nodes[0].nodes[0].root() === root
   * ```
   *
   * @return Root parent.
   */
  root(): Root

  /**
   * Fix circular links on `JSON.stringify()`.
   *
   * @return Cleaned object.
   */
  toJSON(): object

  /**
   * It compiles the node to browser readable cascading style sheets string
   * depending on it's type.
   *
   * ```js
   * new Rule({ selector: 'a' }).toString() //=> "a {}"
   * ```
   *
   * @param stringifier A syntax to use in string generation.
   * @return CSS string of this node.
   */
  toString(stringifier?: Stringifier | Syntax): string

  /**
   * It is a wrapper for {@link Result#warn}, providing convenient
   * way of generating warnings.
   *
   * ```js
   *   Declaration: {
   *     bad: (decl, { result }) => {
   *       decl.warn(result, 'Deprecated property: bad')
   *     }
   *   }
   * ```
   *
   * @param result The `Result` instance that will receive the warning.
   * @param message Description for the warning.
   * @param options Options for the warning.
   *
   * @return `Warning` instance is returned
   */
  warn(result: Result, message: string, options?: WarningOptions): Warning

  /**
   * If this node isn't already dirty, marks it and its ancestors as such. This
   * indicates to the LazyResult processor that the {@link Root} has been
   * modified by the current plugin and may need to be processed again by other
   * plugins.
   */
  protected markDirty(): void
}

declare class Node extends Node_ {}

export = Node

~~~

## node_modules\postcss\lib\node.js

~~~js
'use strict'

let CssSyntaxError = require('./css-syntax-error')
let Stringifier = require('./stringifier')
let stringify = require('./stringify')
let { isClean, my } = require('./symbols')

function cloneNode(obj, parent) {
  let cloned = new obj.constructor()

  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      /* c8 ignore next 2 */
      continue
    }
    if (i === 'proxyCache') continue
    let value = obj[i]
    let type = typeof value

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent
    } else if (i === 'source') {
      cloned[i] = value
    } else if (Array.isArray(value)) {
      cloned[i] = value.map(j => cloneNode(j, cloned))
    } else {
      if (type === 'object' && value !== null) value = cloneNode(value)
      cloned[i] = value
    }
  }

  return cloned
}

function sourceOffset(inputCSS, position) {
  // Not all custom syntaxes support `offset` in `source.start` and `source.end`
  if (position && typeof position.offset !== 'undefined') {
    return position.offset
  }

  let column = 1
  let line = 1
  let offset = 0

  for (let i = 0; i < inputCSS.length; i++) {
    if (line === position.line && column === position.column) {
      offset = i
      break
    }

    if (inputCSS[i] === '\n') {
      column = 1
      line += 1
    } else {
      column += 1
    }
  }

  return offset
}

class Node {
  get proxyOf() {
    return this
  }

  constructor(defaults = {}) {
    this.raws = {}
    this[isClean] = false
    this[my] = true

    for (let name in defaults) {
      if (name === 'nodes') {
        this.nodes = []
        for (let node of defaults[name]) {
          if (typeof node.clone === 'function') {
            this.append(node.clone())
          } else {
            this.append(node)
          }
        }
      } else {
        this[name] = defaults[name]
      }
    }
  }

  addToError(error) {
    error.postcssNode = this
    if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
      let s = this.source
      error.stack = error.stack.replace(
        /\n\s{4}at /,
        `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
      )
    }
    return error
  }

  after(add) {
    this.parent.insertAfter(this, add)
    return this
  }

  assign(overrides = {}) {
    for (let name in overrides) {
      this[name] = overrides[name]
    }
    return this
  }

  before(add) {
    this.parent.insertBefore(this, add)
    return this
  }

  cleanRaws(keepBetween) {
    delete this.raws.before
    delete this.raws.after
    if (!keepBetween) delete this.raws.between
  }

  clone(overrides = {}) {
    let cloned = cloneNode(this)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    }
    return cloned
  }

  cloneAfter(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertAfter(this, cloned)
    return cloned
  }

  cloneBefore(overrides = {}) {
    let cloned = this.clone(overrides)
    this.parent.insertBefore(this, cloned)
    return cloned
  }

  error(message, opts = {}) {
    if (this.source) {
      let { end, start } = this.rangeBy(opts)
      return this.source.input.error(
        message,
        { column: start.column, line: start.line },
        { column: end.column, line: end.line },
        opts
      )
    }
    return new CssSyntaxError(message)
  }

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        } else if (prop === 'root') {
          return () => node.root().toProxy()
        } else {
          return node[prop]
        }
      },

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (
          prop === 'prop' ||
          prop === 'value' ||
          prop === 'name' ||
          prop === 'params' ||
          prop === 'important' ||
          /* c8 ignore next */
          prop === 'text'
        ) {
          node.markDirty()
        }
        return true
      }
    }
  }

  /* c8 ignore next 3 */
  markClean() {
    this[isClean] = true
  }

  markDirty() {
    if (this[isClean]) {
      this[isClean] = false
      let next = this
      while ((next = next.parent)) {
        next[isClean] = false
      }
    }
  }

  next() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index + 1]
  }

  positionBy(opts = {}) {
    let pos = this.source.start
    if (opts.index) {
      pos = this.positionInside(opts.index)
    } else if (opts.word) {
      let inputString =
        'document' in this.source.input
          ? this.source.input.document
          : this.source.input.css
      let stringRepresentation = inputString.slice(
        sourceOffset(inputString, this.source.start),
        sourceOffset(inputString, this.source.end)
      )
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) pos = this.positionInside(index)
    }
    return pos
  }

  positionInside(index) {
    let column = this.source.start.column
    let line = this.source.start.line
    let inputString =
      'document' in this.source.input
        ? this.source.input.document
        : this.source.input.css
    let offset = sourceOffset(inputString, this.source.start)
    let end = offset + index

    for (let i = offset; i < end; i++) {
      if (inputString[i] === '\n') {
        column = 1
        line += 1
      } else {
        column += 1
      }
    }

    return { column, line, offset: end }
  }

  prev() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index - 1]
  }

  rangeBy(opts = {}) {
    let inputString =
      'document' in this.source.input
        ? this.source.input.document
        : this.source.input.css
    let start = {
      column: this.source.start.column,
      line: this.source.start.line,
      offset: sourceOffset(inputString, this.source.start)
    }
    let end = this.source.end
      ? {
          column: this.source.end.column + 1,
          line: this.source.end.line,
          offset:
            typeof this.source.end.offset === 'number'
              ? // `source.end.offset` is exclusive, so we don't need to add 1
                this.source.end.offset
              : // Since line/column in this.source.end is inclusive,
                // the `sourceOffset(... , this.source.end)` returns an inclusive offset.
                // So, we add 1 to convert it to exclusive.
                sourceOffset(inputString, this.source.end) + 1
        }
      : {
          column: start.column + 1,
          line: start.line,
          offset: start.offset + 1
        }

    if (opts.word) {
      let stringRepresentation = inputString.slice(
        sourceOffset(inputString, this.source.start),
        sourceOffset(inputString, this.source.end)
      )
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) {
        start = this.positionInside(index)
        end = this.positionInside(index + opts.word.length)
      }
    } else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line,
          offset: sourceOffset(inputString, opts.start)
        }
      } else if (opts.index) {
        start = this.positionInside(opts.index)
      }

      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line,
          offset: sourceOffset(inputString, opts.end)
        }
      } else if (typeof opts.endIndex === 'number') {
        end = this.positionInside(opts.endIndex)
      } else if (opts.index) {
        end = this.positionInside(opts.index + 1)
      }
    }

    if (
      end.line < start.line ||
      (end.line === start.line && end.column <= start.column)
    ) {
      end = {
        column: start.column + 1,
        line: start.line,
        offset: start.offset + 1
      }
    }

    return { end, start }
  }

  raw(prop, defaultType) {
    let str = new Stringifier()
    return str.raw(this, prop, defaultType)
  }

  remove() {
    if (this.parent) {
      this.parent.removeChild(this)
    }
    this.parent = undefined
    return this
  }

  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this
      let foundSelf = false
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true
        } else if (foundSelf) {
          this.parent.insertAfter(bookmark, node)
          bookmark = node
        } else {
          this.parent.insertBefore(bookmark, node)
        }
      }

      if (!foundSelf) {
        this.remove()
      }
    }

    return this
  }

  root() {
    let result = this
    while (result.parent && result.parent.type !== 'document') {
      result = result.parent
    }
    return result
  }

  toJSON(_, inputs) {
    let fixed = {}
    let emitInputs = inputs == null
    inputs = inputs || new Map()
    let inputsNextIndex = 0

    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        /* c8 ignore next 2 */
        continue
      }
      if (name === 'parent' || name === 'proxyCache') continue
      let value = this[name]

      if (Array.isArray(value)) {
        fixed[name] = value.map(i => {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON(null, inputs)
          } else {
            return i
          }
        })
      } else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs)
      } else if (name === 'source') {
        if (value == null) continue
        let inputId = inputs.get(value.input)
        if (inputId == null) {
          inputId = inputsNextIndex
          inputs.set(value.input, inputsNextIndex)
          inputsNextIndex++
        }
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        }
      } else {
        fixed[name] = value
      }
    }

    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())
    }

    return fixed
  }

  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor())
    }
    return this.proxyCache
  }

  toString(stringifier = stringify) {
    if (stringifier.stringify) stringifier = stringifier.stringify
    let result = ''
    stringifier(this, i => {
      result += i
    })
    return result
  }

  warn(result, text, opts = {}) {
    let data = { node: this }
    for (let i in opts) data[i] = opts[i]
    return result.warn(text, data)
  }
}

module.exports = Node
Node.default = Node

~~~

## node_modules\postcss\lib\no-work-result.d.ts

~~~ts
import LazyResult from './lazy-result.js'
import { SourceMap } from './postcss.js'
import Processor from './processor.js'
import Result, { Message, ResultOptions } from './result.js'
import Root from './root.js'
import Warning from './warning.js'

declare namespace NoWorkResult {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { NoWorkResult_ as default }
}

/**
 * A Promise proxy for the result of PostCSS transformations.
 * This lazy result instance doesn't parse css unless `NoWorkResult#root` or `Result#root`
 * are accessed. See the example below for details.
 * A `NoWork` instance is returned by `Processor#process` ONLY when no plugins defined.
 *
 * ```js
 * const noWorkResult = postcss().process(css) // No plugins are defined.
 *                                             // CSS is not parsed
 * let root = noWorkResult.root // now css is parsed because we accessed the root
 * ```
 */
declare class NoWorkResult_ implements LazyResult<Root> {
  catch: Promise<Result<Root>>['catch']
  finally: Promise<Result<Root>>['finally']
  then: Promise<Result<Root>>['then']
  get content(): string
  get css(): string
  get map(): SourceMap
  get messages(): Message[]
  get opts(): ResultOptions
  get processor(): Processor
  get root(): Root
  get [Symbol.toStringTag](): string
  constructor(processor: Processor, css: string, opts: ResultOptions)
  async(): Promise<Result<Root>>
  sync(): Result<Root>
  toString(): string
  warnings(): Warning[]
}

declare class NoWorkResult extends NoWorkResult_ {}

export = NoWorkResult

~~~

## node_modules\postcss\lib\no-work-result.js

~~~js
'use strict'

let MapGenerator = require('./map-generator')
let parse = require('./parse')
const Result = require('./result')
let stringify = require('./stringify')
let warnOnce = require('./warn-once')

class NoWorkResult {
  get content() {
    return this.result.css
  }

  get css() {
    return this.result.css
  }

  get map() {
    return this.result.map
  }

  get messages() {
    return []
  }

  get opts() {
    return this.result.opts
  }

  get processor() {
    return this.result.processor
  }

  get root() {
    if (this._root) {
      return this._root
    }

    let root
    let parser = parse

    try {
      root = parser(this._css, this._opts)
    } catch (error) {
      this.error = error
    }

    if (this.error) {
      throw this.error
    } else {
      this._root = root
      return root
    }
  }

  get [Symbol.toStringTag]() {
    return 'NoWorkResult'
  }

  constructor(processor, css, opts) {
    css = css.toString()
    this.stringified = false

    this._processor = processor
    this._css = css
    this._opts = opts
    this._map = undefined
    let root

    let str = stringify
    this.result = new Result(this._processor, root, this._opts)
    this.result.css = css

    let self = this
    Object.defineProperty(this.result, 'root', {
      get() {
        return self.root
      }
    })

    let map = new MapGenerator(str, root, this._opts, css)
    if (map.isMap()) {
      let [generatedCSS, generatedMap] = map.generate()
      if (generatedCSS) {
        this.result.css = generatedCSS
      }
      if (generatedMap) {
        this.result.map = generatedMap
      }
    } else {
      map.clearAnnotation()
      this.result.css = map.css
    }
  }

  async() {
    if (this.error) return Promise.reject(this.error)
    return Promise.resolve(this.result)
  }

  catch(onRejected) {
    return this.async().catch(onRejected)
  }

  finally(onFinally) {
    return this.async().then(onFinally, onFinally)
  }

  sync() {
    if (this.error) throw this.error
    return this.result
  }

  then(onFulfilled, onRejected) {
    if (process.env.NODE_ENV !== 'production') {
      if (!('from' in this._opts)) {
        warnOnce(
          'Without `from` option PostCSS could generate wrong source map ' +
            'and will not find Browserslist config. Set it to CSS file path ' +
            'or to `undefined` to prevent this warning.'
        )
      }
    }

    return this.async().then(onFulfilled, onRejected)
  }

  toString() {
    return this._css
  }

  warnings() {
    return []
  }
}

module.exports = NoWorkResult
NoWorkResult.default = NoWorkResult

~~~

## node_modules\postcss\lib\parse.d.ts

~~~ts
import { Parser } from './postcss.js'

interface Parse extends Parser {
  default: Parse
}

declare const parse: Parse

export = parse

~~~

## node_modules\postcss\lib\parse.js

~~~js
'use strict'

let Container = require('./container')
let Input = require('./input')
let Parser = require('./parser')

function parse(css, opts) {
  let input = new Input(css, opts)
  let parser = new Parser(input)
  try {
    parser.parse()
  } catch (e) {
    if (process.env.NODE_ENV !== 'production') {
      if (e.name === 'CssSyntaxError' && opts && opts.from) {
        if (/\.scss$/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse SCSS with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-scss parser'
        } else if (/\.sass/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse Sass with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-sass parser'
        } else if (/\.less$/i.test(opts.from)) {
          e.message +=
            '\nYou tried to parse Less with ' +
            'the standard CSS parser; ' +
            'try again with the postcss-less parser'
        }
      }
    }
    throw e
  }

  return parser.root
}

module.exports = parse
parse.default = parse

Container.registerParse(parse)

~~~

## node_modules\postcss\lib\parser.js

~~~js
'use strict'

let AtRule = require('./at-rule')
let Comment = require('./comment')
let Declaration = require('./declaration')
let Root = require('./root')
let Rule = require('./rule')
let tokenizer = require('./tokenize')

const SAFE_COMMENT_NEIGHBOR = {
  empty: true,
  space: true
}

function findLastWithPosition(tokens) {
  for (let i = tokens.length - 1; i >= 0; i--) {
    let token = tokens[i]
    let pos = token[3] || token[2]
    if (pos) return pos
  }
}

class Parser {
  constructor(input) {
    this.input = input

    this.root = new Root()
    this.current = this.root
    this.spaces = ''
    this.semicolon = false

    this.createTokenizer()
    this.root.source = { input, start: { column: 1, line: 1, offset: 0 } }
  }

  atrule(token) {
    let node = new AtRule()
    node.name = token[1].slice(1)
    if (node.name === '') {
      this.unnamedAtrule(node, token)
    }
    this.init(node, token[2])

    let type
    let prev
    let shift
    let last = false
    let open = false
    let params = []
    let brackets = []

    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()
      type = token[0]

      if (type === '(' || type === '[') {
        brackets.push(type === '(' ? ')' : ']')
      } else if (type === '{' && brackets.length > 0) {
        brackets.push('}')
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
      }

      if (brackets.length === 0) {
        if (type === ';') {
          node.source.end = this.getPosition(token[2])
          node.source.end.offset++
          this.semicolon = true
          break
        } else if (type === '{') {
          open = true
          break
        } else if (type === '}') {
          if (params.length > 0) {
            shift = params.length - 1
            prev = params[shift]
            while (prev && prev[0] === 'space') {
              prev = params[--shift]
            }
            if (prev) {
              node.source.end = this.getPosition(prev[3] || prev[2])
              node.source.end.offset++
            }
          }
          this.end(token)
          break
        } else {
          params.push(token)
        }
      } else {
        params.push(token)
      }

      if (this.tokenizer.endOfFile()) {
        last = true
        break
      }
    }

    node.raws.between = this.spacesAndCommentsFromEnd(params)
    if (params.length) {
      node.raws.afterName = this.spacesAndCommentsFromStart(params)
      this.raw(node, 'params', params)
      if (last) {
        token = params[params.length - 1]
        node.source.end = this.getPosition(token[3] || token[2])
        node.source.end.offset++
        this.spaces = node.raws.between
        node.raws.between = ''
      }
    } else {
      node.raws.afterName = ''
      node.params = ''
    }

    if (open) {
      node.nodes = []
      this.current = node
    }
  }

  checkMissedSemicolon(tokens) {
    let colon = this.colon(tokens)
    if (colon === false) return

    let founded = 0
    let token
    for (let j = colon - 1; j >= 0; j--) {
      token = tokens[j]
      if (token[0] !== 'space') {
        founded += 1
        if (founded === 2) break
      }
    }
    // If the token is a word, e.g. `!important`, `red` or any other valid property's value.
    // Then we need to return the colon after that word token. [3] is the "end" colon of that word.
    // And because we need it after that one we do +1 to get the next one.
    throw this.input.error(
      'Missed semicolon',
      token[0] === 'word' ? token[3] + 1 : token[2]
    )
  }

  colon(tokens) {
    let brackets = 0
    let prev, token, type
    for (let [i, element] of tokens.entries()) {
      token = element
      type = token[0]

      if (type === '(') {
        brackets += 1
      }
      if (type === ')') {
        brackets -= 1
      }
      if (brackets === 0 && type === ':') {
        if (!prev) {
          this.doubleColon(token)
        } else if (prev[0] === 'word' && prev[1] === 'progid') {
          continue
        } else {
          return i
        }
      }

      prev = token
    }
    return false
  }

  comment(token) {
    let node = new Comment()
    this.init(node, token[2])
    node.source.end = this.getPosition(token[3] || token[2])
    node.source.end.offset++

    let text = token[1].slice(2, -2)
    if (/^\s*$/.test(text)) {
      node.text = ''
      node.raws.left = text
      node.raws.right = ''
    } else {
      let match = text.match(/^(\s*)([^]*\S)(\s*)$/)
      node.text = match[2]
      node.raws.left = match[1]
      node.raws.right = match[3]
    }
  }

  createTokenizer() {
    this.tokenizer = tokenizer(this.input)
  }

  decl(tokens, customProperty) {
    let node = new Declaration()
    this.init(node, tokens[0][2])

    let last = tokens[tokens.length - 1]
    if (last[0] === ';') {
      this.semicolon = true
      tokens.pop()
    }

    node.source.end = this.getPosition(
      last[3] || last[2] || findLastWithPosition(tokens)
    )
    node.source.end.offset++

    while (tokens[0][0] !== 'word') {
      if (tokens.length === 1) this.unknownWord(tokens)
      node.raws.before += tokens.shift()[1]
    }
    node.source.start = this.getPosition(tokens[0][2])

    node.prop = ''
    while (tokens.length) {
      let type = tokens[0][0]
      if (type === ':' || type === 'space' || type === 'comment') {
        break
      }
      node.prop += tokens.shift()[1]
    }

    node.raws.between = ''

    let token
    while (tokens.length) {
      token = tokens.shift()

      if (token[0] === ':') {
        node.raws.between += token[1]
        break
      } else {
        if (token[0] === 'word' && /\w/.test(token[1])) {
          this.unknownWord([token])
        }
        node.raws.between += token[1]
      }
    }

    if (node.prop[0] === '_' || node.prop[0] === '*') {
      node.raws.before += node.prop[0]
      node.prop = node.prop.slice(1)
    }

    let firstSpaces = []
    let next
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      firstSpaces.push(tokens.shift())
    }

    this.precheckMissedSemicolon(tokens)

    for (let i = tokens.length - 1; i >= 0; i--) {
      token = tokens[i]
      if (token[1].toLowerCase() === '!important') {
        node.important = true
        let string = this.stringFrom(tokens, i)
        string = this.spacesFromEnd(tokens) + string
        if (string !== ' !important') node.raws.important = string
        break
      } else if (token[1].toLowerCase() === 'important') {
        let cache = tokens.slice(0)
        let str = ''
        for (let j = i; j > 0; j--) {
          let type = cache[j][0]
          if (str.trim().startsWith('!') && type !== 'space') {
            break
          }
          str = cache.pop()[1] + str
        }
        if (str.trim().startsWith('!')) {
          node.important = true
          node.raws.important = str
          tokens = cache
        }
      }

      if (token[0] !== 'space' && token[0] !== 'comment') {
        break
      }
    }

    let hasWord = tokens.some(i => i[0] !== 'space' && i[0] !== 'comment')

    if (hasWord) {
      node.raws.between += firstSpaces.map(i => i[1]).join('')
      firstSpaces = []
    }
    this.raw(node, 'value', firstSpaces.concat(tokens), customProperty)

    if (node.value.includes(':') && !customProperty) {
      this.checkMissedSemicolon(tokens)
    }
  }

  doubleColon(token) {
    throw this.input.error(
      'Double colon',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }

  emptyRule(token) {
    let node = new Rule()
    this.init(node, token[2])
    node.selector = ''
    node.raws.between = ''
    this.current = node
  }

  end(token) {
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.semicolon = false

    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.spaces = ''

    if (this.current.parent) {
      this.current.source.end = this.getPosition(token[2])
      this.current.source.end.offset++
      this.current = this.current.parent
    } else {
      this.unexpectedClose(token)
    }
  }

  endFile() {
    if (this.current.parent) this.unclosedBlock()
    if (this.current.nodes && this.current.nodes.length) {
      this.current.raws.semicolon = this.semicolon
    }
    this.current.raws.after = (this.current.raws.after || '') + this.spaces
    this.root.source.end = this.getPosition(this.tokenizer.position())
  }

  freeSemicolon(token) {
    this.spaces += token[1]
    if (this.current.nodes) {
      let prev = this.current.nodes[this.current.nodes.length - 1]
      if (prev && prev.type === 'rule' && !prev.raws.ownSemicolon) {
        prev.raws.ownSemicolon = this.spaces
        this.spaces = ''
        prev.source.end = this.getPosition(token[2])
        prev.source.end.offset += prev.raws.ownSemicolon.length
      }
    }
  }

  // Helpers

  getPosition(offset) {
    let pos = this.input.fromOffset(offset)
    return {
      column: pos.col,
      line: pos.line,
      offset
    }
  }

  init(node, offset) {
    this.current.push(node)
    node.source = {
      input: this.input,
      start: this.getPosition(offset)
    }
    node.raws.before = this.spaces
    this.spaces = ''
    if (node.type !== 'comment') this.semicolon = false
  }

  other(start) {
    let end = false
    let type = null
    let colon = false
    let bracket = null
    let brackets = []
    let customProperty = start[1].startsWith('--')

    let tokens = []
    let token = start
    while (token) {
      type = token[0]
      tokens.push(token)

      if (type === '(' || type === '[') {
        if (!bracket) bracket = token
        brackets.push(type === '(' ? ')' : ']')
      } else if (customProperty && colon && type === '{') {
        if (!bracket) bracket = token
        brackets.push('}')
      } else if (brackets.length === 0) {
        if (type === ';') {
          if (colon) {
            this.decl(tokens, customProperty)
            return
          } else {
            break
          }
        } else if (type === '{') {
          this.rule(tokens)
          return
        } else if (type === '}') {
          this.tokenizer.back(tokens.pop())
          end = true
          break
        } else if (type === ':') {
          colon = true
        }
      } else if (type === brackets[brackets.length - 1]) {
        brackets.pop()
        if (brackets.length === 0) bracket = null
      }

      token = this.tokenizer.nextToken()
    }

    if (this.tokenizer.endOfFile()) end = true
    if (brackets.length > 0) this.unclosedBracket(bracket)

    if (end && colon) {
      if (!customProperty) {
        while (tokens.length) {
          token = tokens[tokens.length - 1][0]
          if (token !== 'space' && token !== 'comment') break
          this.tokenizer.back(tokens.pop())
        }
      }
      this.decl(tokens, customProperty)
    } else {
      this.unknownWord(tokens)
    }
  }

  parse() {
    let token
    while (!this.tokenizer.endOfFile()) {
      token = this.tokenizer.nextToken()

      switch (token[0]) {
        case 'space':
          this.spaces += token[1]
          break

        case ';':
          this.freeSemicolon(token)
          break

        case '}':
          this.end(token)
          break

        case 'comment':
          this.comment(token)
          break

        case 'at-word':
          this.atrule(token)
          break

        case '{':
          this.emptyRule(token)
          break

        default:
          this.other(token)
          break
      }
    }
    this.endFile()
  }

  precheckMissedSemicolon(/* tokens */) {
    // Hook for Safe Parser
  }

  raw(node, prop, tokens, customProperty) {
    let token, type
    let length = tokens.length
    let value = ''
    let clean = true
    let next, prev

    for (let i = 0; i < length; i += 1) {
      token = tokens[i]
      type = token[0]
      if (type === 'space' && i === length - 1 && !customProperty) {
        clean = false
      } else if (type === 'comment') {
        prev = tokens[i - 1] ? tokens[i - 1][0] : 'empty'
        next = tokens[i + 1] ? tokens[i + 1][0] : 'empty'
        if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
          if (value.slice(-1) === ',') {
            clean = false
          } else {
            value += token[1]
          }
        } else {
          clean = false
        }
      } else {
        value += token[1]
      }
    }
    if (!clean) {
      let raw = tokens.reduce((all, i) => all + i[1], '')
      node.raws[prop] = { raw, value }
    }
    node[prop] = value
  }

  rule(tokens) {
    tokens.pop()

    let node = new Rule()
    this.init(node, tokens[0][2])

    node.raws.between = this.spacesAndCommentsFromEnd(tokens)
    this.raw(node, 'selector', tokens)
    this.current = node
  }

  spacesAndCommentsFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space' && lastTokenType !== 'comment') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  // Errors

  spacesAndCommentsFromStart(tokens) {
    let next
    let spaces = ''
    while (tokens.length) {
      next = tokens[0][0]
      if (next !== 'space' && next !== 'comment') break
      spaces += tokens.shift()[1]
    }
    return spaces
  }

  spacesFromEnd(tokens) {
    let lastTokenType
    let spaces = ''
    while (tokens.length) {
      lastTokenType = tokens[tokens.length - 1][0]
      if (lastTokenType !== 'space') break
      spaces = tokens.pop()[1] + spaces
    }
    return spaces
  }

  stringFrom(tokens, from) {
    let result = ''
    for (let i = from; i < tokens.length; i++) {
      result += tokens[i][1]
    }
    tokens.splice(from, tokens.length - from)
    return result
  }

  unclosedBlock() {
    let pos = this.current.source.start
    throw this.input.error('Unclosed block', pos.line, pos.column)
  }

  unclosedBracket(bracket) {
    throw this.input.error(
      'Unclosed bracket',
      { offset: bracket[2] },
      { offset: bracket[2] + 1 }
    )
  }

  unexpectedClose(token) {
    throw this.input.error(
      'Unexpected }',
      { offset: token[2] },
      { offset: token[2] + 1 }
    )
  }

  unknownWord(tokens) {
    throw this.input.error(
      'Unknown word ' + tokens[0][1],
      { offset: tokens[0][2] },
      { offset: tokens[0][2] + tokens[0][1].length }
    )
  }

  unnamedAtrule(node, token) {
    throw this.input.error(
      'At-rule without name',
      { offset: token[2] },
      { offset: token[2] + token[1].length }
    )
  }
}

module.exports = Parser

~~~

## node_modules\postcss\lib\postcss.d.mts

~~~mts
export {
  // Type-only exports
  AcceptedPlugin,

  AnyNode,
  atRule,
  AtRule,
  AtRuleProps,
  Builder,
  ChildNode,
  ChildProps,
  comment,
  Comment,
  CommentProps,
  Container,
  ContainerProps,
  CssSyntaxError,
  decl,
  Declaration,
  DeclarationProps,
  // postcss function / namespace
  default,
  document,
  Document,
  DocumentProps,
  FilePosition,
  fromJSON,
  Helpers,
  Input,

  JSONHydrator,
  // This is a class, but it?셲 not re-exported. That?셲 why it?셲 exported as type-only here.
  type LazyResult,
  list,
  Message,
  Node,
  NodeErrorOptions,
  NodeProps,
  OldPlugin,
  parse,
  Parser,
  // @ts-expect-error This value exists, but it?셲 untyped.
  plugin,
  Plugin,
  PluginCreator,
  Position,
  Postcss,
  ProcessOptions,
  Processor,
  Result,
  root,
  Root,
  RootProps,
  rule,
  Rule,
  RuleProps,
  Source,
  SourceMap,
  SourceMapOptions,
  Stringifier,
  // Value exports from postcss.mjs
  stringify,
  Syntax,
  TransformCallback,
  Transformer,
  Warning,

  WarningOptions
} from './postcss.js'

~~~

## node_modules\postcss\lib\postcss.d.ts

~~~ts
import { RawSourceMap, SourceMapGenerator } from 'source-map-js'

import AtRule, { AtRuleProps } from './at-rule.js'
import Comment, { CommentProps } from './comment.js'
import Container, { ContainerProps, NewChild } from './container.js'
import CssSyntaxError from './css-syntax-error.js'
import Declaration, { DeclarationProps } from './declaration.js'
import Document, { DocumentProps } from './document.js'
import Input, { FilePosition } from './input.js'
import LazyResult from './lazy-result.js'
import list from './list.js'
import Node, {
  AnyNode,
  ChildNode,
  ChildProps,
  NodeErrorOptions,
  NodeProps,
  Position,
  Source
} from './node.js'
import Processor from './processor.js'
import Result, { Message } from './result.js'
import Root, { RootProps } from './root.js'
import Rule, { RuleProps } from './rule.js'
import Warning, { WarningOptions } from './warning.js'

type DocumentProcessor = (
  document: Document,
  helper: postcss.Helpers
) => Promise<void> | void
type RootProcessor = (
  root: Root,
  helper: postcss.Helpers
) => Promise<void> | void
type DeclarationProcessor = (
  decl: Declaration,
  helper: postcss.Helpers
) => Promise<void> | void
type RuleProcessor = (
  rule: Rule,
  helper: postcss.Helpers
) => Promise<void> | void
type AtRuleProcessor = (
  atRule: AtRule,
  helper: postcss.Helpers
) => Promise<void> | void
type CommentProcessor = (
  comment: Comment,
  helper: postcss.Helpers
) => Promise<void> | void

interface Processors {
  /**
   * Will be called on all`AtRule` nodes.
   *
   * Will be called again on node or children changes.
   */
  AtRule?: { [name: string]: AtRuleProcessor } | AtRuleProcessor

  /**
   * Will be called on all `AtRule` nodes, when all children will be processed.
   *
   * Will be called again on node or children changes.
   */
  AtRuleExit?: { [name: string]: AtRuleProcessor } | AtRuleProcessor

  /**
   * Will be called on all `Comment` nodes.
   *
   * Will be called again on node or children changes.
   */
  Comment?: CommentProcessor

  /**
   * Will be called on all `Comment` nodes after listeners
   * for `Comment` event.
   *
   * Will be called again on node or children changes.
   */
  CommentExit?: CommentProcessor

  /**
   * Will be called on all `Declaration` nodes after listeners
   * for `Declaration` event.
   *
   * Will be called again on node or children changes.
   */
  Declaration?: { [prop: string]: DeclarationProcessor } | DeclarationProcessor

  /**
   * Will be called on all `Declaration` nodes.
   *
   * Will be called again on node or children changes.
   */
  DeclarationExit?:
    | { [prop: string]: DeclarationProcessor }
    | DeclarationProcessor

  /**
   * Will be called on `Document` node.
   *
   * Will be called again on children changes.
   */
  Document?: DocumentProcessor

  /**
   * Will be called on `Document` node, when all children will be processed.
   *
   * Will be called again on children changes.
   */
  DocumentExit?: DocumentProcessor

  /**
   * Will be called on `Root` node once.
   */
  Once?: RootProcessor

  /**
   * Will be called on `Root` node once, when all children will be processed.
   */
  OnceExit?: RootProcessor

  /**
   * Will be called on `Root` node.
   *
   * Will be called again on children changes.
   */
  Root?: RootProcessor

  /**
   * Will be called on `Root` node, when all children will be processed.
   *
   * Will be called again on children changes.
   */
  RootExit?: RootProcessor

  /**
   * Will be called on all `Rule` nodes.
   *
   * Will be called again on node or children changes.
   */
  Rule?: RuleProcessor

  /**
   * Will be called on all `Rule` nodes, when all children will be processed.
   *
   * Will be called again on node or children changes.
   */
  RuleExit?: RuleProcessor
}

declare namespace postcss {
  export {
    AnyNode,
    AtRule,
    AtRuleProps,
    ChildNode,
    ChildProps,
    Comment,
    CommentProps,
    Container,
    ContainerProps,
    CssSyntaxError,
    Declaration,
    DeclarationProps,
    Document,
    DocumentProps,
    FilePosition,
    Input,
    LazyResult,
    list,
    Message,
    NewChild,
    Node,
    NodeErrorOptions,
    NodeProps,
    Position,
    Processor,
    Result,
    Root,
    RootProps,
    Rule,
    RuleProps,
    Source,
    Warning,
    WarningOptions
  }

  export type SourceMap = {
    toJSON(): RawSourceMap
  } & SourceMapGenerator

  export type Helpers = { postcss: Postcss; result: Result } & Postcss

  export interface Plugin extends Processors {
    postcssPlugin: string
    prepare?: (result: Result) => Processors
  }

  export interface PluginCreator<PluginOptions> {
    (opts?: PluginOptions): Plugin | Processor
    postcss: true
  }

  export interface Transformer extends TransformCallback {
    postcssPlugin: string
    postcssVersion: string
  }

  export interface TransformCallback {
    (root: Root, result: Result): Promise<void> | void
  }

  export interface OldPlugin<T> extends Transformer {
    (opts?: T): Transformer
    postcss: Transformer
  }

  export type AcceptedPlugin =
    | {
        postcss: Processor | TransformCallback
      }
    | OldPlugin<any>
    | Plugin
    | PluginCreator<any>
    | Processor
    | TransformCallback

  export interface Parser<RootNode = Document | Root> {
    (
      css: { toString(): string } | string,
      opts?: Pick<ProcessOptions, 'document' | 'from' | 'map'>
    ): RootNode
  }

  export interface Builder {
    (part: string, node?: AnyNode, type?: 'end' | 'start'): void
  }

  export interface Stringifier {
    (node: AnyNode, builder: Builder): void
  }

  export interface JSONHydrator {
    (data: object): Node
    (data: object[]): Node[]
  }

  export interface Syntax<RootNode = Document | Root> {
    /**
     * Function to generate AST by string.
     */
    parse?: Parser<RootNode>

    /**
     * Class to generate string by AST.
     */
    stringify?: Stringifier
  }

  export interface SourceMapOptions {
    /**
     * Use absolute path in generated source map.
     */
    absolute?: boolean

    /**
     * Indicates that PostCSS should add annotation comments to the CSS.
     * By default, PostCSS will always add a comment with a path
     * to the source map. PostCSS will not add annotations to CSS files
     * that do not contain any comments.
     *
     * By default, PostCSS presumes that you want to save the source map as
     * `opts.to + '.map'` and will use this path in the annotation comment.
     * A different path can be set by providing a string value for annotation.
     *
     * If you have set `inline: true`, annotation cannot be disabled.
     */
    annotation?: ((file: string, root: Root) => string) | boolean | string

    /**
     * Override `from` in map?셲 sources.
     */
    from?: string

    /**
     * Indicates that the source map should be embedded in the output CSS
     * as a Base64-encoded comment. By default, it is `true`.
     * But if all previous maps are external, not inline, PostCSS will not embed
     * the map even if you do not set this option.
     *
     * If you have an inline source map, the result.map property will be empty,
     * as the source map will be contained within the text of `result.css`.
     */
    inline?: boolean

    /**
     * Source map content from a previous processing step (e.g., Sass).
     *
     * PostCSS will try to read the previous source map
     * automatically (based on comments within the source CSS), but you can use
     * this option to identify it manually.
     *
     * If desired, you can omit the previous map with prev: `false`.
     */
    prev?: ((file: string) => string) | boolean | object | string

    /**
     * Indicates that PostCSS should set the origin content (e.g., Sass source)
     * of the source map. By default, it is true. But if all previous maps do not
     * contain sources content, PostCSS will also leave it out even if you
     * do not set this option.
     */
    sourcesContent?: boolean
  }

  export interface ProcessOptions<RootNode = Document | Root> {
    /**
     * Input file if it is not simple CSS file, but HTML with <style> or JS with CSS-in-JS blocks.
     */
    document?: string

    /**
     * The path of the CSS source file. You should always set `from`,
     * because it is used in source map generation and syntax error messages.
     */
    from?: string | undefined

    /**
     * Source map options
     */
    map?: boolean | SourceMapOptions

    /**
     * Function to generate AST by string.
     */
    parser?: Parser<RootNode> | Syntax<RootNode>

    /**
     * Class to generate string by AST.
     */
    stringifier?: Stringifier | Syntax<RootNode>

    /**
     * Object with parse and stringify.
     */
    syntax?: Syntax<RootNode>

    /**
     * The path where you'll put the output CSS file. You should always set `to`
     * to generate correct source maps.
     */
    to?: string
  }

  export type Postcss = typeof postcss

  /**
   * Default function to convert a node tree into a CSS string.
   */
  export let stringify: Stringifier

  /**
   * Parses source css and returns a new `Root` or `Document` node,
   * which contains the source CSS nodes.
   *
   * ```js
   * // Simple CSS concatenation with source map support
   * const root1 = postcss.parse(css1, { from: file1 })
   * const root2 = postcss.parse(css2, { from: file2 })
   * root1.append(root2).toResult().css
   * ```
   */
  export let parse: Parser<Root>

  /**
   * Rehydrate a JSON AST (from `Node#toJSON`) back into the AST classes.
   *
   * ```js
   * const json = root.toJSON()
   * // save to file, send by network, etc
   * const root2  = postcss.fromJSON(json)
   * ```
   */
  export let fromJSON: JSONHydrator

  /**
   * Creates a new `Comment` node.
   *
   * @param defaults Properties for the new node.
   * @return New comment node
   */
  export function comment(defaults?: CommentProps): Comment

  /**
   * Creates a new `AtRule` node.
   *
   * @param defaults Properties for the new node.
   * @return New at-rule node.
   */
  export function atRule(defaults?: AtRuleProps): AtRule

  /**
   * Creates a new `Declaration` node.
   *
   * @param defaults Properties for the new node.
   * @return New declaration node.
   */
  export function decl(defaults?: DeclarationProps): Declaration

  /**
   * Creates a new `Rule` node.
   *
   * @param default Properties for the new node.
   * @return New rule node.
   */
  export function rule(defaults?: RuleProps): Rule

  /**
   * Creates a new `Root` node.
   *
   * @param defaults Properties for the new node.
   * @return New root node.
   */
  export function root(defaults?: RootProps): Root

  /**
   * Creates a new `Document` node.
   *
   * @param defaults Properties for the new node.
   * @return New document node.
   */
  export function document(defaults?: DocumentProps): Document

  export { postcss as default }
}

/**
 * Create a new `Processor` instance that will apply `plugins`
 * as CSS processors.
 *
 * ```js
 * let postcss = require('postcss')
 *
 * postcss(plugins).process(css, { from, to }).then(result => {
 *   console.log(result.css)
 * })
 * ```
 *
 * @param plugins PostCSS plugins.
 * @return Processor to process multiple CSS.
 */
declare function postcss(
  plugins?: readonly postcss.AcceptedPlugin[]
): Processor
declare function postcss(...plugins: postcss.AcceptedPlugin[]): Processor

export = postcss

~~~

## node_modules\postcss\lib\postcss.js

~~~js
'use strict'

let AtRule = require('./at-rule')
let Comment = require('./comment')
let Container = require('./container')
let CssSyntaxError = require('./css-syntax-error')
let Declaration = require('./declaration')
let Document = require('./document')
let fromJSON = require('./fromJSON')
let Input = require('./input')
let LazyResult = require('./lazy-result')
let list = require('./list')
let Node = require('./node')
let parse = require('./parse')
let Processor = require('./processor')
let Result = require('./result.js')
let Root = require('./root')
let Rule = require('./rule')
let stringify = require('./stringify')
let Warning = require('./warning')

function postcss(...plugins) {
  if (plugins.length === 1 && Array.isArray(plugins[0])) {
    plugins = plugins[0]
  }
  return new Processor(plugins)
}

postcss.plugin = function plugin(name, initializer) {
  let warningPrinted = false
  function creator(...args) {
    // eslint-disable-next-line no-console
    if (console && console.warn && !warningPrinted) {
      warningPrinted = true
      // eslint-disable-next-line no-console
      console.warn(
        name +
          ': postcss.plugin was deprecated. Migration guide:\n' +
          'https://evilmartians.com/chronicles/postcss-8-plugin-migration'
      )
      if (process.env.LANG && process.env.LANG.startsWith('cn')) {
        /* c8 ignore next 7 */
        // eslint-disable-next-line no-console
        console.warn(
          name +
            ': ?뚪씊 postcss.plugin 熬ュ펱?? 瓦곭㎉?뉐뜔:\n' +
            'https://www.w3ctech.com/topic/2226'
        )
      }
    }
    let transformer = initializer(...args)
    transformer.postcssPlugin = name
    transformer.postcssVersion = new Processor().version
    return transformer
  }

  let cache
  Object.defineProperty(creator, 'postcss', {
    get() {
      if (!cache) cache = creator()
      return cache
    }
  })

  creator.process = function (css, processOpts, pluginOpts) {
    return postcss([creator(pluginOpts)]).process(css, processOpts)
  }

  return creator
}

postcss.stringify = stringify
postcss.parse = parse
postcss.fromJSON = fromJSON
postcss.list = list

postcss.comment = defaults => new Comment(defaults)
postcss.atRule = defaults => new AtRule(defaults)
postcss.decl = defaults => new Declaration(defaults)
postcss.rule = defaults => new Rule(defaults)
postcss.root = defaults => new Root(defaults)
postcss.document = defaults => new Document(defaults)

postcss.CssSyntaxError = CssSyntaxError
postcss.Declaration = Declaration
postcss.Container = Container
postcss.Processor = Processor
postcss.Document = Document
postcss.Comment = Comment
postcss.Warning = Warning
postcss.AtRule = AtRule
postcss.Result = Result
postcss.Input = Input
postcss.Rule = Rule
postcss.Root = Root
postcss.Node = Node

LazyResult.registerPostcss(postcss)

module.exports = postcss
postcss.default = postcss

~~~

## node_modules\postcss\lib\postcss.mjs

~~~mjs
import postcss from './postcss.js'

export default postcss

export const stringify = postcss.stringify
export const fromJSON = postcss.fromJSON
export const plugin = postcss.plugin
export const parse = postcss.parse
export const list = postcss.list

export const document = postcss.document
export const comment = postcss.comment
export const atRule = postcss.atRule
export const rule = postcss.rule
export const decl = postcss.decl
export const root = postcss.root

export const CssSyntaxError = postcss.CssSyntaxError
export const Declaration = postcss.Declaration
export const Container = postcss.Container
export const Processor = postcss.Processor
export const Document = postcss.Document
export const Comment = postcss.Comment
export const Warning = postcss.Warning
export const AtRule = postcss.AtRule
export const Result = postcss.Result
export const Input = postcss.Input
export const Rule = postcss.Rule
export const Root = postcss.Root
export const Node = postcss.Node

~~~

## node_modules\postcss\lib\previous-map.d.ts

~~~ts
import { SourceMapConsumer } from 'source-map-js'

import { ProcessOptions } from './postcss.js'

declare namespace PreviousMap {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { PreviousMap_ as default }
}

/**
 * Source map information from input CSS.
 * For example, source map after Sass compiler.
 *
 * This class will automatically find source map in input CSS or in file system
 * near input file (according `from` option).
 *
 * ```js
 * const root = parse(css, { from: 'a.sass.css' })
 * root.input.map //=> PreviousMap
 * ```
 */
declare class PreviousMap_ {
  /**
   * `sourceMappingURL` content.
   */
  annotation?: string

  /**
   * The CSS source identifier. Contains `Input#file` if the user
   * set the `from` option, or `Input#id` if they did not.
   */
  file?: string

  /**
   * Was source map inlined by data-uri to input CSS.
   */
  inline: boolean

  /**
   * Path to source map file.
   */
  mapFile?: string

  /**
   * The directory with source map file, if source map is in separated file.
   */
  root?: string

  /**
   * Source map file content.
   */
  text?: string

  /**
   * @param css  Input CSS source.
   * @param opts Process options.
   */
  constructor(css: string, opts?: ProcessOptions)

  /**
   * Create a instance of `SourceMapGenerator` class
   * from the `source-map` library to work with source map information.
   *
   * It is lazy method, so it will create object only on first call
   * and then it will use cache.
   *
   * @return Object with source map information.
   */
  consumer(): SourceMapConsumer

  /**
   * Does source map contains `sourcesContent` with input source text.
   *
   * @return Is `sourcesContent` present.
   */
  withContent(): boolean
}

declare class PreviousMap extends PreviousMap_ {}

export = PreviousMap

~~~

## node_modules\postcss\lib\previous-map.js

~~~js
'use strict'

let { existsSync, readFileSync } = require('fs')
let { dirname, join } = require('path')
let { SourceMapConsumer, SourceMapGenerator } = require('source-map-js')

function fromBase64(str) {
  if (Buffer) {
    return Buffer.from(str, 'base64').toString()
  } else {
    /* c8 ignore next 2 */
    return window.atob(str)
  }
}

class PreviousMap {
  constructor(css, opts) {
    if (opts.map === false) return
    this.loadAnnotation(css)
    this.inline = this.startWith(this.annotation, 'data:')

    let prev = opts.map ? opts.map.prev : undefined
    let text = this.loadMap(opts.from, prev)
    if (!this.mapFile && opts.from) {
      this.mapFile = opts.from
    }
    if (this.mapFile) this.root = dirname(this.mapFile)
    if (text) this.text = text
  }

  consumer() {
    if (!this.consumerCache) {
      this.consumerCache = new SourceMapConsumer(this.text)
    }
    return this.consumerCache
  }

  decodeInline(text) {
    let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/
    let baseUri = /^data:application\/json;base64,/
    let charsetUri = /^data:application\/json;charset=utf-?8,/
    let uri = /^data:application\/json,/

    let uriMatch = text.match(charsetUri) || text.match(uri)
    if (uriMatch) {
      return decodeURIComponent(text.substr(uriMatch[0].length))
    }

    let baseUriMatch = text.match(baseCharsetUri) || text.match(baseUri)
    if (baseUriMatch) {
      return fromBase64(text.substr(baseUriMatch[0].length))
    }

    let encoding = text.match(/data:application\/json;([^,]+),/)[1]
    throw new Error('Unsupported source map encoding ' + encoding)
  }

  getAnnotationURL(sourceMapString) {
    return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, '').trim()
  }

  isMap(map) {
    if (typeof map !== 'object') return false
    return (
      typeof map.mappings === 'string' ||
      typeof map._mappings === 'string' ||
      Array.isArray(map.sections)
    )
  }

  loadAnnotation(css) {
    let comments = css.match(/\/\*\s*# sourceMappingURL=/g)
    if (!comments) return

    // sourceMappingURLs from comments, strings, etc.
    let start = css.lastIndexOf(comments.pop())
    let end = css.indexOf('*/', start)

    if (start > -1 && end > -1) {
      // Locate the last sourceMappingURL to avoid pickin
      this.annotation = this.getAnnotationURL(css.substring(start, end))
    }
  }

  loadFile(path) {
    this.root = dirname(path)
    if (existsSync(path)) {
      this.mapFile = path
      return readFileSync(path, 'utf-8').toString().trim()
    }
  }

  loadMap(file, prev) {
    if (prev === false) return false

    if (prev) {
      if (typeof prev === 'string') {
        return prev
      } else if (typeof prev === 'function') {
        let prevPath = prev(file)
        if (prevPath) {
          let map = this.loadFile(prevPath)
          if (!map) {
            throw new Error(
              'Unable to load previous source map: ' + prevPath.toString()
            )
          }
          return map
        }
      } else if (prev instanceof SourceMapConsumer) {
        return SourceMapGenerator.fromSourceMap(prev).toString()
      } else if (prev instanceof SourceMapGenerator) {
        return prev.toString()
      } else if (this.isMap(prev)) {
        return JSON.stringify(prev)
      } else {
        throw new Error(
          'Unsupported previous source map format: ' + prev.toString()
        )
      }
    } else if (this.inline) {
      return this.decodeInline(this.annotation)
    } else if (this.annotation) {
      let map = this.annotation
      if (file) map = join(dirname(file), map)
      return this.loadFile(map)
    }
  }

  startWith(string, start) {
    if (!string) return false
    return string.substr(0, start.length) === start
  }

  withContent() {
    return !!(
      this.consumer().sourcesContent &&
      this.consumer().sourcesContent.length > 0
    )
  }
}

module.exports = PreviousMap
PreviousMap.default = PreviousMap

~~~

## node_modules\postcss\lib\processor.d.ts

~~~ts
import Document from './document.js'
import LazyResult from './lazy-result.js'
import NoWorkResult from './no-work-result.js'
import {
  AcceptedPlugin,
  Plugin,
  ProcessOptions,
  TransformCallback,
  Transformer
} from './postcss.js'
import Result from './result.js'
import Root from './root.js'

declare namespace Processor {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Processor_ as default }
}

/**
 * Contains plugins to process CSS. Create one `Processor` instance,
 * initialize its plugins, and then use that instance on numerous CSS files.
 *
 * ```js
 * const processor = postcss([autoprefixer, postcssNested])
 * processor.process(css1).then(result => console.log(result.css))
 * processor.process(css2).then(result => console.log(result.css))
 * ```
 */
declare class Processor_ {
  /**
   * Plugins added to this processor.
   *
   * ```js
   * const processor = postcss([autoprefixer, postcssNested])
   * processor.plugins.length //=> 2
   * ```
   */
  plugins: (Plugin | TransformCallback | Transformer)[]

  /**
   * Current PostCSS version.
   *
   * ```js
   * if (result.processor.version.split('.')[0] !== '6') {
   *   throw new Error('This plugin works only with PostCSS 6')
   * }
   * ```
   */
  version: string

  /**
   * @param plugins PostCSS plugins
   */
  constructor(plugins?: readonly AcceptedPlugin[])

  /**
   * Parses source CSS and returns a `LazyResult` Promise proxy.
   * Because some plugins can be asynchronous it doesn?셳 make
   * any transformations. Transformations will be applied
   * in the `LazyResult` methods.
   *
   * ```js
   * processor.process(css, { from: 'a.css', to: 'a.out.css' })
   *   .then(result => {
   *      console.log(result.css)
   *   })
   * ```
   *
   * @param css String with input CSS or any object with a `toString()` method,
   *            like a Buffer. Optionally, send a `Result` instance
   *            and the processor will take the `Root` from it.
   * @param opts Options.
   * @return Promise proxy.
   */
  process(
    css: { toString(): string } | LazyResult | Result | Root | string
  ): LazyResult | NoWorkResult
  process<RootNode extends Document | Root = Root>(
    css: { toString(): string } | LazyResult | Result | Root | string,
    options: ProcessOptions<RootNode>
  ): LazyResult<RootNode>

  /**
   * Adds a plugin to be used as a CSS processor.
   *
   * PostCSS plugin can be in 4 formats:
   * * A plugin in `Plugin` format.
   * * A plugin creator function with `pluginCreator.postcss = true`.
   *   PostCSS will call this function without argument to get plugin.
   * * A function. PostCSS will pass the function a {@link Root}
   *   as the first argument and current `Result` instance
   *   as the second.
   * * Another `Processor` instance. PostCSS will copy plugins
   *   from that instance into this one.
   *
   * Plugins can also be added by passing them as arguments when creating
   * a `postcss` instance (see [`postcss(plugins)`]).
   *
   * Asynchronous plugins should return a `Promise` instance.
   *
   * ```js
   * const processor = postcss()
   *   .use(autoprefixer)
   *   .use(postcssNested)
   * ```
   *
   * @param plugin PostCSS plugin or `Processor` with plugins.
   * @return Current processor to make methods chain.
   */
  use(plugin: AcceptedPlugin): this
}

declare class Processor extends Processor_ {}

export = Processor

~~~

## node_modules\postcss\lib\processor.js

~~~js
'use strict'

let Document = require('./document')
let LazyResult = require('./lazy-result')
let NoWorkResult = require('./no-work-result')
let Root = require('./root')

class Processor {
  constructor(plugins = []) {
    this.version = '8.5.6'
    this.plugins = this.normalize(plugins)
  }

  normalize(plugins) {
    let normalized = []
    for (let i of plugins) {
      if (i.postcss === true) {
        i = i()
      } else if (i.postcss) {
        i = i.postcss
      }

      if (typeof i === 'object' && Array.isArray(i.plugins)) {
        normalized = normalized.concat(i.plugins)
      } else if (typeof i === 'object' && i.postcssPlugin) {
        normalized.push(i)
      } else if (typeof i === 'function') {
        normalized.push(i)
      } else if (typeof i === 'object' && (i.parse || i.stringify)) {
        if (process.env.NODE_ENV !== 'production') {
          throw new Error(
            'PostCSS syntaxes cannot be used as plugins. Instead, please use ' +
              'one of the syntax/parser/stringifier options as outlined ' +
              'in your PostCSS runner documentation.'
          )
        }
      } else {
        throw new Error(i + ' is not a PostCSS plugin')
      }
    }
    return normalized
  }

  process(css, opts = {}) {
    if (
      !this.plugins.length &&
      !opts.parser &&
      !opts.stringifier &&
      !opts.syntax
    ) {
      return new NoWorkResult(this, css, opts)
    } else {
      return new LazyResult(this, css, opts)
    }
  }

  use(plugin) {
    this.plugins = this.plugins.concat(this.normalize([plugin]))
    return this
  }
}

module.exports = Processor
Processor.default = Processor

Root.registerProcessor(Processor)
Document.registerProcessor(Processor)

~~~

## node_modules\postcss\lib\result.d.ts

~~~ts
import {
  Document,
  Node,
  Plugin,
  ProcessOptions,
  Root,
  SourceMap,
  TransformCallback,
  Warning,
  WarningOptions
} from './postcss.js'
import Processor from './processor.js'

declare namespace Result {
  export interface Message {
    [others: string]: any

    /**
     * Source PostCSS plugin name.
     */
    plugin?: string

    /**
     * Message type.
     */
    type: string
  }

  export interface ResultOptions extends ProcessOptions {
    /**
     * The CSS node that was the source of the warning.
     */
    node?: Node

    /**
     * Name of plugin that created this warning. `Result#warn` will fill it
     * automatically with `Plugin#postcssPlugin` value.
     */
    plugin?: string
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Result_ as default }
}

/**
 * Provides the result of the PostCSS transformations.
 *
 * A Result instance is returned by `LazyResult#then`
 * or `Root#toResult` methods.
 *
 * ```js
 * postcss([autoprefixer]).process(css).then(result => {
 *  console.log(result.css)
 * })
 * ```
 *
 * ```js
 * const result2 = postcss.parse(css).toResult()
 * ```
 */
declare class Result_<RootNode = Document | Root> {
  /**
   * A CSS string representing of `Result#root`.
   *
   * ```js
   * postcss.parse('a{}').toResult().css //=> "a{}"
   * ```
   */
  css: string

  /**
   * Last runned PostCSS plugin.
   */
  lastPlugin: Plugin | TransformCallback

  /**
   * An instance of `SourceMapGenerator` class from the `source-map` library,
   * representing changes to the `Result#root` instance.
   *
   * ```js
   * result.map.toJSON() //=> { version: 3, file: 'a.css', ??}
   * ```
   *
   * ```js
   * if (result.map) {
   *   fs.writeFileSync(result.opts.to + '.map', result.map.toString())
   * }
   * ```
   */
  map: SourceMap

  /**
   * Contains messages from plugins (e.g., warnings or custom messages).
   * Each message should have type and plugin properties.
   *
   * ```js
   * AtRule: {
   *   import: (atRule, { result }) {
   *     const importedFile = parseImport(atRule)
   *     result.messages.push({
   *       type: 'dependency',
   *       plugin: 'postcss-import',
   *       file: importedFile,
   *       parent: result.opts.from
   *     })
   *   }
   * }
   * ```
   */
  messages: Result.Message[]

  /**
   * Options from the `Processor#process` or `Root#toResult` call
   * that produced this Result instance.]
   *
   * ```js
   * root.toResult(opts).opts === opts
   * ```
   */
  opts: Result.ResultOptions

  /**
   * The Processor instance used for this transformation.
   *
   * ```js
   * for (const plugin of result.processor.plugins) {
   *   if (plugin.postcssPlugin === 'postcss-bad') {
   *     throw 'postcss-good is incompatible with postcss-bad'
   *   }
   * })
   * ```
   */
  processor: Processor

  /**
   * Root node after all transformations.
   *
   * ```js
   * root.toResult().root === root
   * ```
   */
  root: RootNode

  /**
   * An alias for the `Result#css` property.
   * Use it with syntaxes that generate non-CSS output.
   *
   * ```js
   * result.css === result.content
   * ```
   */
  get content(): string

  /**
   * @param processor Processor used for this transformation.
   * @param root      Root node after all transformations.
   * @param opts      Options from the `Processor#process` or `Root#toResult`.
   */
  constructor(processor: Processor, root: RootNode, opts: Result.ResultOptions)

  /**
   * Returns for `Result#css` content.
   *
   * ```js
   * result + '' === result.css
   * ```
   *
   * @return String representing of `Result#root`.
   */
  toString(): string

  /**
   * Creates an instance of `Warning` and adds it to `Result#messages`.
   *
   * ```js
   * if (decl.important) {
   *   result.warn('Avoid !important', { node: decl, word: '!important' })
   * }
   * ```
   *
   * @param text Warning message.
   * @param opts Warning options.
   * @return Created warning.
   */
  warn(message: string, options?: WarningOptions): Warning

  /**
   * Returns warnings from plugins. Filters `Warning` instances
   * from `Result#messages`.
   *
   * ```js
   * result.warnings().forEach(warn => {
   *   console.warn(warn.toString())
   * })
   * ```
   *
   * @return Warnings from plugins.
   */
  warnings(): Warning[]
}

declare class Result<RootNode = Document | Root> extends Result_<RootNode> {}

export = Result

~~~

## node_modules\postcss\lib\result.js

~~~js
'use strict'

let Warning = require('./warning')

class Result {
  get content() {
    return this.css
  }

  constructor(processor, root, opts) {
    this.processor = processor
    this.messages = []
    this.root = root
    this.opts = opts
    this.css = ''
    this.map = undefined
  }

  toString() {
    return this.css
  }

  warn(text, opts = {}) {
    if (!opts.plugin) {
      if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
        opts.plugin = this.lastPlugin.postcssPlugin
      }
    }

    let warning = new Warning(text, opts)
    this.messages.push(warning)

    return warning
  }

  warnings() {
    return this.messages.filter(i => i.type === 'warning')
  }
}

module.exports = Result
Result.default = Result

~~~

## node_modules\postcss\lib\root.d.ts

~~~ts
import Container, { ContainerProps } from './container.js'
import Document from './document.js'
import { ProcessOptions } from './postcss.js'
import Result from './result.js'

declare namespace Root {
  export interface RootRaws extends Record<string, any> {
    /**
     * The space symbols after the last child to the end of file.
     */
    after?: string

    /**
     * Non-CSS code after `Root`, when `Root` is inside `Document`.
     *
     * **Experimental:** some aspects of this node could change within minor
     * or patch version releases.
     */
    codeAfter?: string

    /**
     * Non-CSS code before `Root`, when `Root` is inside `Document`.
     *
     * **Experimental:** some aspects of this node could change within minor
     * or patch version releases.
     */
    codeBefore?: string

    /**
     * Is the last child has an (optional) semicolon.
     */
    semicolon?: boolean
  }

  export interface RootProps extends ContainerProps {
    /**
     * Information used to generate byte-to-byte equal node string
     * as it was in the origin input.
     * */
    raws?: RootRaws
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Root_ as default }
}

/**
 * Represents a CSS file and contains all its parsed nodes.
 *
 * ```js
 * const root = postcss.parse('a{color:black} b{z-index:2}')
 * root.type         //=> 'root'
 * root.nodes.length //=> 2
 * ```
 */
declare class Root_ extends Container {
  nodes: NonNullable<Container['nodes']>
  parent: Document | undefined
  raws: Root.RootRaws
  type: 'root'

  constructor(defaults?: Root.RootProps)

  assign(overrides: object | Root.RootProps): this
  clone(overrides?: Partial<Root.RootProps>): this
  cloneAfter(overrides?: Partial<Root.RootProps>): this
  cloneBefore(overrides?: Partial<Root.RootProps>): this

  /**
   * Returns a `Result` instance representing the root?셲 CSS.
   *
   * ```js
   * const root1 = postcss.parse(css1, { from: 'a.css' })
   * const root2 = postcss.parse(css2, { from: 'b.css' })
   * root1.append(root2)
   * const result = root1.toResult({ to: 'all.css', map: true })
   * ```
   *
   * @param options Options.
   * @return Result with current root?셲 CSS.
   */
  toResult(options?: ProcessOptions): Result
}

declare class Root extends Root_ {}

export = Root

~~~

## node_modules\postcss\lib\root.js

~~~js
'use strict'

let Container = require('./container')

let LazyResult, Processor

class Root extends Container {
  constructor(defaults) {
    super(defaults)
    this.type = 'root'
    if (!this.nodes) this.nodes = []
  }

  normalize(child, sample, type) {
    let nodes = super.normalize(child)

    if (sample) {
      if (type === 'prepend') {
        if (this.nodes.length > 1) {
          sample.raws.before = this.nodes[1].raws.before
        } else {
          delete sample.raws.before
        }
      } else if (this.first !== sample) {
        for (let node of nodes) {
          node.raws.before = sample.raws.before
        }
      }
    }

    return nodes
  }

  removeChild(child, ignore) {
    let index = this.index(child)

    if (!ignore && index === 0 && this.nodes.length > 1) {
      this.nodes[1].raws.before = this.nodes[index].raws.before
    }

    return super.removeChild(child)
  }

  toResult(opts = {}) {
    let lazy = new LazyResult(new Processor(), this, opts)
    return lazy.stringify()
  }
}

Root.registerLazyResult = dependant => {
  LazyResult = dependant
}

Root.registerProcessor = dependant => {
  Processor = dependant
}

module.exports = Root
Root.default = Root

Container.registerRoot(Root)

~~~

## node_modules\postcss\lib\rule.d.ts

~~~ts
import Container, {
  ContainerProps,
  ContainerWithChildren
} from './container.js'

declare namespace Rule {
  export interface RuleRaws extends Record<string, unknown> {
    /**
     * The space symbols after the last child of the node to the end of the node.
     */
    after?: string

    /**
     * The space symbols before the node. It also stores `*`
     * and `_` symbols before the declaration (IE hack).
     */
    before?: string

    /**
     * The symbols between the selector and `{` for rules.
     */
    between?: string

    /**
     * Contains the text of the semicolon after this rule.
     */
    ownSemicolon?: string

    /**
     * The rule?셲 selector with comments.
     */
    selector?: {
      raw: string
      value: string
    }

    /**
     * Contains `true` if the last child has an (optional) semicolon.
     */
    semicolon?: boolean
  }

  export type RuleProps = {
    /** Information used to generate byte-to-byte equal node string as it was in the origin input. */
    raws?: RuleRaws
  } & (
      | {
          /** Selector or selectors of the rule. */
          selector: string
          selectors?: never
        }
      | {
          selector?: never
          /** Selectors of the rule represented as an array of strings. */
          selectors: readonly string[]
        }
    ) & ContainerProps

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Rule_ as default }
}

/**
 * Represents a CSS rule: a selector followed by a declaration block.
 *
 * ```js
 * Once (root, { Rule }) {
 *   let a = new Rule({ selector: 'a' })
 *   a.append(??
 *   root.append(a)
 * }
 * ```
 *
 * ```js
 * const root = postcss.parse('a{}')
 * const rule = root.first
 * rule.type       //=> 'rule'
 * rule.toString() //=> 'a{}'
 * ```
 */
declare class Rule_ extends Container {
  nodes: NonNullable<Container['nodes']>
  parent: ContainerWithChildren | undefined
  raws: Rule.RuleRaws
  type: 'rule'
  /**
   * The rule?셲 full selector represented as a string.
   *
   * ```js
   * const root = postcss.parse('a, b { }')
   * const rule = root.first
   * rule.selector //=> 'a, b'
   * ```
   */
  get selector(): string

  set selector(value: string)
  /**
   * An array containing the rule?셲 individual selectors.
   * Groups of selectors are split at commas.
   *
   * ```js
   * const root = postcss.parse('a, b { }')
   * const rule = root.first
   *
   * rule.selector  //=> 'a, b'
   * rule.selectors //=> ['a', 'b']
   *
   * rule.selectors = ['a', 'strong']
   * rule.selector //=> 'a, strong'
   * ```
   */
  get selectors(): string[]

  set selectors(values: string[])

  constructor(defaults?: Rule.RuleProps)
  assign(overrides: object | Rule.RuleProps): this
  clone(overrides?: Partial<Rule.RuleProps>): this
  cloneAfter(overrides?: Partial<Rule.RuleProps>): this
  cloneBefore(overrides?: Partial<Rule.RuleProps>): this
}

declare class Rule extends Rule_ {}

export = Rule

~~~

## node_modules\postcss\lib\rule.js

~~~js
'use strict'

let Container = require('./container')
let list = require('./list')

class Rule extends Container {
  get selectors() {
    return list.comma(this.selector)
  }

  set selectors(values) {
    let match = this.selector ? this.selector.match(/,\s*/) : null
    let sep = match ? match[0] : ',' + this.raw('between', 'beforeOpen')
    this.selector = values.join(sep)
  }

  constructor(defaults) {
    super(defaults)
    this.type = 'rule'
    if (!this.nodes) this.nodes = []
  }
}

module.exports = Rule
Rule.default = Rule

Container.registerRule(Rule)

~~~

## node_modules\postcss\lib\stringifier.d.ts

~~~ts
import {
  AnyNode,
  AtRule,
  Builder,
  Comment,
  Container,
  Declaration,
  Document,
  Root,
  Rule
} from './postcss.js'

declare namespace Stringifier {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Stringifier_ as default }
}

declare class Stringifier_ {
  builder: Builder
  constructor(builder: Builder)
  atrule(node: AtRule, semicolon?: boolean): void
  beforeAfter(node: AnyNode, detect: 'after' | 'before'): string
  block(node: AnyNode, start: string): void
  body(node: Container): void
  comment(node: Comment): void
  decl(node: Declaration, semicolon?: boolean): void
  document(node: Document): void
  raw(node: AnyNode, own: null | string, detect?: string): boolean | string
  rawBeforeClose(root: Root): string | undefined
  rawBeforeComment(root: Root, node: Comment): string | undefined
  rawBeforeDecl(root: Root, node: Declaration): string | undefined
  rawBeforeOpen(root: Root): string | undefined
  rawBeforeRule(root: Root): string | undefined
  rawColon(root: Root): string | undefined
  rawEmptyBody(root: Root): string | undefined
  rawIndent(root: Root): string | undefined
  rawSemicolon(root: Root): boolean | undefined
  rawValue(node: AnyNode, prop: string): number | string
  root(node: Root): void
  rule(node: Rule): void
  stringify(node: AnyNode, semicolon?: boolean): void
}

declare class Stringifier extends Stringifier_ {}

export = Stringifier

~~~

## node_modules\postcss\lib\stringifier.js

~~~js
'use strict'

const DEFAULT_RAW = {
  after: '\n',
  beforeClose: '\n',
  beforeComment: '\n',
  beforeDecl: '\n',
  beforeOpen: ' ',
  beforeRule: '\n',
  colon: ': ',
  commentLeft: ' ',
  commentRight: ' ',
  emptyBody: '',
  indent: '    ',
  semicolon: false
}

function capitalize(str) {
  return str[0].toUpperCase() + str.slice(1)
}

class Stringifier {
  constructor(builder) {
    this.builder = builder
  }

  atrule(node, semicolon) {
    let name = '@' + node.name
    let params = node.params ? this.rawValue(node, 'params') : ''

    if (typeof node.raws.afterName !== 'undefined') {
      name += node.raws.afterName
    } else if (params) {
      name += ' '
    }

    if (node.nodes) {
      this.block(node, name + params)
    } else {
      let end = (node.raws.between || '') + (semicolon ? ';' : '')
      this.builder(name + params + end, node)
    }
  }

  beforeAfter(node, detect) {
    let value
    if (node.type === 'decl') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (node.type === 'comment') {
      value = this.raw(node, null, 'beforeComment')
    } else if (detect === 'before') {
      value = this.raw(node, null, 'beforeRule')
    } else {
      value = this.raw(node, null, 'beforeClose')
    }

    let buf = node.parent
    let depth = 0
    while (buf && buf.type !== 'root') {
      depth += 1
      buf = buf.parent
    }

    if (value.includes('\n')) {
      let indent = this.raw(node, null, 'indent')
      if (indent.length) {
        for (let step = 0; step < depth; step++) value += indent
      }
    }

    return value
  }

  block(node, start) {
    let between = this.raw(node, 'between', 'beforeOpen')
    this.builder(start + between + '{', node, 'start')

    let after
    if (node.nodes && node.nodes.length) {
      this.body(node)
      after = this.raw(node, 'after')
    } else {
      after = this.raw(node, 'after', 'emptyBody')
    }

    if (after) this.builder(after)
    this.builder('}', node, 'end')
  }

  body(node) {
    let last = node.nodes.length - 1
    while (last > 0) {
      if (node.nodes[last].type !== 'comment') break
      last -= 1
    }

    let semicolon = this.raw(node, 'semicolon')
    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i]
      let before = this.raw(child, 'before')
      if (before) this.builder(before)
      this.stringify(child, last !== i || semicolon)
    }
  }

  comment(node) {
    let left = this.raw(node, 'left', 'commentLeft')
    let right = this.raw(node, 'right', 'commentRight')
    this.builder('/*' + left + node.text + right + '*/', node)
  }

  decl(node, semicolon) {
    let between = this.raw(node, 'between', 'colon')
    let string = node.prop + between + this.rawValue(node, 'value')

    if (node.important) {
      string += node.raws.important || ' !important'
    }

    if (semicolon) string += ';'
    this.builder(string, node)
  }

  document(node) {
    this.body(node)
  }

  raw(node, own, detect) {
    let value
    if (!detect) detect = own

    // Already had
    if (own) {
      value = node.raws[own]
      if (typeof value !== 'undefined') return value
    }

    let parent = node.parent

    if (detect === 'before') {
      // Hack for first rule in CSS
      if (!parent || (parent.type === 'root' && parent.first === node)) {
        return ''
      }

      // `root` nodes in `document` should use only their own raws
      if (parent && parent.type === 'document') {
        return ''
      }
    }

    // Floating child without parent
    if (!parent) return DEFAULT_RAW[detect]

    // Detect style by other nodes
    let root = node.root()
    if (!root.rawCache) root.rawCache = {}
    if (typeof root.rawCache[detect] !== 'undefined') {
      return root.rawCache[detect]
    }

    if (detect === 'before' || detect === 'after') {
      return this.beforeAfter(node, detect)
    } else {
      let method = 'raw' + capitalize(detect)
      if (this[method]) {
        value = this[method](root, node)
      } else {
        root.walk(i => {
          value = i.raws[own]
          if (typeof value !== 'undefined') return false
        })
      }
    }

    if (typeof value === 'undefined') value = DEFAULT_RAW[detect]

    root.rawCache[detect] = value
    return value
  }

  rawBeforeClose(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length > 0) {
        if (typeof i.raws.after !== 'undefined') {
          value = i.raws.after
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawBeforeComment(root, node) {
    let value
    root.walkComments(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeDecl')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeDecl(root, node) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.before !== 'undefined') {
        value = i.raws.before
        if (value.includes('\n')) {
          value = value.replace(/[^\n]+$/, '')
        }
        return false
      }
    })
    if (typeof value === 'undefined') {
      value = this.raw(node, null, 'beforeRule')
    } else if (value) {
      value = value.replace(/\S/g, '')
    }
    return value
  }

  rawBeforeOpen(root) {
    let value
    root.walk(i => {
      if (i.type !== 'decl') {
        value = i.raws.between
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawBeforeRule(root) {
    let value
    root.walk(i => {
      if (i.nodes && (i.parent !== root || root.first !== i)) {
        if (typeof i.raws.before !== 'undefined') {
          value = i.raws.before
          if (value.includes('\n')) {
            value = value.replace(/[^\n]+$/, '')
          }
          return false
        }
      }
    })
    if (value) value = value.replace(/\S/g, '')
    return value
  }

  rawColon(root) {
    let value
    root.walkDecls(i => {
      if (typeof i.raws.between !== 'undefined') {
        value = i.raws.between.replace(/[^\s:]/g, '')
        return false
      }
    })
    return value
  }

  rawEmptyBody(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length === 0) {
        value = i.raws.after
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawIndent(root) {
    if (root.raws.indent) return root.raws.indent
    let value
    root.walk(i => {
      let p = i.parent
      if (p && p !== root && p.parent && p.parent === root) {
        if (typeof i.raws.before !== 'undefined') {
          let parts = i.raws.before.split('\n')
          value = parts[parts.length - 1]
          value = value.replace(/\S/g, '')
          return false
        }
      }
    })
    return value
  }

  rawSemicolon(root) {
    let value
    root.walk(i => {
      if (i.nodes && i.nodes.length && i.last.type === 'decl') {
        value = i.raws.semicolon
        if (typeof value !== 'undefined') return false
      }
    })
    return value
  }

  rawValue(node, prop) {
    let value = node[prop]
    let raw = node.raws[prop]
    if (raw && raw.value === value) {
      return raw.raw
    }

    return value
  }

  root(node) {
    this.body(node)
    if (node.raws.after) this.builder(node.raws.after)
  }

  rule(node) {
    this.block(node, this.rawValue(node, 'selector'))
    if (node.raws.ownSemicolon) {
      this.builder(node.raws.ownSemicolon, node, 'end')
    }
  }

  stringify(node, semicolon) {
    /* c8 ignore start */
    if (!this[node.type]) {
      throw new Error(
        'Unknown AST node type ' +
          node.type +
          '. ' +
          'Maybe you need to change PostCSS stringifier.'
      )
    }
    /* c8 ignore stop */
    this[node.type](node, semicolon)
  }
}

module.exports = Stringifier
Stringifier.default = Stringifier

~~~

## node_modules\postcss\lib\stringify.d.ts

~~~ts
import { Stringifier } from './postcss.js'

interface Stringify extends Stringifier {
  default: Stringify
}

declare const stringify: Stringify

export = stringify

~~~

## node_modules\postcss\lib\stringify.js

~~~js
'use strict'

let Stringifier = require('./stringifier')

function stringify(node, builder) {
  let str = new Stringifier(builder)
  str.stringify(node)
}

module.exports = stringify
stringify.default = stringify

~~~

## node_modules\postcss\lib\symbols.js

~~~js
'use strict'

module.exports.isClean = Symbol('isClean')

module.exports.my = Symbol('my')

~~~

## node_modules\postcss\lib\terminal-highlight.js

~~~js
'use strict'

let pico = require('picocolors')

let tokenizer = require('./tokenize')

let Input

function registerInput(dependant) {
  Input = dependant
}

const HIGHLIGHT_THEME = {
  ';': pico.yellow,
  ':': pico.yellow,
  '(': pico.cyan,
  ')': pico.cyan,
  '[': pico.yellow,
  ']': pico.yellow,
  '{': pico.yellow,
  '}': pico.yellow,
  'at-word': pico.cyan,
  'brackets': pico.cyan,
  'call': pico.cyan,
  'class': pico.yellow,
  'comment': pico.gray,
  'hash': pico.magenta,
  'string': pico.green
}

function getTokenType([type, value], processor) {
  if (type === 'word') {
    if (value[0] === '.') {
      return 'class'
    }
    if (value[0] === '#') {
      return 'hash'
    }
  }

  if (!processor.endOfFile()) {
    let next = processor.nextToken()
    processor.back(next)
    if (next[0] === 'brackets' || next[0] === '(') return 'call'
  }

  return type
}

function terminalHighlight(css) {
  let processor = tokenizer(new Input(css), { ignoreErrors: true })
  let result = ''
  while (!processor.endOfFile()) {
    let token = processor.nextToken()
    let color = HIGHLIGHT_THEME[getTokenType(token, processor)]
    if (color) {
      result += token[1]
        .split(/\r?\n/)
        .map(i => color(i))
        .join('\n')
    } else {
      result += token[1]
    }
  }
  return result
}

terminalHighlight.registerInput = registerInput

module.exports = terminalHighlight

~~~

## node_modules\postcss\lib\tokenize.js

~~~js
'use strict'

const SINGLE_QUOTE = "'".charCodeAt(0)
const DOUBLE_QUOTE = '"'.charCodeAt(0)
const BACKSLASH = '\\'.charCodeAt(0)
const SLASH = '/'.charCodeAt(0)
const NEWLINE = '\n'.charCodeAt(0)
const SPACE = ' '.charCodeAt(0)
const FEED = '\f'.charCodeAt(0)
const TAB = '\t'.charCodeAt(0)
const CR = '\r'.charCodeAt(0)
const OPEN_SQUARE = '['.charCodeAt(0)
const CLOSE_SQUARE = ']'.charCodeAt(0)
const OPEN_PARENTHESES = '('.charCodeAt(0)
const CLOSE_PARENTHESES = ')'.charCodeAt(0)
const OPEN_CURLY = '{'.charCodeAt(0)
const CLOSE_CURLY = '}'.charCodeAt(0)
const SEMICOLON = ';'.charCodeAt(0)
const ASTERISK = '*'.charCodeAt(0)
const COLON = ':'.charCodeAt(0)
const AT = '@'.charCodeAt(0)

const RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g
const RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g
const RE_BAD_BRACKET = /.[\r\n"'(/\\]/
const RE_HEX_ESCAPE = /[\da-f]/i

module.exports = function tokenizer(input, options = {}) {
  let css = input.css.valueOf()
  let ignore = options.ignoreErrors

  let code, content, escape, next, quote
  let currentToken, escaped, escapePos, n, prev

  let length = css.length
  let pos = 0
  let buffer = []
  let returned = []

  function position() {
    return pos
  }

  function unclosed(what) {
    throw input.error('Unclosed ' + what, pos)
  }

  function endOfFile() {
    return returned.length === 0 && pos >= length
  }

  function nextToken(opts) {
    if (returned.length) return returned.pop()
    if (pos >= length) return

    let ignoreUnclosed = opts ? opts.ignoreUnclosed : false

    code = css.charCodeAt(pos)

    switch (code) {
      case NEWLINE:
      case SPACE:
      case TAB:
      case CR:
      case FEED: {
        next = pos
        do {
          next += 1
          code = css.charCodeAt(next)
        } while (
          code === SPACE ||
          code === NEWLINE ||
          code === TAB ||
          code === CR ||
          code === FEED
        )

        currentToken = ['space', css.slice(pos, next)]
        pos = next - 1
        break
      }

      case OPEN_SQUARE:
      case CLOSE_SQUARE:
      case OPEN_CURLY:
      case CLOSE_CURLY:
      case COLON:
      case SEMICOLON:
      case CLOSE_PARENTHESES: {
        let controlChar = String.fromCharCode(code)
        currentToken = [controlChar, controlChar, pos]
        break
      }

      case OPEN_PARENTHESES: {
        prev = buffer.length ? buffer.pop()[1] : ''
        n = css.charCodeAt(pos + 1)
        if (
          prev === 'url' &&
          n !== SINGLE_QUOTE &&
          n !== DOUBLE_QUOTE &&
          n !== SPACE &&
          n !== NEWLINE &&
          n !== TAB &&
          n !== FEED &&
          n !== CR
        ) {
          next = pos
          do {
            escaped = false
            next = css.indexOf(')', next + 1)
            if (next === -1) {
              if (ignore || ignoreUnclosed) {
                next = pos
                break
              } else {
                unclosed('bracket')
              }
            }
            escapePos = next
            while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
              escapePos -= 1
              escaped = !escaped
            }
          } while (escaped)

          currentToken = ['brackets', css.slice(pos, next + 1), pos, next]

          pos = next
        } else {
          next = css.indexOf(')', pos + 1)
          content = css.slice(pos, next + 1)

          if (next === -1 || RE_BAD_BRACKET.test(content)) {
            currentToken = ['(', '(', pos]
          } else {
            currentToken = ['brackets', content, pos, next]
            pos = next
          }
        }

        break
      }

      case SINGLE_QUOTE:
      case DOUBLE_QUOTE: {
        quote = code === SINGLE_QUOTE ? "'" : '"'
        next = pos
        do {
          escaped = false
          next = css.indexOf(quote, next + 1)
          if (next === -1) {
            if (ignore || ignoreUnclosed) {
              next = pos + 1
              break
            } else {
              unclosed('string')
            }
          }
          escapePos = next
          while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
            escapePos -= 1
            escaped = !escaped
          }
        } while (escaped)

        currentToken = ['string', css.slice(pos, next + 1), pos, next]
        pos = next
        break
      }

      case AT: {
        RE_AT_END.lastIndex = pos + 1
        RE_AT_END.test(css)
        if (RE_AT_END.lastIndex === 0) {
          next = css.length - 1
        } else {
          next = RE_AT_END.lastIndex - 2
        }

        currentToken = ['at-word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      case BACKSLASH: {
        next = pos
        escape = true
        while (css.charCodeAt(next + 1) === BACKSLASH) {
          next += 1
          escape = !escape
        }
        code = css.charCodeAt(next + 1)
        if (
          escape &&
          code !== SLASH &&
          code !== SPACE &&
          code !== NEWLINE &&
          code !== TAB &&
          code !== CR &&
          code !== FEED
        ) {
          next += 1
          if (RE_HEX_ESCAPE.test(css.charAt(next))) {
            while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
              next += 1
            }
            if (css.charCodeAt(next + 1) === SPACE) {
              next += 1
            }
          }
        }

        currentToken = ['word', css.slice(pos, next + 1), pos, next]

        pos = next
        break
      }

      default: {
        if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {
          next = css.indexOf('*/', pos + 2) + 1
          if (next === 0) {
            if (ignore || ignoreUnclosed) {
              next = css.length
            } else {
              unclosed('comment')
            }
          }

          currentToken = ['comment', css.slice(pos, next + 1), pos, next]
          pos = next
        } else {
          RE_WORD_END.lastIndex = pos + 1
          RE_WORD_END.test(css)
          if (RE_WORD_END.lastIndex === 0) {
            next = css.length - 1
          } else {
            next = RE_WORD_END.lastIndex - 2
          }

          currentToken = ['word', css.slice(pos, next + 1), pos, next]
          buffer.push(currentToken)
          pos = next
        }

        break
      }
    }

    pos++
    return currentToken
  }

  function back(token) {
    returned.push(token)
  }

  return {
    back,
    endOfFile,
    nextToken,
    position
  }
}

~~~

## node_modules\postcss\lib\warning.d.ts

~~~ts
import { RangePosition } from './css-syntax-error.js'
import Node from './node.js'

declare namespace Warning {
  export interface WarningOptions {
    /**
     * End position, exclusive, in CSS node string that caused the warning.
     */
    end?: RangePosition

    /**
     * End index, exclusive, in CSS node string that caused the warning.
     */
    endIndex?: number

    /**
     * Start index, inclusive, in CSS node string that caused the warning.
     */
    index?: number

    /**
     * CSS node that caused the warning.
     */
    node?: Node

    /**
     * Name of the plugin that created this warning. `Result#warn` fills
     * this property automatically.
     */
    plugin?: string

    /**
     * Start position, inclusive, in CSS node string that caused the warning.
     */
    start?: RangePosition

    /**
     * Word in CSS source that caused the warning.
     */
    word?: string
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Warning_ as default }
}

/**
 * Represents a plugin?셲 warning. It can be created using `Node#warn`.
 *
 * ```js
 * if (decl.important) {
 *   decl.warn(result, 'Avoid !important', { word: '!important' })
 * }
 * ```
 */
declare class Warning_ {
  /**
   * Column for inclusive start position in the input file with this warning?셲 source.
   *
   * ```js
   * warning.column //=> 6
   * ```
   */
  column: number

  /**
   * Column for exclusive end position in the input file with this warning?셲 source.
   *
   * ```js
   * warning.endColumn //=> 4
   * ```
   */
  endColumn?: number

  /**
   * Line for exclusive end position in the input file with this warning?셲 source.
   *
   * ```js
   * warning.endLine //=> 6
   * ```
   */
  endLine?: number

  /**
   * Line for inclusive start position in the input file with this warning?셲 source.
   *
   * ```js
   * warning.line //=> 5
   * ```
   */
  line: number

  /**
   * Contains the CSS node that caused the warning.
   *
   * ```js
   * warning.node.toString() //=> 'color: white !important'
   * ```
   */
  node: Node

  /**
   * The name of the plugin that created this warning.
   * When you call `Node#warn` it will fill this property automatically.
   *
   * ```js
   * warning.plugin //=> 'postcss-important'
   * ```
   */
  plugin: string

  /**
   * The warning message.
   *
   * ```js
   * warning.text //=> 'Try to avoid !important'
   * ```
   */
  text: string

  /**
   * Type to filter warnings from `Result#messages`.
   * Always equal to `"warning"`.
   */
  type: 'warning'

  /**
   * @param text Warning message.
   * @param opts Warning options.
   */
  constructor(text: string, opts?: Warning.WarningOptions)

  /**
   * Returns a warning position and message.
   *
   * ```js
   * warning.toString() //=> 'postcss-lint:a.css:10:14: Avoid !important'
   * ```
   *
   * @return Warning position and message.
   */
  toString(): string
}

declare class Warning extends Warning_ {}

export = Warning

~~~

## node_modules\postcss\lib\warning.js

~~~js
'use strict'

class Warning {
  constructor(text, opts = {}) {
    this.type = 'warning'
    this.text = text

    if (opts.node && opts.node.source) {
      let range = opts.node.rangeBy(opts)
      this.line = range.start.line
      this.column = range.start.column
      this.endLine = range.end.line
      this.endColumn = range.end.column
    }

    for (let opt in opts) this[opt] = opts[opt]
  }

  toString() {
    if (this.node) {
      return this.node.error(this.text, {
        index: this.index,
        plugin: this.plugin,
        word: this.word
      }).message
    }

    if (this.plugin) {
      return this.plugin + ': ' + this.text
    }

    return this.text
  }
}

module.exports = Warning
Warning.default = Warning

~~~

## node_modules\postcss\lib\warn-once.js

~~~js
/* eslint-disable no-console */
'use strict'

let printed = {}

module.exports = function warnOnce(message) {
  if (printed[message]) return
  printed[message] = true

  if (typeof console !== 'undefined' && console.warn) {
    console.warn(message)
  }
}

~~~

## node_modules\postcss\LICENSE

~~~text
The MIT License (MIT)

Copyright 2013 Andrey Sitnik <andrey@sitnik.ru>

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

~~~

## node_modules\postcss\package.json

~~~json
{
  "name": "postcss",
  "version": "8.5.6",
  "description": "Tool for transforming styles with JS plugins",
  "engines": {
    "node": "^10 || ^12 || >=14"
  },
  "exports": {
    ".": {
      "import": "./lib/postcss.mjs",
      "require": "./lib/postcss.js"
    },
    "./lib/at-rule": "./lib/at-rule.js",
    "./lib/comment": "./lib/comment.js",
    "./lib/container": "./lib/container.js",
    "./lib/css-syntax-error": "./lib/css-syntax-error.js",
    "./lib/declaration": "./lib/declaration.js",
    "./lib/fromJSON": "./lib/fromJSON.js",
    "./lib/input": "./lib/input.js",
    "./lib/lazy-result": "./lib/lazy-result.js",
    "./lib/no-work-result": "./lib/no-work-result.js",
    "./lib/list": "./lib/list.js",
    "./lib/map-generator": "./lib/map-generator.js",
    "./lib/node": "./lib/node.js",
    "./lib/parse": "./lib/parse.js",
    "./lib/parser": "./lib/parser.js",
    "./lib/postcss": "./lib/postcss.js",
    "./lib/previous-map": "./lib/previous-map.js",
    "./lib/processor": "./lib/processor.js",
    "./lib/result": "./lib/result.js",
    "./lib/root": "./lib/root.js",
    "./lib/rule": "./lib/rule.js",
    "./lib/stringifier": "./lib/stringifier.js",
    "./lib/stringify": "./lib/stringify.js",
    "./lib/symbols": "./lib/symbols.js",
    "./lib/terminal-highlight": "./lib/terminal-highlight.js",
    "./lib/tokenize": "./lib/tokenize.js",
    "./lib/warn-once": "./lib/warn-once.js",
    "./lib/warning": "./lib/warning.js",
    "./package.json": "./package.json"
  },
  "main": "./lib/postcss.js",
  "types": "./lib/postcss.d.ts",
  "keywords": [
    "css",
    "postcss",
    "rework",
    "preprocessor",
    "parser",
    "source map",
    "transform",
    "manipulation",
    "transpiler"
  ],
  "funding": [
    {
      "type": "opencollective",
      "url": "https://opencollective.com/postcss/"
    },
    {
      "type": "tidelift",
      "url": "https://tidelift.com/funding/github/npm/postcss"
    },
    {
      "type": "github",
      "url": "https://github.com/sponsors/ai"
    }
  ],
  "author": "Andrey Sitnik <andrey@sitnik.ru>",
  "license": "MIT",
  "homepage": "https://postcss.org/",
  "repository": "postcss/postcss",
  "bugs": {
    "url": "https://github.com/postcss/postcss/issues"
  },
  "dependencies": {
    "nanoid": "^3.3.11",
    "picocolors": "^1.1.1",
    "source-map-js": "^1.2.1"
  },
  "browser": {
    "./lib/terminal-highlight": false,
    "source-map-js": false,
    "path": false,
    "url": false,
    "fs": false
  }
}

~~~

## node_modules\postcss\README.md

~~~md
# PostCSS

<img align="right" width="95" height="95"
     alt="Philosopher?셲 stone, logo of PostCSS"
     src="https://postcss.org/logo.svg">

PostCSS is a tool for transforming styles with JS plugins.
These plugins can lint your CSS, support혻variables혻and혻mixins,
transpile혻future혻CSS혻syntax, inline혻images, and혻more.

PostCSS is used by industry leaders including Wikipedia, Twitter, Alibaba,
and JetBrains. The혻[Autoprefixer] and [Stylelint]혻PostCSS plugins혻are some혻of혻the혻most popular CSS tools.

---

<img src="https://cdn.evilmartians.com/badges/logo-no-label.svg" alt="" width="22" height="16" />혻혻Built by
 <b><a href="https://evilmartians.com/devtools?utm_source=postcss&utm_campaign=devtools-button&utm_medium=github">Evil Martians</a></b>, go-to agency for <b>developer tools</b>.

---

[Abstract혻Syntax혻Tree]: https://en.wikipedia.org/wiki/Abstract_syntax_tree
[Evil혻Martians]:        https://evilmartians.com/?utm_source=postcss
[Autoprefixer]:         https://github.com/postcss/autoprefixer
[Stylelint]:            https://stylelint.io/
[plugins]:              https://github.com/postcss/postcss#plugins


## Docs
Read full docs **[here](https://postcss.org/)**.

~~~

## node_modules\react\cjs\react.development.js

~~~js
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {

          'use strict';

/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
if (
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
    'function'
) {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
}
          var ReactVersion = '18.3.1';

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

/**
 * Keeps track of the current dispatcher.
 */
var ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

/**
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
 */
var ReactCurrentBatchConfig = {
  transition: null
};

var ReactCurrentActQueue = {
  current: null,
  // Used to reproduce behavior of `batchedUpdates` in legacy mode.
  isBatchingLegacy: false,
  didScheduleLegacyUpdate: false
};

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

var ReactDebugCurrentFrame = {};
var currentExtraStackFrame = null;
function setExtraStackFrame(stack) {
  {
    currentExtraStackFrame = stack;
  }
}

{
  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
    {
      currentExtraStackFrame = stack;
    }
  }; // Stack implementation injected by the current renderer.


  ReactDebugCurrentFrame.getCurrentStack = null;

  ReactDebugCurrentFrame.getStackAddendum = function () {
    var stack = ''; // Add an extra top frame while an element is being validated

    if (currentExtraStackFrame) {
      stack += currentExtraStackFrame;
    } // Delegate to the injected renderer-specific implementation


    var impl = ReactDebugCurrentFrame.getCurrentStack;

    if (impl) {
      stack += impl() || '';
    }

    return stack;
  };
}

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var ReactSharedInternals = {
  ReactCurrentDispatcher: ReactCurrentDispatcher,
  ReactCurrentBatchConfig: ReactCurrentBatchConfig,
  ReactCurrentOwner: ReactCurrentOwner
};

{
  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
  ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
}

// by calls to these methods by a Babel plugin.
//
// In PROD (or in packages without access to React internals),
// they are left as they are instead.

function warn(format) {
  {
    {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      printWarning('warn', format, args);
    }
  }
}
function error(format) {
  {
    {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      printWarning('error', format, args);
    }
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    } // eslint-disable-next-line react-internal/safe-string-coercion


    var argsWithFormat = args.map(function (item) {
      return String(item);
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

var didWarnStateUpdateForUnmountedComponent = {};

function warnNoop(publicInstance, callerName) {
  {
    var _constructor = publicInstance.constructor;
    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
    var warningKey = componentName + "." + callerName;

    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
      return;
    }

    error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

    didWarnStateUpdateForUnmountedComponent[warningKey] = true;
  }
}
/**
 * This is the abstract API for an update queue.
 */


var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState, callback, callerName) {
    warnNoop(publicInstance, 'setState');
  }
};

var assign = Object.assign;

var emptyObject = {};

{
  Object.freeze(emptyObject);
}
/**
 * Base class helpers for the updating state of a component.
 */


function Component(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
  // renderer.

  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */

Component.prototype.setState = function (partialState, callback) {
  if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
    throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
  }

  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */


Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
};
/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */


{
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };

  var defineDeprecationWarning = function (methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

        return undefined;
      }
    });
  };

  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;
/**
 * Convenience component with default shallow equality check for sCU.
 */

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context; // If a component has string refs, we will assign a different object later.

  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = true;

// an immutable object with a single mutable value
function createRef() {
  var refObject = {
    current: null
  };

  {
    Object.seal(refObject);
  }

  return refObject;
}

var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */
// $FlowFixMe only called in DEV, so void return is not possible.
function typeName(value) {
  {
    // toStringTag is needed for namespaced types like Temporal.Instant
    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
    return type;
  }
} // $FlowFixMe only called in DEV, so void return is not possible.


function willCoercionThrow(value) {
  {
    try {
      testStringCoercion(value);
      return false;
    } catch (e) {
      return true;
    }
  }
}

function testStringCoercion(value) {
  // If you ended up here by following an exception call stack, here's what's
  // happened: you supplied an object or symbol value to React (as a prop, key,
  // DOM attribute, CSS property, string ref, etc.) and when React tried to
  // coerce it to a string using `'' + value`, an exception was thrown.
  //
  // The most common types that will cause this exception are `Symbol` instances
  // and Temporal objects like `Temporal.Instant`. But any object that has a
  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
  // exception. (Library authors do this to prevent users from using built-in
  // numeric operators like `+` or comparison operators like `>=` because custom
  // methods are needed to perform accurate arithmetic or comparison.)
  //
  // To fix the problem, coerce this object or symbol value to a string before
  // passing it to React. The most reliable way is usually `String(value)`.
  //
  // To find which value is throwing, check the browser or debugger console.
  // Before this exception was thrown, there should be `console.error` output
  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
  // problem and how that type was used: key, atrribute, input value prop, etc.
  // In most cases, this console output also shows the component and its
  // ancestor components where the exception happened.
  //
  // eslint-disable-next-line react-internal/safe-string-coercion
  return '' + value;
}
function checkKeyStringCoercion(value) {
  {
    if (willCoercionThrow(value)) {
      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
    }
  }
}

function getWrappedName(outerType, innerType, wrapperName) {
  var displayName = outerType.displayName;

  if (displayName) {
    return displayName;
  }

  var functionName = innerType.displayName || innerType.name || '';
  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
} // Keep in sync with react-reconciler/getComponentNameFromFiber


function getContextName(type) {
  return type.displayName || 'Context';
} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


function getComponentNameFromType(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';

  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        var outerName = type.displayName || null;

        if (outerName !== null) {
          return outerName;
        }

        return getComponentNameFromType(type.type) || 'Memo';

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentNameFromType(init(payload));
          } catch (x) {
            return null;
          }
        }

      // eslint-disable-next-line no-fallthrough
    }
  }

  return null;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    }
  };

  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

function warnIfStringRefCannotBeAutoConverted(config) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 */

function createElement(type, config, children) {
  var propName; // Reserved names are extracted

  var props = {};
  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;

      {
        warnIfStringRefCannotBeAutoConverted(config);
      }
    }

    if (hasValidKey(config)) {
      {
        checkKeyStringCoercion(config.key);
      }

      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }

    props.children = childArray;
  } // Resolve default props


  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;

    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }

  {
    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }
  }

  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
}
function cloneAndReplaceKey(oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
  return newElement;
}
/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://reactjs.org/docs/react-api.html#cloneelement
 */

function cloneElement(element, config, children) {
  if (element === null || element === undefined) {
    throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
  }

  var propName; // Original props are copied

  var props = assign({}, element.props); // Reserved names are extracted

  var key = element.key;
  var ref = element.ref; // Self is preserved since the owner is preserved.

  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.

  var source = element._source; // Owner will be preserved, unless ref is overridden

  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }

    if (hasValidKey(config)) {
      {
        checkKeyStringCoercion(config.key);
      }

      key = '' + config.key;
    } // Remaining properties override existing props


    var defaultProps;

    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }

    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  } // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.


  var childrenLength = arguments.length - 2;

  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);

    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */

function isValidElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}

var SEPARATOR = '.';
var SUBSEPARATOR = ':';
/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = key.replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });
  return '$' + escapedString;
}
/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */


var didWarnAboutMaps = false;
var userProvidedKeyEscapeRegex = /\/+/g;

function escapeUserProvidedKey(text) {
  return text.replace(userProvidedKeyEscapeRegex, '$&/');
}
/**
 * Generate a key string that identifies a element within a set.
 *
 * @param {*} element A element that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */


function getElementKey(element, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (typeof element === 'object' && element !== null && element.key != null) {
    // Explicit key
    {
      checkKeyStringCoercion(element.key);
    }

    return escape('' + element.key);
  } // Implicit key determined by the index in the set


  return index.toString(36);
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  var invokeCallback = false;

  if (children === null) {
    invokeCallback = true;
  } else {
    switch (type) {
      case 'string':
      case 'number':
        invokeCallback = true;
        break;

      case 'object':
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = true;
        }

    }
  }

  if (invokeCallback) {
    var _child = children;
    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows:

    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

    if (isArray(mappedChild)) {
      var escapedChildKey = '';

      if (childKey != null) {
        escapedChildKey = escapeUserProvidedKey(childKey) + '/';
      }

      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
        return c;
      });
    } else if (mappedChild != null) {
      if (isValidElement(mappedChild)) {
        {
          // The `if` statement here prevents auto-disabling of the safe
          // coercion ESLint rule, so we must manually disable it below.
          // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
          if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
            checkKeyStringCoercion(mappedChild.key);
          }
        }

        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
        // traverseAllChildren used to do for objects as children
        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
        // eslint-disable-next-line react-internal/safe-string-coercion
        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
      }

      array.push(mappedChild);
    }

    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.

  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getElementKey(child, i);
      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
    }
  } else {
    var iteratorFn = getIteratorFn(children);

    if (typeof iteratorFn === 'function') {
      var iterableChildren = children;

      {
        // Warn about using Maps as children
        if (iteratorFn === iterableChildren.entries) {
          if (!didWarnAboutMaps) {
            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
          }

          didWarnAboutMaps = true;
        }
      }

      var iterator = iteratorFn.call(iterableChildren);
      var step;
      var ii = 0;

      while (!(step = iterator.next()).done) {
        child = step.value;
        nextName = nextNamePrefix + getElementKey(child, ii++);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else if (type === 'object') {
      // eslint-disable-next-line react-internal/safe-string-coercion
      var childrenString = String(children);
      throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
    }
  }

  return subtreeCount;
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenmap
 *
 * The provided mapFunction(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }

  var result = [];
  var count = 0;
  mapIntoArray(children, result, '', '', function (child) {
    return func.call(context, child, count++);
  });
  return result;
}
/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrencount
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */


function countChildren(children) {
  var n = 0;
  mapChildren(children, function () {
    n++; // Don't return anything
  });
  return n;
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  mapChildren(children, function () {
    forEachFunc.apply(this, arguments); // Don't return anything.
  }, forEachContext);
}
/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
 */


function toArray(children) {
  return mapChildren(children, function (child) {
    return child;
  }) || [];
}
/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */


function onlyChild(children) {
  if (!isValidElement(children)) {
    throw new Error('React.Children.only expected to receive a single React element child.');
  }

  return children;
}

function createContext(defaultValue) {
  // TODO: Second argument used to be an optional `calculateChangedBits`
  // function. Warn to reserve for future use?
  var context = {
    $$typeof: REACT_CONTEXT_TYPE,
    // As a workaround to support multiple concurrent renderers, we categorize
    // some renderers as primary and others as secondary. We only expect
    // there to be two concurrent renderers at most: React Native (primary) and
    // Fabric (secondary); React DOM (primary) and React ART (secondary).
    // Secondary renderers store their context values on separate fields.
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    // Used to track how many concurrent renderers this context currently
    // supports within in a single renderer. Such as parallel server rendering.
    _threadCount: 0,
    // These are circular
    Provider: null,
    Consumer: null,
    // Add these to use same hidden class in VM as ServerContext
    _defaultValue: null,
    _globalName: null
  };
  context.Provider = {
    $$typeof: REACT_PROVIDER_TYPE,
    _context: context
  };
  var hasWarnedAboutUsingNestedContextConsumers = false;
  var hasWarnedAboutUsingConsumerProvider = false;
  var hasWarnedAboutDisplayNameOnConsumer = false;

  {
    // A separate object, but proxies back to the original context object for
    // backwards compatibility. It has a different $$typeof, so we can properly
    // warn for the incorrect usage of Context as a Consumer.
    var Consumer = {
      $$typeof: REACT_CONTEXT_TYPE,
      _context: context
    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

    Object.defineProperties(Consumer, {
      Provider: {
        get: function () {
          if (!hasWarnedAboutUsingConsumerProvider) {
            hasWarnedAboutUsingConsumerProvider = true;

            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
          }

          return context.Provider;
        },
        set: function (_Provider) {
          context.Provider = _Provider;
        }
      },
      _currentValue: {
        get: function () {
          return context._currentValue;
        },
        set: function (_currentValue) {
          context._currentValue = _currentValue;
        }
      },
      _currentValue2: {
        get: function () {
          return context._currentValue2;
        },
        set: function (_currentValue2) {
          context._currentValue2 = _currentValue2;
        }
      },
      _threadCount: {
        get: function () {
          return context._threadCount;
        },
        set: function (_threadCount) {
          context._threadCount = _threadCount;
        }
      },
      Consumer: {
        get: function () {
          if (!hasWarnedAboutUsingNestedContextConsumers) {
            hasWarnedAboutUsingNestedContextConsumers = true;

            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
          }

          return context.Consumer;
        }
      },
      displayName: {
        get: function () {
          return context.displayName;
        },
        set: function (displayName) {
          if (!hasWarnedAboutDisplayNameOnConsumer) {
            warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

            hasWarnedAboutDisplayNameOnConsumer = true;
          }
        }
      }
    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

    context.Consumer = Consumer;
  }

  {
    context._currentRenderer = null;
    context._currentRenderer2 = null;
  }

  return context;
}

var Uninitialized = -1;
var Pending = 0;
var Resolved = 1;
var Rejected = 2;

function lazyInitializer(payload) {
  if (payload._status === Uninitialized) {
    var ctor = payload._result;
    var thenable = ctor(); // Transition to the next state.
    // This might throw either because it's missing or throws. If so, we treat it
    // as still uninitialized and try again next time. Which is the same as what
    // happens if the ctor or any wrappers processing the ctor throws. This might
    // end up fixing it if the resolution was a concurrency bug.

    thenable.then(function (moduleObject) {
      if (payload._status === Pending || payload._status === Uninitialized) {
        // Transition to the next state.
        var resolved = payload;
        resolved._status = Resolved;
        resolved._result = moduleObject;
      }
    }, function (error) {
      if (payload._status === Pending || payload._status === Uninitialized) {
        // Transition to the next state.
        var rejected = payload;
        rejected._status = Rejected;
        rejected._result = error;
      }
    });

    if (payload._status === Uninitialized) {
      // In case, we're still uninitialized, then we're waiting for the thenable
      // to resolve. Set it as pending in the meantime.
      var pending = payload;
      pending._status = Pending;
      pending._result = thenable;
    }
  }

  if (payload._status === Resolved) {
    var moduleObject = payload._result;

    {
      if (moduleObject === undefined) {
        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
        'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
      }
    }

    {
      if (!('default' in moduleObject)) {
        error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
        'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
      }
    }

    return moduleObject.default;
  } else {
    throw payload._result;
  }
}

function lazy(ctor) {
  var payload = {
    // We use these fields to store the result.
    _status: Uninitialized,
    _result: ctor
  };
  var lazyType = {
    $$typeof: REACT_LAZY_TYPE,
    _payload: payload,
    _init: lazyInitializer
  };

  {
    // In production, this would just set it on the object.
    var defaultProps;
    var propTypes; // $FlowFixMe

    Object.defineProperties(lazyType, {
      defaultProps: {
        configurable: true,
        get: function () {
          return defaultProps;
        },
        set: function (newDefaultProps) {
          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          defaultProps = newDefaultProps; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'defaultProps', {
            enumerable: true
          });
        }
      },
      propTypes: {
        configurable: true,
        get: function () {
          return propTypes;
        },
        set: function (newPropTypes) {
          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

          propTypes = newPropTypes; // Match production behavior more closely:
          // $FlowFixMe

          Object.defineProperty(lazyType, 'propTypes', {
            enumerable: true
          });
        }
      }
    });
  }

  return lazyType;
}

function forwardRef(render) {
  {
    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
    } else if (typeof render !== 'function') {
      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
    } else {
      if (render.length !== 0 && render.length !== 2) {
        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
      }
    }

    if (render != null) {
      if (render.defaultProps != null || render.propTypes != null) {
        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
      }
    }
  }

  var elementType = {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name; // The inner component shouldn't inherit this display name in most cases,
        // because the component may be used elsewhere.
        // But it's nice for anonymous functions to inherit the name,
        // so that our component-stack generation logic will display their frames.
        // An anonymous function generally suggests a pattern like:
        //   React.forwardRef((props, ref) => {...});
        // This kind of inner function is not used elsewhere so the side effect is okay.

        if (!render.name && !render.displayName) {
          render.displayName = name;
        }
      }
    });
  }

  return elementType;
}

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function memo(type, compare) {
  {
    if (!isValidElementType(type)) {
      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
    }
  }

  var elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: compare === undefined ? null : compare
  };

  {
    var ownName;
    Object.defineProperty(elementType, 'displayName', {
      enumerable: false,
      configurable: true,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name; // The inner component shouldn't inherit this display name in most cases,
        // because the component may be used elsewhere.
        // But it's nice for anonymous functions to inherit the name,
        // so that our component-stack generation logic will display their frames.
        // An anonymous function generally suggests a pattern like:
        //   React.memo((props) => {...});
        // This kind of inner function is not used elsewhere so the side effect is okay.

        if (!type.name && !type.displayName) {
          type.displayName = name;
        }
      }
    });
  }

  return elementType;
}

function resolveDispatcher() {
  var dispatcher = ReactCurrentDispatcher.current;

  {
    if (dispatcher === null) {
      error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
    }
  } // Will result in a null access error if accessed outside render phase. We
  // intentionally don't throw our own error because this is in a hot path.
  // Also helps ensure this is inlined.


  return dispatcher;
}
function useContext(Context) {
  var dispatcher = resolveDispatcher();

  {
    // TODO: add a more generic warning for invalid values.
    if (Context._context !== undefined) {
      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
      // and nobody should be using this in existing code.

      if (realContext.Consumer === Context) {
        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
      } else if (realContext.Provider === Context) {
        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
      }
    }
  }

  return dispatcher.useContext(Context);
}
function useState(initialState) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}
function useReducer(reducer, initialArg, init) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useReducer(reducer, initialArg, init);
}
function useRef(initialValue) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialValue);
}
function useEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}
function useInsertionEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useInsertionEffect(create, deps);
}
function useLayoutEffect(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useLayoutEffect(create, deps);
}
function useCallback(callback, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useCallback(callback, deps);
}
function useMemo(create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useMemo(create, deps);
}
function useImperativeHandle(ref, create, deps) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}
function useDebugValue(value, formatterFn) {
  {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDebugValue(value, formatterFn);
  }
}
function useTransition() {
  var dispatcher = resolveDispatcher();
  return dispatcher.useTransition();
}
function useDeferredValue(value) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useDeferredValue(value);
}
function useId() {
  var dispatcher = resolveDispatcher();
  return dispatcher.useId();
}
function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
  var dispatcher = resolveDispatcher();
  return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
}

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if ( !fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher$1.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                // but we have a user-provided "displayName"
                // splice it in to make the stack more readable.


                if (fn.displayName && _frame.includes('<anonymous>')) {
                  _frame = _frame.replace('<anonymous>', fn.displayName);
                }

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher$1.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var loggedTypeFailures = {};
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            // eslint-disable-next-line react-internal/prod-error-codes
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      setExtraStackFrame(stack);
    } else {
      setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = getComponentNameFromType(ReactCurrentOwner.current.type);

    if (name) {
      return '\n\nCheck the render method of `' + name + '`.';
    }
  }

  return '';
}

function getSourceInfoErrorAddendum(source) {
  if (source !== undefined) {
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
  }

  return '';
}

function getSourceInfoErrorAddendumForProps(elementProps) {
  if (elementProps !== null && elementProps !== undefined) {
    return getSourceInfoErrorAddendum(elementProps.__source);
  }

  return '';
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

    if (parentName) {
      info = "\n\nCheck the top-level render call using <" + parentName + ">.";
    }
  }

  return info;
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }

  element._store.validated = true;
  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
    return;
  }

  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.

  var childOwner = '';

  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
  }

  {
    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }

  if (isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];

      if (isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);

    if (typeof iteratorFn === 'function') {
      // Entry iterators used to provide implicit keys,
      // but now we print a separate warning for them later.
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;

        while (!(step = iterator.next()).done) {
          if (isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentNameFromType(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentNameFromType(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}
function createElementWithValidation(type, props, children) {
  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
  // succeed and there will likely be errors in render.

  if (!validType) {
    var info = '';

    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
      info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
    }

    var sourceInfo = getSourceInfoErrorAddendumForProps(props);

    if (sourceInfo) {
      info += sourceInfo;
    } else {
      info += getDeclarationErrorAddendum();
    }

    var typeString;

    if (type === null) {
      typeString = 'null';
    } else if (isArray(type)) {
      typeString = 'array';
    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
      typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
      info = ' Did you accidentally export a JSX literal instead of a component?';
    } else {
      typeString = typeof type;
    }

    {
      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }
  }

  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
  // TODO: Drop this when these are no longer allowed as the type argument.

  if (element == null) {
    return element;
  } // Skip key warning if the type isn't valid since our key validation logic
  // doesn't expect a non-string/function type and can throw confusing errors.
  // We don't want exception behavior to differ between dev and prod.
  // (Rendering will throw with a helpful message and as soon as the type is
  // fixed, the key warnings will appear.)


  if (validType) {
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], type);
    }
  }

  if (type === REACT_FRAGMENT_TYPE) {
    validateFragmentProps(element);
  } else {
    validatePropTypes(element);
  }

  return element;
}
var didWarnAboutDeprecatedCreateFactory = false;
function createFactoryWithValidation(type) {
  var validatedFactory = createElementWithValidation.bind(null, type);
  validatedFactory.type = type;

  {
    if (!didWarnAboutDeprecatedCreateFactory) {
      didWarnAboutDeprecatedCreateFactory = true;

      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
    } // Legacy hook: remove it


    Object.defineProperty(validatedFactory, 'type', {
      enumerable: false,
      get: function () {
        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

        Object.defineProperty(this, 'type', {
          value: type
        });
        return type;
      }
    });
  }

  return validatedFactory;
}
function cloneElementWithValidation(element, props, children) {
  var newElement = cloneElement.apply(this, arguments);

  for (var i = 2; i < arguments.length; i++) {
    validateChildKeys(arguments[i], newElement.type);
  }

  validatePropTypes(newElement);
  return newElement;
}

function startTransition(scope, options) {
  var prevTransition = ReactCurrentBatchConfig.transition;
  ReactCurrentBatchConfig.transition = {};
  var currentTransition = ReactCurrentBatchConfig.transition;

  {
    ReactCurrentBatchConfig.transition._updatedFibers = new Set();
  }

  try {
    scope();
  } finally {
    ReactCurrentBatchConfig.transition = prevTransition;

    {
      if (prevTransition === null && currentTransition._updatedFibers) {
        var updatedFibersCount = currentTransition._updatedFibers.size;

        if (updatedFibersCount > 10) {
          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
        }

        currentTransition._updatedFibers.clear();
      }
    }
  }
}

var didWarnAboutMessageChannel = false;
var enqueueTaskImpl = null;
function enqueueTask(task) {
  if (enqueueTaskImpl === null) {
    try {
      // read require off the module object to get around the bundlers.
      // we don't want them to detect a require and bundle a Node polyfill.
      var requireString = ('require' + Math.random()).slice(0, 7);
      var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's
      // version of setImmediate, bypassing fake timers if any.

      enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
    } catch (_err) {
      // we're in a browser
      // we can't use regular timers because they may still be faked
      // so we try MessageChannel+postMessage instead
      enqueueTaskImpl = function (callback) {
        {
          if (didWarnAboutMessageChannel === false) {
            didWarnAboutMessageChannel = true;

            if (typeof MessageChannel === 'undefined') {
              error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
            }
          }
        }

        var channel = new MessageChannel();
        channel.port1.onmessage = callback;
        channel.port2.postMessage(undefined);
      };
    }
  }

  return enqueueTaskImpl(task);
}

var actScopeDepth = 0;
var didWarnNoAwaitAct = false;
function act(callback) {
  {
    // `act` calls can be nested, so we track the depth. This represents the
    // number of `act` scopes on the stack.
    var prevActScopeDepth = actScopeDepth;
    actScopeDepth++;

    if (ReactCurrentActQueue.current === null) {
      // This is the outermost `act` scope. Initialize the queue. The reconciler
      // will detect the queue and use it instead of Scheduler.
      ReactCurrentActQueue.current = [];
    }

    var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
    var result;

    try {
      // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only
      // set to `true` while the given callback is executed, not for updates
      // triggered during an async event, because this is how the legacy
      // implementation of `act` behaved.
      ReactCurrentActQueue.isBatchingLegacy = true;
      result = callback(); // Replicate behavior of original `act` implementation in legacy mode,
      // which flushed updates immediately after the scope function exits, even
      // if it's an async function.

      if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
        var queue = ReactCurrentActQueue.current;

        if (queue !== null) {
          ReactCurrentActQueue.didScheduleLegacyUpdate = false;
          flushActQueue(queue);
        }
      }
    } catch (error) {
      popActScope(prevActScopeDepth);
      throw error;
    } finally {
      ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
    }

    if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
      var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait
      // for it to resolve before exiting the current scope.

      var wasAwaited = false;
      var thenable = {
        then: function (resolve, reject) {
          wasAwaited = true;
          thenableResult.then(function (returnValue) {
            popActScope(prevActScopeDepth);

            if (actScopeDepth === 0) {
              // We've exited the outermost act scope. Recursively flush the
              // queue until there's no remaining work.
              recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            } else {
              resolve(returnValue);
            }
          }, function (error) {
            // The callback threw an error.
            popActScope(prevActScopeDepth);
            reject(error);
          });
        }
      };

      {
        if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {
          // eslint-disable-next-line no-undef
          Promise.resolve().then(function () {}).then(function () {
            if (!wasAwaited) {
              didWarnNoAwaitAct = true;

              error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
            }
          });
        }
      }

      return thenable;
    } else {
      var returnValue = result; // The callback is not an async function. Exit the current scope
      // immediately, without awaiting.

      popActScope(prevActScopeDepth);

      if (actScopeDepth === 0) {
        // Exiting the outermost act scope. Flush the queue.
        var _queue = ReactCurrentActQueue.current;

        if (_queue !== null) {
          flushActQueue(_queue);
          ReactCurrentActQueue.current = null;
        } // Return a thenable. If the user awaits it, we'll flush again in
        // case additional work was scheduled by a microtask.


        var _thenable = {
          then: function (resolve, reject) {
            // Confirm we haven't re-entered another `act` scope, in case
            // the user does something weird like await the thenable
            // multiple times.
            if (ReactCurrentActQueue.current === null) {
              // Recursively flush the queue until there's no remaining work.
              ReactCurrentActQueue.current = [];
              recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            } else {
              resolve(returnValue);
            }
          }
        };
        return _thenable;
      } else {
        // Since we're inside a nested `act` scope, the returned thenable
        // immediately resolves. The outer scope will flush the queue.
        var _thenable2 = {
          then: function (resolve, reject) {
            resolve(returnValue);
          }
        };
        return _thenable2;
      }
    }
  }
}

function popActScope(prevActScopeDepth) {
  {
    if (prevActScopeDepth !== actScopeDepth - 1) {
      error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
    }

    actScopeDepth = prevActScopeDepth;
  }
}

function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
  {
    var queue = ReactCurrentActQueue.current;

    if (queue !== null) {
      try {
        flushActQueue(queue);
        enqueueTask(function () {
          if (queue.length === 0) {
            // No additional work was scheduled. Finish.
            ReactCurrentActQueue.current = null;
            resolve(returnValue);
          } else {
            // Keep flushing work until there's none left.
            recursivelyFlushAsyncActWork(returnValue, resolve, reject);
          }
        });
      } catch (error) {
        reject(error);
      }
    } else {
      resolve(returnValue);
    }
  }
}

var isFlushing = false;

function flushActQueue(queue) {
  {
    if (!isFlushing) {
      // Prevent re-entrance.
      isFlushing = true;
      var i = 0;

      try {
        for (; i < queue.length; i++) {
          var callback = queue[i];

          do {
            callback = callback(true);
          } while (callback !== null);
        }

        queue.length = 0;
      } catch (error) {
        // If something throws, leave the remaining callbacks on the queue.
        queue = queue.slice(i + 1);
        throw error;
      } finally {
        isFlushing = false;
      }
    }
  }
}

var createElement$1 =  createElementWithValidation ;
var cloneElement$1 =  cloneElementWithValidation ;
var createFactory =  createFactoryWithValidation ;
var Children = {
  map: mapChildren,
  forEach: forEachChildren,
  count: countChildren,
  toArray: toArray,
  only: onlyChild
};

exports.Children = Children;
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
exports.act = act;
exports.cloneElement = cloneElement$1;
exports.createContext = createContext;
exports.createElement = createElement$1;
exports.createFactory = createFactory;
exports.createRef = createRef;
exports.forwardRef = forwardRef;
exports.isValidElement = isValidElement;
exports.lazy = lazy;
exports.memo = memo;
exports.startTransition = startTransition;
exports.unstable_act = act;
exports.useCallback = useCallback;
exports.useContext = useContext;
exports.useDebugValue = useDebugValue;
exports.useDeferredValue = useDeferredValue;
exports.useEffect = useEffect;
exports.useId = useId;
exports.useImperativeHandle = useImperativeHandle;
exports.useInsertionEffect = useInsertionEffect;
exports.useLayoutEffect = useLayoutEffect;
exports.useMemo = useMemo;
exports.useReducer = useReducer;
exports.useRef = useRef;
exports.useState = useState;
exports.useSyncExternalStore = useSyncExternalStore;
exports.useTransition = useTransition;
exports.version = ReactVersion;
          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
if (
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
    'function'
) {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
}
        
  })();
}

~~~

## node_modules\react\cjs\react.production.min.js

~~~js
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';var l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return"function"===typeof a?a:null}
var B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};
E.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;
H.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};
function M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}
function N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g;function Q(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
function R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=
a[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
function S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}
var U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};function X(){throw Error("act(...) is not supported in production builds of React.");}
exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};exports.Component=E;exports.Fragment=p;exports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;exports.act=X;
exports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};
exports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=X;exports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};
exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};exports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};
exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};exports.useTransition=function(){return U.current.useTransition()};exports.version="18.3.1";

~~~

## node_modules\react\cjs\react.shared-subset.development.js

~~~js
/**
 * @license React
 * react.shared-subset.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

// eslint-disable-next-line react-internal/prod-error-codes
throw new Error('This entry point is not yet supported outside of experimental channels');
  })();
}

~~~

## node_modules\react\cjs\react.shared-subset.production.min.js

~~~js
/**
 * @license React
 * react.shared-subset.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';throw Error("This entry point is not yet supported outside of experimental channels");

~~~

## node_modules\react\cjs\react-jsx-dev-runtime.development.js

~~~js
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var React = require('react');

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      printWarning('error', format, args);
    }
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    } // eslint-disable-next-line react-internal/safe-string-coercion


    var argsWithFormat = args.map(function (item) {
      return String(item);
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var displayName = outerType.displayName;

  if (displayName) {
    return displayName;
  }

  var functionName = innerType.displayName || innerType.name || '';
  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
} // Keep in sync with react-reconciler/getComponentNameFromFiber


function getContextName(type) {
  return type.displayName || 'Context';
} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


function getComponentNameFromType(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';

  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        var outerName = type.displayName || null;

        if (outerName !== null) {
          return outerName;
        }

        return getComponentNameFromType(type.type) || 'Memo';

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentNameFromType(init(payload));
          } catch (x) {
            return null;
          }
        }

      // eslint-disable-next-line no-fallthrough
    }
  }

  return null;
}

var assign = Object.assign;

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if ( !fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                // but we have a user-provided "displayName"
                // splice it in to make the stack more readable.


                if (fn.displayName && _frame.includes('<anonymous>')) {
                  _frame = _frame.replace('<anonymous>', fn.displayName);
                }

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            // eslint-disable-next-line react-internal/prod-error-codes
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */
// $FlowFixMe only called in DEV, so void return is not possible.
function typeName(value) {
  {
    // toStringTag is needed for namespaced types like Temporal.Instant
    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
    return type;
  }
} // $FlowFixMe only called in DEV, so void return is not possible.


function willCoercionThrow(value) {
  {
    try {
      testStringCoercion(value);
      return false;
    } catch (e) {
      return true;
    }
  }
}

function testStringCoercion(value) {
  // If you ended up here by following an exception call stack, here's what's
  // happened: you supplied an object or symbol value to React (as a prop, key,
  // DOM attribute, CSS property, string ref, etc.) and when React tried to
  // coerce it to a string using `'' + value`, an exception was thrown.
  //
  // The most common types that will cause this exception are `Symbol` instances
  // and Temporal objects like `Temporal.Instant`. But any object that has a
  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
  // exception. (Library authors do this to prevent users from using built-in
  // numeric operators like `+` or comparison operators like `>=` because custom
  // methods are needed to perform accurate arithmetic or comparison.)
  //
  // To fix the problem, coerce this object or symbol value to a string before
  // passing it to React. The most reliable way is usually `String(value)`.
  //
  // To find which value is throwing, check the browser or debugger console.
  // Before this exception was thrown, there should be `console.error` output
  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
  // problem and how that type was used: key, atrribute, input value prop, etc.
  // In most cases, this console output also shows the component and its
  // ancestor components where the exception happened.
  //
  // eslint-disable-next-line react-internal/safe-string-coercion
  return '' + value;
}
function checkKeyStringCoercion(value) {
  {
    if (willCoercionThrow(value)) {
      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      {
        checkKeyStringCoercion(maybeKey);
      }

      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      {
        checkKeyStringCoercion(config.key);
      }

      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */


function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentNameFromType(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentNameFromType(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

var didWarnAboutKeySpread = {};
function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    {
      if (hasOwnProperty.call(props, 'key')) {
        var componentName = getComponentNameFromType(type);
        var keys = Object.keys(props).filter(function (k) {
          return k !== 'key';
        });
        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';

        if (!didWarnAboutKeySpread[componentName + beforeExample]) {
          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';

          error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);

          didWarnAboutKeySpread[componentName + beforeExample] = true;
        }
      }
    }

    if (type === REACT_FRAGMENT_TYPE) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev

var jsxDEV$1 =  jsxWithValidation ;

exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsxDEV = jsxDEV$1;
  })();
}

~~~

## node_modules\react\cjs\react-jsx-dev-runtime.production.min.js

~~~js
/**
 * @license React
 * react-jsx-dev-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';var a=Symbol.for("react.fragment");exports.Fragment=a;exports.jsxDEV=void 0;

~~~

## node_modules\react\cjs\react-jsx-dev-runtime.profiling.min.js

~~~js
/**
 * @license React
 * react-jsx-dev-runtime.profiling.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';var a=Symbol.for("react.fragment");exports.Fragment=a;exports.jsxDEV=void 0;

~~~

## node_modules\react\cjs\react-jsx-runtime.development.js

~~~js
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== "production") {
  (function() {
'use strict';

var React = require('react');

// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types.
var REACT_ELEMENT_TYPE = Symbol.for('react.element');
var REACT_PORTAL_TYPE = Symbol.for('react.portal');
var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
var REACT_CONTEXT_TYPE = Symbol.for('react.context');
var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
var REACT_MEMO_TYPE = Symbol.for('react.memo');
var REACT_LAZY_TYPE = Symbol.for('react.lazy');
var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || typeof maybeIterable !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}

var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

function error(format) {
  {
    {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      printWarning('error', format, args);
    }
  }
}

function printWarning(level, format, args) {
  // When changing this logic, you might want to also
  // update consoleWithStackDev.www.js as well.
  {
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
    var stack = ReactDebugCurrentFrame.getStackAddendum();

    if (stack !== '') {
      format += '%s';
      args = args.concat([stack]);
    } // eslint-disable-next-line react-internal/safe-string-coercion


    var argsWithFormat = args.map(function (item) {
      return String(item);
    }); // Careful: RN currently depends on this prefix

    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
    // breaks IE9: https://github.com/facebook/react/issues/13610
    // eslint-disable-next-line react-internal/no-production-logging

    Function.prototype.apply.call(console[level], console, argsWithFormat);
  }
}

// -----------------------------------------------------------------------------

var enableScopeAPI = false; // Experimental Create Event Handle API.
var enableCacheElement = false;
var enableTransitionTracing = false; // No known bugs, but needs performance testing

var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
// stuff. Intended to enable React core members to more easily debug scheduling
// issues in DEV builds.

var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

var REACT_MODULE_REFERENCE;

{
  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
}

function isValidElementType(type) {
  if (typeof type === 'string' || typeof type === 'function') {
    return true;
  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
    return true;
  }

  if (typeof type === 'object' && type !== null) {
    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
    // types supported by any Flight configuration anywhere since
    // we don't know which Flight build this will end up being used
    // with.
    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
      return true;
    }
  }

  return false;
}

function getWrappedName(outerType, innerType, wrapperName) {
  var displayName = outerType.displayName;

  if (displayName) {
    return displayName;
  }

  var functionName = innerType.displayName || innerType.name || '';
  return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
} // Keep in sync with react-reconciler/getComponentNameFromFiber


function getContextName(type) {
  return type.displayName || 'Context';
} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


function getComponentNameFromType(type) {
  if (type == null) {
    // Host root, text node or just invalid type.
    return null;
  }

  {
    if (typeof type.tag === 'number') {
      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
    }
  }

  if (typeof type === 'function') {
    return type.displayName || type.name || null;
  }

  if (typeof type === 'string') {
    return type;
  }

  switch (type) {
    case REACT_FRAGMENT_TYPE:
      return 'Fragment';

    case REACT_PORTAL_TYPE:
      return 'Portal';

    case REACT_PROFILER_TYPE:
      return 'Profiler';

    case REACT_STRICT_MODE_TYPE:
      return 'StrictMode';

    case REACT_SUSPENSE_TYPE:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';

  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        var context = type;
        return getContextName(context) + '.Consumer';

      case REACT_PROVIDER_TYPE:
        var provider = type;
        return getContextName(provider._context) + '.Provider';

      case REACT_FORWARD_REF_TYPE:
        return getWrappedName(type, type.render, 'ForwardRef');

      case REACT_MEMO_TYPE:
        var outerName = type.displayName || null;

        if (outerName !== null) {
          return outerName;
        }

        return getComponentNameFromType(type.type) || 'Memo';

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            return getComponentNameFromType(init(payload));
          } catch (x) {
            return null;
          }
        }

      // eslint-disable-next-line no-fallthrough
    }
  }

  return null;
}

var assign = Object.assign;

// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  {
    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

      var props = {
        configurable: true,
        enumerable: true,
        value: disabledLog,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    disabledDepth++;
  }
}
function reenableLogs() {
  {
    disabledDepth--;

    if (disabledDepth === 0) {
      /* eslint-disable react-internal/no-production-logging */
      var props = {
        configurable: true,
        enumerable: true,
        writable: true
      }; // $FlowFixMe Flow thinks console is immutable.

      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
      /* eslint-enable react-internal/no-production-logging */
    }

    if (disabledDepth < 0) {
      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
    }
  }
}

var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  {
    if (prefix === undefined) {
      // Extract the VM specific prefix used by each line.
      try {
        throw Error();
      } catch (x) {
        var match = x.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || '';
      }
    } // We use the prefix to ensure our stacks line up with native stack frames.


    return '\n' + prefix + name;
  }
}
var reentry = false;
var componentFrameCache;

{
  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
  componentFrameCache = new PossiblyWeakMap();
}

function describeNativeComponentFrame(fn, construct) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if ( !fn || reentry) {
    return '';
  }

  {
    var frame = componentFrameCache.get(fn);

    if (frame !== undefined) {
      return frame;
    }
  }

  var control;
  reentry = true;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  var previousDispatcher;

  {
    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function
    // for warnings.

    ReactCurrentDispatcher.current = null;
    disableLogs();
  }

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function () {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function () {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if (typeof Reflect === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                // but we have a user-provided "displayName"
                // splice it in to make the stack more readable.


                if (fn.displayName && _frame.includes('<anonymous>')) {
                  _frame = _frame.replace('<anonymous>', fn.displayName);
                }

                {
                  if (typeof fn === 'function') {
                    componentFrameCache.set(fn, _frame);
                  }
                } // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;

    {
      ReactCurrentDispatcher.current = previousDispatcher;
      reenableLogs();
    }

    Error.prepareStackTrace = previousPrepareStackTrace;
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  {
    if (typeof fn === 'function') {
      componentFrameCache.set(fn, syntheticFrame);
    }
  }

  return syntheticFrame;
}
function describeFunctionComponentFrame(fn, source, ownerFn) {
  {
    return describeNativeComponentFrame(fn, false);
  }
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    {
      return describeNativeComponentFrame(type, shouldConstruct(type));
    }
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type);
  }

  switch (type) {
    case REACT_SUSPENSE_TYPE:
      return describeBuiltInComponentFrame('Suspense');

    case REACT_SUSPENSE_LIST_TYPE:
      return describeBuiltInComponentFrame('SuspenseList');
  }

  if (typeof type === 'object') {
    switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return describeFunctionComponentFrame(type.render);

      case REACT_MEMO_TYPE:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

      case REACT_LAZY_TYPE:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
          } catch (x) {}
        }
    }
  }

  return '';
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

var loggedTypeFailures = {};
var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame.setExtraStackFrame(null);
    }
  }
}

function checkPropTypes(typeSpecs, values, location, componentName, element) {
  {
    // $FlowFixMe This is okay but Flow doesn't know it.
    var has = Function.call.bind(hasOwnProperty);

    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            // eslint-disable-next-line react-internal/prod-error-codes
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
        } catch (ex) {
          error$1 = ex;
        }

        if (error$1 && !(error$1 instanceof Error)) {
          setCurrentlyValidatingElement(element);

          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

          setCurrentlyValidatingElement(null);
        }

        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error$1.message] = true;
          setCurrentlyValidatingElement(element);

          error('Failed %s type: %s', location, error$1.message);

          setCurrentlyValidatingElement(null);
        }
      }
    }
  }
}

var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/*
 * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
 * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
 *
 * The functions in this module will throw an easier-to-understand,
 * easier-to-debug exception with a clear errors message message explaining the
 * problem. (Instead of a confusing exception thrown inside the implementation
 * of the `value` object).
 */
// $FlowFixMe only called in DEV, so void return is not possible.
function typeName(value) {
  {
    // toStringTag is needed for namespaced types like Temporal.Instant
    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
    return type;
  }
} // $FlowFixMe only called in DEV, so void return is not possible.


function willCoercionThrow(value) {
  {
    try {
      testStringCoercion(value);
      return false;
    } catch (e) {
      return true;
    }
  }
}

function testStringCoercion(value) {
  // If you ended up here by following an exception call stack, here's what's
  // happened: you supplied an object or symbol value to React (as a prop, key,
  // DOM attribute, CSS property, string ref, etc.) and when React tried to
  // coerce it to a string using `'' + value`, an exception was thrown.
  //
  // The most common types that will cause this exception are `Symbol` instances
  // and Temporal objects like `Temporal.Instant`. But any object that has a
  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
  // exception. (Library authors do this to prevent users from using built-in
  // numeric operators like `+` or comparison operators like `>=` because custom
  // methods are needed to perform accurate arithmetic or comparison.)
  //
  // To fix the problem, coerce this object or symbol value to a string before
  // passing it to React. The most reliable way is usually `String(value)`.
  //
  // To find which value is throwing, check the browser or debugger console.
  // Before this exception was thrown, there should be `console.error` output
  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
  // problem and how that type was used: key, atrribute, input value prop, etc.
  // In most cases, this console output also shows the component and its
  // ancestor components where the exception happened.
  //
  // eslint-disable-next-line react-internal/safe-string-coercion
  return '' + value;
}
function checkKeyStringCoercion(value) {
  {
    if (willCoercionThrow(value)) {
      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
    }
  }
}

var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};
var specialPropKeyWarningShown;
var specialPropRefWarningShown;
var didWarnAboutStringRefs;

{
  didWarnAboutStringRefs = {};
}

function hasValidRef(config) {
  {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.ref !== undefined;
}

function hasValidKey(config) {
  {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }

  return config.key !== undefined;
}

function warnIfStringRefCannotBeAutoConverted(config, self) {
  {
    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

      if (!didWarnAboutStringRefs[componentName]) {
        error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);

        didWarnAboutStringRefs[componentName] = true;
      }
    }
  }
}

function defineKeyPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingKey = function () {
      if (!specialPropKeyWarningShown) {
        specialPropKeyWarningShown = true;

        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }
}

function defineRefPropWarningGetter(props, displayName) {
  {
    var warnAboutAccessingRef = function () {
      if (!specialPropRefWarningShown) {
        specialPropRefWarningShown = true;

        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }
}
/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} props
 * @param {*} key
 * @param {string|object} ref
 * @param {*} owner
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 */


var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,
    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,
    // Record the component responsible for creating this element.
    _owner: owner
  };

  {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.

    Object.defineProperty(element._store, 'validated', {
      configurable: false,
      enumerable: false,
      writable: true,
      value: false
    }); // self and source are DEV only properties.

    Object.defineProperty(element, '_self', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: self
    }); // Two elements created in two different places should be considered
    // equal for testing purposes and therefore we hide it from enumeration.

    Object.defineProperty(element, '_source', {
      configurable: false,
      enumerable: false,
      writable: false,
      value: source
    });

    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};
/**
 * https://github.com/reactjs/rfcs/pull/107
 * @param {*} type
 * @param {object} props
 * @param {string} key
 */

function jsxDEV(type, config, maybeKey, source, self) {
  {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null; // Currently, key can be spread in as a prop. This causes a potential
    // issue if key is also explicitly declared (ie. <div {...props} key="Hi" />
    // or <div key="Hi" {...props} /> ). We want to deprecate key spread,
    // but as an intermediary step, we will use jsxDEV for everything except
    // <div {...props} key="Hi" />, because we aren't currently able to tell if
    // key is explicitly declared to be undefined or not.

    if (maybeKey !== undefined) {
      {
        checkKeyStringCoercion(maybeKey);
      }

      key = '' + maybeKey;
    }

    if (hasValidKey(config)) {
      {
        checkKeyStringCoercion(config.key);
      }

      key = '' + config.key;
    }

    if (hasValidRef(config)) {
      ref = config.ref;
      warnIfStringRefCannotBeAutoConverted(config, self);
    } // Remaining properties are added to a new props object


    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    if (key || ref) {
      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

      if (key) {
        defineKeyPropWarningGetter(props, displayName);
      }

      if (ref) {
        defineRefPropWarningGetter(props, displayName);
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
}

var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

function setCurrentlyValidatingElement$1(element) {
  {
    if (element) {
      var owner = element._owner;
      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
    } else {
      ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
  }
}

var propTypesMisspellWarningShown;

{
  propTypesMisspellWarningShown = false;
}
/**
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a ReactElement.
 * @final
 */


function isValidElement(object) {
  {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }
}

function getDeclarationErrorAddendum() {
  {
    if (ReactCurrentOwner$1.current) {
      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }
}

function getSourceInfoErrorAddendum(source) {
  {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }
}
/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */


var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
}
/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */


function validateExplicitKey(element, parentType) {
  {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
    }

    setCurrentlyValidatingElement$1(element);

    error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

    setCurrentlyValidatingElement$1(null);
  }
}
/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */


function validateChildKeys(node, parentType) {
  {
    if (typeof node !== 'object') {
      return;
    }

    if (isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
}
/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */


function validatePropTypes(element) {
  {
    var type = element.type;

    if (type === null || type === undefined || typeof type === 'string') {
      return;
    }

    var propTypes;

    if (typeof type === 'function') {
      propTypes = type.propTypes;
    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
    // Inner props are checked in the reconciler.
    type.$$typeof === REACT_MEMO_TYPE)) {
      propTypes = type.propTypes;
    } else {
      return;
    }

    if (propTypes) {
      // Intentionally inside to avoid triggering lazy initializers:
      var name = getComponentNameFromType(type);
      checkPropTypes(propTypes, element.props, 'prop', name, element);
    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

      var _name = getComponentNameFromType(type);

      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
    }

    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
    }
  }
}
/**
 * Given a fragment, validate that it can only be provided with fragment props
 * @param {ReactElement} fragment
 */


function validateFragmentProps(fragment) {
  {
    var keys = Object.keys(fragment.props);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];

      if (key !== 'children' && key !== 'key') {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

        setCurrentlyValidatingElement$1(null);
        break;
      }
    }

    if (fragment.ref !== null) {
      setCurrentlyValidatingElement$1(fragment);

      error('Invalid attribute `ref` supplied to `React.Fragment`.');

      setCurrentlyValidatingElement$1(null);
    }
  }
}

var didWarnAboutKeySpread = {};
function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
  {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendum(source);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
    }

    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      var children = props.children;

      if (children !== undefined) {
        if (isStaticChildren) {
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              validateChildKeys(children[i], type);
            }

            if (Object.freeze) {
              Object.freeze(children);
            }
          } else {
            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');
          }
        } else {
          validateChildKeys(children, type);
        }
      }
    }

    {
      if (hasOwnProperty.call(props, 'key')) {
        var componentName = getComponentNameFromType(type);
        var keys = Object.keys(props).filter(function (k) {
          return k !== 'key';
        });
        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';

        if (!didWarnAboutKeySpread[componentName + beforeExample]) {
          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';

          error('A props object containing a "key" prop is being spread into JSX:\n' + '  let props = %s;\n' + '  <%s {...props} />\n' + 'React keys must be passed directly to JSX without using spread:\n' + '  let props = %s;\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);

          didWarnAboutKeySpread[componentName + beforeExample] = true;
        }
      }
    }

    if (type === REACT_FRAGMENT_TYPE) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
} // These two functions exist to still get child warnings in dev
// even with the prod transform. This means that jsxDEV is purely
// opt-in behavior for better messages but that we won't stop
// giving you warnings if you use production apis.

function jsxWithValidationStatic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, true);
  }
}
function jsxWithValidationDynamic(type, props, key) {
  {
    return jsxWithValidation(type, props, key, false);
  }
}

var jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.
// for now we can ship identical prod functions

var jsxs =  jsxWithValidationStatic ;

exports.Fragment = REACT_FRAGMENT_TYPE;
exports.jsx = jsx;
exports.jsxs = jsxs;
  })();
}

~~~

## node_modules\react\cjs\react-jsx-runtime.production.min.js

~~~js
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';var f=require("react"),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};
function q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;

~~~

## node_modules\react\cjs\react-jsx-runtime.profiling.min.js

~~~js
/**
 * @license React
 * react-jsx-runtime.profiling.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';var f=require("react"),k=Symbol.for("react.element"),l=Symbol.for("react.fragment"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};
function q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=""+g);void 0!==a.key&&(e=""+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;

~~~

## node_modules\react\index.js

~~~js
'use strict';

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}

~~~

## node_modules\react\jsx-dev-runtime.js

~~~js
'use strict';

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react-jsx-dev-runtime.production.min.js');
} else {
  module.exports = require('./cjs/react-jsx-dev-runtime.development.js');
}

~~~

## node_modules\react\jsx-runtime.js

~~~js
'use strict';

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react-jsx-runtime.production.min.js');
} else {
  module.exports = require('./cjs/react-jsx-runtime.development.js');
}

~~~

## node_modules\react\LICENSE

~~~text
MIT License

Copyright (c) Facebook, Inc. and its affiliates.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

~~~

## node_modules\react\package.json

~~~json
{
  "name": "react",
  "description": "React is a JavaScript library for building user interfaces.",
  "keywords": [
    "react"
  ],
  "version": "18.3.1",
  "homepage": "https://reactjs.org/",
  "bugs": "https://github.com/facebook/react/issues",
  "license": "MIT",
  "files": [
    "LICENSE",
    "README.md",
    "index.js",
    "cjs/",
    "umd/",
    "jsx-runtime.js",
    "jsx-dev-runtime.js",
    "react.shared-subset.js"
  ],
  "main": "index.js",
  "exports": {
    ".": {
      "react-server": "./react.shared-subset.js",
      "default": "./index.js"
    },
    "./package.json": "./package.json",
    "./jsx-runtime": "./jsx-runtime.js",
    "./jsx-dev-runtime": "./jsx-dev-runtime.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/facebook/react.git",
    "directory": "packages/react"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "dependencies": {
    "loose-envify": "^1.1.0"
  },
  "browserify": {
    "transform": [
      "loose-envify"
    ]
  }
}
~~~

## node_modules\react\react.shared-subset.js

~~~js
'use strict';

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react.shared-subset.production.min.js');
} else {
  module.exports = require('./cjs/react.shared-subset.development.js');
}

~~~

## node_modules\react\README.md

~~~md
# `react`

React is a JavaScript library for creating user interfaces.

The `react` package contains only the functionality necessary to define React components. It is typically used together with a React renderer like `react-dom` for the web, or `react-native` for the native environments.

**Note:** by default, React will be in development mode. The development version includes extra warnings about common mistakes, whereas the production version includes extra performance optimizations and strips all error messages. Don't forget to use the [production build](https://reactjs.org/docs/optimizing-performance.html#use-the-production-build) when deploying your application.

## Usage

```js
import { useState } from 'react';
import { createRoot } from 'react-dom/client';

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <>
      <h1>{count}</h1>
      <button onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </>
  );
}

const root = createRoot(document.getElementById('root'));
root.render(<App />);
```

## Documentation

See https://reactjs.org/

## API

See https://reactjs.org/docs/react-api.html

~~~

## node_modules\react\umd\react.development.js

~~~js
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.React = {}));
}(this, (function (exports) { 'use strict';

  var ReactVersion = '18.3.1';

  // ATTENTION
  // When adding new symbols to this file,
  // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
  // The Symbol used to tag the ReactElement-like types.
  var REACT_ELEMENT_TYPE = Symbol.for('react.element');
  var REACT_PORTAL_TYPE = Symbol.for('react.portal');
  var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');
  var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');
  var REACT_PROFILER_TYPE = Symbol.for('react.profiler');
  var REACT_PROVIDER_TYPE = Symbol.for('react.provider');
  var REACT_CONTEXT_TYPE = Symbol.for('react.context');
  var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');
  var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');
  var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');
  var REACT_MEMO_TYPE = Symbol.for('react.memo');
  var REACT_LAZY_TYPE = Symbol.for('react.lazy');
  var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');
  var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator';
  function getIteratorFn(maybeIterable) {
    if (maybeIterable === null || typeof maybeIterable !== 'object') {
      return null;
    }

    var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

    if (typeof maybeIterator === 'function') {
      return maybeIterator;
    }

    return null;
  }

  /**
   * Keeps track of the current dispatcher.
   */
  var ReactCurrentDispatcher = {
    /**
     * @internal
     * @type {ReactComponent}
     */
    current: null
  };

  /**
   * Keeps track of the current batch's configuration such as how long an update
   * should suspend for if it needs to.
   */
  var ReactCurrentBatchConfig = {
    transition: null
  };

  var ReactCurrentActQueue = {
    current: null,
    // Used to reproduce behavior of `batchedUpdates` in legacy mode.
    isBatchingLegacy: false,
    didScheduleLegacyUpdate: false
  };

  /**
   * Keeps track of the current owner.
   *
   * The current owner is the component who should own any components that are
   * currently being constructed.
   */
  var ReactCurrentOwner = {
    /**
     * @internal
     * @type {ReactComponent}
     */
    current: null
  };

  var ReactDebugCurrentFrame = {};
  var currentExtraStackFrame = null;
  function setExtraStackFrame(stack) {
    {
      currentExtraStackFrame = stack;
    }
  }

  {
    ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {
      {
        currentExtraStackFrame = stack;
      }
    }; // Stack implementation injected by the current renderer.


    ReactDebugCurrentFrame.getCurrentStack = null;

    ReactDebugCurrentFrame.getStackAddendum = function () {
      var stack = ''; // Add an extra top frame while an element is being validated

      if (currentExtraStackFrame) {
        stack += currentExtraStackFrame;
      } // Delegate to the injected renderer-specific implementation


      var impl = ReactDebugCurrentFrame.getCurrentStack;

      if (impl) {
        stack += impl() || '';
      }

      return stack;
    };
  }

  // -----------------------------------------------------------------------------

  var enableScopeAPI = false; // Experimental Create Event Handle API.
  var enableCacheElement = false;
  var enableTransitionTracing = false; // No known bugs, but needs performance testing

  var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber
  // stuff. Intended to enable React core members to more easily debug scheduling
  // issues in DEV builds.

  var enableDebugTracing = false; // Track which Fiber(s) schedule render work.

  var ReactSharedInternals = {
    ReactCurrentDispatcher: ReactCurrentDispatcher,
    ReactCurrentBatchConfig: ReactCurrentBatchConfig,
    ReactCurrentOwner: ReactCurrentOwner
  };

  {
    ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
    ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
  }

  // by calls to these methods by a Babel plugin.
  //
  // In PROD (or in packages without access to React internals),
  // they are left as they are instead.

  function warn(format) {
    {
      {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        printWarning('warn', format, args);
      }
    }
  }
  function error(format) {
    {
      {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        printWarning('error', format, args);
      }
    }
  }

  function printWarning(level, format, args) {
    // When changing this logic, you might want to also
    // update consoleWithStackDev.www.js as well.
    {
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      var stack = ReactDebugCurrentFrame.getStackAddendum();

      if (stack !== '') {
        format += '%s';
        args = args.concat([stack]);
      } // eslint-disable-next-line react-internal/safe-string-coercion


      var argsWithFormat = args.map(function (item) {
        return String(item);
      }); // Careful: RN currently depends on this prefix

      argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
      // breaks IE9: https://github.com/facebook/react/issues/13610
      // eslint-disable-next-line react-internal/no-production-logging

      Function.prototype.apply.call(console[level], console, argsWithFormat);
    }
  }

  var didWarnStateUpdateForUnmountedComponent = {};

  function warnNoop(publicInstance, callerName) {
    {
      var _constructor = publicInstance.constructor;
      var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
      var warningKey = componentName + "." + callerName;

      if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
        return;
      }

      error("Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);

      didWarnStateUpdateForUnmountedComponent[warningKey] = true;
    }
  }
  /**
   * This is the abstract API for an update queue.
   */


  var ReactNoopUpdateQueue = {
    /**
     * Checks whether or not this composite component is mounted.
     * @param {ReactClass} publicInstance The instance we want to test.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function (publicInstance) {
      return false;
    },

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {?function} callback Called after component is updated.
     * @param {?string} callerName name of the calling function in the public API.
     * @internal
     */
    enqueueForceUpdate: function (publicInstance, callback, callerName) {
      warnNoop(publicInstance, 'forceUpdate');
    },

    /**
     * Replaces all of the state. Always use this or `setState` to mutate state.
     * You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object} completeState Next state.
     * @param {?function} callback Called after component is updated.
     * @param {?string} callerName name of the calling function in the public API.
     * @internal
     */
    enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
      warnNoop(publicInstance, 'replaceState');
    },

    /**
     * Sets a subset of the state. This only exists because _pendingState is
     * internal. This provides a merging strategy that is not available to deep
     * properties which is confusing. TODO: Expose pendingState or don't use it
     * during the merge.
     *
     * @param {ReactClass} publicInstance The instance that should rerender.
     * @param {object} partialState Next partial state to be merged with state.
     * @param {?function} callback Called after component is updated.
     * @param {?string} Name of the calling function in the public API.
     * @internal
     */
    enqueueSetState: function (publicInstance, partialState, callback, callerName) {
      warnNoop(publicInstance, 'setState');
    }
  };

  var assign = Object.assign;

  var emptyObject = {};

  {
    Object.freeze(emptyObject);
  }
  /**
   * Base class helpers for the updating state of a component.
   */


  function Component(props, context, updater) {
    this.props = props;
    this.context = context; // If a component has string refs, we will assign a different object later.

    this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
    // renderer.

    this.updater = updater || ReactNoopUpdateQueue;
  }

  Component.prototype.isReactComponent = {};
  /**
   * Sets a subset of the state. Always use this to mutate
   * state. You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * There is no guarantee that calls to `setState` will run synchronously,
   * as they may eventually be batched together.  You can provide an optional
   * callback that will be executed when the call to setState is actually
   * completed.
   *
   * When a function is provided to setState, it will be called at some point in
   * the future (not synchronously). It will be called with the up to date
   * component arguments (state, props, context). These values can be different
   * from this.* because your function may be called after receiveProps but before
   * shouldComponentUpdate, and this new state, props, and context will not yet be
   * assigned to this.
   *
   * @param {object|function} partialState Next partial state or function to
   *        produce next partial state to be merged with current state.
   * @param {?function} callback Called after state is updated.
   * @final
   * @protected
   */

  Component.prototype.setState = function (partialState, callback) {
    if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {
      throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');
    }

    this.updater.enqueueSetState(this, partialState, callback, 'setState');
  };
  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {?function} callback Called after update is complete.
   * @final
   * @protected
   */


  Component.prototype.forceUpdate = function (callback) {
    this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
  };
  /**
   * Deprecated APIs. These APIs used to exist on classic React classes but since
   * we would like to deprecate them, we're not going to move them over to this
   * modern base class. Instead, we define a getter that warns if it's accessed.
   */


  {
    var deprecatedAPIs = {
      isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
      replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
    };

    var defineDeprecationWarning = function (methodName, info) {
      Object.defineProperty(Component.prototype, methodName, {
        get: function () {
          warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);

          return undefined;
        }
      });
    };

    for (var fnName in deprecatedAPIs) {
      if (deprecatedAPIs.hasOwnProperty(fnName)) {
        defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      }
    }
  }

  function ComponentDummy() {}

  ComponentDummy.prototype = Component.prototype;
  /**
   * Convenience component with default shallow equality check for sCU.
   */

  function PureComponent(props, context, updater) {
    this.props = props;
    this.context = context; // If a component has string refs, we will assign a different object later.

    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }

  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
  pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

  assign(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;

  // an immutable object with a single mutable value
  function createRef() {
    var refObject = {
      current: null
    };

    {
      Object.seal(refObject);
    }

    return refObject;
  }

  var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

  function isArray(a) {
    return isArrayImpl(a);
  }

  /*
   * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol
   * and Temporal.* types. See https://github.com/facebook/react/pull/22064.
   *
   * The functions in this module will throw an easier-to-understand,
   * easier-to-debug exception with a clear errors message message explaining the
   * problem. (Instead of a confusing exception thrown inside the implementation
   * of the `value` object).
   */
  // $FlowFixMe only called in DEV, so void return is not possible.
  function typeName(value) {
    {
      // toStringTag is needed for namespaced types like Temporal.Instant
      var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;
      var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';
      return type;
    }
  } // $FlowFixMe only called in DEV, so void return is not possible.


  function willCoercionThrow(value) {
    {
      try {
        testStringCoercion(value);
        return false;
      } catch (e) {
        return true;
      }
    }
  }

  function testStringCoercion(value) {
    // If you ended up here by following an exception call stack, here's what's
    // happened: you supplied an object or symbol value to React (as a prop, key,
    // DOM attribute, CSS property, string ref, etc.) and when React tried to
    // coerce it to a string using `'' + value`, an exception was thrown.
    //
    // The most common types that will cause this exception are `Symbol` instances
    // and Temporal objects like `Temporal.Instant`. But any object that has a
    // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this
    // exception. (Library authors do this to prevent users from using built-in
    // numeric operators like `+` or comparison operators like `>=` because custom
    // methods are needed to perform accurate arithmetic or comparison.)
    //
    // To fix the problem, coerce this object or symbol value to a string before
    // passing it to React. The most reliable way is usually `String(value)`.
    //
    // To find which value is throwing, check the browser or debugger console.
    // Before this exception was thrown, there should be `console.error` output
    // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the
    // problem and how that type was used: key, atrribute, input value prop, etc.
    // In most cases, this console output also shows the component and its
    // ancestor components where the exception happened.
    //
    // eslint-disable-next-line react-internal/safe-string-coercion
    return '' + value;
  }
  function checkKeyStringCoercion(value) {
    {
      if (willCoercionThrow(value)) {
        error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));

        return testStringCoercion(value); // throw (to help callers find troubleshooting comments)
      }
    }
  }

  function getWrappedName(outerType, innerType, wrapperName) {
    var displayName = outerType.displayName;

    if (displayName) {
      return displayName;
    }

    var functionName = innerType.displayName || innerType.name || '';
    return functionName !== '' ? wrapperName + "(" + functionName + ")" : wrapperName;
  } // Keep in sync with react-reconciler/getComponentNameFromFiber


  function getContextName(type) {
    return type.displayName || 'Context';
  } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.


  function getComponentNameFromType(type) {
    if (type == null) {
      // Host root, text node or just invalid type.
      return null;
    }

    {
      if (typeof type.tag === 'number') {
        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');
      }
    }

    if (typeof type === 'function') {
      return type.displayName || type.name || null;
    }

    if (typeof type === 'string') {
      return type;
    }

    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return 'Fragment';

      case REACT_PORTAL_TYPE:
        return 'Portal';

      case REACT_PROFILER_TYPE:
        return 'Profiler';

      case REACT_STRICT_MODE_TYPE:
        return 'StrictMode';

      case REACT_SUSPENSE_TYPE:
        return 'Suspense';

      case REACT_SUSPENSE_LIST_TYPE:
        return 'SuspenseList';

    }

    if (typeof type === 'object') {
      switch (type.$$typeof) {
        case REACT_CONTEXT_TYPE:
          var context = type;
          return getContextName(context) + '.Consumer';

        case REACT_PROVIDER_TYPE:
          var provider = type;
          return getContextName(provider._context) + '.Provider';

        case REACT_FORWARD_REF_TYPE:
          return getWrappedName(type, type.render, 'ForwardRef');

        case REACT_MEMO_TYPE:
          var outerName = type.displayName || null;

          if (outerName !== null) {
            return outerName;
          }

          return getComponentNameFromType(type.type) || 'Memo';

        case REACT_LAZY_TYPE:
          {
            var lazyComponent = type;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;

            try {
              return getComponentNameFromType(init(payload));
            } catch (x) {
              return null;
            }
          }

        // eslint-disable-next-line no-fallthrough
      }
    }

    return null;
  }

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  var RESERVED_PROPS = {
    key: true,
    ref: true,
    __self: true,
    __source: true
  };
  var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;

  {
    didWarnAboutStringRefs = {};
  }

  function hasValidRef(config) {
    {
      if (hasOwnProperty.call(config, 'ref')) {
        var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

        if (getter && getter.isReactWarning) {
          return false;
        }
      }
    }

    return config.ref !== undefined;
  }

  function hasValidKey(config) {
    {
      if (hasOwnProperty.call(config, 'key')) {
        var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

        if (getter && getter.isReactWarning) {
          return false;
        }
      }
    }

    return config.key !== undefined;
  }

  function defineKeyPropWarningGetter(props, displayName) {
    var warnAboutAccessingKey = function () {
      {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;

          error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
        }
      }
    };

    warnAboutAccessingKey.isReactWarning = true;
    Object.defineProperty(props, 'key', {
      get: warnAboutAccessingKey,
      configurable: true
    });
  }

  function defineRefPropWarningGetter(props, displayName) {
    var warnAboutAccessingRef = function () {
      {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;

          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);
        }
      }
    };

    warnAboutAccessingRef.isReactWarning = true;
    Object.defineProperty(props, 'ref', {
      get: warnAboutAccessingRef,
      configurable: true
    });
  }

  function warnIfStringRefCannotBeAutoConverted(config) {
    {
      if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
        var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);

        if (!didWarnAboutStringRefs[componentName]) {
          error('Component "%s" contains the string ref "%s". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);

          didWarnAboutStringRefs[componentName] = true;
        }
      }
    }
  }
  /**
   * Factory method to create a new React element. This no longer adheres to
   * the class pattern, so do not use new to call it. Also, instanceof check
   * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
   * if something is a React Element.
   *
   * @param {*} type
   * @param {*} props
   * @param {*} key
   * @param {string|object} ref
   * @param {*} owner
   * @param {*} self A *temporary* helper to detect places where `this` is
   * different from the `owner` when React.createElement is called, so that we
   * can warn. We want to get rid of owner and replace string `ref`s with arrow
   * functions, and as long as `this` and owner are the same, there will be no
   * change in behavior.
   * @param {*} source An annotation object (added by a transpiler or otherwise)
   * indicating filename, line number, and/or other information.
   * @internal
   */


  var ReactElement = function (type, key, ref, self, source, owner, props) {
    var element = {
      // This tag allows us to uniquely identify this as a React Element
      $$typeof: REACT_ELEMENT_TYPE,
      // Built-in properties that belong on the element
      type: type,
      key: key,
      ref: ref,
      props: props,
      // Record the component responsible for creating this element.
      _owner: owner
    };

    {
      // The validation flag is currently mutative. We put it on
      // an external backing store so that we can freeze the whole object.
      // This can be replaced with a WeakMap once they are implemented in
      // commonly used development environments.
      element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
      // the validation flag non-enumerable (where possible, which should
      // include every environment we run tests in), so the test framework
      // ignores it.

      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }); // self and source are DEV only properties.

      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      }); // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.

      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });

      if (Object.freeze) {
        Object.freeze(element.props);
        Object.freeze(element);
      }
    }

    return element;
  };
  /**
   * Create and return a new ReactElement of the given type.
   * See https://reactjs.org/docs/react-api.html#createelement
   */

  function createElement(type, config, children) {
    var propName; // Reserved names are extracted

    var props = {};
    var key = null;
    var ref = null;
    var self = null;
    var source = null;

    if (config != null) {
      if (hasValidRef(config)) {
        ref = config.ref;

        {
          warnIfStringRefCannotBeAutoConverted(config);
        }
      }

      if (hasValidKey(config)) {
        {
          checkKeyStringCoercion(config.key);
        }

        key = '' + config.key;
      }

      self = config.__self === undefined ? null : config.__self;
      source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

      for (propName in config) {
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          props[propName] = config[propName];
        }
      }
    } // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.


    var childrenLength = arguments.length - 2;

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }

      {
        if (Object.freeze) {
          Object.freeze(childArray);
        }
      }

      props.children = childArray;
    } // Resolve default props


    if (type && type.defaultProps) {
      var defaultProps = type.defaultProps;

      for (propName in defaultProps) {
        if (props[propName] === undefined) {
          props[propName] = defaultProps[propName];
        }
      }
    }

    {
      if (key || ref) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }

        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }

    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
  }
  function cloneAndReplaceKey(oldElement, newKey) {
    var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
    return newElement;
  }
  /**
   * Clone and return a new ReactElement using element as the starting point.
   * See https://reactjs.org/docs/react-api.html#cloneelement
   */

  function cloneElement(element, config, children) {
    if (element === null || element === undefined) {
      throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
    }

    var propName; // Original props are copied

    var props = assign({}, element.props); // Reserved names are extracted

    var key = element.key;
    var ref = element.ref; // Self is preserved since the owner is preserved.

    var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
    // transpiler, and the original source is probably a better indicator of the
    // true owner.

    var source = element._source; // Owner will be preserved, unless ref is overridden

    var owner = element._owner;

    if (config != null) {
      if (hasValidRef(config)) {
        // Silently steal the ref from the parent.
        ref = config.ref;
        owner = ReactCurrentOwner.current;
      }

      if (hasValidKey(config)) {
        {
          checkKeyStringCoercion(config.key);
        }

        key = '' + config.key;
      } // Remaining properties override existing props


      var defaultProps;

      if (element.type && element.type.defaultProps) {
        defaultProps = element.type.defaultProps;
      }

      for (propName in config) {
        if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
          if (config[propName] === undefined && defaultProps !== undefined) {
            // Resolve default props
            props[propName] = defaultProps[propName];
          } else {
            props[propName] = config[propName];
          }
        }
      }
    } // Children can be more than one argument, and those are transferred onto
    // the newly allocated props object.


    var childrenLength = arguments.length - 2;

    if (childrenLength === 1) {
      props.children = children;
    } else if (childrenLength > 1) {
      var childArray = Array(childrenLength);

      for (var i = 0; i < childrenLength; i++) {
        childArray[i] = arguments[i + 2];
      }

      props.children = childArray;
    }

    return ReactElement(element.type, key, ref, self, source, owner, props);
  }
  /**
   * Verifies the object is a ReactElement.
   * See https://reactjs.org/docs/react-api.html#isvalidelement
   * @param {?object} object
   * @return {boolean} True if `object` is a ReactElement.
   * @final
   */

  function isValidElement(object) {
    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  }

  var SEPARATOR = '.';
  var SUBSEPARATOR = ':';
  /**
   * Escape and wrap key so it is safe to use as a reactid
   *
   * @param {string} key to be escaped.
   * @return {string} the escaped key.
   */

  function escape(key) {
    var escapeRegex = /[=:]/g;
    var escaperLookup = {
      '=': '=0',
      ':': '=2'
    };
    var escapedString = key.replace(escapeRegex, function (match) {
      return escaperLookup[match];
    });
    return '$' + escapedString;
  }
  /**
   * TODO: Test that a single child and an array with one item have the same key
   * pattern.
   */


  var didWarnAboutMaps = false;
  var userProvidedKeyEscapeRegex = /\/+/g;

  function escapeUserProvidedKey(text) {
    return text.replace(userProvidedKeyEscapeRegex, '$&/');
  }
  /**
   * Generate a key string that identifies a element within a set.
   *
   * @param {*} element A element that could contain a manual key.
   * @param {number} index Index that is used if a manual key is not provided.
   * @return {string}
   */


  function getElementKey(element, index) {
    // Do some typechecking here since we call this blindly. We want to ensure
    // that we don't block potential future ES APIs.
    if (typeof element === 'object' && element !== null && element.key != null) {
      // Explicit key
      {
        checkKeyStringCoercion(element.key);
      }

      return escape('' + element.key);
    } // Implicit key determined by the index in the set


    return index.toString(36);
  }

  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
    var type = typeof children;

    if (type === 'undefined' || type === 'boolean') {
      // All of the above are perceived as null.
      children = null;
    }

    var invokeCallback = false;

    if (children === null) {
      invokeCallback = true;
    } else {
      switch (type) {
        case 'string':
        case 'number':
          invokeCallback = true;
          break;

        case 'object':
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = true;
          }

      }
    }

    if (invokeCallback) {
      var _child = children;
      var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array
      // so that it's consistent if the number of children grows:

      var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;

      if (isArray(mappedChild)) {
        var escapedChildKey = '';

        if (childKey != null) {
          escapedChildKey = escapeUserProvidedKey(childKey) + '/';
        }

        mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {
          return c;
        });
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          {
            // The `if` statement here prevents auto-disabling of the safe
            // coercion ESLint rule, so we must manually disable it below.
            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
              checkKeyStringCoercion(mappedChild.key);
            }
          }

          mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
          mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
          // eslint-disable-next-line react-internal/safe-string-coercion
          escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);
        }

        array.push(mappedChild);
      }

      return 1;
    }

    var child;
    var nextName;
    var subtreeCount = 0; // Count of children found in the current subtree.

    var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

    if (isArray(children)) {
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        nextName = nextNamePrefix + getElementKey(child, i);
        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
      }
    } else {
      var iteratorFn = getIteratorFn(children);

      if (typeof iteratorFn === 'function') {
        var iterableChildren = children;

        {
          // Warn about using Maps as children
          if (iteratorFn === iterableChildren.entries) {
            if (!didWarnAboutMaps) {
              warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');
            }

            didWarnAboutMaps = true;
          }
        }

        var iterator = iteratorFn.call(iterableChildren);
        var step;
        var ii = 0;

        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getElementKey(child, ii++);
          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
        }
      } else if (type === 'object') {
        // eslint-disable-next-line react-internal/safe-string-coercion
        var childrenString = String(children);
        throw new Error("Objects are not valid as a React child (found: " + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + "). " + 'If you meant to render a collection of children, use an array ' + 'instead.');
      }
    }

    return subtreeCount;
  }

  /**
   * Maps children that are typically specified as `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrenmap
   *
   * The provided mapFunction(child, index) will be called for each
   * leaf child.
   *
   * @param {?*} children Children tree container.
   * @param {function(*, int)} func The map function.
   * @param {*} context Context for mapFunction.
   * @return {object} Object containing the ordered map of results.
   */
  function mapChildren(children, func, context) {
    if (children == null) {
      return children;
    }

    var result = [];
    var count = 0;
    mapIntoArray(children, result, '', '', function (child) {
      return func.call(context, child, count++);
    });
    return result;
  }
  /**
   * Count the number of children that are typically specified as
   * `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrencount
   *
   * @param {?*} children Children tree container.
   * @return {number} The number of children.
   */


  function countChildren(children) {
    var n = 0;
    mapChildren(children, function () {
      n++; // Don't return anything
    });
    return n;
  }

  /**
   * Iterates through children that are typically specified as `props.children`.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
   *
   * The provided forEachFunc(child, index) will be called for each
   * leaf child.
   *
   * @param {?*} children Children tree container.
   * @param {function(*, int)} forEachFunc
   * @param {*} forEachContext Context for forEachContext.
   */
  function forEachChildren(children, forEachFunc, forEachContext) {
    mapChildren(children, function () {
      forEachFunc.apply(this, arguments); // Don't return anything.
    }, forEachContext);
  }
  /**
   * Flatten a children object (typically specified as `props.children`) and
   * return an array with appropriately re-keyed children.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
   */


  function toArray(children) {
    return mapChildren(children, function (child) {
      return child;
    }) || [];
  }
  /**
   * Returns the first child in a collection of children and verifies that there
   * is only one child in the collection.
   *
   * See https://reactjs.org/docs/react-api.html#reactchildrenonly
   *
   * The current implementation of this function assumes that a single child gets
   * passed without a wrapper, but the purpose of this helper function is to
   * abstract away the particular structure of children.
   *
   * @param {?object} children Child collection structure.
   * @return {ReactElement} The first and only `ReactElement` contained in the
   * structure.
   */


  function onlyChild(children) {
    if (!isValidElement(children)) {
      throw new Error('React.Children.only expected to receive a single React element child.');
    }

    return children;
  }

  function createContext(defaultValue) {
    // TODO: Second argument used to be an optional `calculateChangedBits`
    // function. Warn to reserve for future use?
    var context = {
      $$typeof: REACT_CONTEXT_TYPE,
      // As a workaround to support multiple concurrent renderers, we categorize
      // some renderers as primary and others as secondary. We only expect
      // there to be two concurrent renderers at most: React Native (primary) and
      // Fabric (secondary); React DOM (primary) and React ART (secondary).
      // Secondary renderers store their context values on separate fields.
      _currentValue: defaultValue,
      _currentValue2: defaultValue,
      // Used to track how many concurrent renderers this context currently
      // supports within in a single renderer. Such as parallel server rendering.
      _threadCount: 0,
      // These are circular
      Provider: null,
      Consumer: null,
      // Add these to use same hidden class in VM as ServerContext
      _defaultValue: null,
      _globalName: null
    };
    context.Provider = {
      $$typeof: REACT_PROVIDER_TYPE,
      _context: context
    };
    var hasWarnedAboutUsingNestedContextConsumers = false;
    var hasWarnedAboutUsingConsumerProvider = false;
    var hasWarnedAboutDisplayNameOnConsumer = false;

    {
      // A separate object, but proxies back to the original context object for
      // backwards compatibility. It has a different $$typeof, so we can properly
      // warn for the incorrect usage of Context as a Consumer.
      var Consumer = {
        $$typeof: REACT_CONTEXT_TYPE,
        _context: context
      }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

      Object.defineProperties(Consumer, {
        Provider: {
          get: function () {
            if (!hasWarnedAboutUsingConsumerProvider) {
              hasWarnedAboutUsingConsumerProvider = true;

              error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
            }

            return context.Provider;
          },
          set: function (_Provider) {
            context.Provider = _Provider;
          }
        },
        _currentValue: {
          get: function () {
            return context._currentValue;
          },
          set: function (_currentValue) {
            context._currentValue = _currentValue;
          }
        },
        _currentValue2: {
          get: function () {
            return context._currentValue2;
          },
          set: function (_currentValue2) {
            context._currentValue2 = _currentValue2;
          }
        },
        _threadCount: {
          get: function () {
            return context._threadCount;
          },
          set: function (_threadCount) {
            context._threadCount = _threadCount;
          }
        },
        Consumer: {
          get: function () {
            if (!hasWarnedAboutUsingNestedContextConsumers) {
              hasWarnedAboutUsingNestedContextConsumers = true;

              error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
            }

            return context.Consumer;
          }
        },
        displayName: {
          get: function () {
            return context.displayName;
          },
          set: function (displayName) {
            if (!hasWarnedAboutDisplayNameOnConsumer) {
              warn('Setting `displayName` on Context.Consumer has no effect. ' + "You should set it directly on the context with Context.displayName = '%s'.", displayName);

              hasWarnedAboutDisplayNameOnConsumer = true;
            }
          }
        }
      }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

      context.Consumer = Consumer;
    }

    {
      context._currentRenderer = null;
      context._currentRenderer2 = null;
    }

    return context;
  }

  var Uninitialized = -1;
  var Pending = 0;
  var Resolved = 1;
  var Rejected = 2;

  function lazyInitializer(payload) {
    if (payload._status === Uninitialized) {
      var ctor = payload._result;
      var thenable = ctor(); // Transition to the next state.
      // This might throw either because it's missing or throws. If so, we treat it
      // as still uninitialized and try again next time. Which is the same as what
      // happens if the ctor or any wrappers processing the ctor throws. This might
      // end up fixing it if the resolution was a concurrency bug.

      thenable.then(function (moduleObject) {
        if (payload._status === Pending || payload._status === Uninitialized) {
          // Transition to the next state.
          var resolved = payload;
          resolved._status = Resolved;
          resolved._result = moduleObject;
        }
      }, function (error) {
        if (payload._status === Pending || payload._status === Uninitialized) {
          // Transition to the next state.
          var rejected = payload;
          rejected._status = Rejected;
          rejected._result = error;
        }
      });

      if (payload._status === Uninitialized) {
        // In case, we're still uninitialized, then we're waiting for the thenable
        // to resolve. Set it as pending in the meantime.
        var pending = payload;
        pending._status = Pending;
        pending._result = thenable;
      }
    }

    if (payload._status === Resolved) {
      var moduleObject = payload._result;

      {
        if (moduleObject === undefined) {
          error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
          'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))\n\n" + 'Did you accidentally put curly braces around the import?', moduleObject);
        }
      }

      {
        if (!('default' in moduleObject)) {
          error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\n\nYour code should look like: \n  ' + // Break up imports to avoid accidentally parsing them as dependencies.
          'const MyComponent = lazy(() => imp' + "ort('./MyComponent'))", moduleObject);
        }
      }

      return moduleObject.default;
    } else {
      throw payload._result;
    }
  }

  function lazy(ctor) {
    var payload = {
      // We use these fields to store the result.
      _status: Uninitialized,
      _result: ctor
    };
    var lazyType = {
      $$typeof: REACT_LAZY_TYPE,
      _payload: payload,
      _init: lazyInitializer
    };

    {
      // In production, this would just set it on the object.
      var defaultProps;
      var propTypes; // $FlowFixMe

      Object.defineProperties(lazyType, {
        defaultProps: {
          configurable: true,
          get: function () {
            return defaultProps;
          },
          set: function (newDefaultProps) {
            error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

            defaultProps = newDefaultProps; // Match production behavior more closely:
            // $FlowFixMe

            Object.defineProperty(lazyType, 'defaultProps', {
              enumerable: true
            });
          }
        },
        propTypes: {
          configurable: true,
          get: function () {
            return propTypes;
          },
          set: function (newPropTypes) {
            error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');

            propTypes = newPropTypes; // Match production behavior more closely:
            // $FlowFixMe

            Object.defineProperty(lazyType, 'propTypes', {
              enumerable: true
            });
          }
        }
      });
    }

    return lazyType;
  }

  function forwardRef(render) {
    {
      if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
        error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
      } else if (typeof render !== 'function') {
        error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
      } else {
        if (render.length !== 0 && render.length !== 2) {
          error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');
        }
      }

      if (render != null) {
        if (render.defaultProps != null || render.propTypes != null) {
          error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');
        }
      }
    }

    var elementType = {
      $$typeof: REACT_FORWARD_REF_TYPE,
      render: render
    };

    {
      var ownName;
      Object.defineProperty(elementType, 'displayName', {
        enumerable: false,
        configurable: true,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name; // The inner component shouldn't inherit this display name in most cases,
          // because the component may be used elsewhere.
          // But it's nice for anonymous functions to inherit the name,
          // so that our component-stack generation logic will display their frames.
          // An anonymous function generally suggests a pattern like:
          //   React.forwardRef((props, ref) => {...});
          // This kind of inner function is not used elsewhere so the side effect is okay.

          if (!render.name && !render.displayName) {
            render.displayName = name;
          }
        }
      });
    }

    return elementType;
  }

  var REACT_MODULE_REFERENCE;

  {
    REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');
  }

  function isValidElementType(type) {
    if (typeof type === 'string' || typeof type === 'function') {
      return true;
    } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).


    if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {
      return true;
    }

    if (typeof type === 'object' && type !== null) {
      if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
        return true;
      }
    }

    return false;
  }

  function memo(type, compare) {
    {
      if (!isValidElementType(type)) {
        error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
      }
    }

    var elementType = {
      $$typeof: REACT_MEMO_TYPE,
      type: type,
      compare: compare === undefined ? null : compare
    };

    {
      var ownName;
      Object.defineProperty(elementType, 'displayName', {
        enumerable: false,
        configurable: true,
        get: function () {
          return ownName;
        },
        set: function (name) {
          ownName = name; // The inner component shouldn't inherit this display name in most cases,
          // because the component may be used elsewhere.
          // But it's nice for anonymous functions to inherit the name,
          // so that our component-stack generation logic will display their frames.
          // An anonymous function generally suggests a pattern like:
          //   React.memo((props) => {...});
          // This kind of inner function is not used elsewhere so the side effect is okay.

          if (!type.name && !type.displayName) {
            type.displayName = name;
          }
        }
      });
    }

    return elementType;
  }

  function resolveDispatcher() {
    var dispatcher = ReactCurrentDispatcher.current;

    {
      if (dispatcher === null) {
        error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\n' + '2. You might be breaking the Rules of Hooks\n' + '3. You might have more than one copy of React in the same app\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');
      }
    } // Will result in a null access error if accessed outside render phase. We
    // intentionally don't throw our own error because this is in a hot path.
    // Also helps ensure this is inlined.


    return dispatcher;
  }
  function useContext(Context) {
    var dispatcher = resolveDispatcher();

    {
      // TODO: add a more generic warning for invalid values.
      if (Context._context !== undefined) {
        var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
        // and nobody should be using this in existing code.

        if (realContext.Consumer === Context) {
          error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
        } else if (realContext.Provider === Context) {
          error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
        }
      }
    }

    return dispatcher.useContext(Context);
  }
  function useState(initialState) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useState(initialState);
  }
  function useReducer(reducer, initialArg, init) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useReducer(reducer, initialArg, init);
  }
  function useRef(initialValue) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useRef(initialValue);
  }
  function useEffect(create, deps) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useEffect(create, deps);
  }
  function useInsertionEffect(create, deps) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useInsertionEffect(create, deps);
  }
  function useLayoutEffect(create, deps) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useLayoutEffect(create, deps);
  }
  function useCallback(callback, deps) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useCallback(callback, deps);
  }
  function useMemo(create, deps) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useMemo(create, deps);
  }
  function useImperativeHandle(ref, create, deps) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useImperativeHandle(ref, create, deps);
  }
  function useDebugValue(value, formatterFn) {
    {
      var dispatcher = resolveDispatcher();
      return dispatcher.useDebugValue(value, formatterFn);
    }
  }
  function useTransition() {
    var dispatcher = resolveDispatcher();
    return dispatcher.useTransition();
  }
  function useDeferredValue(value) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useDeferredValue(value);
  }
  function useId() {
    var dispatcher = resolveDispatcher();
    return dispatcher.useId();
  }
  function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
    var dispatcher = resolveDispatcher();
    return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  }

  // Helpers to patch console.logs to avoid logging during side-effect free
  // replaying on render function. This currently only patches the object
  // lazily which won't cover if the log function was extracted eagerly.
  // We could also eagerly patch the method.
  var disabledDepth = 0;
  var prevLog;
  var prevInfo;
  var prevWarn;
  var prevError;
  var prevGroup;
  var prevGroupCollapsed;
  var prevGroupEnd;

  function disabledLog() {}

  disabledLog.__reactDisabledLog = true;
  function disableLogs() {
    {
      if (disabledDepth === 0) {
        /* eslint-disable react-internal/no-production-logging */
        prevLog = console.log;
        prevInfo = console.info;
        prevWarn = console.warn;
        prevError = console.error;
        prevGroup = console.group;
        prevGroupCollapsed = console.groupCollapsed;
        prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

        var props = {
          configurable: true,
          enumerable: true,
          value: disabledLog,
          writable: true
        }; // $FlowFixMe Flow thinks console is immutable.

        Object.defineProperties(console, {
          info: props,
          log: props,
          warn: props,
          error: props,
          group: props,
          groupCollapsed: props,
          groupEnd: props
        });
        /* eslint-enable react-internal/no-production-logging */
      }

      disabledDepth++;
    }
  }
  function reenableLogs() {
    {
      disabledDepth--;

      if (disabledDepth === 0) {
        /* eslint-disable react-internal/no-production-logging */
        var props = {
          configurable: true,
          enumerable: true,
          writable: true
        }; // $FlowFixMe Flow thinks console is immutable.

        Object.defineProperties(console, {
          log: assign({}, props, {
            value: prevLog
          }),
          info: assign({}, props, {
            value: prevInfo
          }),
          warn: assign({}, props, {
            value: prevWarn
          }),
          error: assign({}, props, {
            value: prevError
          }),
          group: assign({}, props, {
            value: prevGroup
          }),
          groupCollapsed: assign({}, props, {
            value: prevGroupCollapsed
          }),
          groupEnd: assign({}, props, {
            value: prevGroupEnd
          })
        });
        /* eslint-enable react-internal/no-production-logging */
      }

      if (disabledDepth < 0) {
        error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
      }
    }
  }

  var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
  var prefix;
  function describeBuiltInComponentFrame(name, source, ownerFn) {
    {
      if (prefix === undefined) {
        // Extract the VM specific prefix used by each line.
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || '';
        }
      } // We use the prefix to ensure our stacks line up with native stack frames.


      return '\n' + prefix + name;
    }
  }
  var reentry = false;
  var componentFrameCache;

  {
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
    componentFrameCache = new PossiblyWeakMap();
  }

  function describeNativeComponentFrame(fn, construct) {
    // If something asked for a stack inside a fake render, it should get ignored.
    if ( !fn || reentry) {
      return '';
    }

    {
      var frame = componentFrameCache.get(fn);

      if (frame !== undefined) {
        return frame;
      }
    }

    var control;
    reentry = true;
    var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

    Error.prepareStackTrace = undefined;
    var previousDispatcher;

    {
      previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function
      // for warnings.

      ReactCurrentDispatcher$1.current = null;
      disableLogs();
    }

    try {
      // This should throw.
      if (construct) {
        // Something should be setting the props in the constructor.
        var Fake = function () {
          throw Error();
        }; // $FlowFixMe


        Object.defineProperty(Fake.prototype, 'props', {
          set: function () {
            // We use a throwing setter instead of frozen or non-writable props
            // because that won't throw in a non-strict mode function.
            throw Error();
          }
        });

        if (typeof Reflect === 'object' && Reflect.construct) {
          // We construct a different control for this case to include any extra
          // frames added by the construct call.
          try {
            Reflect.construct(Fake, []);
          } catch (x) {
            control = x;
          }

          Reflect.construct(fn, [], Fake);
        } else {
          try {
            Fake.call();
          } catch (x) {
            control = x;
          }

          fn.call(Fake.prototype);
        }
      } else {
        try {
          throw Error();
        } catch (x) {
          control = x;
        }

        fn();
      }
    } catch (sample) {
      // This is inlined manually because closure doesn't do it for us.
      if (sample && control && typeof sample.stack === 'string') {
        // This extracts the first frame from the sample that isn't also in the control.
        // Skipping one frame that we assume is the frame that calls the two.
        var sampleLines = sample.stack.split('\n');
        var controlLines = control.stack.split('\n');
        var s = sampleLines.length - 1;
        var c = controlLines.length - 1;

        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
          // We expect at least one stack frame to be shared.
          // Typically this will be the root most one. However, stack frames may be
          // cut off due to maximum stack limits. In this case, one maybe cut off
          // earlier than the other. We assume that the sample is longer or the same
          // and there for cut off earlier. So we should find the root most frame in
          // the sample somewhere in the control.
          c--;
        }

        for (; s >= 1 && c >= 0; s--, c--) {
          // Next we find the first one that isn't the same which should be the
          // frame that called our sample function and the control.
          if (sampleLines[s] !== controlLines[c]) {
            // In V8, the first line is describing the message but other VMs don't.
            // If we're about to return the first line, and the control is also on the same
            // line, that's a pretty good indicator that our sample threw at same line as
            // the control. I.e. before we entered the sample frame. So we ignore this result.
            // This can happen if you passed a class to function component, or non-function.
            if (s !== 1 || c !== 1) {
              do {
                s--;
                c--; // We may still have similar intermediate frames from the construct call.
                // The next one that isn't the same should be our match though.

                if (c < 0 || sampleLines[s] !== controlLines[c]) {
                  // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                  var _frame = '\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled "<anonymous>"
                  // but we have a user-provided "displayName"
                  // splice it in to make the stack more readable.


                  if (fn.displayName && _frame.includes('<anonymous>')) {
                    _frame = _frame.replace('<anonymous>', fn.displayName);
                  }

                  {
                    if (typeof fn === 'function') {
                      componentFrameCache.set(fn, _frame);
                    }
                  } // Return the line we found.


                  return _frame;
                }
              } while (s >= 1 && c >= 0);
            }

            break;
          }
        }
      }
    } finally {
      reentry = false;

      {
        ReactCurrentDispatcher$1.current = previousDispatcher;
        reenableLogs();
      }

      Error.prepareStackTrace = previousPrepareStackTrace;
    } // Fallback to just using the name if we couldn't make it throw.


    var name = fn ? fn.displayName || fn.name : '';
    var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

    {
      if (typeof fn === 'function') {
        componentFrameCache.set(fn, syntheticFrame);
      }
    }

    return syntheticFrame;
  }
  function describeFunctionComponentFrame(fn, source, ownerFn) {
    {
      return describeNativeComponentFrame(fn, false);
    }
  }

  function shouldConstruct(Component) {
    var prototype = Component.prototype;
    return !!(prototype && prototype.isReactComponent);
  }

  function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {

    if (type == null) {
      return '';
    }

    if (typeof type === 'function') {
      {
        return describeNativeComponentFrame(type, shouldConstruct(type));
      }
    }

    if (typeof type === 'string') {
      return describeBuiltInComponentFrame(type);
    }

    switch (type) {
      case REACT_SUSPENSE_TYPE:
        return describeBuiltInComponentFrame('Suspense');

      case REACT_SUSPENSE_LIST_TYPE:
        return describeBuiltInComponentFrame('SuspenseList');
    }

    if (typeof type === 'object') {
      switch (type.$$typeof) {
        case REACT_FORWARD_REF_TYPE:
          return describeFunctionComponentFrame(type.render);

        case REACT_MEMO_TYPE:
          // Memo may contain any component type so we recursively resolve it.
          return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);

        case REACT_LAZY_TYPE:
          {
            var lazyComponent = type;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;

            try {
              // Lazy may contain any component type so we recursively resolve it.
              return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
            } catch (x) {}
          }
      }
    }

    return '';
  }

  var loggedTypeFailures = {};
  var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;

  function setCurrentlyValidatingElement(element) {
    {
      if (element) {
        var owner = element._owner;
        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
      } else {
        ReactDebugCurrentFrame$1.setExtraStackFrame(null);
      }
    }
  }

  function checkPropTypes(typeSpecs, values, location, componentName, element) {
    {
      // $FlowFixMe This is okay but Flow doesn't know it.
      var has = Function.call.bind(hasOwnProperty);

      for (var typeSpecName in typeSpecs) {
        if (has(typeSpecs, typeSpecName)) {
          var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to
          // fail the render phase where it didn't fail before. So we log it.
          // After these have been cleaned up, we'll let them throw.

          try {
            // This is intentionally an invariant that gets caught. It's the same
            // behavior as without this statement except with a better message.
            if (typeof typeSpecs[typeSpecName] !== 'function') {
              // eslint-disable-next-line react-internal/prod-error-codes
              var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
              err.name = 'Invariant Violation';
              throw err;
            }

            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');
          } catch (ex) {
            error$1 = ex;
          }

          if (error$1 && !(error$1 instanceof Error)) {
            setCurrentlyValidatingElement(element);

            error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);

            setCurrentlyValidatingElement(null);
          }

          if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
            // Only monitor this failure once because there tends to be a lot of the
            // same error.
            loggedTypeFailures[error$1.message] = true;
            setCurrentlyValidatingElement(element);

            error('Failed %s type: %s', location, error$1.message);

            setCurrentlyValidatingElement(null);
          }
        }
      }
    }
  }

  function setCurrentlyValidatingElement$1(element) {
    {
      if (element) {
        var owner = element._owner;
        var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        setExtraStackFrame(stack);
      } else {
        setExtraStackFrame(null);
      }
    }
  }

  var propTypesMisspellWarningShown;

  {
    propTypesMisspellWarningShown = false;
  }

  function getDeclarationErrorAddendum() {
    if (ReactCurrentOwner.current) {
      var name = getComponentNameFromType(ReactCurrentOwner.current.type);

      if (name) {
        return '\n\nCheck the render method of `' + name + '`.';
      }
    }

    return '';
  }

  function getSourceInfoErrorAddendum(source) {
    if (source !== undefined) {
      var fileName = source.fileName.replace(/^.*[\\\/]/, '');
      var lineNumber = source.lineNumber;
      return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
    }

    return '';
  }

  function getSourceInfoErrorAddendumForProps(elementProps) {
    if (elementProps !== null && elementProps !== undefined) {
      return getSourceInfoErrorAddendum(elementProps.__source);
    }

    return '';
  }
  /**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */


  var ownerHasKeyUseWarning = {};

  function getCurrentComponentErrorInfo(parentType) {
    var info = getDeclarationErrorAddendum();

    if (!info) {
      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

      if (parentName) {
        info = "\n\nCheck the top-level render call using <" + parentName + ">.";
      }
    }

    return info;
  }
  /**
   * Warn if the element doesn't have an explicit key assigned to it.
   * This element is in an array. The array could grow and shrink or be
   * reordered. All children that haven't already been validated are required to
   * have a "key" property assigned to it. Error statuses are cached so a warning
   * will only be shown once.
   *
   * @internal
   * @param {ReactElement} element Element that requires a key.
   * @param {*} parentType element's parent's type.
   */


  function validateExplicitKey(element, parentType) {
    if (!element._store || element._store.validated || element.key != null) {
      return;
    }

    element._store.validated = true;
    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
      return;
    }

    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
    // property, it may be the creator of the child that's responsible for
    // assigning it a key.

    var childOwner = '';

    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
      // Give the component that originally created this child.
      childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
    }

    {
      setCurrentlyValidatingElement$1(element);

      error('Each child in a list should have a unique "key" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);

      setCurrentlyValidatingElement$1(null);
    }
  }
  /**
   * Ensure that every element either is passed in a static location, in an
   * array with an explicit keys property defined, or in an object literal
   * with valid key property.
   *
   * @internal
   * @param {ReactNode} node Statically passed child of any type.
   * @param {*} parentType node's parent's type.
   */


  function validateChildKeys(node, parentType) {
    if (typeof node !== 'object') {
      return;
    }

    if (isArray(node)) {
      for (var i = 0; i < node.length; i++) {
        var child = node[i];

        if (isValidElement(child)) {
          validateExplicitKey(child, parentType);
        }
      }
    } else if (isValidElement(node)) {
      // This element was passed in a valid location.
      if (node._store) {
        node._store.validated = true;
      }
    } else if (node) {
      var iteratorFn = getIteratorFn(node);

      if (typeof iteratorFn === 'function') {
        // Entry iterators used to provide implicit keys,
        // but now we print a separate warning for them later.
        if (iteratorFn !== node.entries) {
          var iterator = iteratorFn.call(node);
          var step;

          while (!(step = iterator.next()).done) {
            if (isValidElement(step.value)) {
              validateExplicitKey(step.value, parentType);
            }
          }
        }
      }
    }
  }
  /**
   * Given an element, validate that its props follow the propTypes definition,
   * provided by the type.
   *
   * @param {ReactElement} element
   */


  function validatePropTypes(element) {
    {
      var type = element.type;

      if (type === null || type === undefined || typeof type === 'string') {
        return;
      }

      var propTypes;

      if (typeof type === 'function') {
        propTypes = type.propTypes;
      } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
      // Inner props are checked in the reconciler.
      type.$$typeof === REACT_MEMO_TYPE)) {
        propTypes = type.propTypes;
      } else {
        return;
      }

      if (propTypes) {
        // Intentionally inside to avoid triggering lazy initializers:
        var name = getComponentNameFromType(type);
        checkPropTypes(propTypes, element.props, 'prop', name, element);
      } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:

        var _name = getComponentNameFromType(type);

        error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');
      }

      if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {
        error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }
  }
  /**
   * Given a fragment, validate that it can only be provided with fragment props
   * @param {ReactElement} fragment
   */


  function validateFragmentProps(fragment) {
    {
      var keys = Object.keys(fragment.props);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (key !== 'children' && key !== 'key') {
          setCurrentlyValidatingElement$1(fragment);

          error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);

          setCurrentlyValidatingElement$1(null);
          break;
        }
      }

      if (fragment.ref !== null) {
        setCurrentlyValidatingElement$1(fragment);

        error('Invalid attribute `ref` supplied to `React.Fragment`.');

        setCurrentlyValidatingElement$1(null);
      }
    }
  }
  function createElementWithValidation(type, props, children) {
    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.

    if (!validType) {
      var info = '';

      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
        info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
      }

      var sourceInfo = getSourceInfoErrorAddendumForProps(props);

      if (sourceInfo) {
        info += sourceInfo;
      } else {
        info += getDeclarationErrorAddendum();
      }

      var typeString;

      if (type === null) {
        typeString = 'null';
      } else if (isArray(type)) {
        typeString = 'array';
      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
        typeString = "<" + (getComponentNameFromType(type.type) || 'Unknown') + " />";
        info = ' Did you accidentally export a JSX literal instead of a component?';
      } else {
        typeString = typeof type;
      }

      {
        error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
      }
    }

    var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.

    if (element == null) {
      return element;
    } // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)


    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    if (type === REACT_FRAGMENT_TYPE) {
      validateFragmentProps(element);
    } else {
      validatePropTypes(element);
    }

    return element;
  }
  var didWarnAboutDeprecatedCreateFactory = false;
  function createFactoryWithValidation(type) {
    var validatedFactory = createElementWithValidation.bind(null, type);
    validatedFactory.type = type;

    {
      if (!didWarnAboutDeprecatedCreateFactory) {
        didWarnAboutDeprecatedCreateFactory = true;

        warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');
      } // Legacy hook: remove it


      Object.defineProperty(validatedFactory, 'type', {
        enumerable: false,
        get: function () {
          warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');

          Object.defineProperty(this, 'type', {
            value: type
          });
          return type;
        }
      });
    }

    return validatedFactory;
  }
  function cloneElementWithValidation(element, props, children) {
    var newElement = cloneElement.apply(this, arguments);

    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }

    validatePropTypes(newElement);
    return newElement;
  }

  var enableSchedulerDebugging = false;
  var enableProfiling = false;
  var frameYieldMs = 5;

  function push(heap, node) {
    var index = heap.length;
    heap.push(node);
    siftUp(heap, node, index);
  }
  function peek(heap) {
    return heap.length === 0 ? null : heap[0];
  }
  function pop(heap) {
    if (heap.length === 0) {
      return null;
    }

    var first = heap[0];
    var last = heap.pop();

    if (last !== first) {
      heap[0] = last;
      siftDown(heap, last, 0);
    }

    return first;
  }

  function siftUp(heap, node, i) {
    var index = i;

    while (index > 0) {
      var parentIndex = index - 1 >>> 1;
      var parent = heap[parentIndex];

      if (compare(parent, node) > 0) {
        // The parent is larger. Swap positions.
        heap[parentIndex] = node;
        heap[index] = parent;
        index = parentIndex;
      } else {
        // The parent is smaller. Exit.
        return;
      }
    }
  }

  function siftDown(heap, node, i) {
    var index = i;
    var length = heap.length;
    var halfLength = length >>> 1;

    while (index < halfLength) {
      var leftIndex = (index + 1) * 2 - 1;
      var left = heap[leftIndex];
      var rightIndex = leftIndex + 1;
      var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.

      if (compare(left, node) < 0) {
        if (rightIndex < length && compare(right, left) < 0) {
          heap[index] = right;
          heap[rightIndex] = node;
          index = rightIndex;
        } else {
          heap[index] = left;
          heap[leftIndex] = node;
          index = leftIndex;
        }
      } else if (rightIndex < length && compare(right, node) < 0) {
        heap[index] = right;
        heap[rightIndex] = node;
        index = rightIndex;
      } else {
        // Neither child is smaller. Exit.
        return;
      }
    }
  }

  function compare(a, b) {
    // Compare sort index first, then task id.
    var diff = a.sortIndex - b.sortIndex;
    return diff !== 0 ? diff : a.id - b.id;
  }

  // TODO: Use symbols?
  var ImmediatePriority = 1;
  var UserBlockingPriority = 2;
  var NormalPriority = 3;
  var LowPriority = 4;
  var IdlePriority = 5;

  function markTaskErrored(task, ms) {
  }

  /* eslint-disable no-var */
  var getCurrentTime;
  var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

  if (hasPerformanceNow) {
    var localPerformance = performance;

    getCurrentTime = function () {
      return localPerformance.now();
    };
  } else {
    var localDate = Date;
    var initialTime = localDate.now();

    getCurrentTime = function () {
      return localDate.now() - initialTime;
    };
  } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
  // Math.pow(2, 30) - 1
  // 0b111111111111111111111111111111


  var maxSigned31BitInt = 1073741823; // Times out immediately

  var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

  var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
  var NORMAL_PRIORITY_TIMEOUT = 5000;
  var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

  var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap

  var taskQueue = [];
  var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.

  var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.
  var currentTask = null;
  var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.

  var isPerformingWork = false;
  var isHostCallbackScheduled = false;
  var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.

  var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;
  var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;
  var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom

  var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;

  function advanceTimers(currentTime) {
    // Check for tasks that are no longer delayed and add them to the queue.
    var timer = peek(timerQueue);

    while (timer !== null) {
      if (timer.callback === null) {
        // Timer was cancelled.
        pop(timerQueue);
      } else if (timer.startTime <= currentTime) {
        // Timer fired. Transfer to the task queue.
        pop(timerQueue);
        timer.sortIndex = timer.expirationTime;
        push(taskQueue, timer);
      } else {
        // Remaining timers are pending.
        return;
      }

      timer = peek(timerQueue);
    }
  }

  function handleTimeout(currentTime) {
    isHostTimeoutScheduled = false;
    advanceTimers(currentTime);

    if (!isHostCallbackScheduled) {
      if (peek(taskQueue) !== null) {
        isHostCallbackScheduled = true;
        requestHostCallback(flushWork);
      } else {
        var firstTimer = peek(timerQueue);

        if (firstTimer !== null) {
          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
      }
    }
  }

  function flushWork(hasTimeRemaining, initialTime) {


    isHostCallbackScheduled = false;

    if (isHostTimeoutScheduled) {
      // We scheduled a timeout but it's no longer needed. Cancel it.
      isHostTimeoutScheduled = false;
      cancelHostTimeout();
    }

    isPerformingWork = true;
    var previousPriorityLevel = currentPriorityLevel;

    try {
      if (enableProfiling) {
        try {
          return workLoop(hasTimeRemaining, initialTime);
        } catch (error) {
          if (currentTask !== null) {
            var currentTime = getCurrentTime();
            markTaskErrored(currentTask, currentTime);
            currentTask.isQueued = false;
          }

          throw error;
        }
      } else {
        // No catch in prod code path.
        return workLoop(hasTimeRemaining, initialTime);
      }
    } finally {
      currentTask = null;
      currentPriorityLevel = previousPriorityLevel;
      isPerformingWork = false;
    }
  }

  function workLoop(hasTimeRemaining, initialTime) {
    var currentTime = initialTime;
    advanceTimers(currentTime);
    currentTask = peek(taskQueue);

    while (currentTask !== null && !(enableSchedulerDebugging )) {
      if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
        // This currentTask hasn't expired, and we've reached the deadline.
        break;
      }

      var callback = currentTask.callback;

      if (typeof callback === 'function') {
        currentTask.callback = null;
        currentPriorityLevel = currentTask.priorityLevel;
        var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;

        var continuationCallback = callback(didUserCallbackTimeout);
        currentTime = getCurrentTime();

        if (typeof continuationCallback === 'function') {
          currentTask.callback = continuationCallback;
        } else {

          if (currentTask === peek(taskQueue)) {
            pop(taskQueue);
          }
        }

        advanceTimers(currentTime);
      } else {
        pop(taskQueue);
      }

      currentTask = peek(taskQueue);
    } // Return whether there's additional work


    if (currentTask !== null) {
      return true;
    } else {
      var firstTimer = peek(timerQueue);

      if (firstTimer !== null) {
        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
      }

      return false;
    }
  }

  function unstable_runWithPriority(priorityLevel, eventHandler) {
    switch (priorityLevel) {
      case ImmediatePriority:
      case UserBlockingPriority:
      case NormalPriority:
      case LowPriority:
      case IdlePriority:
        break;

      default:
        priorityLevel = NormalPriority;
    }

    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;

    try {
      return eventHandler();
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  }

  function unstable_next(eventHandler) {
    var priorityLevel;

    switch (currentPriorityLevel) {
      case ImmediatePriority:
      case UserBlockingPriority:
      case NormalPriority:
        // Shift down to normal priority
        priorityLevel = NormalPriority;
        break;

      default:
        // Anything lower than normal priority should remain at the current level.
        priorityLevel = currentPriorityLevel;
        break;
    }

    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;

    try {
      return eventHandler();
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  }

  function unstable_wrapCallback(callback) {
    var parentPriorityLevel = currentPriorityLevel;
    return function () {
      // This is a fork of runWithPriority, inlined for performance.
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = parentPriorityLevel;

      try {
        return callback.apply(this, arguments);
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
  }

  function unstable_scheduleCallback(priorityLevel, callback, options) {
    var currentTime = getCurrentTime();
    var startTime;

    if (typeof options === 'object' && options !== null) {
      var delay = options.delay;

      if (typeof delay === 'number' && delay > 0) {
        startTime = currentTime + delay;
      } else {
        startTime = currentTime;
      }
    } else {
      startTime = currentTime;
    }

    var timeout;

    switch (priorityLevel) {
      case ImmediatePriority:
        timeout = IMMEDIATE_PRIORITY_TIMEOUT;
        break;

      case UserBlockingPriority:
        timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
        break;

      case IdlePriority:
        timeout = IDLE_PRIORITY_TIMEOUT;
        break;

      case LowPriority:
        timeout = LOW_PRIORITY_TIMEOUT;
        break;

      case NormalPriority:
      default:
        timeout = NORMAL_PRIORITY_TIMEOUT;
        break;
    }

    var expirationTime = startTime + timeout;
    var newTask = {
      id: taskIdCounter++,
      callback: callback,
      priorityLevel: priorityLevel,
      startTime: startTime,
      expirationTime: expirationTime,
      sortIndex: -1
    };

    if (startTime > currentTime) {
      // This is a delayed task.
      newTask.sortIndex = startTime;
      push(timerQueue, newTask);

      if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
        // All tasks are delayed, and this is the task with the earliest delay.
        if (isHostTimeoutScheduled) {
          // Cancel an existing timeout.
          cancelHostTimeout();
        } else {
          isHostTimeoutScheduled = true;
        } // Schedule a timeout.


        requestHostTimeout(handleTimeout, startTime - currentTime);
      }
    } else {
      newTask.sortIndex = expirationTime;
      push(taskQueue, newTask);
      // wait until the next time we yield.


      if (!isHostCallbackScheduled && !isPerformingWork) {
        isHostCallbackScheduled = true;
        requestHostCallback(flushWork);
      }
    }

    return newTask;
  }

  function unstable_pauseExecution() {
  }

  function unstable_continueExecution() {

    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  function unstable_getFirstCallbackNode() {
    return peek(taskQueue);
  }

  function unstable_cancelCallback(task) {
    // remove from the queue because you can't remove arbitrary nodes from an
    // array based heap, only the first one.)


    task.callback = null;
  }

  function unstable_getCurrentPriorityLevel() {
    return currentPriorityLevel;
  }

  var isMessageLoopRunning = false;
  var scheduledHostCallback = null;
  var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main
  // thread, like user events. By default, it yields multiple times per frame.
  // It does not attempt to align with frame boundaries, since most tasks don't
  // need to be frame aligned; for those that do, use requestAnimationFrame.

  var frameInterval = frameYieldMs;
  var startTime = -1;

  function shouldYieldToHost() {
    var timeElapsed = getCurrentTime() - startTime;

    if (timeElapsed < frameInterval) {
      // The main thread has only been blocked for a really short amount of time;
      // smaller than a single frame. Don't yield yet.
      return false;
    } // The main thread has been blocked for a non-negligible amount of time. We


    return true;
  }

  function requestPaint() {

  }

  function forceFrameRate(fps) {
    if (fps < 0 || fps > 125) {
      // Using console['error'] to evade Babel and ESLint
      console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');
      return;
    }

    if (fps > 0) {
      frameInterval = Math.floor(1000 / fps);
    } else {
      // reset the framerate
      frameInterval = frameYieldMs;
    }
  }

  var performWorkUntilDeadline = function () {
    if (scheduledHostCallback !== null) {
      var currentTime = getCurrentTime(); // Keep track of the start time so we can measure how long the main thread
      // has been blocked.

      startTime = currentTime;
      var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the
      // error can be observed.
      //
      // Intentionally not using a try-catch, since that makes some debugging
      // techniques harder. Instead, if `scheduledHostCallback` errors, then
      // `hasMoreWork` will remain true, and we'll continue the work loop.

      var hasMoreWork = true;

      try {
        hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
      } finally {
        if (hasMoreWork) {
          // If there's more work, schedule the next message event at the end
          // of the preceding one.
          schedulePerformWorkUntilDeadline();
        } else {
          isMessageLoopRunning = false;
          scheduledHostCallback = null;
        }
      }
    } else {
      isMessageLoopRunning = false;
    } // Yielding to the browser will give it a chance to paint, so we can
  };

  var schedulePerformWorkUntilDeadline;

  if (typeof localSetImmediate === 'function') {
    // Node.js and old IE.
    // There's a few reasons for why we prefer setImmediate.
    //
    // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.
    // (Even though this is a DOM fork of the Scheduler, you could get here
    // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)
    // https://github.com/facebook/react/issues/20756
    //
    // But also, it runs earlier which is the semantic we want.
    // If other browsers ever implement it, it's better to use it.
    // Although both of these would be inferior to native scheduling.
    schedulePerformWorkUntilDeadline = function () {
      localSetImmediate(performWorkUntilDeadline);
    };
  } else if (typeof MessageChannel !== 'undefined') {
    // DOM and Worker environments.
    // We prefer MessageChannel because of the 4ms setTimeout clamping.
    var channel = new MessageChannel();
    var port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;

    schedulePerformWorkUntilDeadline = function () {
      port.postMessage(null);
    };
  } else {
    // We should only fallback here in non-browser environments.
    schedulePerformWorkUntilDeadline = function () {
      localSetTimeout(performWorkUntilDeadline, 0);
    };
  }

  function requestHostCallback(callback) {
    scheduledHostCallback = callback;

    if (!isMessageLoopRunning) {
      isMessageLoopRunning = true;
      schedulePerformWorkUntilDeadline();
    }
  }

  function requestHostTimeout(callback, ms) {
    taskTimeoutID = localSetTimeout(function () {
      callback(getCurrentTime());
    }, ms);
  }

  function cancelHostTimeout() {
    localClearTimeout(taskTimeoutID);
    taskTimeoutID = -1;
  }

  var unstable_requestPaint = requestPaint;
  var unstable_Profiling =  null;



  var Scheduler = /*#__PURE__*/Object.freeze({
    __proto__: null,
    unstable_ImmediatePriority: ImmediatePriority,
    unstable_UserBlockingPriority: UserBlockingPriority,
    unstable_NormalPriority: NormalPriority,
    unstable_IdlePriority: IdlePriority,
    unstable_LowPriority: LowPriority,
    unstable_runWithPriority: unstable_runWithPriority,
    unstable_next: unstable_next,
    unstable_scheduleCallback: unstable_scheduleCallback,
    unstable_cancelCallback: unstable_cancelCallback,
    unstable_wrapCallback: unstable_wrapCallback,
    unstable_getCurrentPriorityLevel: unstable_getCurrentPriorityLevel,
    unstable_shouldYield: shouldYieldToHost,
    unstable_requestPaint: unstable_requestPaint,
    unstable_continueExecution: unstable_continueExecution,
    unstable_pauseExecution: unstable_pauseExecution,
    unstable_getFirstCallbackNode: unstable_getFirstCallbackNode,
    get unstable_now () { return getCurrentTime; },
    unstable_forceFrameRate: forceFrameRate,
    unstable_Profiling: unstable_Profiling
  });

  var ReactSharedInternals$1 = {
    ReactCurrentDispatcher: ReactCurrentDispatcher,
    ReactCurrentOwner: ReactCurrentOwner,
    ReactCurrentBatchConfig: ReactCurrentBatchConfig,
    // Re-export the schedule API(s) for UMD bundles.
    // This avoids introducing a dependency on a new UMD global in a minor update,
    // Since that would be a breaking change (e.g. for all existing CodeSandboxes).
    // This re-export is only required for UMD bundles;
    // CJS bundles use the shared NPM package.
    Scheduler: Scheduler
  };

  {
    ReactSharedInternals$1.ReactCurrentActQueue = ReactCurrentActQueue;
    ReactSharedInternals$1.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
  }

  function startTransition(scope, options) {
    var prevTransition = ReactCurrentBatchConfig.transition;
    ReactCurrentBatchConfig.transition = {};
    var currentTransition = ReactCurrentBatchConfig.transition;

    {
      ReactCurrentBatchConfig.transition._updatedFibers = new Set();
    }

    try {
      scope();
    } finally {
      ReactCurrentBatchConfig.transition = prevTransition;

      {
        if (prevTransition === null && currentTransition._updatedFibers) {
          var updatedFibersCount = currentTransition._updatedFibers.size;

          if (updatedFibersCount > 10) {
            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');
          }

          currentTransition._updatedFibers.clear();
        }
      }
    }
  }

  var didWarnAboutMessageChannel = false;
  var enqueueTaskImpl = null;
  function enqueueTask(task) {
    if (enqueueTaskImpl === null) {
      try {
        // read require off the module object to get around the bundlers.
        // we don't want them to detect a require and bundle a Node polyfill.
        var requireString = ('require' + Math.random()).slice(0, 7);
        var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's
        // version of setImmediate, bypassing fake timers if any.

        enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;
      } catch (_err) {
        // we're in a browser
        // we can't use regular timers because they may still be faked
        // so we try MessageChannel+postMessage instead
        enqueueTaskImpl = function (callback) {
          {
            if (didWarnAboutMessageChannel === false) {
              didWarnAboutMessageChannel = true;

              if (typeof MessageChannel === 'undefined') {
                error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');
              }
            }
          }

          var channel = new MessageChannel();
          channel.port1.onmessage = callback;
          channel.port2.postMessage(undefined);
        };
      }
    }

    return enqueueTaskImpl(task);
  }

  var actScopeDepth = 0;
  var didWarnNoAwaitAct = false;
  function act(callback) {
    {
      // `act` calls can be nested, so we track the depth. This represents the
      // number of `act` scopes on the stack.
      var prevActScopeDepth = actScopeDepth;
      actScopeDepth++;

      if (ReactCurrentActQueue.current === null) {
        // This is the outermost `act` scope. Initialize the queue. The reconciler
        // will detect the queue and use it instead of Scheduler.
        ReactCurrentActQueue.current = [];
      }

      var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
      var result;

      try {
        // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only
        // set to `true` while the given callback is executed, not for updates
        // triggered during an async event, because this is how the legacy
        // implementation of `act` behaved.
        ReactCurrentActQueue.isBatchingLegacy = true;
        result = callback(); // Replicate behavior of original `act` implementation in legacy mode,
        // which flushed updates immediately after the scope function exits, even
        // if it's an async function.

        if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
          var queue = ReactCurrentActQueue.current;

          if (queue !== null) {
            ReactCurrentActQueue.didScheduleLegacyUpdate = false;
            flushActQueue(queue);
          }
        }
      } catch (error) {
        popActScope(prevActScopeDepth);
        throw error;
      } finally {
        ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
      }

      if (result !== null && typeof result === 'object' && typeof result.then === 'function') {
        var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait
        // for it to resolve before exiting the current scope.

        var wasAwaited = false;
        var thenable = {
          then: function (resolve, reject) {
            wasAwaited = true;
            thenableResult.then(function (returnValue) {
              popActScope(prevActScopeDepth);

              if (actScopeDepth === 0) {
                // We've exited the outermost act scope. Recursively flush the
                // queue until there's no remaining work.
                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              } else {
                resolve(returnValue);
              }
            }, function (error) {
              // The callback threw an error.
              popActScope(prevActScopeDepth);
              reject(error);
            });
          }
        };

        {
          if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {
            // eslint-disable-next-line no-undef
            Promise.resolve().then(function () {}).then(function () {
              if (!wasAwaited) {
                didWarnNoAwaitAct = true;

                error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');
              }
            });
          }
        }

        return thenable;
      } else {
        var returnValue = result; // The callback is not an async function. Exit the current scope
        // immediately, without awaiting.

        popActScope(prevActScopeDepth);

        if (actScopeDepth === 0) {
          // Exiting the outermost act scope. Flush the queue.
          var _queue = ReactCurrentActQueue.current;

          if (_queue !== null) {
            flushActQueue(_queue);
            ReactCurrentActQueue.current = null;
          } // Return a thenable. If the user awaits it, we'll flush again in
          // case additional work was scheduled by a microtask.


          var _thenable = {
            then: function (resolve, reject) {
              // Confirm we haven't re-entered another `act` scope, in case
              // the user does something weird like await the thenable
              // multiple times.
              if (ReactCurrentActQueue.current === null) {
                // Recursively flush the queue until there's no remaining work.
                ReactCurrentActQueue.current = [];
                recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              } else {
                resolve(returnValue);
              }
            }
          };
          return _thenable;
        } else {
          // Since we're inside a nested `act` scope, the returned thenable
          // immediately resolves. The outer scope will flush the queue.
          var _thenable2 = {
            then: function (resolve, reject) {
              resolve(returnValue);
            }
          };
          return _thenable2;
        }
      }
    }
  }

  function popActScope(prevActScopeDepth) {
    {
      if (prevActScopeDepth !== actScopeDepth - 1) {
        error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');
      }

      actScopeDepth = prevActScopeDepth;
    }
  }

  function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
    {
      var queue = ReactCurrentActQueue.current;

      if (queue !== null) {
        try {
          flushActQueue(queue);
          enqueueTask(function () {
            if (queue.length === 0) {
              // No additional work was scheduled. Finish.
              ReactCurrentActQueue.current = null;
              resolve(returnValue);
            } else {
              // Keep flushing work until there's none left.
              recursivelyFlushAsyncActWork(returnValue, resolve, reject);
            }
          });
        } catch (error) {
          reject(error);
        }
      } else {
        resolve(returnValue);
      }
    }
  }

  var isFlushing = false;

  function flushActQueue(queue) {
    {
      if (!isFlushing) {
        // Prevent re-entrance.
        isFlushing = true;
        var i = 0;

        try {
          for (; i < queue.length; i++) {
            var callback = queue[i];

            do {
              callback = callback(true);
            } while (callback !== null);
          }

          queue.length = 0;
        } catch (error) {
          // If something throws, leave the remaining callbacks on the queue.
          queue = queue.slice(i + 1);
          throw error;
        } finally {
          isFlushing = false;
        }
      }
    }
  }

  var createElement$1 =  createElementWithValidation ;
  var cloneElement$1 =  cloneElementWithValidation ;
  var createFactory =  createFactoryWithValidation ;
  var Children = {
    map: mapChildren,
    forEach: forEachChildren,
    count: countChildren,
    toArray: toArray,
    only: onlyChild
  };

  exports.Children = Children;
  exports.Component = Component;
  exports.Fragment = REACT_FRAGMENT_TYPE;
  exports.Profiler = REACT_PROFILER_TYPE;
  exports.PureComponent = PureComponent;
  exports.StrictMode = REACT_STRICT_MODE_TYPE;
  exports.Suspense = REACT_SUSPENSE_TYPE;
  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals$1;
  exports.act = act;
  exports.cloneElement = cloneElement$1;
  exports.createContext = createContext;
  exports.createElement = createElement$1;
  exports.createFactory = createFactory;
  exports.createRef = createRef;
  exports.forwardRef = forwardRef;
  exports.isValidElement = isValidElement;
  exports.lazy = lazy;
  exports.memo = memo;
  exports.startTransition = startTransition;
  exports.unstable_act = act;
  exports.useCallback = useCallback;
  exports.useContext = useContext;
  exports.useDebugValue = useDebugValue;
  exports.useDeferredValue = useDeferredValue;
  exports.useEffect = useEffect;
  exports.useId = useId;
  exports.useImperativeHandle = useImperativeHandle;
  exports.useInsertionEffect = useInsertionEffect;
  exports.useLayoutEffect = useLayoutEffect;
  exports.useMemo = useMemo;
  exports.useReducer = useReducer;
  exports.useRef = useRef;
  exports.useState = useState;
  exports.useSyncExternalStore = useSyncExternalStore;
  exports.useTransition = useTransition;
  exports.version = ReactVersion;

})));

~~~

## node_modules\react\umd\react.production.min.js

~~~js
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(){'use strict';(function(c,x){"object"===typeof exports&&"undefined"!==typeof module?x(exports):"function"===typeof define&&define.amd?define(["exports"],x):(c=c||self,x(c.React={}))})(this,function(c){function x(a){if(null===a||"object"!==typeof a)return null;a=V&&a[V]||a["@@iterator"];return"function"===typeof a?a:null}function w(a,b,e){this.props=a;this.context=b;this.refs=W;this.updater=e||X}function Y(){}function K(a,b,e){this.props=a;this.context=b;this.refs=W;this.updater=e||X}function Z(a,b,
e){var m,d={},c=null,h=null;if(null!=b)for(m in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(c=""+b.key),b)aa.call(b,m)&&!ba.hasOwnProperty(m)&&(d[m]=b[m]);var l=arguments.length-2;if(1===l)d.children=e;else if(1<l){for(var f=Array(l),k=0;k<l;k++)f[k]=arguments[k+2];d.children=f}if(a&&a.defaultProps)for(m in l=a.defaultProps,l)void 0===d[m]&&(d[m]=l[m]);return{$$typeof:y,type:a,key:c,ref:h,props:d,_owner:L.current}}function oa(a,b){return{$$typeof:y,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}
function M(a){return"object"===typeof a&&null!==a&&a.$$typeof===y}function pa(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}function N(a,b){return"object"===typeof a&&null!==a&&null!=a.key?pa(""+a.key):b.toString(36)}function B(a,b,e,m,d){var c=typeof a;if("undefined"===c||"boolean"===c)a=null;var h=!1;if(null===a)h=!0;else switch(c){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case y:case qa:h=!0}}if(h)return h=a,d=d(h),a=""===m?"."+
N(h,0):m,ca(d)?(e="",null!=a&&(e=a.replace(da,"$&/")+"/"),B(d,b,e,"",function(a){return a})):null!=d&&(M(d)&&(d=oa(d,e+(!d.key||h&&h.key===d.key?"":(""+d.key).replace(da,"$&/")+"/")+a)),b.push(d)),1;h=0;m=""===m?".":m+":";if(ca(a))for(var l=0;l<a.length;l++){c=a[l];var f=m+N(c,l);h+=B(c,b,e,f,d)}else if(f=x(a),"function"===typeof f)for(a=f.call(a),l=0;!(c=a.next()).done;)c=c.value,f=m+N(c,l++),h+=B(c,b,e,f,d);else if("object"===c)throw b=String(a),Error("Objects are not valid as a React child (found: "+
("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}function C(a,b,e){if(null==a)return a;var c=[],d=0;B(a,c,"","",function(a){return b.call(e,a,d++)});return c}function ra(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=
0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}function O(a,b){var e=a.length;a.push(b);a:for(;0<e;){var c=e-1>>>1,d=a[c];if(0<D(d,b))a[c]=b,a[e]=d,e=c;else break a}}function p(a){return 0===a.length?null:a[0]}function E(a){if(0===a.length)return null;var b=a[0],e=a.pop();if(e!==b){a[0]=e;a:for(var c=0,d=a.length,k=d>>>1;c<k;){var h=2*(c+1)-1,l=a[h],f=h+1,g=a[f];if(0>D(l,e))f<d&&0>D(g,l)?(a[c]=g,a[f]=e,c=f):(a[c]=l,a[h]=e,c=h);else if(f<d&&0>D(g,e))a[c]=g,a[f]=e,c=f;else break a}}return b}
function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function P(a){for(var b=p(r);null!==b;){if(null===b.callback)E(r);else if(b.startTime<=a)E(r),b.sortIndex=b.expirationTime,O(q,b);else break;b=p(r)}}function Q(a){z=!1;P(a);if(!u)if(null!==p(q))u=!0,R(S);else{var b=p(r);null!==b&&T(Q,b.startTime-a)}}function S(a,b){u=!1;z&&(z=!1,ea(A),A=-1);F=!0;var c=k;try{P(b);for(n=p(q);null!==n&&(!(n.expirationTime>b)||a&&!fa());){var m=n.callback;if("function"===typeof m){n.callback=null;
k=n.priorityLevel;var d=m(n.expirationTime<=b);b=v();"function"===typeof d?n.callback=d:n===p(q)&&E(q);P(b)}else E(q);n=p(q)}if(null!==n)var g=!0;else{var h=p(r);null!==h&&T(Q,h.startTime-b);g=!1}return g}finally{n=null,k=c,F=!1}}function fa(){return v()-ha<ia?!1:!0}function R(a){G=a;H||(H=!0,I())}function T(a,b){A=ja(function(){a(v())},b)}function ka(a){throw Error("act(...) is not supported in production builds of React.");}var y=Symbol.for("react.element"),qa=Symbol.for("react.portal"),sa=Symbol.for("react.fragment"),
ta=Symbol.for("react.strict_mode"),ua=Symbol.for("react.profiler"),va=Symbol.for("react.provider"),wa=Symbol.for("react.context"),xa=Symbol.for("react.forward_ref"),ya=Symbol.for("react.suspense"),za=Symbol.for("react.memo"),Aa=Symbol.for("react.lazy"),V=Symbol.iterator,X={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,m){},enqueueSetState:function(a,b,c,m){}},la=Object.assign,W={};w.prototype.isReactComponent={};w.prototype.setState=function(a,
b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};Y.prototype=w.prototype;var t=K.prototype=new Y;t.constructor=K;la(t,w.prototype);t.isPureReactComponent=!0;var ca=Array.isArray,aa=Object.prototype.hasOwnProperty,L={current:null},
ba={key:!0,ref:!0,__self:!0,__source:!0},da=/\/+/g,g={current:null},J={transition:null};if("object"===typeof performance&&"function"===typeof performance.now){var Ba=performance;var v=function(){return Ba.now()}}else{var ma=Date,Ca=ma.now();v=function(){return ma.now()-Ca}}var q=[],r=[],Da=1,n=null,k=3,F=!1,u=!1,z=!1,ja="function"===typeof setTimeout?setTimeout:null,ea="function"===typeof clearTimeout?clearTimeout:null,na="undefined"!==typeof setImmediate?setImmediate:null;"undefined"!==typeof navigator&&
void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var H=!1,G=null,A=-1,ia=5,ha=-1,U=function(){if(null!==G){var a=v();ha=a;var b=!0;try{b=G(!0,a)}finally{b?I():(H=!1,G=null)}}else H=!1};if("function"===typeof na)var I=function(){na(U)};else if("undefined"!==typeof MessageChannel){t=new MessageChannel;var Ea=t.port2;t.port1.onmessage=U;I=function(){Ea.postMessage(null)}}else I=function(){ja(U,0)};t={ReactCurrentDispatcher:g,
ReactCurrentOwner:L,ReactCurrentBatchConfig:J,Scheduler:{__proto__:null,unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=k;k=a;try{return b()}finally{k=c}},unstable_next:function(a){switch(k){case 1:case 2:case 3:var b=3;break;default:b=k}var c=k;k=b;try{return a()}finally{k=c}},unstable_scheduleCallback:function(a,
b,c){var e=v();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?e+c:e):c=e;switch(a){case 1:var d=-1;break;case 2:d=250;break;case 5:d=1073741823;break;case 4:d=1E4;break;default:d=5E3}d=c+d;a={id:Da++,callback:b,priorityLevel:a,startTime:c,expirationTime:d,sortIndex:-1};c>e?(a.sortIndex=c,O(r,a),null===p(q)&&a===p(r)&&(z?(ea(A),A=-1):z=!0,T(Q,c-e))):(a.sortIndex=d,O(q,a),u||F||(u=!0,R(S)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=
k;return function(){var c=k;k=b;try{return a.apply(this,arguments)}finally{k=c}}},unstable_getCurrentPriorityLevel:function(){return k},unstable_shouldYield:fa,unstable_requestPaint:function(){},unstable_continueExecution:function(){u||F||(u=!0,R(S))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return p(q)},get unstable_now(){return v},unstable_forceFrameRate:function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):
ia=0<a?Math.floor(1E3/a):5},unstable_Profiling:null}};c.Children={map:C,forEach:function(a,b,c){C(a,function(){b.apply(this,arguments)},c)},count:function(a){var b=0;C(a,function(){b++});return b},toArray:function(a){return C(a,function(a){return a})||[]},only:function(a){if(!M(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};c.Component=w;c.Fragment=sa;c.Profiler=ua;c.PureComponent=K;c.StrictMode=ta;c.Suspense=ya;c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=
t;c.act=ka;c.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var e=la({},a.props),d=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=L.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var l=a.type.defaultProps;for(f in b)aa.call(b,f)&&!ba.hasOwnProperty(f)&&(e[f]=void 0===b[f]&&void 0!==l?l[f]:b[f])}var f=arguments.length-2;if(1===f)e.children=c;else if(1<f){l=
Array(f);for(var g=0;g<f;g++)l[g]=arguments[g+2];e.children=l}return{$$typeof:y,type:a.type,key:d,ref:k,props:e,_owner:h}};c.createContext=function(a){a={$$typeof:wa,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:va,_context:a};return a.Consumer=a};c.createElement=Z;c.createFactory=function(a){var b=Z.bind(null,a);b.type=a;return b};c.createRef=function(){return{current:null}};c.forwardRef=function(a){return{$$typeof:xa,
render:a}};c.isValidElement=M;c.lazy=function(a){return{$$typeof:Aa,_payload:{_status:-1,_result:a},_init:ra}};c.memo=function(a,b){return{$$typeof:za,type:a,compare:void 0===b?null:b}};c.startTransition=function(a,b){b=J.transition;J.transition={};try{a()}finally{J.transition=b}};c.unstable_act=ka;c.useCallback=function(a,b){return g.current.useCallback(a,b)};c.useContext=function(a){return g.current.useContext(a)};c.useDebugValue=function(a,b){};c.useDeferredValue=function(a){return g.current.useDeferredValue(a)};
c.useEffect=function(a,b){return g.current.useEffect(a,b)};c.useId=function(){return g.current.useId()};c.useImperativeHandle=function(a,b,c){return g.current.useImperativeHandle(a,b,c)};c.useInsertionEffect=function(a,b){return g.current.useInsertionEffect(a,b)};c.useLayoutEffect=function(a,b){return g.current.useLayoutEffect(a,b)};c.useMemo=function(a,b){return g.current.useMemo(a,b)};c.useReducer=function(a,b,c){return g.current.useReducer(a,b,c)};c.useRef=function(a){return g.current.useRef(a)};
c.useState=function(a){return g.current.useState(a)};c.useSyncExternalStore=function(a,b,c){return g.current.useSyncExternalStore(a,b,c)};c.useTransition=function(){return g.current.useTransition()};c.version="18.3.1"});
})();

~~~

## node_modules\react\umd\react.profiling.min.js

~~~js
/**
 * @license React
 * react.profiling.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(){'use strict';(function(c,x){"object"===typeof exports&&"undefined"!==typeof module?x(exports):"function"===typeof define&&define.amd?define(["exports"],x):(c=c||self,x(c.React={}))})(this,function(c){function x(a){if(null===a||"object"!==typeof a)return null;a=V&&a[V]||a["@@iterator"];return"function"===typeof a?a:null}function w(a,b,e){this.props=a;this.context=b;this.refs=W;this.updater=e||X}function Y(){}function K(a,b,e){this.props=a;this.context=b;this.refs=W;this.updater=e||X}function Z(a,b,
e){var m,d={},c=null,h=null;if(null!=b)for(m in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(c=""+b.key),b)aa.call(b,m)&&!ba.hasOwnProperty(m)&&(d[m]=b[m]);var l=arguments.length-2;if(1===l)d.children=e;else if(1<l){for(var f=Array(l),k=0;k<l;k++)f[k]=arguments[k+2];d.children=f}if(a&&a.defaultProps)for(m in l=a.defaultProps,l)void 0===d[m]&&(d[m]=l[m]);return{$$typeof:y,type:a,key:c,ref:h,props:d,_owner:L.current}}function oa(a,b){return{$$typeof:y,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}
function M(a){return"object"===typeof a&&null!==a&&a.$$typeof===y}function pa(a){var b={"=":"=0",":":"=2"};return"$"+a.replace(/[=:]/g,function(a){return b[a]})}function N(a,b){return"object"===typeof a&&null!==a&&null!=a.key?pa(""+a.key):b.toString(36)}function B(a,b,e,m,d){var c=typeof a;if("undefined"===c||"boolean"===c)a=null;var h=!1;if(null===a)h=!0;else switch(c){case "string":case "number":h=!0;break;case "object":switch(a.$$typeof){case y:case qa:h=!0}}if(h)return h=a,d=d(h),a=""===m?"."+
N(h,0):m,ca(d)?(e="",null!=a&&(e=a.replace(da,"$&/")+"/"),B(d,b,e,"",function(a){return a})):null!=d&&(M(d)&&(d=oa(d,e+(!d.key||h&&h.key===d.key?"":(""+d.key).replace(da,"$&/")+"/")+a)),b.push(d)),1;h=0;m=""===m?".":m+":";if(ca(a))for(var l=0;l<a.length;l++){c=a[l];var f=m+N(c,l);h+=B(c,b,e,f,d)}else if(f=x(a),"function"===typeof f)for(a=f.call(a),l=0;!(c=a.next()).done;)c=c.value,f=m+N(c,l++),h+=B(c,b,e,f,d);else if("object"===c)throw b=String(a),Error("Objects are not valid as a React child (found: "+
("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}function C(a,b,e){if(null==a)return a;var c=[],d=0;B(a,c,"","",function(a){return b.call(e,a,d++)});return c}function ra(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=
0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}function O(a,b){var e=a.length;a.push(b);a:for(;0<e;){var c=e-1>>>1,d=a[c];if(0<D(d,b))a[c]=b,a[e]=d,e=c;else break a}}function p(a){return 0===a.length?null:a[0]}function E(a){if(0===a.length)return null;var b=a[0],e=a.pop();if(e!==b){a[0]=e;a:for(var c=0,d=a.length,k=d>>>1;c<k;){var h=2*(c+1)-1,l=a[h],f=h+1,g=a[f];if(0>D(l,e))f<d&&0>D(g,l)?(a[c]=g,a[f]=e,c=f):(a[c]=l,a[h]=e,c=h);else if(f<d&&0>D(g,e))a[c]=g,a[f]=e,c=f;else break a}}return b}
function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function P(a){for(var b=p(r);null!==b;){if(null===b.callback)E(r);else if(b.startTime<=a)E(r),b.sortIndex=b.expirationTime,O(q,b);else break;b=p(r)}}function Q(a){z=!1;P(a);if(!u)if(null!==p(q))u=!0,R(S);else{var b=p(r);null!==b&&T(Q,b.startTime-a)}}function S(a,b){u=!1;z&&(z=!1,ea(A),A=-1);F=!0;var c=k;try{P(b);for(n=p(q);null!==n&&(!(n.expirationTime>b)||a&&!fa());){var m=n.callback;if("function"===typeof m){n.callback=null;
k=n.priorityLevel;var d=m(n.expirationTime<=b);b=v();"function"===typeof d?n.callback=d:n===p(q)&&E(q);P(b)}else E(q);n=p(q)}if(null!==n)var g=!0;else{var h=p(r);null!==h&&T(Q,h.startTime-b);g=!1}return g}finally{n=null,k=c,F=!1}}function fa(){return v()-ha<ia?!1:!0}function R(a){G=a;H||(H=!0,I())}function T(a,b){A=ja(function(){a(v())},b)}function ka(a){throw Error("act(...) is not supported in production builds of React.");}var y=Symbol.for("react.element"),qa=Symbol.for("react.portal"),sa=Symbol.for("react.fragment"),
ta=Symbol.for("react.strict_mode"),ua=Symbol.for("react.profiler"),va=Symbol.for("react.provider"),wa=Symbol.for("react.context"),xa=Symbol.for("react.forward_ref"),ya=Symbol.for("react.suspense"),za=Symbol.for("react.memo"),Aa=Symbol.for("react.lazy"),V=Symbol.iterator,X={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,m){},enqueueSetState:function(a,b,c,m){}},la=Object.assign,W={};w.prototype.isReactComponent={};w.prototype.setState=function(a,
b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};Y.prototype=w.prototype;var t=K.prototype=new Y;t.constructor=K;la(t,w.prototype);t.isPureReactComponent=!0;var ca=Array.isArray,aa=Object.prototype.hasOwnProperty,L={current:null},
ba={key:!0,ref:!0,__self:!0,__source:!0},da=/\/+/g,g={current:null},J={transition:null};if("object"===typeof performance&&"function"===typeof performance.now){var Ba=performance;var v=function(){return Ba.now()}}else{var ma=Date,Ca=ma.now();v=function(){return ma.now()-Ca}}var q=[],r=[],Da=1,n=null,k=3,F=!1,u=!1,z=!1,ja="function"===typeof setTimeout?setTimeout:null,ea="function"===typeof clearTimeout?clearTimeout:null,na="undefined"!==typeof setImmediate?setImmediate:null;"undefined"!==typeof navigator&&
void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var H=!1,G=null,A=-1,ia=5,ha=-1,U=function(){if(null!==G){var a=v();ha=a;var b=!0;try{b=G(!0,a)}finally{b?I():(H=!1,G=null)}}else H=!1};if("function"===typeof na)var I=function(){na(U)};else if("undefined"!==typeof MessageChannel){t=new MessageChannel;var Ea=t.port2;t.port1.onmessage=U;I=function(){Ea.postMessage(null)}}else I=function(){ja(U,0)};t={ReactCurrentDispatcher:g,
ReactCurrentOwner:L,ReactCurrentBatchConfig:J,Scheduler:{__proto__:null,unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=k;k=a;try{return b()}finally{k=c}},unstable_next:function(a){switch(k){case 1:case 2:case 3:var b=3;break;default:b=k}var c=k;k=b;try{return a()}finally{k=c}},unstable_scheduleCallback:function(a,
b,c){var e=v();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?e+c:e):c=e;switch(a){case 1:var d=-1;break;case 2:d=250;break;case 5:d=1073741823;break;case 4:d=1E4;break;default:d=5E3}d=c+d;a={id:Da++,callback:b,priorityLevel:a,startTime:c,expirationTime:d,sortIndex:-1};c>e?(a.sortIndex=c,O(r,a),null===p(q)&&a===p(r)&&(z?(ea(A),A=-1):z=!0,T(Q,c-e))):(a.sortIndex=d,O(q,a),u||F||(u=!0,R(S)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=
k;return function(){var c=k;k=b;try{return a.apply(this,arguments)}finally{k=c}}},unstable_getCurrentPriorityLevel:function(){return k},unstable_shouldYield:fa,unstable_requestPaint:function(){},unstable_continueExecution:function(){u||F||(u=!0,R(S))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return p(q)},get unstable_now(){return v},unstable_forceFrameRate:function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):
ia=0<a?Math.floor(1E3/a):5},unstable_Profiling:null}};c.Children={map:C,forEach:function(a,b,c){C(a,function(){b.apply(this,arguments)},c)},count:function(a){var b=0;C(a,function(){b++});return b},toArray:function(a){return C(a,function(a){return a})||[]},only:function(a){if(!M(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};c.Component=w;c.Fragment=sa;c.Profiler=ua;c.PureComponent=K;c.StrictMode=ta;c.Suspense=ya;c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=
t;c.act=ka;c.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var e=la({},a.props),d=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=L.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var l=a.type.defaultProps;for(f in b)aa.call(b,f)&&!ba.hasOwnProperty(f)&&(e[f]=void 0===b[f]&&void 0!==l?l[f]:b[f])}var f=arguments.length-2;if(1===f)e.children=c;else if(1<f){l=
Array(f);for(var g=0;g<f;g++)l[g]=arguments[g+2];e.children=l}return{$$typeof:y,type:a.type,key:d,ref:k,props:e,_owner:h}};c.createContext=function(a){a={$$typeof:wa,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:va,_context:a};return a.Consumer=a};c.createElement=Z;c.createFactory=function(a){var b=Z.bind(null,a);b.type=a;return b};c.createRef=function(){return{current:null}};c.forwardRef=function(a){return{$$typeof:xa,
render:a}};c.isValidElement=M;c.lazy=function(a){return{$$typeof:Aa,_payload:{_status:-1,_result:a},_init:ra}};c.memo=function(a,b){return{$$typeof:za,type:a,compare:void 0===b?null:b}};c.startTransition=function(a,b){b=J.transition;J.transition={};try{a()}finally{J.transition=b}};c.unstable_act=ka;c.useCallback=function(a,b){return g.current.useCallback(a,b)};c.useContext=function(a){return g.current.useContext(a)};c.useDebugValue=function(a,b){};c.useDeferredValue=function(a){return g.current.useDeferredValue(a)};
c.useEffect=function(a,b){return g.current.useEffect(a,b)};c.useId=function(){return g.current.useId()};c.useImperativeHandle=function(a,b,c){return g.current.useImperativeHandle(a,b,c)};c.useInsertionEffect=function(a,b){return g.current.useInsertionEffect(a,b)};c.useLayoutEffect=function(a,b){return g.current.useLayoutEffect(a,b)};c.useMemo=function(a,b){return g.current.useMemo(a,b)};c.useReducer=function(a,b,c){return g.current.useReducer(a,b,c)};c.useRef=function(a){return g.current.useRef(a)};
c.useState=function(a){return g.current.useState(a)};c.useSyncExternalStore=function(a,b,c){return g.current.useSyncExternalStore(a,b,c)};c.useTransition=function(){return g.current.useTransition()};c.version="18.3.1"});
})();

~~~

## node_modules\react-day-picker\buddhist.d.ts

~~~ts
export * from "./dist/cjs/buddhist/index.d.ts";

~~~

## node_modules\react-day-picker\buddhist.js

~~~js
const buddhist = require("./dist/cjs/buddhist/index.js");
module.exports = buddhist;

~~~

## node_modules\react-day-picker\dist\cjs\buddhist\index.d.ts

~~~ts
import type { Locale } from "date-fns";
import React from "react";
import { DateLib, type DateLibOptions } from "../index.js";
import type { DayPickerProps } from "../types/props.js";
export declare const th: Locale;
export declare const enUS: Locale;
/**
 * Render the Buddhist (Thai) calendar.
 *
 * Months/weeks are Gregorian; displayed year is Buddhist Era (BE = CE + 543).
 * Thai digits are used by default.
 *
 * Defaults:
 *
 * - `locale`: `th`
 * - `dir`: `ltr`
 * - `numerals`: `thai`
 */
export declare function DayPicker(props: DayPickerProps & {
    locale?: Locale;
    dir?: DayPickerProps["dir"];
    numerals?: DayPickerProps["numerals"];
    dateLib?: DayPickerProps["dateLib"];
}): React.JSX.Element;
/** Returns the date library used in the Buddhist calendar. */
export declare const getDateLib: (options?: DateLibOptions) => DateLib;

~~~

## node_modules\react-day-picker\dist\cjs\buddhist\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDateLib = exports.enUS = exports.th = void 0;
exports.DayPicker = DayPicker;
const locales = __importStar(require("date-fns/locale"));
const react_1 = __importDefault(require("react"));
const index_js_1 = require("../index.js");
const format_js_1 = require("./lib/format.js");
// Adapter to match DateLib's format signature without using `any`.
const buddhistFormat = (date, formatStr, options) => {
    return (0, format_js_1.format)(date, formatStr, options);
};
exports.th = locales.th;
exports.enUS = locales.enUS;
/**
 * Render the Buddhist (Thai) calendar.
 *
 * Months/weeks are Gregorian; displayed year is Buddhist Era (BE = CE + 543).
 * Thai digits are used by default.
 *
 * Defaults:
 *
 * - `locale`: `th`
 * - `dir`: `ltr`
 * - `numerals`: `thai`
 */
function DayPicker(props) {
    const dateLib = (0, exports.getDateLib)({
        locale: props.locale ?? exports.th,
        weekStartsOn: props.broadcastCalendar ? 1 : props.weekStartsOn,
        firstWeekContainsDate: props.firstWeekContainsDate,
        useAdditionalWeekYearTokens: props.useAdditionalWeekYearTokens,
        useAdditionalDayOfYearTokens: props.useAdditionalDayOfYearTokens,
        timeZone: props.timeZone,
    });
    return (react_1.default.createElement(index_js_1.DayPicker, { ...props, locale: props.locale ?? exports.th, numerals: props.numerals ?? "thai", dir: props.dir ?? "ltr", dateLib: dateLib }));
}
/** Returns the date library used in the Buddhist calendar. */
const getDateLib = (options) => {
    return new index_js_1.DateLib(options, {
        format: buddhistFormat,
    });
};
exports.getDateLib = getDateLib;

~~~

## node_modules\react-day-picker\dist\cjs\buddhist\lib\format.d.ts

~~~ts
import type { DateLibOptions } from "../../classes/DateLib.js";
/** Format override adding +543 to year tokens for Buddhist Era (BE). */
export declare function format(date: Date, formatStr: string, options?: DateLibOptions): string;

~~~

## node_modules\react-day-picker\dist\cjs\buddhist\lib\format.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = format;
const date_fns_1 = require("date-fns");
/** Format override adding +543 to year tokens for Buddhist Era (BE). */
function format(date, formatStr, options) {
    const beYear = date.getFullYear() + 543;
    switch (formatStr) {
        case "LLLL y":
        case "LLLL yyyy":
            return `${(0, date_fns_1.format)(date, "LLLL", options)} ${beYear}`;
        case "LLLL":
            return (0, date_fns_1.format)(date, "LLLL", options);
        case "yyyy":
            return String(beYear).padStart(4, "0");
        case "y":
            return String(beYear);
        case "yyyy-MM":
            return `${beYear}-${(0, date_fns_1.format)(date, "MM", options)}`;
        case "yyyy-MM-dd":
            return `${beYear}-${(0, date_fns_1.format)(date, "MM", options)}-${(0, date_fns_1.format)(date, "dd", options)}`;
        case "PPP":
        case "PPPP": {
            const raw = (0, date_fns_1.format)(date, formatStr, options);
            return raw.replace(/(.*)(\d{4})(?!.*\d)/, (_m, pre) => `${pre}${beYear}`);
        }
        default:
            return (0, date_fns_1.format)(date, formatStr, options);
    }
}

~~~

## node_modules\react-day-picker\dist\cjs\classes\CalendarDay.d.ts

~~~ts
import { type DateLib } from "./DateLib.js";
/**
 * Represents a day displayed in the calendar.
 *
 * In DayPicker, a `CalendarDay` is a wrapper around a `Date` object that
 * provides additional information about the day, such as whether it belongs to
 * the displayed month.
 */
export declare class CalendarDay {
    constructor(date: Date, displayMonth: Date, dateLib?: DateLib);
    /**
     * Utility functions for manipulating dates.
     *
     * @private
     */
    readonly dateLib: DateLib;
    /**
     * Indicates whether the day does not belong to the displayed month.
     *
     * If `outside` is `true`, use `displayMonth` to determine the month to which
     * the day belongs.
     */
    readonly outside: boolean;
    /**
     * The month that is currently displayed in the calendar.
     *
     * This property is useful for determining if the day belongs to the same
     * month as the displayed month, especially when `showOutsideDays` is
     * enabled.
     */
    readonly displayMonth: Date;
    /** The date represented by this day. */
    readonly date: Date;
    /**
     * Checks if this day is equal to another `CalendarDay`, considering both the
     * date and the displayed month.
     *
     * @param day The `CalendarDay` to compare with.
     * @returns `true` if the days are equal, otherwise `false`.
     */
    isEqualTo(day: CalendarDay): boolean;
}

~~~

## node_modules\react-day-picker\dist\cjs\classes\CalendarDay.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalendarDay = void 0;
const DateLib_js_1 = require("./DateLib.js");
/**
 * Represents a day displayed in the calendar.
 *
 * In DayPicker, a `CalendarDay` is a wrapper around a `Date` object that
 * provides additional information about the day, such as whether it belongs to
 * the displayed month.
 */
class CalendarDay {
    constructor(date, displayMonth, dateLib = DateLib_js_1.defaultDateLib) {
        this.date = date;
        this.displayMonth = displayMonth;
        this.outside = Boolean(displayMonth && !dateLib.isSameMonth(date, displayMonth));
        this.dateLib = dateLib;
    }
    /**
     * Checks if this day is equal to another `CalendarDay`, considering both the
     * date and the displayed month.
     *
     * @param day The `CalendarDay` to compare with.
     * @returns `true` if the days are equal, otherwise `false`.
     */
    isEqualTo(day) {
        return (this.dateLib.isSameDay(day.date, this.date) &&
            this.dateLib.isSameMonth(day.displayMonth, this.displayMonth));
    }
}
exports.CalendarDay = CalendarDay;

~~~

## node_modules\react-day-picker\dist\cjs\classes\CalendarMonth.d.ts

~~~ts
import type { CalendarWeek } from "./CalendarWeek.js";
/**
 * Represents a month in a calendar year.
 *
 * A `CalendarMonth` contains the weeks within the month and the date of the
 * month.
 */
export declare class CalendarMonth {
    constructor(month: Date, weeks: CalendarWeek[]);
    /** The date representing the first day of the month. */
    date: Date;
    /** The weeks that belong to this month. */
    weeks: CalendarWeek[];
}

~~~

## node_modules\react-day-picker\dist\cjs\classes\CalendarMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalendarMonth = void 0;
/**
 * Represents a month in a calendar year.
 *
 * A `CalendarMonth` contains the weeks within the month and the date of the
 * month.
 */
class CalendarMonth {
    constructor(month, weeks) {
        this.date = month;
        this.weeks = weeks;
    }
}
exports.CalendarMonth = CalendarMonth;

~~~

## node_modules\react-day-picker\dist\cjs\classes\CalendarWeek.d.ts

~~~ts
import type { CalendarDay } from "./CalendarDay.js";
/**
 * Represents a week in a calendar month.
 *
 * A `CalendarWeek` contains the days within the week and the week number.
 */
export declare class CalendarWeek {
    constructor(weekNumber: number, days: CalendarDay[]);
    /** The number of the week within the year. */
    weekNumber: number;
    /** The days that belong to this week. */
    days: CalendarDay[];
}

~~~

## node_modules\react-day-picker\dist\cjs\classes\CalendarWeek.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalendarWeek = void 0;
/**
 * Represents a week in a calendar month.
 *
 * A `CalendarWeek` contains the days within the week and the week number.
 */
class CalendarWeek {
    constructor(weekNumber, days) {
        this.days = days;
        this.weekNumber = weekNumber;
    }
}
exports.CalendarWeek = CalendarWeek;

~~~

## node_modules\react-day-picker\dist\cjs\classes\DateLib.d.ts

~~~ts
import type { FormatOptions as DateFnsFormatOptions, EndOfWeekOptions, GetMonthOptions, GetWeekOptions, GetYearOptions, Interval, StartOfWeekOptions } from "date-fns";
import type { Locale } from "date-fns/locale";
import type { Numerals } from "../types/shared.js";
export type { Month as DateFnsMonth } from "date-fns";
export type { Locale } from "date-fns/locale";
/**
 * @ignore
 * @deprecated Use {@link DateLibOptions} instead.
 */
export type FormatOptions = DateLibOptions;
/**
 * @ignore
 * @deprecated Use {@link DateLibOptions} instead.
 */
export type LabelOptions = DateLibOptions;
/** Indicates the preferred ordering of month and year for localized labels. */
export type MonthYearOrder = "month-first" | "year-first";
/**
 * The options for the `DateLib` class.
 *
 * Extends `date-fns` [format](https://date-fns.org/docs/format),
 * [startOfWeek](https://date-fns.org/docs/startOfWeek) and
 * [endOfWeek](https://date-fns.org/docs/endOfWeek) options.
 *
 * @since 9.2.0
 */
export interface DateLibOptions extends DateFnsFormatOptions, StartOfWeekOptions, EndOfWeekOptions {
    /** A constructor for the `Date` object. */
    Date?: typeof Date;
    /** A locale to use for formatting dates. */
    locale?: Locale;
    /**
     * A time zone to use for dates.
     *
     * @since 9.5.0
     */
    timeZone?: string;
    /**
     * The numbering system to use for formatting numbers.
     *
     * @since 9.5.0
     */
    numerals?: Numerals;
}
/**
 * A wrapper class around [date-fns](http://date-fns.org) that provides utility
 * methods for date manipulation and formatting.
 *
 * @since 9.2.0
 * @example
 *   const dateLib = new DateLib({ locale: es });
 *   const newDate = dateLib.addDays(new Date(), 5);
 */
export declare class DateLib {
    /** The options for configuring the date library. */
    readonly options: DateLibOptions;
    /** Overrides for the default date library functions. */
    readonly overrides?: Partial<typeof DateLib.prototype>;
    /**
     * Creates an instance of `DateLib`.
     *
     * @param options Configuration options for the date library.
     * @param overrides Custom overrides for the date library functions.
     */
    constructor(options?: DateLibOptions, overrides?: Partial<typeof DateLib.prototype>);
    /**
     * Generates a mapping of Arabic digits (0-9) to the target numbering system
     * digits.
     *
     * @since 9.5.0
     * @returns A record mapping Arabic digits to the target numerals.
     */
    private getDigitMap;
    /**
     * Replaces Arabic digits in a string with the target numbering system digits.
     *
     * @since 9.5.0
     * @param input The string containing Arabic digits.
     * @returns The string with digits replaced.
     */
    private replaceDigits;
    /**
     * Formats a number using the configured numbering system.
     *
     * @since 9.5.0
     * @param value The number to format.
     * @returns The formatted number as a string.
     */
    formatNumber(value: number | string): string;
    /**
     * Returns the preferred ordering for month and year labels for the current
     * locale.
     */
    getMonthYearOrder(): MonthYearOrder;
    /**
     * Formats the month/year pair respecting locale conventions.
     *
     * @since 9.11.0
     */
    formatMonthYear(date: Date): string;
    private static readonly yearFirstLocales;
    /**
     * Reference to the built-in Date constructor.
     *
     * @deprecated Use `newDate()` or `today()`.
     */
    Date: typeof Date;
    /**
     * Creates a new `Date` object representing today's date.
     *
     * @since 9.5.0
     * @returns A `Date` object for today's date.
     */
    today: () => Date;
    /**
     * Creates a new `Date` object with the specified year, month, and day.
     *
     * @since 9.5.0
     * @param year The year.
     * @param monthIndex The month (0-11).
     * @param date The day of the month.
     * @returns A new `Date` object.
     */
    newDate: (year: number, monthIndex: number, date: number) => Date;
    /**
     * Adds the specified number of days to the given date.
     *
     * @param date The date to add days to.
     * @param amount The number of days to add.
     * @returns The new date with the days added.
     */
    addDays: (date: Date, amount: number) => Date;
    /**
     * Adds the specified number of months to the given date.
     *
     * @param date The date to add months to.
     * @param amount The number of months to add.
     * @returns The new date with the months added.
     */
    addMonths: (date: Date, amount: number) => Date;
    /**
     * Adds the specified number of weeks to the given date.
     *
     * @param date The date to add weeks to.
     * @param amount The number of weeks to add.
     * @returns The new date with the weeks added.
     */
    addWeeks: (date: Date, amount: number) => Date;
    /**
     * Adds the specified number of years to the given date.
     *
     * @param date The date to add years to.
     * @param amount The number of years to add.
     * @returns The new date with the years added.
     */
    addYears: (date: Date, amount: number) => Date;
    /**
     * Returns the number of calendar days between the given dates.
     *
     * @param dateLeft The later date.
     * @param dateRight The earlier date.
     * @returns The number of calendar days between the dates.
     */
    differenceInCalendarDays: (dateLeft: Date, dateRight: Date) => number;
    /**
     * Returns the number of calendar months between the given dates.
     *
     * @param dateLeft The later date.
     * @param dateRight The earlier date.
     * @returns The number of calendar months between the dates.
     */
    differenceInCalendarMonths: (dateLeft: Date, dateRight: Date) => number;
    /**
     * Returns the months between the given dates.
     *
     * @param interval The interval to get the months for.
     */
    eachMonthOfInterval: (interval: Interval) => Date[];
    /**
     * Returns the years between the given dates.
     *
     * @since 9.11.1
     * @param interval The interval to get the years for.
     * @returns The array of years in the interval.
     */
    eachYearOfInterval: (interval: Interval) => Date[];
    /**
     * Returns the end of the broadcast week for the given date.
     *
     * @param date The original date.
     * @returns The end of the broadcast week.
     */
    endOfBroadcastWeek: (date: Date) => Date;
    /**
     * Returns the end of the ISO week for the given date.
     *
     * @param date The original date.
     * @returns The end of the ISO week.
     */
    endOfISOWeek: (date: Date) => Date;
    /**
     * Returns the end of the month for the given date.
     *
     * @param date The original date.
     * @returns The end of the month.
     */
    endOfMonth: (date: Date) => Date;
    /**
     * Returns the end of the week for the given date.
     *
     * @param date The original date.
     * @returns The end of the week.
     */
    endOfWeek: (date: Date, options?: EndOfWeekOptions<Date>) => Date;
    /**
     * Returns the end of the year for the given date.
     *
     * @param date The original date.
     * @returns The end of the year.
     */
    endOfYear: (date: Date) => Date;
    /**
     * Formats the given date using the specified format string.
     *
     * @param date The date to format.
     * @param formatStr The format string.
     * @returns The formatted date string.
     */
    format: (date: Date, formatStr: string, _options?: DateFnsFormatOptions) => string;
    /**
     * Returns the ISO week number for the given date.
     *
     * @param date The date to get the ISO week number for.
     * @returns The ISO week number.
     */
    getISOWeek: (date: Date) => number;
    /**
     * Returns the month of the given date.
     *
     * @param date The date to get the month for.
     * @returns The month.
     */
    getMonth: (date: Date, _options?: GetMonthOptions) => number;
    /**
     * Returns the year of the given date.
     *
     * @param date The date to get the year for.
     * @returns The year.
     */
    getYear: (date: Date, _options?: GetYearOptions) => number;
    /**
     * Returns the local week number for the given date.
     *
     * @param date The date to get the week number for.
     * @returns The week number.
     */
    getWeek: (date: Date, _options?: GetWeekOptions) => number;
    /**
     * Checks if the first date is after the second date.
     *
     * @param date The date to compare.
     * @param dateToCompare The date to compare with.
     * @returns True if the first date is after the second date.
     */
    isAfter: (date: Date, dateToCompare: Date) => boolean;
    /**
     * Checks if the first date is before the second date.
     *
     * @param date The date to compare.
     * @param dateToCompare The date to compare with.
     * @returns True if the first date is before the second date.
     */
    isBefore: (date: Date, dateToCompare: Date) => boolean;
    /**
     * Checks if the given value is a Date object.
     *
     * @param value The value to check.
     * @returns True if the value is a Date object.
     */
    isDate: (value: unknown) => value is Date;
    /**
     * Checks if the given dates are on the same day.
     *
     * @param dateLeft The first date to compare.
     * @param dateRight The second date to compare.
     * @returns True if the dates are on the same day.
     */
    isSameDay: (dateLeft: Date, dateRight: Date) => boolean;
    /**
     * Checks if the given dates are in the same month.
     *
     * @param dateLeft The first date to compare.
     * @param dateRight The second date to compare.
     * @returns True if the dates are in the same month.
     */
    isSameMonth: (dateLeft: Date, dateRight: Date) => boolean;
    /**
     * Checks if the given dates are in the same year.
     *
     * @param dateLeft The first date to compare.
     * @param dateRight The second date to compare.
     * @returns True if the dates are in the same year.
     */
    isSameYear: (dateLeft: Date, dateRight: Date) => boolean;
    /**
     * Returns the latest date in the given array of dates.
     *
     * @param dates The array of dates to compare.
     * @returns The latest date.
     */
    max: (dates: Date[]) => Date;
    /**
     * Returns the earliest date in the given array of dates.
     *
     * @param dates The array of dates to compare.
     * @returns The earliest date.
     */
    min: (dates: Date[]) => Date;
    /**
     * Sets the month of the given date.
     *
     * @param date The date to set the month on.
     * @param month The month to set (0-11).
     * @returns The new date with the month set.
     */
    setMonth: (date: Date, month: number) => Date;
    /**
     * Sets the year of the given date.
     *
     * @param date The date to set the year on.
     * @param year The year to set.
     * @returns The new date with the year set.
     */
    setYear: (date: Date, year: number) => Date;
    /**
     * Returns the start of the broadcast week for the given date.
     *
     * @param date The original date.
     * @returns The start of the broadcast week.
     */
    startOfBroadcastWeek: (date: Date, _dateLib: DateLib) => Date;
    /**
     * Returns the start of the day for the given date.
     *
     * @param date The original date.
     * @returns The start of the day.
     */
    startOfDay: (date: Date) => Date;
    /**
     * Returns the start of the ISO week for the given date.
     *
     * @param date The original date.
     * @returns The start of the ISO week.
     */
    startOfISOWeek: (date: Date) => Date;
    /**
     * Returns the start of the month for the given date.
     *
     * @param date The original date.
     * @returns The start of the month.
     */
    startOfMonth: (date: Date) => Date;
    /**
     * Returns the start of the week for the given date.
     *
     * @param date The original date.
     * @returns The start of the week.
     */
    startOfWeek: (date: Date, _options?: StartOfWeekOptions) => Date;
    /**
     * Returns the start of the year for the given date.
     *
     * @param date The original date.
     * @returns The start of the year.
     */
    startOfYear: (date: Date) => Date;
}
/** The default locale (English). */
export { enUS as defaultLocale } from "date-fns/locale/en-US";
/**
 * The default date library with English locale.
 *
 * @since 9.2.0
 */
export declare const defaultDateLib: DateLib;
/**
 * @ignore
 * @deprecated Use `defaultDateLib`.
 */
export declare const dateLib: DateLib;

~~~

## node_modules\react-day-picker\dist\cjs\classes\DateLib.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dateLib = exports.defaultDateLib = exports.defaultLocale = exports.DateLib = void 0;
const tz_1 = require("@date-fns/tz");
const date_fns_1 = require("date-fns");
const en_US_1 = require("date-fns/locale/en-US");
const endOfBroadcastWeek_js_1 = require("../helpers/endOfBroadcastWeek.js");
const startOfBroadcastWeek_js_1 = require("../helpers/startOfBroadcastWeek.js");
/**
 * A wrapper class around [date-fns](http://date-fns.org) that provides utility
 * methods for date manipulation and formatting.
 *
 * @since 9.2.0
 * @example
 *   const dateLib = new DateLib({ locale: es });
 *   const newDate = dateLib.addDays(new Date(), 5);
 */
class DateLib {
    /**
     * Creates an instance of `DateLib`.
     *
     * @param options Configuration options for the date library.
     * @param overrides Custom overrides for the date library functions.
     */
    constructor(options, overrides) {
        /**
         * Reference to the built-in Date constructor.
         *
         * @deprecated Use `newDate()` or `today()`.
         */
        this.Date = Date;
        /**
         * Creates a new `Date` object representing today's date.
         *
         * @since 9.5.0
         * @returns A `Date` object for today's date.
         */
        this.today = () => {
            if (this.overrides?.today) {
                return this.overrides.today();
            }
            if (this.options.timeZone) {
                return tz_1.TZDate.tz(this.options.timeZone);
            }
            return new this.Date();
        };
        /**
         * Creates a new `Date` object with the specified year, month, and day.
         *
         * @since 9.5.0
         * @param year The year.
         * @param monthIndex The month (0-11).
         * @param date The day of the month.
         * @returns A new `Date` object.
         */
        this.newDate = (year, monthIndex, date) => {
            if (this.overrides?.newDate) {
                return this.overrides.newDate(year, monthIndex, date);
            }
            if (this.options.timeZone) {
                return new tz_1.TZDate(year, monthIndex, date, this.options.timeZone);
            }
            return new Date(year, monthIndex, date);
        };
        /**
         * Adds the specified number of days to the given date.
         *
         * @param date The date to add days to.
         * @param amount The number of days to add.
         * @returns The new date with the days added.
         */
        this.addDays = (date, amount) => {
            return this.overrides?.addDays
                ? this.overrides.addDays(date, amount)
                : (0, date_fns_1.addDays)(date, amount);
        };
        /**
         * Adds the specified number of months to the given date.
         *
         * @param date The date to add months to.
         * @param amount The number of months to add.
         * @returns The new date with the months added.
         */
        this.addMonths = (date, amount) => {
            return this.overrides?.addMonths
                ? this.overrides.addMonths(date, amount)
                : (0, date_fns_1.addMonths)(date, amount);
        };
        /**
         * Adds the specified number of weeks to the given date.
         *
         * @param date The date to add weeks to.
         * @param amount The number of weeks to add.
         * @returns The new date with the weeks added.
         */
        this.addWeeks = (date, amount) => {
            return this.overrides?.addWeeks
                ? this.overrides.addWeeks(date, amount)
                : (0, date_fns_1.addWeeks)(date, amount);
        };
        /**
         * Adds the specified number of years to the given date.
         *
         * @param date The date to add years to.
         * @param amount The number of years to add.
         * @returns The new date with the years added.
         */
        this.addYears = (date, amount) => {
            return this.overrides?.addYears
                ? this.overrides.addYears(date, amount)
                : (0, date_fns_1.addYears)(date, amount);
        };
        /**
         * Returns the number of calendar days between the given dates.
         *
         * @param dateLeft The later date.
         * @param dateRight The earlier date.
         * @returns The number of calendar days between the dates.
         */
        this.differenceInCalendarDays = (dateLeft, dateRight) => {
            return this.overrides?.differenceInCalendarDays
                ? this.overrides.differenceInCalendarDays(dateLeft, dateRight)
                : (0, date_fns_1.differenceInCalendarDays)(dateLeft, dateRight);
        };
        /**
         * Returns the number of calendar months between the given dates.
         *
         * @param dateLeft The later date.
         * @param dateRight The earlier date.
         * @returns The number of calendar months between the dates.
         */
        this.differenceInCalendarMonths = (dateLeft, dateRight) => {
            return this.overrides?.differenceInCalendarMonths
                ? this.overrides.differenceInCalendarMonths(dateLeft, dateRight)
                : (0, date_fns_1.differenceInCalendarMonths)(dateLeft, dateRight);
        };
        /**
         * Returns the months between the given dates.
         *
         * @param interval The interval to get the months for.
         */
        this.eachMonthOfInterval = (interval) => {
            return this.overrides?.eachMonthOfInterval
                ? this.overrides.eachMonthOfInterval(interval)
                : (0, date_fns_1.eachMonthOfInterval)(interval);
        };
        /**
         * Returns the years between the given dates.
         *
         * @since 9.11.1
         * @param interval The interval to get the years for.
         * @returns The array of years in the interval.
         */
        this.eachYearOfInterval = (interval) => {
            const years = this.overrides?.eachYearOfInterval
                ? this.overrides.eachYearOfInterval(interval)
                : (0, date_fns_1.eachYearOfInterval)(interval);
            // Remove duplicates that may happen across DST transitions (e.g., "America/Sao_Paulo")
            // See https://github.com/date-fns/tz/issues/72
            const uniqueYears = new Set(years.map((d) => this.getYear(d)));
            if (uniqueYears.size === years.length) {
                // No duplicates, return as is
                return years;
            }
            // Rebuild the array to ensure one date per year
            const yearsArray = [];
            uniqueYears.forEach((y) => {
                yearsArray.push(new Date(y, 0, 1));
            });
            return yearsArray;
        };
        /**
         * Returns the end of the broadcast week for the given date.
         *
         * @param date The original date.
         * @returns The end of the broadcast week.
         */
        this.endOfBroadcastWeek = (date) => {
            return this.overrides?.endOfBroadcastWeek
                ? this.overrides.endOfBroadcastWeek(date)
                : (0, endOfBroadcastWeek_js_1.endOfBroadcastWeek)(date, this);
        };
        /**
         * Returns the end of the ISO week for the given date.
         *
         * @param date The original date.
         * @returns The end of the ISO week.
         */
        this.endOfISOWeek = (date) => {
            return this.overrides?.endOfISOWeek
                ? this.overrides.endOfISOWeek(date)
                : (0, date_fns_1.endOfISOWeek)(date);
        };
        /**
         * Returns the end of the month for the given date.
         *
         * @param date The original date.
         * @returns The end of the month.
         */
        this.endOfMonth = (date) => {
            return this.overrides?.endOfMonth
                ? this.overrides.endOfMonth(date)
                : (0, date_fns_1.endOfMonth)(date);
        };
        /**
         * Returns the end of the week for the given date.
         *
         * @param date The original date.
         * @returns The end of the week.
         */
        this.endOfWeek = (date, options) => {
            return this.overrides?.endOfWeek
                ? this.overrides.endOfWeek(date, options)
                : (0, date_fns_1.endOfWeek)(date, this.options);
        };
        /**
         * Returns the end of the year for the given date.
         *
         * @param date The original date.
         * @returns The end of the year.
         */
        this.endOfYear = (date) => {
            return this.overrides?.endOfYear
                ? this.overrides.endOfYear(date)
                : (0, date_fns_1.endOfYear)(date);
        };
        /**
         * Formats the given date using the specified format string.
         *
         * @param date The date to format.
         * @param formatStr The format string.
         * @returns The formatted date string.
         */
        this.format = (date, formatStr, _options) => {
            const formatted = this.overrides?.format
                ? this.overrides.format(date, formatStr, this.options)
                : (0, date_fns_1.format)(date, formatStr, this.options);
            if (this.options.numerals && this.options.numerals !== "latn") {
                return this.replaceDigits(formatted);
            }
            return formatted;
        };
        /**
         * Returns the ISO week number for the given date.
         *
         * @param date The date to get the ISO week number for.
         * @returns The ISO week number.
         */
        this.getISOWeek = (date) => {
            return this.overrides?.getISOWeek
                ? this.overrides.getISOWeek(date)
                : (0, date_fns_1.getISOWeek)(date);
        };
        /**
         * Returns the month of the given date.
         *
         * @param date The date to get the month for.
         * @returns The month.
         */
        this.getMonth = (date, _options) => {
            return this.overrides?.getMonth
                ? this.overrides.getMonth(date, this.options)
                : (0, date_fns_1.getMonth)(date, this.options);
        };
        /**
         * Returns the year of the given date.
         *
         * @param date The date to get the year for.
         * @returns The year.
         */
        this.getYear = (date, _options) => {
            return this.overrides?.getYear
                ? this.overrides.getYear(date, this.options)
                : (0, date_fns_1.getYear)(date, this.options);
        };
        /**
         * Returns the local week number for the given date.
         *
         * @param date The date to get the week number for.
         * @returns The week number.
         */
        this.getWeek = (date, _options) => {
            return this.overrides?.getWeek
                ? this.overrides.getWeek(date, this.options)
                : (0, date_fns_1.getWeek)(date, this.options);
        };
        /**
         * Checks if the first date is after the second date.
         *
         * @param date The date to compare.
         * @param dateToCompare The date to compare with.
         * @returns True if the first date is after the second date.
         */
        this.isAfter = (date, dateToCompare) => {
            return this.overrides?.isAfter
                ? this.overrides.isAfter(date, dateToCompare)
                : (0, date_fns_1.isAfter)(date, dateToCompare);
        };
        /**
         * Checks if the first date is before the second date.
         *
         * @param date The date to compare.
         * @param dateToCompare The date to compare with.
         * @returns True if the first date is before the second date.
         */
        this.isBefore = (date, dateToCompare) => {
            return this.overrides?.isBefore
                ? this.overrides.isBefore(date, dateToCompare)
                : (0, date_fns_1.isBefore)(date, dateToCompare);
        };
        /**
         * Checks if the given value is a Date object.
         *
         * @param value The value to check.
         * @returns True if the value is a Date object.
         */
        this.isDate = (value) => {
            return this.overrides?.isDate
                ? this.overrides.isDate(value)
                : (0, date_fns_1.isDate)(value);
        };
        /**
         * Checks if the given dates are on the same day.
         *
         * @param dateLeft The first date to compare.
         * @param dateRight The second date to compare.
         * @returns True if the dates are on the same day.
         */
        this.isSameDay = (dateLeft, dateRight) => {
            return this.overrides?.isSameDay
                ? this.overrides.isSameDay(dateLeft, dateRight)
                : (0, date_fns_1.isSameDay)(dateLeft, dateRight);
        };
        /**
         * Checks if the given dates are in the same month.
         *
         * @param dateLeft The first date to compare.
         * @param dateRight The second date to compare.
         * @returns True if the dates are in the same month.
         */
        this.isSameMonth = (dateLeft, dateRight) => {
            return this.overrides?.isSameMonth
                ? this.overrides.isSameMonth(dateLeft, dateRight)
                : (0, date_fns_1.isSameMonth)(dateLeft, dateRight);
        };
        /**
         * Checks if the given dates are in the same year.
         *
         * @param dateLeft The first date to compare.
         * @param dateRight The second date to compare.
         * @returns True if the dates are in the same year.
         */
        this.isSameYear = (dateLeft, dateRight) => {
            return this.overrides?.isSameYear
                ? this.overrides.isSameYear(dateLeft, dateRight)
                : (0, date_fns_1.isSameYear)(dateLeft, dateRight);
        };
        /**
         * Returns the latest date in the given array of dates.
         *
         * @param dates The array of dates to compare.
         * @returns The latest date.
         */
        this.max = (dates) => {
            return this.overrides?.max ? this.overrides.max(dates) : (0, date_fns_1.max)(dates);
        };
        /**
         * Returns the earliest date in the given array of dates.
         *
         * @param dates The array of dates to compare.
         * @returns The earliest date.
         */
        this.min = (dates) => {
            return this.overrides?.min ? this.overrides.min(dates) : (0, date_fns_1.min)(dates);
        };
        /**
         * Sets the month of the given date.
         *
         * @param date The date to set the month on.
         * @param month The month to set (0-11).
         * @returns The new date with the month set.
         */
        this.setMonth = (date, month) => {
            return this.overrides?.setMonth
                ? this.overrides.setMonth(date, month)
                : (0, date_fns_1.setMonth)(date, month);
        };
        /**
         * Sets the year of the given date.
         *
         * @param date The date to set the year on.
         * @param year The year to set.
         * @returns The new date with the year set.
         */
        this.setYear = (date, year) => {
            return this.overrides?.setYear
                ? this.overrides.setYear(date, year)
                : (0, date_fns_1.setYear)(date, year);
        };
        /**
         * Returns the start of the broadcast week for the given date.
         *
         * @param date The original date.
         * @returns The start of the broadcast week.
         */
        this.startOfBroadcastWeek = (date, _dateLib) => {
            return this.overrides?.startOfBroadcastWeek
                ? this.overrides.startOfBroadcastWeek(date, this)
                : (0, startOfBroadcastWeek_js_1.startOfBroadcastWeek)(date, this);
        };
        /**
         * Returns the start of the day for the given date.
         *
         * @param date The original date.
         * @returns The start of the day.
         */
        this.startOfDay = (date) => {
            return this.overrides?.startOfDay
                ? this.overrides.startOfDay(date)
                : (0, date_fns_1.startOfDay)(date);
        };
        /**
         * Returns the start of the ISO week for the given date.
         *
         * @param date The original date.
         * @returns The start of the ISO week.
         */
        this.startOfISOWeek = (date) => {
            return this.overrides?.startOfISOWeek
                ? this.overrides.startOfISOWeek(date)
                : (0, date_fns_1.startOfISOWeek)(date);
        };
        /**
         * Returns the start of the month for the given date.
         *
         * @param date The original date.
         * @returns The start of the month.
         */
        this.startOfMonth = (date) => {
            return this.overrides?.startOfMonth
                ? this.overrides.startOfMonth(date)
                : (0, date_fns_1.startOfMonth)(date);
        };
        /**
         * Returns the start of the week for the given date.
         *
         * @param date The original date.
         * @returns The start of the week.
         */
        this.startOfWeek = (date, _options) => {
            return this.overrides?.startOfWeek
                ? this.overrides.startOfWeek(date, this.options)
                : (0, date_fns_1.startOfWeek)(date, this.options);
        };
        /**
         * Returns the start of the year for the given date.
         *
         * @param date The original date.
         * @returns The start of the year.
         */
        this.startOfYear = (date) => {
            return this.overrides?.startOfYear
                ? this.overrides.startOfYear(date)
                : (0, date_fns_1.startOfYear)(date);
        };
        this.options = { locale: en_US_1.enUS, ...options };
        this.overrides = overrides;
    }
    /**
     * Generates a mapping of Arabic digits (0-9) to the target numbering system
     * digits.
     *
     * @since 9.5.0
     * @returns A record mapping Arabic digits to the target numerals.
     */
    getDigitMap() {
        const { numerals = "latn" } = this.options;
        // Use Intl.NumberFormat to create a formatter with the specified numbering system
        const formatter = new Intl.NumberFormat("en-US", {
            numberingSystem: numerals,
        });
        // Map Arabic digits (0-9) to the target numerals
        const digitMap = {};
        for (let i = 0; i < 10; i++) {
            digitMap[i.toString()] = formatter.format(i);
        }
        return digitMap;
    }
    /**
     * Replaces Arabic digits in a string with the target numbering system digits.
     *
     * @since 9.5.0
     * @param input The string containing Arabic digits.
     * @returns The string with digits replaced.
     */
    replaceDigits(input) {
        const digitMap = this.getDigitMap();
        return input.replace(/\d/g, (digit) => digitMap[digit] || digit);
    }
    /**
     * Formats a number using the configured numbering system.
     *
     * @since 9.5.0
     * @param value The number to format.
     * @returns The formatted number as a string.
     */
    formatNumber(value) {
        return this.replaceDigits(value.toString());
    }
    /**
     * Returns the preferred ordering for month and year labels for the current
     * locale.
     */
    getMonthYearOrder() {
        const code = this.options.locale?.code;
        if (!code) {
            return "month-first";
        }
        return DateLib.yearFirstLocales.has(code) ? "year-first" : "month-first";
    }
    /**
     * Formats the month/year pair respecting locale conventions.
     *
     * @since 9.11.0
     */
    formatMonthYear(date) {
        const { locale, timeZone, numerals } = this.options;
        const localeCode = locale?.code;
        if (localeCode && DateLib.yearFirstLocales.has(localeCode)) {
            try {
                const intl = new Intl.DateTimeFormat(localeCode, {
                    month: "long",
                    year: "numeric",
                    timeZone,
                    numberingSystem: numerals,
                });
                const formatted = intl.format(date);
                return formatted;
            }
            catch {
                // Fallback to date-fns formatting below.
            }
        }
        const pattern = this.getMonthYearOrder() === "year-first" ? "y LLLL" : "LLLL y";
        return this.format(date, pattern);
    }
}
exports.DateLib = DateLib;
DateLib.yearFirstLocales = new Set([
    "eu",
    "hu",
    "ja",
    "ja-Hira",
    "ja-JP",
    "ko",
    "ko-KR",
    "lt",
    "lt-LT",
    "lv",
    "lv-LV",
    "mn",
    "mn-MN",
    "zh",
    "zh-CN",
    "zh-HK",
    "zh-TW",
]);
/** The default locale (English). */
var en_US_2 = require("date-fns/locale/en-US");
Object.defineProperty(exports, "defaultLocale", { enumerable: true, get: function () { return en_US_2.enUS; } });
/**
 * The default date library with English locale.
 *
 * @since 9.2.0
 */
exports.defaultDateLib = new DateLib();
/**
 * @ignore
 * @deprecated Use `defaultDateLib`.
 */
exports.dateLib = exports.defaultDateLib;

~~~

## node_modules\react-day-picker\dist\cjs\classes\index.d.ts

~~~ts
export * from "./CalendarDay.js";
export * from "./CalendarMonth.js";
export * from "./CalendarWeek.js";
export * from "./DateLib.js";

~~~

## node_modules\react-day-picker\dist\cjs\classes\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./CalendarDay.js"), exports);
__exportStar(require("./CalendarMonth.js"), exports);
__exportStar(require("./CalendarWeek.js"), exports);
__exportStar(require("./DateLib.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\components\Button.d.ts

~~~ts
import React, { type ButtonHTMLAttributes } from "react";
/**
 * Render the button elements in the calendar.
 *
 * @private
 * @deprecated Use `PreviousMonthButton` or `@link NextMonthButton` instead.
 */
export declare function Button(props: ButtonHTMLAttributes<HTMLButtonElement>): React.JSX.Element;
export type ButtonProps = Parameters<typeof Button>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Button.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Button = Button;
const react_1 = __importDefault(require("react"));
/**
 * Render the button elements in the calendar.
 *
 * @private
 * @deprecated Use `PreviousMonthButton` or `@link NextMonthButton` instead.
 */
function Button(props) {
    return react_1.default.createElement("button", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\CaptionLabel.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the label in the month caption.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function CaptionLabel(props: HTMLAttributes<HTMLSpanElement>): React.JSX.Element;
export type CaptionLabelProps = Parameters<typeof CaptionLabel>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\CaptionLabel.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CaptionLabel = CaptionLabel;
const react_1 = __importDefault(require("react"));
/**
 * Render the label in the month caption.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function CaptionLabel(props) {
    return react_1.default.createElement("span", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Chevron.d.ts

~~~ts
import React from "react";
/**
 * Render the chevron icon used in the navigation buttons and dropdowns.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Chevron(props: {
    className?: string;
    /**
     * The size of the chevron.
     *
     * @defaultValue 24
     */
    size?: number;
    /** Set to `true` to disable the chevron. */
    disabled?: boolean;
    /** The orientation of the chevron. */
    orientation?: "up" | "down" | "left" | "right";
}): React.JSX.Element;
export type ChevronProps = Parameters<typeof Chevron>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Chevron.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chevron = Chevron;
const react_1 = __importDefault(require("react"));
/**
 * Render the chevron icon used in the navigation buttons and dropdowns.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Chevron(props) {
    const { size = 24, orientation = "left", className } = props;
    return (
    // biome-ignore lint/a11y/noSvgWithoutTitle: handled by the parent component
    react_1.default.createElement("svg", { className: className, width: size, height: size, viewBox: "0 0 24 24" },
        orientation === "up" && (react_1.default.createElement("polygon", { points: "6.77 17 12.5 11.43 18.24 17 20 15.28 12.5 8 5 15.28" })),
        orientation === "down" && (react_1.default.createElement("polygon", { points: "6.77 8 12.5 13.57 18.24 8 20 9.72 12.5 17 5 9.72" })),
        orientation === "left" && (react_1.default.createElement("polygon", { points: "16 18.112 9.81111111 12 16 5.87733333 14.0888889 4 6 12 14.0888889 20" })),
        orientation === "right" && (react_1.default.createElement("polygon", { points: "8 18.112 14.18888889 12 8 5.87733333 9.91111111 4 18 12 9.91111111 20" }))));
}

~~~

## node_modules\react-day-picker\dist\cjs\components\custom-components.d.ts

~~~ts
export * from "./Button.js";
export * from "./CaptionLabel.js";
export * from "./Chevron.js";
export * from "./Day.js";
export * from "./DayButton.js";
export * from "./Dropdown.js";
export * from "./DropdownNav.js";
export * from "./Footer.js";
export * from "./Month.js";
export * from "./MonthCaption.js";
export * from "./MonthGrid.js";
export * from "./Months.js";
export * from "./MonthsDropdown.js";
export * from "./Nav.js";
export * from "./NextMonthButton.js";
export * from "./Option.js";
export * from "./PreviousMonthButton.js";
export * from "./Root.js";
export * from "./Select.js";
export * from "./Week.js";
export * from "./Weekday.js";
export * from "./Weekdays.js";
export * from "./WeekNumber.js";
export * from "./WeekNumberHeader.js";
export * from "./Weeks.js";
export * from "./YearsDropdown.js";

~~~

## node_modules\react-day-picker\dist\cjs\components\custom-components.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./Button.js"), exports);
__exportStar(require("./CaptionLabel.js"), exports);
__exportStar(require("./Chevron.js"), exports);
__exportStar(require("./Day.js"), exports);
__exportStar(require("./DayButton.js"), exports);
__exportStar(require("./Dropdown.js"), exports);
__exportStar(require("./DropdownNav.js"), exports);
__exportStar(require("./Footer.js"), exports);
__exportStar(require("./Month.js"), exports);
__exportStar(require("./MonthCaption.js"), exports);
__exportStar(require("./MonthGrid.js"), exports);
__exportStar(require("./Months.js"), exports);
__exportStar(require("./MonthsDropdown.js"), exports);
__exportStar(require("./Nav.js"), exports);
__exportStar(require("./NextMonthButton.js"), exports);
__exportStar(require("./Option.js"), exports);
__exportStar(require("./PreviousMonthButton.js"), exports);
__exportStar(require("./Root.js"), exports);
__exportStar(require("./Select.js"), exports);
__exportStar(require("./Week.js"), exports);
__exportStar(require("./Weekday.js"), exports);
__exportStar(require("./Weekdays.js"), exports);
__exportStar(require("./WeekNumber.js"), exports);
__exportStar(require("./WeekNumberHeader.js"), exports);
__exportStar(require("./Weeks.js"), exports);
__exportStar(require("./YearsDropdown.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\components\Day.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
import type { CalendarDay } from "../classes/index.js";
import type { Modifiers } from "../types/index.js";
/**
 * Render a grid cell for a specific day in the calendar.
 *
 * Handles interaction and focus for the day. If you only need to change the
 * content of the day cell, consider swapping the `DayButton` component
 * instead.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Day(props: {
    /** The day to render. */
    day: CalendarDay;
    /** The modifiers to apply to the day. */
    modifiers: Modifiers;
} & HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type DayProps = Parameters<typeof Day>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Day.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Day = Day;
const react_1 = __importDefault(require("react"));
/**
 * Render a grid cell for a specific day in the calendar.
 *
 * Handles interaction and focus for the day. If you only need to change the
 * content of the day cell, consider swapping the `DayButton` component
 * instead.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Day(props) {
    const { day, modifiers, ...tdProps } = props;
    return react_1.default.createElement("td", { ...tdProps });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\DayButton.d.ts

~~~ts
import React, { type ButtonHTMLAttributes } from "react";
import type { CalendarDay } from "../classes/index.js";
import type { Modifiers } from "../types/index.js";
/**
 * Render a button for a specific day in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function DayButton(props: {
    /** The day to render. */
    day: CalendarDay;
    /** The modifiers to apply to the day. */
    modifiers: Modifiers;
} & ButtonHTMLAttributes<HTMLButtonElement>): React.JSX.Element;
export type DayButtonProps = Parameters<typeof DayButton>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\DayButton.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DayButton = DayButton;
const react_1 = __importDefault(require("react"));
/**
 * Render a button for a specific day in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function DayButton(props) {
    const { day, modifiers, ...buttonProps } = props;
    const ref = react_1.default.useRef(null);
    react_1.default.useEffect(() => {
        if (modifiers.focused)
            ref.current?.focus();
    }, [modifiers.focused]);
    return react_1.default.createElement("button", { ref: ref, ...buttonProps });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Dropdown.d.ts

~~~ts
import React, { type SelectHTMLAttributes } from "react";
import type { ClassNames, CustomComponents } from "../types/index.js";
/** An option to use in the dropdown. Maps to the `<option>` HTML element. */
export type DropdownOption = {
    /** The value of the option. */
    value: number;
    /** The label of the option. */
    label: string;
    /** Whether the dropdown option is disabled (e.g., out of the calendar range). */
    disabled: boolean;
};
/**
 * Render a dropdown component for navigation in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Dropdown(props: {
    /**
     * @deprecated Use {@link useDayPicker} hook to get the list of internal
     *   components.
     */
    components: CustomComponents;
    /**
     * @deprecated Use {@link useDayPicker} hook to get the list of internal
     *   class names.
     */
    classNames: ClassNames;
    /** The options to display in the dropdown. */
    options?: DropdownOption[] | undefined;
} & Omit<SelectHTMLAttributes<HTMLSelectElement>, "children">): React.JSX.Element;
export type DropdownProps = Parameters<typeof Dropdown>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Dropdown.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dropdown = Dropdown;
const react_1 = __importDefault(require("react"));
const UI_js_1 = require("../UI.js");
/**
 * Render a dropdown component for navigation in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Dropdown(props) {
    const { options, className, components, classNames, ...selectProps } = props;
    const cssClassSelect = [classNames[UI_js_1.UI.Dropdown], className].join(" ");
    const selectedOption = options?.find(({ value }) => value === selectProps.value);
    return (react_1.default.createElement("span", { "data-disabled": selectProps.disabled, className: classNames[UI_js_1.UI.DropdownRoot] },
        react_1.default.createElement(components.Select, { className: cssClassSelect, ...selectProps }, options?.map(({ value, label, disabled }) => (react_1.default.createElement(components.Option, { key: value, value: value, disabled: disabled }, label)))),
        react_1.default.createElement("span", { className: classNames[UI_js_1.UI.CaptionLabel], "aria-hidden": true },
            selectedOption?.label,
            react_1.default.createElement(components.Chevron, { orientation: "down", size: 18, className: classNames[UI_js_1.UI.Chevron] }))));
}

~~~

## node_modules\react-day-picker\dist\cjs\components\DropdownNav.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the navigation dropdowns for the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function DropdownNav(props: HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type DropdownNavProps = Parameters<typeof DropdownNav>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\DropdownNav.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DropdownNav = DropdownNav;
const react_1 = __importDefault(require("react"));
/**
 * Render the navigation dropdowns for the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function DropdownNav(props) {
    return react_1.default.createElement("div", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Footer.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the footer of the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Footer(props: HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type FooterProps = Parameters<typeof Footer>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Footer.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Footer = Footer;
const react_1 = __importDefault(require("react"));
/**
 * Render the footer of the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Footer(props) {
    return react_1.default.createElement("div", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Month.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
import type { CalendarMonth } from "../classes/CalendarMonth.js";
/**
 * Render the grid with the weekday header row and the weeks for a specific
 * month.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Month(props: {
    /** The month to display in the grid. */
    calendarMonth: CalendarMonth;
    /** The index of the month being displayed. */
    displayIndex: number;
} & HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type MonthProps = Parameters<typeof Month>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Month.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Month = Month;
const react_1 = __importDefault(require("react"));
/**
 * Render the grid with the weekday header row and the weeks for a specific
 * month.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Month(props) {
    const { calendarMonth, displayIndex, ...divProps } = props;
    return react_1.default.createElement("div", { ...divProps }, props.children);
}

~~~

## node_modules\react-day-picker\dist\cjs\components\MonthCaption.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
import type { CalendarMonth } from "../classes/index.js";
/**
 * Render the caption for a month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function MonthCaption(props: {
    /** The month to display in the caption. */
    calendarMonth: CalendarMonth;
    /** The index of the month being displayed. */
    displayIndex: number;
} & HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type MonthCaptionProps = Parameters<typeof MonthCaption>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\MonthCaption.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonthCaption = MonthCaption;
const react_1 = __importDefault(require("react"));
/**
 * Render the caption for a month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function MonthCaption(props) {
    const { calendarMonth, displayIndex, ...divProps } = props;
    return react_1.default.createElement("div", { ...divProps });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\MonthGrid.d.ts

~~~ts
import React, { type TableHTMLAttributes } from "react";
/**
 * Render the grid of days for a specific month.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function MonthGrid(props: TableHTMLAttributes<HTMLTableElement>): React.JSX.Element;
export type MonthGridProps = Parameters<typeof MonthGrid>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\MonthGrid.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonthGrid = MonthGrid;
const react_1 = __importDefault(require("react"));
/**
 * Render the grid of days for a specific month.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function MonthGrid(props) {
    return react_1.default.createElement("table", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Months.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render a container wrapping the month grids.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Months(props: HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type MonthsProps = Parameters<typeof Months>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Months.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Months = Months;
const react_1 = __importDefault(require("react"));
/**
 * Render a container wrapping the month grids.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Months(props) {
    return react_1.default.createElement("div", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\MonthsDropdown.d.ts

~~~ts
import React from "react";
import type { DropdownProps } from "./Dropdown.js";
/**
 * Render a dropdown to navigate between months in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function MonthsDropdown(props: DropdownProps): React.JSX.Element;

~~~

## node_modules\react-day-picker\dist\cjs\components\MonthsDropdown.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MonthsDropdown = MonthsDropdown;
const react_1 = __importDefault(require("react"));
const useDayPicker_js_1 = require("../useDayPicker.js");
/**
 * Render a dropdown to navigate between months in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function MonthsDropdown(props) {
    const { components } = (0, useDayPicker_js_1.useDayPicker)();
    return react_1.default.createElement(components.Dropdown, { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Nav.d.ts

~~~ts
import React, { type HTMLAttributes, type MouseEventHandler } from "react";
/**
 * Render the navigation toolbar with buttons to navigate between months.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Nav(props: {
    /** Handler for the previous month button click. */
    onPreviousClick?: MouseEventHandler<HTMLButtonElement>;
    /** Handler for the next month button click. */
    onNextClick?: MouseEventHandler<HTMLButtonElement>;
    /** The date of the previous month, if available. */
    previousMonth?: Date | undefined;
    /** The date of the next month, if available. */
    nextMonth?: Date | undefined;
} & HTMLAttributes<HTMLElement>): React.JSX.Element;
export type NavProps = Parameters<typeof Nav>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Nav.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Nav = Nav;
const react_1 = __importStar(require("react"));
const UI_js_1 = require("../UI.js");
const useDayPicker_js_1 = require("../useDayPicker.js");
/**
 * Render the navigation toolbar with buttons to navigate between months.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Nav(props) {
    const { onPreviousClick, onNextClick, previousMonth, nextMonth, ...navProps } = props;
    const { components, classNames, labels: { labelPrevious, labelNext }, } = (0, useDayPicker_js_1.useDayPicker)();
    const handleNextClick = (0, react_1.useCallback)((e) => {
        if (nextMonth) {
            onNextClick?.(e);
        }
    }, [nextMonth, onNextClick]);
    const handlePreviousClick = (0, react_1.useCallback)((e) => {
        if (previousMonth) {
            onPreviousClick?.(e);
        }
    }, [previousMonth, onPreviousClick]);
    return (react_1.default.createElement("nav", { ...navProps },
        react_1.default.createElement(components.PreviousMonthButton, { type: "button", className: classNames[UI_js_1.UI.PreviousMonthButton], tabIndex: previousMonth ? undefined : -1, "aria-disabled": previousMonth ? undefined : true, "aria-label": labelPrevious(previousMonth), onClick: handlePreviousClick },
            react_1.default.createElement(components.Chevron, { disabled: previousMonth ? undefined : true, className: classNames[UI_js_1.UI.Chevron], orientation: "left" })),
        react_1.default.createElement(components.NextMonthButton, { type: "button", className: classNames[UI_js_1.UI.NextMonthButton], tabIndex: nextMonth ? undefined : -1, "aria-disabled": nextMonth ? undefined : true, "aria-label": labelNext(nextMonth), onClick: handleNextClick },
            react_1.default.createElement(components.Chevron, { disabled: nextMonth ? undefined : true, orientation: "right", className: classNames[UI_js_1.UI.Chevron] }))));
}

~~~

## node_modules\react-day-picker\dist\cjs\components\NextMonthButton.d.ts

~~~ts
import React, { type ButtonHTMLAttributes } from "react";
/**
 * Render the button to navigate to the next month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function NextMonthButton(props: ButtonHTMLAttributes<HTMLButtonElement>): React.JSX.Element;
export type NextMonthButtonProps = Parameters<typeof NextMonthButton>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\NextMonthButton.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NextMonthButton = NextMonthButton;
const react_1 = __importDefault(require("react"));
const useDayPicker_js_1 = require("../useDayPicker.js");
/**
 * Render the button to navigate to the next month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function NextMonthButton(props) {
    const { components } = (0, useDayPicker_js_1.useDayPicker)();
    return react_1.default.createElement(components.Button, { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Option.d.ts

~~~ts
import React, { type OptionHTMLAttributes } from "react";
/**
 * Render an `option` element.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Option(props: OptionHTMLAttributes<HTMLOptionElement>): React.JSX.Element;
export type OptionProps = Parameters<typeof Option>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Option.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Option = Option;
const react_1 = __importDefault(require("react"));
/**
 * Render an `option` element.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Option(props) {
    return react_1.default.createElement("option", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\PreviousMonthButton.d.ts

~~~ts
import React, { type ButtonHTMLAttributes } from "react";
/**
 * Render the button to navigate to the previous month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function PreviousMonthButton(props: ButtonHTMLAttributes<HTMLButtonElement>): React.JSX.Element;
export type PreviousMonthButtonProps = Parameters<typeof PreviousMonthButton>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\PreviousMonthButton.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreviousMonthButton = PreviousMonthButton;
const react_1 = __importDefault(require("react"));
const useDayPicker_js_1 = require("../useDayPicker.js");
/**
 * Render the button to navigate to the previous month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function PreviousMonthButton(props) {
    const { components } = (0, useDayPicker_js_1.useDayPicker)();
    return react_1.default.createElement(components.Button, { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Root.d.ts

~~~ts
import React, { type HTMLAttributes, type Ref } from "react";
/**
 * Render the root element of the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Root(props: {
    /** Ref for the root element, used when `animate` is `true`. */
    rootRef?: Ref<HTMLDivElement>;
} & HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type RootProps = Parameters<typeof Root>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Root.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Root = Root;
const react_1 = __importDefault(require("react"));
/**
 * Render the root element of the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Root(props) {
    const { rootRef, ...rest } = props;
    return react_1.default.createElement("div", { ...rest, ref: rootRef });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Select.d.ts

~~~ts
import React, { type SelectHTMLAttributes } from "react";
/**
 * Render a `select` element.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Select(props: SelectHTMLAttributes<HTMLSelectElement>): React.JSX.Element;
export type SelectProps = Parameters<typeof Select>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Select.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Select = Select;
const react_1 = __importDefault(require("react"));
/**
 * Render a `select` element.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Select(props) {
    return react_1.default.createElement("select", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Week.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
import type { CalendarWeek } from "../classes/index.js";
/**
 * Render a table row representing a week in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Week(props: {
    /** The week to render. */
    week: CalendarWeek;
} & HTMLAttributes<HTMLTableRowElement>): React.JSX.Element;
export type WeekProps = Parameters<typeof Week>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Week.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Week = Week;
const react_1 = __importDefault(require("react"));
/**
 * Render a table row representing a week in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Week(props) {
    const { week, ...trProps } = props;
    return react_1.default.createElement("tr", { ...trProps });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Weekday.d.ts

~~~ts
import React, { type ThHTMLAttributes } from "react";
/**
 * Render a table header cell with the name of a weekday (e.g., "Mo", "Tu").
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Weekday(props: ThHTMLAttributes<HTMLTableCellElement>): React.JSX.Element;
export type WeekdayProps = Parameters<typeof Weekday>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Weekday.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Weekday = Weekday;
const react_1 = __importDefault(require("react"));
/**
 * Render a table header cell with the name of a weekday (e.g., "Mo", "Tu").
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Weekday(props) {
    return react_1.default.createElement("th", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Weekdays.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the table row containing the weekday names.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Weekdays(props: HTMLAttributes<HTMLTableRowElement>): React.JSX.Element;
export type WeekdaysProps = Parameters<typeof Weekdays>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Weekdays.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Weekdays = Weekdays;
const react_1 = __importDefault(require("react"));
/**
 * Render the table row containing the weekday names.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Weekdays(props) {
    return (react_1.default.createElement("thead", { "aria-hidden": true },
        react_1.default.createElement("tr", { ...props })));
}

~~~

## node_modules\react-day-picker\dist\cjs\components\WeekNumber.d.ts

~~~ts
import React, { type ThHTMLAttributes } from "react";
import type { CalendarWeek } from "../classes/index.js";
/**
 * Render a table cell displaying the number of the week.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function WeekNumber(props: {
    /** The week to display. */
    week: CalendarWeek;
} & ThHTMLAttributes<HTMLTableCellElement>): React.JSX.Element;
export type WeekNumberProps = Parameters<typeof WeekNumber>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\WeekNumber.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WeekNumber = WeekNumber;
const react_1 = __importDefault(require("react"));
/**
 * Render a table cell displaying the number of the week.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function WeekNumber(props) {
    const { week, ...thProps } = props;
    return react_1.default.createElement("th", { ...thProps });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\WeekNumberHeader.d.ts

~~~ts
import React, { type ThHTMLAttributes } from "react";
/**
 * Render the header cell for the week numbers column.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function WeekNumberHeader(props: ThHTMLAttributes<HTMLTableCellElement>): React.JSX.Element;
export type WeekNumberHeaderProps = Parameters<typeof WeekNumberHeader>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\WeekNumberHeader.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WeekNumberHeader = WeekNumberHeader;
const react_1 = __importDefault(require("react"));
/**
 * Render the header cell for the week numbers column.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function WeekNumberHeader(props) {
    return react_1.default.createElement("th", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\Weeks.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the container for the weeks in the month grid.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Weeks(props: HTMLAttributes<HTMLTableSectionElement>): React.JSX.Element;
export type WeeksProps = Parameters<typeof Weeks>[0];

~~~

## node_modules\react-day-picker\dist\cjs\components\Weeks.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Weeks = Weeks;
const react_1 = __importDefault(require("react"));
/**
 * Render the container for the weeks in the month grid.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function Weeks(props) {
    return react_1.default.createElement("tbody", { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\components\YearsDropdown.d.ts

~~~ts
import React from "react";
import type { DropdownProps } from "./Dropdown.js";
/**
 * Render a dropdown to navigate between years in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function YearsDropdown(props: DropdownProps): React.JSX.Element;

~~~

## node_modules\react-day-picker\dist\cjs\components\YearsDropdown.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YearsDropdown = YearsDropdown;
const react_1 = __importDefault(require("react"));
const useDayPicker_js_1 = require("../useDayPicker.js");
/**
 * Render a dropdown to navigate between years in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
function YearsDropdown(props) {
    const { components } = (0, useDayPicker_js_1.useDayPicker)();
    return react_1.default.createElement(components.Dropdown, { ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\DayPicker.d.ts

~~~ts
import React from "react";
import type { DayPickerProps } from "./types/index.js";
/**
 * Renders the DayPicker calendar component.
 *
 * @param initialProps - The props for the DayPicker component.
 * @returns The rendered DayPicker component.
 * @group DayPicker
 * @see https://daypicker.dev
 */
export declare function DayPicker(initialProps: DayPickerProps): React.JSX.Element;

~~~

## node_modules\react-day-picker\dist\cjs\DayPicker.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DayPicker = DayPicker;
const tz_1 = require("@date-fns/tz");
const react_1 = __importStar(require("react"));
const DateLib_js_1 = require("./classes/DateLib.js");
const createGetModifiers_js_1 = require("./helpers/createGetModifiers.js");
const getClassNamesForModifiers_js_1 = require("./helpers/getClassNamesForModifiers.js");
const getComponents_js_1 = require("./helpers/getComponents.js");
const getDataAttributes_js_1 = require("./helpers/getDataAttributes.js");
const getDefaultClassNames_js_1 = require("./helpers/getDefaultClassNames.js");
const getFormatters_js_1 = require("./helpers/getFormatters.js");
const getMonthOptions_js_1 = require("./helpers/getMonthOptions.js");
const getStyleForModifiers_js_1 = require("./helpers/getStyleForModifiers.js");
const getWeekdays_js_1 = require("./helpers/getWeekdays.js");
const getYearOptions_js_1 = require("./helpers/getYearOptions.js");
const defaultLabels = __importStar(require("./labels/index.js"));
const UI_js_1 = require("./UI.js");
const useAnimation_js_1 = require("./useAnimation.js");
const useCalendar_js_1 = require("./useCalendar.js");
const useDayPicker_js_1 = require("./useDayPicker.js");
const useFocus_js_1 = require("./useFocus.js");
const useSelection_js_1 = require("./useSelection.js");
const rangeIncludesDate_js_1 = require("./utils/rangeIncludesDate.js");
const typeguards_js_1 = require("./utils/typeguards.js");
/**
 * Renders the DayPicker calendar component.
 *
 * @param initialProps - The props for the DayPicker component.
 * @returns The rendered DayPicker component.
 * @group DayPicker
 * @see https://daypicker.dev
 */
function DayPicker(initialProps) {
    let props = initialProps;
    if (props.timeZone) {
        props = {
            ...initialProps,
        };
        if (props.today) {
            props.today = new tz_1.TZDate(props.today, props.timeZone);
        }
        if (props.month) {
            props.month = new tz_1.TZDate(props.month, props.timeZone);
        }
        if (props.defaultMonth) {
            props.defaultMonth = new tz_1.TZDate(props.defaultMonth, props.timeZone);
        }
        if (props.startMonth) {
            props.startMonth = new tz_1.TZDate(props.startMonth, props.timeZone);
        }
        if (props.endMonth) {
            props.endMonth = new tz_1.TZDate(props.endMonth, props.timeZone);
        }
        if (props.mode === "single" && props.selected) {
            props.selected = new tz_1.TZDate(props.selected, props.timeZone);
        }
        else if (props.mode === "multiple" && props.selected) {
            props.selected = props.selected?.map((date) => new tz_1.TZDate(date, props.timeZone));
        }
        else if (props.mode === "range" && props.selected) {
            props.selected = {
                from: props.selected.from
                    ? new tz_1.TZDate(props.selected.from, props.timeZone)
                    : undefined,
                to: props.selected.to
                    ? new tz_1.TZDate(props.selected.to, props.timeZone)
                    : undefined,
            };
        }
    }
    const { components, formatters, labels, dateLib, locale, classNames } = (0, react_1.useMemo)(() => {
        const locale = { ...DateLib_js_1.defaultLocale, ...props.locale };
        const dateLib = new DateLib_js_1.DateLib({
            locale,
            weekStartsOn: props.broadcastCalendar ? 1 : props.weekStartsOn,
            firstWeekContainsDate: props.firstWeekContainsDate,
            useAdditionalWeekYearTokens: props.useAdditionalWeekYearTokens,
            useAdditionalDayOfYearTokens: props.useAdditionalDayOfYearTokens,
            timeZone: props.timeZone,
            numerals: props.numerals,
        }, props.dateLib);
        return {
            dateLib,
            components: (0, getComponents_js_1.getComponents)(props.components),
            formatters: (0, getFormatters_js_1.getFormatters)(props.formatters),
            labels: { ...defaultLabels, ...props.labels },
            locale,
            classNames: { ...(0, getDefaultClassNames_js_1.getDefaultClassNames)(), ...props.classNames },
        };
    }, [
        props.locale,
        props.broadcastCalendar,
        props.weekStartsOn,
        props.firstWeekContainsDate,
        props.useAdditionalWeekYearTokens,
        props.useAdditionalDayOfYearTokens,
        props.timeZone,
        props.numerals,
        props.dateLib,
        props.components,
        props.formatters,
        props.labels,
        props.classNames,
    ]);
    const { captionLayout, mode, navLayout, numberOfMonths = 1, onDayBlur, onDayClick, onDayFocus, onDayKeyDown, onDayMouseEnter, onDayMouseLeave, onNextClick, onPrevClick, showWeekNumber, styles, } = props;
    const { formatCaption, formatDay, formatMonthDropdown, formatWeekNumber, formatWeekNumberHeader, formatWeekdayName, formatYearDropdown, } = formatters;
    const calendar = (0, useCalendar_js_1.useCalendar)(props, dateLib);
    const { days, months, navStart, navEnd, previousMonth, nextMonth, goToMonth, } = calendar;
    const getModifiers = (0, createGetModifiers_js_1.createGetModifiers)(days, props, navStart, navEnd, dateLib);
    const { isSelected, select, selected: selectedValue, } = (0, useSelection_js_1.useSelection)(props, dateLib) ?? {};
    const { blur, focused, isFocusTarget, moveFocus, setFocused } = (0, useFocus_js_1.useFocus)(props, calendar, getModifiers, isSelected ?? (() => false), dateLib);
    const { labelDayButton, labelGridcell, labelGrid, labelMonthDropdown, labelNav, labelPrevious, labelNext, labelWeekday, labelWeekNumber, labelWeekNumberHeader, labelYearDropdown, } = labels;
    const weekdays = (0, react_1.useMemo)(() => (0, getWeekdays_js_1.getWeekdays)(dateLib, props.ISOWeek), [dateLib, props.ISOWeek]);
    const isInteractive = mode !== undefined || onDayClick !== undefined;
    const handlePreviousClick = (0, react_1.useCallback)(() => {
        if (!previousMonth)
            return;
        goToMonth(previousMonth);
        onPrevClick?.(previousMonth);
    }, [previousMonth, goToMonth, onPrevClick]);
    const handleNextClick = (0, react_1.useCallback)(() => {
        if (!nextMonth)
            return;
        goToMonth(nextMonth);
        onNextClick?.(nextMonth);
    }, [goToMonth, nextMonth, onNextClick]);
    const handleDayClick = (0, react_1.useCallback)((day, m) => (e) => {
        e.preventDefault();
        e.stopPropagation();
        setFocused(day);
        select?.(day.date, m, e);
        onDayClick?.(day.date, m, e);
    }, [select, onDayClick, setFocused]);
    const handleDayFocus = (0, react_1.useCallback)((day, m) => (e) => {
        setFocused(day);
        onDayFocus?.(day.date, m, e);
    }, [onDayFocus, setFocused]);
    const handleDayBlur = (0, react_1.useCallback)((day, m) => (e) => {
        blur();
        onDayBlur?.(day.date, m, e);
    }, [blur, onDayBlur]);
    const handleDayKeyDown = (0, react_1.useCallback)((day, modifiers) => (e) => {
        const keyMap = {
            ArrowLeft: [
                e.shiftKey ? "month" : "day",
                props.dir === "rtl" ? "after" : "before",
            ],
            ArrowRight: [
                e.shiftKey ? "month" : "day",
                props.dir === "rtl" ? "before" : "after",
            ],
            ArrowDown: [e.shiftKey ? "year" : "week", "after"],
            ArrowUp: [e.shiftKey ? "year" : "week", "before"],
            PageUp: [e.shiftKey ? "year" : "month", "before"],
            PageDown: [e.shiftKey ? "year" : "month", "after"],
            Home: ["startOfWeek", "before"],
            End: ["endOfWeek", "after"],
        };
        if (keyMap[e.key]) {
            e.preventDefault();
            e.stopPropagation();
            const [moveBy, moveDir] = keyMap[e.key];
            moveFocus(moveBy, moveDir);
        }
        onDayKeyDown?.(day.date, modifiers, e);
    }, [moveFocus, onDayKeyDown, props.dir]);
    const handleDayMouseEnter = (0, react_1.useCallback)((day, modifiers) => (e) => {
        onDayMouseEnter?.(day.date, modifiers, e);
    }, [onDayMouseEnter]);
    const handleDayMouseLeave = (0, react_1.useCallback)((day, modifiers) => (e) => {
        onDayMouseLeave?.(day.date, modifiers, e);
    }, [onDayMouseLeave]);
    const handleMonthChange = (0, react_1.useCallback)((date) => (e) => {
        const selectedMonth = Number(e.target.value);
        const month = dateLib.setMonth(dateLib.startOfMonth(date), selectedMonth);
        goToMonth(month);
    }, [dateLib, goToMonth]);
    const handleYearChange = (0, react_1.useCallback)((date) => (e) => {
        const selectedYear = Number(e.target.value);
        const month = dateLib.setYear(dateLib.startOfMonth(date), selectedYear);
        goToMonth(month);
    }, [dateLib, goToMonth]);
    const { className, style } = (0, react_1.useMemo)(() => ({
        className: [classNames[UI_js_1.UI.Root], props.className]
            .filter(Boolean)
            .join(" "),
        style: { ...styles?.[UI_js_1.UI.Root], ...props.style },
    }), [classNames, props.className, props.style, styles]);
    const dataAttributes = (0, getDataAttributes_js_1.getDataAttributes)(props);
    const rootElRef = (0, react_1.useRef)(null);
    (0, useAnimation_js_1.useAnimation)(rootElRef, Boolean(props.animate), {
        classNames,
        months,
        focused,
        dateLib,
    });
    const contextValue = {
        dayPickerProps: props,
        selected: selectedValue,
        select: select,
        isSelected,
        months,
        nextMonth,
        previousMonth,
        goToMonth,
        getModifiers,
        components,
        classNames,
        styles,
        labels,
        formatters,
    };
    return (react_1.default.createElement(useDayPicker_js_1.dayPickerContext.Provider, { value: contextValue },
        react_1.default.createElement(components.Root, { rootRef: props.animate ? rootElRef : undefined, className: className, style: style, dir: props.dir, id: props.id, lang: props.lang, nonce: props.nonce, title: props.title, role: props.role, "aria-label": props["aria-label"], "aria-labelledby": props["aria-labelledby"], ...dataAttributes },
            react_1.default.createElement(components.Months, { className: classNames[UI_js_1.UI.Months], style: styles?.[UI_js_1.UI.Months] },
                !props.hideNavigation && !navLayout && (react_1.default.createElement(components.Nav, { "data-animated-nav": props.animate ? "true" : undefined, className: classNames[UI_js_1.UI.Nav], style: styles?.[UI_js_1.UI.Nav], "aria-label": labelNav(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth: previousMonth, nextMonth: nextMonth })),
                months.map((calendarMonth, displayIndex) => {
                    return (react_1.default.createElement(components.Month, { "data-animated-month": props.animate ? "true" : undefined, className: classNames[UI_js_1.UI.Month], style: styles?.[UI_js_1.UI.Month], 
                        // biome-ignore lint/suspicious/noArrayIndexKey: breaks animation
                        key: displayIndex, displayIndex: displayIndex, calendarMonth: calendarMonth },
                        navLayout === "around" &&
                            !props.hideNavigation &&
                            displayIndex === 0 && (react_1.default.createElement(components.PreviousMonthButton, { type: "button", className: classNames[UI_js_1.UI.PreviousMonthButton], tabIndex: previousMonth ? undefined : -1, "aria-disabled": previousMonth ? undefined : true, "aria-label": labelPrevious(previousMonth), onClick: handlePreviousClick, "data-animated-button": props.animate ? "true" : undefined },
                            react_1.default.createElement(components.Chevron, { disabled: previousMonth ? undefined : true, className: classNames[UI_js_1.UI.Chevron], orientation: props.dir === "rtl" ? "right" : "left" }))),
                        react_1.default.createElement(components.MonthCaption, { "data-animated-caption": props.animate ? "true" : undefined, className: classNames[UI_js_1.UI.MonthCaption], style: styles?.[UI_js_1.UI.MonthCaption], calendarMonth: calendarMonth, displayIndex: displayIndex }, captionLayout?.startsWith("dropdown") ? (react_1.default.createElement(components.DropdownNav, { className: classNames[UI_js_1.UI.Dropdowns], style: styles?.[UI_js_1.UI.Dropdowns] },
                            (() => {
                                const monthControl = captionLayout === "dropdown" ||
                                    captionLayout === "dropdown-months" ? (react_1.default.createElement(components.MonthsDropdown, { key: "month", className: classNames[UI_js_1.UI.MonthsDropdown], "aria-label": labelMonthDropdown(), classNames: classNames, components: components, disabled: Boolean(props.disableNavigation), onChange: handleMonthChange(calendarMonth.date), options: (0, getMonthOptions_js_1.getMonthOptions)(calendarMonth.date, navStart, navEnd, formatters, dateLib), style: styles?.[UI_js_1.UI.Dropdown], value: dateLib.getMonth(calendarMonth.date) })) : (react_1.default.createElement("span", { key: "month" }, formatMonthDropdown(calendarMonth.date, dateLib)));
                                const yearControl = captionLayout === "dropdown" ||
                                    captionLayout === "dropdown-years" ? (react_1.default.createElement(components.YearsDropdown, { key: "year", className: classNames[UI_js_1.UI.YearsDropdown], "aria-label": labelYearDropdown(dateLib.options), classNames: classNames, components: components, disabled: Boolean(props.disableNavigation), onChange: handleYearChange(calendarMonth.date), options: (0, getYearOptions_js_1.getYearOptions)(navStart, navEnd, formatters, dateLib, Boolean(props.reverseYears)), style: styles?.[UI_js_1.UI.Dropdown], value: dateLib.getYear(calendarMonth.date) })) : (react_1.default.createElement("span", { key: "year" }, formatYearDropdown(calendarMonth.date, dateLib)));
                                const controls = dateLib.getMonthYearOrder() === "year-first"
                                    ? [yearControl, monthControl]
                                    : [monthControl, yearControl];
                                return controls;
                            })(),
                            react_1.default.createElement("span", { role: "status", "aria-live": "polite", style: {
                                    border: 0,
                                    clip: "rect(0 0 0 0)",
                                    height: "1px",
                                    margin: "-1px",
                                    overflow: "hidden",
                                    padding: 0,
                                    position: "absolute",
                                    width: "1px",
                                    whiteSpace: "nowrap",
                                    wordWrap: "normal",
                                } }, formatCaption(calendarMonth.date, dateLib.options, dateLib)))) : (
                        // biome-ignore lint/a11y/useSemanticElements: breaking change
                        react_1.default.createElement(components.CaptionLabel, { className: classNames[UI_js_1.UI.CaptionLabel], role: "status", "aria-live": "polite" }, formatCaption(calendarMonth.date, dateLib.options, dateLib)))),
                        navLayout === "around" &&
                            !props.hideNavigation &&
                            displayIndex === numberOfMonths - 1 && (react_1.default.createElement(components.NextMonthButton, { type: "button", className: classNames[UI_js_1.UI.NextMonthButton], tabIndex: nextMonth ? undefined : -1, "aria-disabled": nextMonth ? undefined : true, "aria-label": labelNext(nextMonth), onClick: handleNextClick, "data-animated-button": props.animate ? "true" : undefined },
                            react_1.default.createElement(components.Chevron, { disabled: nextMonth ? undefined : true, className: classNames[UI_js_1.UI.Chevron], orientation: props.dir === "rtl" ? "left" : "right" }))),
                        displayIndex === numberOfMonths - 1 &&
                            navLayout === "after" &&
                            !props.hideNavigation && (react_1.default.createElement(components.Nav, { "data-animated-nav": props.animate ? "true" : undefined, className: classNames[UI_js_1.UI.Nav], style: styles?.[UI_js_1.UI.Nav], "aria-label": labelNav(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth: previousMonth, nextMonth: nextMonth })),
                        react_1.default.createElement(components.MonthGrid, { role: "grid", "aria-multiselectable": mode === "multiple" || mode === "range", "aria-label": labelGrid(calendarMonth.date, dateLib.options, dateLib) ||
                                undefined, className: classNames[UI_js_1.UI.MonthGrid], style: styles?.[UI_js_1.UI.MonthGrid] },
                            !props.hideWeekdays && (react_1.default.createElement(components.Weekdays, { "data-animated-weekdays": props.animate ? "true" : undefined, className: classNames[UI_js_1.UI.Weekdays], style: styles?.[UI_js_1.UI.Weekdays] },
                                showWeekNumber && (react_1.default.createElement(components.WeekNumberHeader, { "aria-label": labelWeekNumberHeader(dateLib.options), className: classNames[UI_js_1.UI.WeekNumberHeader], style: styles?.[UI_js_1.UI.WeekNumberHeader], scope: "col" }, formatWeekNumberHeader())),
                                weekdays.map((weekday) => (react_1.default.createElement(components.Weekday, { "aria-label": labelWeekday(weekday, dateLib.options, dateLib), className: classNames[UI_js_1.UI.Weekday], key: String(weekday), style: styles?.[UI_js_1.UI.Weekday], scope: "col" }, formatWeekdayName(weekday, dateLib.options, dateLib)))))),
                            react_1.default.createElement(components.Weeks, { "data-animated-weeks": props.animate ? "true" : undefined, className: classNames[UI_js_1.UI.Weeks], style: styles?.[UI_js_1.UI.Weeks] }, calendarMonth.weeks.map((week) => {
                                return (react_1.default.createElement(components.Week, { className: classNames[UI_js_1.UI.Week], key: week.weekNumber, style: styles?.[UI_js_1.UI.Week], week: week },
                                    showWeekNumber && (
                                    // biome-ignore lint/a11y/useSemanticElements: react component
                                    react_1.default.createElement(components.WeekNumber, { week: week, style: styles?.[UI_js_1.UI.WeekNumber], "aria-label": labelWeekNumber(week.weekNumber, {
                                            locale,
                                        }), className: classNames[UI_js_1.UI.WeekNumber], scope: "row", role: "rowheader" }, formatWeekNumber(week.weekNumber, dateLib))),
                                    week.days.map((day) => {
                                        const { date } = day;
                                        const modifiers = getModifiers(day);
                                        modifiers[UI_js_1.DayFlag.focused] =
                                            !modifiers.hidden &&
                                                Boolean(focused?.isEqualTo(day));
                                        modifiers[UI_js_1.SelectionState.selected] =
                                            isSelected?.(date) || modifiers.selected;
                                        if ((0, typeguards_js_1.isDateRange)(selectedValue)) {
                                            // add range modifiers
                                            const { from, to } = selectedValue;
                                            modifiers[UI_js_1.SelectionState.range_start] = Boolean(from && to && dateLib.isSameDay(date, from));
                                            modifiers[UI_js_1.SelectionState.range_end] = Boolean(from && to && dateLib.isSameDay(date, to));
                                            modifiers[UI_js_1.SelectionState.range_middle] =
                                                (0, rangeIncludesDate_js_1.rangeIncludesDate)(selectedValue, date, true, dateLib);
                                        }
                                        const style = (0, getStyleForModifiers_js_1.getStyleForModifiers)(modifiers, styles, props.modifiersStyles);
                                        const className = (0, getClassNamesForModifiers_js_1.getClassNamesForModifiers)(modifiers, classNames, props.modifiersClassNames);
                                        const ariaLabel = !isInteractive && !modifiers.hidden
                                            ? labelGridcell(date, modifiers, dateLib.options, dateLib)
                                            : undefined;
                                        return (
                                        // biome-ignore lint/a11y/useSemanticElements: react component
                                        react_1.default.createElement(components.Day, { key: `${dateLib.format(date, "yyyy-MM-dd")}_${dateLib.format(day.displayMonth, "yyyy-MM")}`, day: day, modifiers: modifiers, className: className.join(" "), style: style, role: "gridcell", "aria-selected": modifiers.selected || undefined, "aria-label": ariaLabel, "data-day": dateLib.format(date, "yyyy-MM-dd"), "data-month": day.outside
                                                ? dateLib.format(date, "yyyy-MM")
                                                : undefined, "data-selected": modifiers.selected || undefined, "data-disabled": modifiers.disabled || undefined, "data-hidden": modifiers.hidden || undefined, "data-outside": day.outside || undefined, "data-focused": modifiers.focused || undefined, "data-today": modifiers.today || undefined }, !modifiers.hidden && isInteractive ? (react_1.default.createElement(components.DayButton, { className: classNames[UI_js_1.UI.DayButton], style: styles?.[UI_js_1.UI.DayButton], type: "button", day: day, modifiers: modifiers, disabled: modifiers.disabled || undefined, tabIndex: isFocusTarget(day) ? 0 : -1, "aria-label": labelDayButton(date, modifiers, dateLib.options, dateLib), onClick: handleDayClick(day, modifiers), onBlur: handleDayBlur(day, modifiers), onFocus: handleDayFocus(day, modifiers), onKeyDown: handleDayKeyDown(day, modifiers), onMouseEnter: handleDayMouseEnter(day, modifiers), onMouseLeave: handleDayMouseLeave(day, modifiers) }, formatDay(date, dateLib.options, dateLib))) : (!modifiers.hidden &&
                                            formatDay(day.date, dateLib.options, dateLib))));
                                    })));
                            })))));
                })),
            props.footer && (
            // biome-ignore lint/a11y/useSemanticElements: react component
            react_1.default.createElement(components.Footer, { className: classNames[UI_js_1.UI.Footer], style: styles?.[UI_js_1.UI.Footer], role: "status", "aria-live": "polite" }, props.footer)))));
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\index.d.ts

~~~ts
import type { Locale } from "date-fns";
import React from "react";
import { DateLib, type DateLibOptions } from "../index.js";
import type { DayPickerProps } from "../types/props.js";
export { enUS } from "date-fns/locale/en-US";
/**
 * Render the Ethiopic calendar.
 *
 * Defaults:
 *
 * - `locale`: `am-ET` (Amharic) via an Intl-backed date-fns locale
 * - `numerals`: `geez` (Ethiopic digits)
 *
 * Notes:
 *
 * - Weekday names are taken from `Intl.DateTimeFormat(locale.code)`.
 * - Month names are Amharic by default; they switch to Latin transliteration when
 *   `locale.code` starts with `en` or when `numerals` is `latn`.
 * - Time tokens like `hh:mm a` are formatted via `Intl.DateTimeFormat` using the
 *   provided `locale`.
 *
 * @see https://daypicker.dev/docs/localization#ethiopic-calendar
 */
export declare function DayPicker(props: DayPickerProps & {
    /**
     * The locale to use in the calendar.
     *
     * @default `am-ET`
     */
    locale?: Locale;
    /**
     * The numeral system to use when formatting dates.
     *
     * - `latn`: Latin (Western Arabic)
     * - `geez`: Ge'ez (Ethiopic numerals)
     *
     * @defaultValue `geez` (Ethiopic numerals)
     * @see https://daypicker.dev/docs/translation#numeral-systems
     */
    numerals?: DayPickerProps["numerals"];
}): React.JSX.Element;
/** Returns the date library used in the calendar. */
export declare const getDateLib: (options?: DateLibOptions) => DateLib;
export { amET } from "./locale/am-ET.js";

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.amET = exports.getDateLib = exports.enUS = void 0;
exports.DayPicker = DayPicker;
const react_1 = __importDefault(require("react"));
const index_js_1 = require("../index.js");
const ethiopicDateLib = __importStar(require("./lib/index.js"));
const am_ET_js_1 = __importDefault(require("./locale/am-ET.js"));
var en_US_1 = require("date-fns/locale/en-US");
Object.defineProperty(exports, "enUS", { enumerable: true, get: function () { return en_US_1.enUS; } });
/**
 * Render the Ethiopic calendar.
 *
 * Defaults:
 *
 * - `locale`: `am-ET` (Amharic) via an Intl-backed date-fns locale
 * - `numerals`: `geez` (Ethiopic digits)
 *
 * Notes:
 *
 * - Weekday names are taken from `Intl.DateTimeFormat(locale.code)`.
 * - Month names are Amharic by default; they switch to Latin transliteration when
 *   `locale.code` starts with `en` or when `numerals` is `latn`.
 * - Time tokens like `hh:mm a` are formatted via `Intl.DateTimeFormat` using the
 *   provided `locale`.
 *
 * @see https://daypicker.dev/docs/localization#ethiopic-calendar
 */
function DayPicker(props) {
    return (react_1.default.createElement(index_js_1.DayPicker, { ...props, locale: props.locale ?? am_ET_js_1.default, numerals: props.numerals ?? "geez", 
        // Pass overrides, not a DateLib instance
        dateLib: ethiopicDateLib }));
}
/** Returns the date library used in the calendar. */
const getDateLib = (options) => {
    return new index_js_1.DateLib(options, ethiopicDateLib);
};
exports.getDateLib = getDateLib;
// Export a minimal Amharic (Ethiopia) date-fns locale that uses Intl
var am_ET_js_2 = require("./locale/am-ET.js");
Object.defineProperty(exports, "amET", { enumerable: true, get: function () { return am_ET_js_2.amET; } });

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\addMonths.d.ts

~~~ts
/**
 * Adds the specified number of months to the given Ethiopian date. Handles
 * month overflow and year boundaries correctly.
 *
 * @param date - The starting gregorian date
 * @param amount - The number of months to add (can be negative)
 * @returns A new gregorian date with the months added
 */
export declare function addMonths(date: Date, amount: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\addMonths.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMonths = addMonths;
const daysInMonth_js_1 = require("../utils/daysInMonth.js");
const index_js_1 = require("../utils/index.js");
/**
 * Adds the specified number of months to the given Ethiopian date. Handles
 * month overflow and year boundaries correctly.
 *
 * @param date - The starting gregorian date
 * @param amount - The number of months to add (can be negative)
 * @returns A new gregorian date with the months added
 */
function addMonths(date, amount) {
    const { year, month, day } = (0, index_js_1.toEthiopicDate)(date);
    let newMonth = month + amount;
    const yearAdjustment = Math.floor((newMonth - 1) / 13);
    newMonth = ((newMonth - 1) % 13) + 1;
    if (newMonth < 1) {
        newMonth += 13;
    }
    const newYear = year + yearAdjustment;
    // Adjust day if it exceeds the month length
    const monthLength = (0, daysInMonth_js_1.daysInMonth)(newMonth, newYear);
    const newDay = Math.min(day, monthLength);
    return (0, index_js_1.toGregorianDate)({ year: newYear, month: newMonth, day: newDay });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\addYears.d.ts

~~~ts
/**
 * Adds the specified number of years to the given Ethiopian date. Handles leap
 * year transitions for Pagume month.
 *
 * @param date - The starting gregorian date
 * @param amount - The number of years to add (can be negative)
 * @returns A new gregorian date with the years added
 */
export declare function addYears(date: Date, amount: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\addYears.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addYears = addYears;
const index_js_1 = require("../utils/index.js");
/**
 * Adds the specified number of years to the given Ethiopian date. Handles leap
 * year transitions for Pagume month.
 *
 * @param date - The starting gregorian date
 * @param amount - The number of years to add (can be negative)
 * @returns A new gregorian date with the years added
 */
function addYears(date, amount) {
    const etDate = (0, index_js_1.toEthiopicDate)(date);
    const day = (0, index_js_1.isEthiopicLeapYear)(etDate.year) &&
        etDate.month === 13 &&
        etDate.day === 6 &&
        amount % 4 !== 0
        ? 5
        : etDate.day;
    return (0, index_js_1.toGregorianDate)({
        month: etDate.month,
        day: day,
        year: etDate.year + amount,
    });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\differenceInCalendarMonths.d.ts

~~~ts
/**
 * Difference in calendar months
 *
 * @param {Date} dateLeft - The later date
 * @param {Date} dateRight - The earlier date
 * @returns {number} The number of calendar months between the two dates
 */
export declare function differenceInCalendarMonths(dateLeft: Date, dateRight: Date): number;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\differenceInCalendarMonths.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.differenceInCalendarMonths = differenceInCalendarMonths;
const index_js_1 = require("../utils/index.js");
/**
 * Difference in calendar months
 *
 * @param {Date} dateLeft - The later date
 * @param {Date} dateRight - The earlier date
 * @returns {number} The number of calendar months between the two dates
 */
function differenceInCalendarMonths(dateLeft, dateRight) {
    const ethiopicLeft = (0, index_js_1.toEthiopicDate)(dateLeft);
    const ethiopicRight = (0, index_js_1.toEthiopicDate)(dateRight);
    return ((ethiopicLeft.year - ethiopicRight.year) * 13 +
        (ethiopicLeft.month - ethiopicRight.month));
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\eachMonthOfInterval.d.ts

~~~ts
import type { Interval } from "date-fns";
/**
 * Each month of an interval
 *
 * @param {Object} interval - The interval object
 * @param {Date} interval.start - The start date of the interval
 * @param {Date} interval.end - The end date of the interval
 * @returns {Date[]} An array of dates representing the start of each month in
 *   the interval
 */
export declare function eachMonthOfInterval(interval: Interval): Date[];

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\eachMonthOfInterval.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachMonthOfInterval = eachMonthOfInterval;
const index_js_1 = require("../utils/index.js");
/**
 * Each month of an interval
 *
 * @param {Object} interval - The interval object
 * @param {Date} interval.start - The start date of the interval
 * @param {Date} interval.end - The end date of the interval
 * @returns {Date[]} An array of dates representing the start of each month in
 *   the interval
 */
function eachMonthOfInterval(interval) {
    const start = (0, index_js_1.toEthiopicDate)(new Date(interval.start));
    const end = (0, index_js_1.toEthiopicDate)(new Date(interval.end));
    const dates = [];
    let currentYear = start.year;
    let currentMonth = start.month;
    while (currentYear < end.year ||
        (currentYear === end.year && currentMonth <= end.month)) {
        dates.push((0, index_js_1.toGregorianDate)({ year: currentYear, month: currentMonth, day: 1 }));
        currentMonth++;
        if (currentMonth > 13) {
            currentMonth = 1;
            currentYear++;
        }
    }
    return dates;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\eachYearOfInterval.d.ts

~~~ts
import type { Interval } from "date-fns";
/**
 * Returns the start of each Ethiopic year included in the given interval.
 *
 * @param interval The interval whose years should be returned.
 */
export declare function eachYearOfInterval(interval: Interval): Date[];

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\eachYearOfInterval.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachYearOfInterval = eachYearOfInterval;
const index_js_1 = require("../utils/index.js");
/**
 * Returns the start of each Ethiopic year included in the given interval.
 *
 * @param interval The interval whose years should be returned.
 */
function eachYearOfInterval(interval) {
    const start = (0, index_js_1.toEthiopicDate)(new Date(interval.start));
    const end = (0, index_js_1.toEthiopicDate)(new Date(interval.end));
    if (end.year < start.year) {
        return [];
    }
    const years = [];
    for (let year = start.year; year <= end.year; year += 1) {
        years.push((0, index_js_1.toGregorianDate)({ year, month: 1, day: 1 }));
    }
    return years;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\endOfMonth.d.ts

~~~ts
/**
 * Returns the last day of the Ethiopian month for the given date.
 *
 * @param date - The gregorian date to get the end of month for
 * @returns A new gregorian date representing the last day of the Ethiopian
 *   month
 */
export declare function endOfMonth(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\endOfMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.endOfMonth = endOfMonth;
const daysInMonth_js_1 = require("../utils/daysInMonth.js");
const index_js_1 = require("../utils/index.js");
/**
 * Returns the last day of the Ethiopian month for the given date.
 *
 * @param date - The gregorian date to get the end of month for
 * @returns A new gregorian date representing the last day of the Ethiopian
 *   month
 */
function endOfMonth(date) {
    const { year, month } = (0, index_js_1.toEthiopicDate)(date);
    const day = (0, daysInMonth_js_1.daysInMonth)(month, year);
    return (0, index_js_1.toGregorianDate)({ year, month, day: day });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\endOfWeek.d.ts

~~~ts
import { type EndOfWeekOptions } from "date-fns";
/**
 * End of week
 *
 * @param {Date} date - The original date
 * @param {EndOfWeekOptions} [options] - The options object
 * @returns {Date} The end of the week
 */
export declare function endOfWeek(date: Date, options?: EndOfWeekOptions): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\endOfWeek.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.endOfWeek = endOfWeek;
const date_fns_1 = require("date-fns");
/**
 * End of week
 *
 * @param {Date} date - The original date
 * @param {EndOfWeekOptions} [options] - The options object
 * @returns {Date} The end of the week
 */
function endOfWeek(date, options) {
    const weekStartsOn = options?.weekStartsOn ?? 0; // Default to Monday (1)
    const endOfWeek = (0, date_fns_1.endOfWeek)(date, { weekStartsOn });
    return endOfWeek;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\endOfYear.d.ts

~~~ts
/**
 * End of year
 *
 * @param {Date} date - The original date
 * @returns {Date} The end of the year
 */
export declare function endOfYear(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\endOfYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.endOfYear = endOfYear;
const index_js_1 = require("../utils/index.js");
/**
 * End of year
 *
 * @param {Date} date - The original date
 * @returns {Date} The end of the year
 */
function endOfYear(date) {
    const { year } = (0, index_js_1.toEthiopicDate)(date);
    const day = (0, index_js_1.isEthiopicLeapYear)(year) ? 6 : 5;
    return (0, index_js_1.toGregorianDate)({ year, month: 13, day });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\format.d.ts

~~~ts
import type { FormatOptions as DateFnsFormatOptions } from "date-fns";
/** Options for formatting dates in the Ethiopian calendar */
export type FormatOptions = DateFnsFormatOptions;
/**
 * Format an Ethiopic calendar date using a subset of date-fns tokens.
 *
 * Behavior specifics for Ethiopic mode:
 *
 * - Weekday names ("cccc", "cccccc") come from `Intl.DateTimeFormat` using
 *   `options.locale?.code` (default: `am-ET`). Narrow form is a single letter.
 * - Month names ("LLLL") are Amharic by default and switch to Latin
 *   transliteration when the locale code starts with `en` or when
 *   `options.numerals === 'latn'`.
 * - Time parts such as `hh:mm a` are delegated to `Intl.DateTimeFormat` with the
 *   given locale.
 * - Digits are converted to Ethiopic (Geez) when `options.numerals === 'geez'`.
 */
export declare function format(date: Date, formatStr: string, options?: DateFnsFormatOptions): string;
export declare const ethMonths: string[];
export declare const ethMonthsLatin: string[];
export declare const shortDays: string[];
export declare const longDays: string[];

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\format.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.longDays = exports.shortDays = exports.ethMonthsLatin = exports.ethMonths = void 0;
exports.format = format;
const index_js_1 = require("../utils/index.js");
const formatNumber_js_1 = require("./formatNumber.js");
function getEtDayName(day, short = true, localeCode = "am-ET") {
    try {
        const dtf = new Intl.DateTimeFormat(localeCode, {
            // Ethiopic calendar expects single-letter for "cccccc" -> use narrow
            weekday: short ? "narrow" : "long",
        });
        return dtf.format(day);
    }
    catch {
        const dayOfWeek = day.getDay();
        return short ? exports.shortDays[dayOfWeek] : exports.longDays[dayOfWeek];
    }
}
function getEtMonthName(m, latin = false) {
    if (m > 0 && m <= 13) {
        return latin ? exports.ethMonthsLatin[m - 1] : exports.ethMonths[m - 1];
    }
    return "";
}
function formatEthiopianDate(dateObj, formatStr, numerals, localeCode) {
    const etDate = dateObj ? (0, index_js_1.toEthiopicDate)(dateObj) : undefined;
    if (!etDate)
        return "";
    const useLatin = (localeCode?.startsWith("en") ?? false) || numerals === "latn";
    const yearTokenMatch = formatStr.match(/^(\s*)(y+)(\s*)$/);
    if (yearTokenMatch) {
        const [, leading = "", yearToken, trailing = ""] = yearTokenMatch;
        const year = etDate.year.toString();
        let formattedYear;
        if (yearToken.length === 1) {
            formattedYear = year;
        }
        else if (yearToken.length === 2) {
            formattedYear = year.slice(-2).padStart(2, "0");
        }
        else {
            formattedYear = year.padStart(yearToken.length, "0");
        }
        return `${leading}${formattedYear}${trailing}`;
    }
    switch (formatStr) {
        case "LLLL yyyy":
        case "LLLL y":
            return `${getEtMonthName(etDate.month, useLatin)} ${etDate.year}`;
        case "LLLL":
            return getEtMonthName(etDate.month, useLatin);
        case "yyyy-MM-dd":
            return `${etDate.year}-${etDate.month
                .toString()
                .padStart(2, "0")}-${etDate.day.toString().padStart(2, "0")}`;
        case "yyyy-MM":
            return `${etDate.year}-${etDate.month.toString().padStart(2, "0")}`;
        case "d":
            return etDate.day.toString();
        case "PPP":
            return ` ${getEtMonthName(etDate.month, useLatin)} ${etDate.day}, ${etDate.year}`;
        case "PPPP":
            if (!dateObj)
                return "";
            return `${getEtDayName(dateObj, false, localeCode)}, ${getEtMonthName(etDate.month, useLatin)} ${etDate.day}, ${etDate.year}`;
        case "cccc":
            return dateObj ? getEtDayName(dateObj, false, localeCode) : "";
        case "cccccc":
            return dateObj ? getEtDayName(dateObj, true, localeCode) : "";
        default:
            return `${etDate.day}/${etDate.month}/${etDate.year}`;
    }
}
/**
 * Format an Ethiopic calendar date using a subset of date-fns tokens.
 *
 * Behavior specifics for Ethiopic mode:
 *
 * - Weekday names ("cccc", "cccccc") come from `Intl.DateTimeFormat` using
 *   `options.locale?.code` (default: `am-ET`). Narrow form is a single letter.
 * - Month names ("LLLL") are Amharic by default and switch to Latin
 *   transliteration when the locale code starts with `en` or when
 *   `options.numerals === 'latn'`.
 * - Time parts such as `hh:mm a` are delegated to `Intl.DateTimeFormat` with the
 *   given locale.
 * - Digits are converted to Ethiopic (Geez) when `options.numerals === 'geez'`.
 */
function format(date, formatStr, options) {
    const extendedOptions = options;
    if (formatStr.includes("hh:mm") || formatStr.includes("a")) {
        return new Intl.DateTimeFormat(extendedOptions?.locale?.code ?? "en-US", {
            hour: "numeric",
            minute: "numeric",
            hour12: formatStr.includes("a"),
        }).format(date);
    }
    const formatted = formatEthiopianDate(date, formatStr, extendedOptions?.numerals, extendedOptions?.locale?.code ?? "am-ET");
    if (extendedOptions?.numerals && extendedOptions.numerals === "geez") {
        return formatted.replace(/\d+/g, (match) => (0, formatNumber_js_1.formatNumber)(parseInt(match, 10), "geez"));
    }
    return formatted;
}
exports.ethMonths = [
    "?섂댌?ⓤ닲??,
    "?α뎲?앩돲",
    "?끷떝??,
    "?녁늼?녁댌",
    "?α댂",
    "?ⓤ뒲?꿍돲",
    "?섂뙅?㏇돲",
    "?싡떕?싡떕",
    "?띮뒘?╇돲",
    "?결뒗",
    "?먤닜??,
    "?먤???,
    "?녁뙃??,
];
exports.ethMonthsLatin = [
    "Meskerem",
    "Tikimt",
    "Hidar",
    "Tahsas",
    "Tir",
    "Yekatit",
    "Megabit",
    "Miyazya",
    "Ginbot",
    "Sene",
    "Hamle",
    "Nehase",
    "Pagumen",
];
exports.shortDays = ["??, "??, "??, "??, "??, "??, "??];
exports.longDays = ["?α늸??, "?결뒢", "?쎺뒴?결뒢", "?ⓤ돘??, "?먤닕??, "?볚댂??, "?끷떝??];

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\formatNumber.d.ts

~~~ts
/**
 * Formats a number using either Latin or Ethiopic (Geez) numerals
 *
 * @example
 *   ```ts
 *   formatNumber(123) // '123'
 *   formatNumber(123, 'geez') // '?삔뜵??
 *   formatNumber(2023, 'geez') // '?녁띀?녁뜪'
 *   ```;
 *
 * @param value - The number to format
 * @param numerals - The numeral system to use:
 *
 *   - 'latn': Latin numerals (1, 2, 3...)
 *   - 'geez': Ethiopic numerals (?? ?? ??..)
 *
 * @returns The formatted number string
 */
export declare function formatNumber(value: number, numerals?: string): string;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\formatNumber.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatNumber = formatNumber;
const toGeezNumerals_js_1 = require("../utils/toGeezNumerals.js");
/**
 * Formats a number using either Latin or Ethiopic (Geez) numerals
 *
 * @example
 *   ```ts
 *   formatNumber(123) // '123'
 *   formatNumber(123, 'geez') // '?삔뜵??
 *   formatNumber(2023, 'geez') // '?녁띀?녁뜪'
 *   ```;
 *
 * @param value - The number to format
 * @param numerals - The numeral system to use:
 *
 *   - 'latn': Latin numerals (1, 2, 3...)
 *   - 'geez': Ethiopic numerals (?? ?? ??..)
 *
 * @returns The formatted number string
 */
function formatNumber(value, numerals = "latn") {
    if (numerals === "geez") {
        return (0, toGeezNumerals_js_1.toGeezNumerals)(value);
    }
    // Use Intl.NumberFormat for other numeral systems
    const formatter = new Intl.NumberFormat("en-US", {
        numberingSystem: numerals,
    });
    return formatter.format(value);
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\getMonth.d.ts

~~~ts
/**
 * Get month
 *
 * @param {Date} date - The original date
 * @returns {number} The zero-based month index
 */
export declare function getMonth(date: Date): number;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\getMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMonth = getMonth;
const index_js_1 = require("../utils/index.js");
/**
 * Get month
 *
 * @param {Date} date - The original date
 * @returns {number} The zero-based month index
 */
function getMonth(date) {
    const { month } = (0, index_js_1.toEthiopicDate)(date);
    return month - 1; // Return zero-based month index
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\getWeek.d.ts

~~~ts
import { type GetWeekOptions } from "date-fns";
/**
 * Get week number for Ethiopian calendar
 *
 * @param {Date} date - The original date
 * @param {GetWeekOptions} [options] - The options object
 * @returns {number} The week number
 */
export declare function getWeek(date: Date, options?: GetWeekOptions): number;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\getWeek.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWeek = getWeek;
const date_fns_1 = require("date-fns");
const index_js_1 = require("../utils/index.js");
const startOfWeek_js_1 = require("./startOfWeek.js");
/**
 * Get week number for Ethiopian calendar
 *
 * @param {Date} date - The original date
 * @param {GetWeekOptions} [options] - The options object
 * @returns {number} The week number
 */
function getWeek(date, options) {
    const weekStartsOn = options?.weekStartsOn ?? 1; // Default to Monday (1)
    const etDate = (0, index_js_1.toEthiopicDate)(date);
    const currentWeekStart = (0, startOfWeek_js_1.startOfWeek)(date, { weekStartsOn });
    // Get the first day of the current year
    const firstDayOfYear = (0, index_js_1.toGregorianDate)({
        year: etDate.year,
        month: 1,
        day: 1,
    });
    const firstWeekStart = (0, startOfWeek_js_1.startOfWeek)(firstDayOfYear, { weekStartsOn });
    // If date is before the first week of its year
    if (date < firstWeekStart) {
        return (0, date_fns_1.getWeek)(date, { weekStartsOn, firstWeekContainsDate: 1 });
    }
    // If date falls into the first week of the NEXT Ethiopic year, return 1
    const nextYearFirstDay = (0, index_js_1.toGregorianDate)({
        year: etDate.year + 1,
        month: 1,
        day: 1,
    });
    const nextYearFirstWeekStart = (0, startOfWeek_js_1.startOfWeek)(nextYearFirstDay, {
        weekStartsOn,
    });
    if (date >= nextYearFirstWeekStart) {
        return 1;
    }
    // Calculate week number based on days since first week
    const daysSinceFirstWeek = (0, date_fns_1.differenceInDays)(currentWeekStart, firstWeekStart);
    return Math.floor(daysSinceFirstWeek / 7) + 1;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\getYear.d.ts

~~~ts
/**
 * Get year
 *
 * @param {Date} date - The original date
 * @returns {number} The year
 */
export declare function getYear(date: Date): number;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\getYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getYear = getYear;
const index_js_1 = require("../utils/index.js");
/**
 * Get year
 *
 * @param {Date} date - The original date
 * @returns {number} The year
 */
function getYear(date) {
    const { year } = (0, index_js_1.toEthiopicDate)(date);
    return year;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\index.d.ts

~~~ts
export * from "./addMonths.js";
export * from "./addYears.js";
export * from "./differenceInCalendarMonths.js";
export * from "./eachMonthOfInterval.js";
export * from "./eachYearOfInterval.js";
export * from "./endOfMonth.js";
export * from "./endOfWeek.js";
export * from "./endOfYear.js";
export * from "./format.js";
export * from "./formatNumber.js";
export * from "./getMonth.js";
export * from "./getWeek.js";
export * from "./getYear.js";
export * from "./isSameMonth.js";
export * from "./isSameYear.js";
export * from "./newDate.js";
export * from "./setMonth.js";
export * from "./setYear.js";
export * from "./startOfDay.js";
export * from "./startOfMonth.js";
export * from "./startOfWeek.js";
export * from "./startOfYear.js";

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./addMonths.js"), exports);
__exportStar(require("./addYears.js"), exports);
__exportStar(require("./differenceInCalendarMonths.js"), exports);
__exportStar(require("./eachMonthOfInterval.js"), exports);
__exportStar(require("./eachYearOfInterval.js"), exports);
__exportStar(require("./endOfMonth.js"), exports);
__exportStar(require("./endOfWeek.js"), exports);
__exportStar(require("./endOfYear.js"), exports);
__exportStar(require("./format.js"), exports);
__exportStar(require("./formatNumber.js"), exports);
__exportStar(require("./getMonth.js"), exports);
__exportStar(require("./getWeek.js"), exports);
__exportStar(require("./getYear.js"), exports);
__exportStar(require("./isSameMonth.js"), exports);
__exportStar(require("./isSameYear.js"), exports);
__exportStar(require("./newDate.js"), exports);
__exportStar(require("./setMonth.js"), exports);
__exportStar(require("./setYear.js"), exports);
__exportStar(require("./startOfDay.js"), exports);
__exportStar(require("./startOfMonth.js"), exports);
__exportStar(require("./startOfWeek.js"), exports);
__exportStar(require("./startOfYear.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\isSameMonth.d.ts

~~~ts
/**
 * Is same month
 *
 * @param {Date} dateLeft - The first date
 * @param {Date} dateRight - The second date
 * @returns {boolean} True if the two dates are in the same month
 */
export declare function isSameMonth(dateLeft: Date, dateRight: Date): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\isSameMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameMonth = isSameMonth;
const index_js_1 = require("../utils/index.js");
/**
 * Is same month
 *
 * @param {Date} dateLeft - The first date
 * @param {Date} dateRight - The second date
 * @returns {boolean} True if the two dates are in the same month
 */
function isSameMonth(dateLeft, dateRight) {
    const left = (0, index_js_1.toEthiopicDate)(dateLeft);
    const right = (0, index_js_1.toEthiopicDate)(dateRight);
    return left.year === right.year && left.month === right.month;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\isSameYear.d.ts

~~~ts
/**
 * Checks if two dates fall in the same Ethiopian year.
 *
 * @param dateLeft - The first gregorian date to compare
 * @param dateRight - The second gregorian date to compare
 * @returns True if the dates are in the same Ethiopian year
 */
export declare function isSameYear(dateLeft: Date, dateRight: Date): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\isSameYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameYear = isSameYear;
const index_js_1 = require("../utils/index.js");
/**
 * Checks if two dates fall in the same Ethiopian year.
 *
 * @param dateLeft - The first gregorian date to compare
 * @param dateRight - The second gregorian date to compare
 * @returns True if the dates are in the same Ethiopian year
 */
function isSameYear(dateLeft, dateRight) {
    const left = (0, index_js_1.toEthiopicDate)(dateLeft);
    const right = (0, index_js_1.toEthiopicDate)(dateRight);
    return left.year === right.year;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\newDate.d.ts

~~~ts
/**
 * Creates a new Ethiopic date
 *
 * @param {number} year - The year of the Ethiopic date
 * @param {number} monthIndex - The zero-based month index of the Ethiopic date
 * @param {number} date - The day of the month of the Ethiopic date
 * @returns {Date} The corresponding Gregorian date
 */
export declare function newDate(year: number, monthIndex: number, date: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\newDate.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newDate = newDate;
const index_js_1 = require("../utils/index.js");
const isEthiopicDateValid_js_1 = require("../utils/isEthiopicDateValid.js");
/**
 * Creates a new Ethiopic date
 *
 * @param {number} year - The year of the Ethiopic date
 * @param {number} monthIndex - The zero-based month index of the Ethiopic date
 * @param {number} date - The day of the month of the Ethiopic date
 * @returns {Date} The corresponding Gregorian date
 */
function newDate(year, monthIndex, date) {
    // Convert from 0-based month index to 1-based Ethiopic month
    const month = monthIndex + 1;
    if (!(0, isEthiopicDateValid_js_1.isEthiopicDateValid)({ year, month, day: date })) {
        throw new Error("Invalid Ethiopic date");
    }
    return (0, index_js_1.toGregorianDate)({
        year: year,
        month: month,
        day: date,
    });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\setMonth.d.ts

~~~ts
/**
 * Set month
 *
 * @param {Date} date - The original date
 * @param {number} month - The zero-based month index
 * @returns {Date} The new date with the month set
 */
export declare function setMonth(date: Date, month: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\setMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMonth = setMonth;
const index_js_1 = require("../utils/index.js");
/**
 * Set month
 *
 * @param {Date} date - The original date
 * @param {number} month - The zero-based month index
 * @returns {Date} The new date with the month set
 */
function setMonth(date, month) {
    const { year, day } = (0, index_js_1.toEthiopicDate)(date);
    const targetMonth = month + 1; // Convert from zero-based index
    const safeDay = Math.min(day, (0, index_js_1.daysInMonth)(targetMonth, year));
    return (0, index_js_1.toGregorianDate)({ year, month: targetMonth, day: safeDay });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\setYear.d.ts

~~~ts
/**
 * Set year
 *
 * @param {Date} date - The original date
 * @param {number} year - The year to set
 * @returns {Date} The new date with the year set
 */
export declare function setYear(date: Date, year: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\setYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setYear = setYear;
const daysInMonth_js_1 = require("../utils/daysInMonth.js");
const index_js_1 = require("../utils/index.js");
/**
 * Set year
 *
 * @param {Date} date - The original date
 * @param {number} year - The year to set
 * @returns {Date} The new date with the year set
 */
function setYear(date, year) {
    const { month, day } = (0, index_js_1.toEthiopicDate)(date);
    // Check if the day is valid in the new year (handles leap year changes)
    const maxDays = (0, daysInMonth_js_1.daysInMonth)(month, year);
    const newDay = Math.min(day, maxDays);
    return (0, index_js_1.toGregorianDate)({ year, month, day: newDay });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\startOfDay.d.ts

~~~ts
/**
 * Start of day
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the day
 */
export declare function startOfDay(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\startOfDay.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startOfDay = startOfDay;
const index_js_1 = require("../utils/index.js");
/**
 * Start of day
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the day
 */
function startOfDay(date) {
    const { year, month, day } = (0, index_js_1.toEthiopicDate)(date);
    return (0, index_js_1.toGregorianDate)({ year, month, day });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\startOfMonth.d.ts

~~~ts
/**
 * Start of month
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the month
 */
export declare function startOfMonth(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\startOfMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startOfMonth = startOfMonth;
const index_js_1 = require("../utils/index.js");
/**
 * Start of month
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the month
 */
function startOfMonth(date) {
    const { year, month } = (0, index_js_1.toEthiopicDate)(date);
    return (0, index_js_1.toGregorianDate)({ year, month, day: 1 });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\startOfWeek.d.ts

~~~ts
import { type StartOfWeekOptions } from "date-fns";
/**
 * Start of week
 *
 * @param {Date} date - The original date
 * @param {StartOfWeekOptions} [options] - The options object
 * @returns {Date} The start of the week
 */
export declare function startOfWeek(date: Date, options?: StartOfWeekOptions): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\startOfWeek.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startOfWeek = startOfWeek;
const date_fns_1 = require("date-fns");
/**
 * Start of week
 *
 * @param {Date} date - The original date
 * @param {StartOfWeekOptions} [options] - The options object
 * @returns {Date} The start of the week
 */
function startOfWeek(date, options) {
    const weekStartsOn = options?.weekStartsOn ?? 1; // Default to Monday (1)
    return (0, date_fns_1.startOfWeek)(date, { weekStartsOn: weekStartsOn });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\startOfYear.d.ts

~~~ts
/**
 * Start of year
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the year
 */
export declare function startOfYear(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\lib\startOfYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startOfYear = startOfYear;
const index_js_1 = require("../utils/index.js");
/**
 * Start of year
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the year
 */
function startOfYear(date) {
    const { year } = (0, index_js_1.toEthiopicDate)(date);
    return (0, index_js_1.toGregorianDate)({ year, month: 1, day: 1 });
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\locale\am-ET.d.ts

~~~ts
import type { Locale } from "date-fns/locale";
/** Amharic (Ethiopia) locale backed by Intl for core names. */
export declare const amET: Locale;
export default amET;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\locale\am-ET.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.amET = void 0;
const en_US_1 = require("date-fns/locale/en-US");
/**
 * Minimal Amharic (Ethiopia) locale for date-fns v4.
 *
 * - Uses `Intl.DateTimeFormat('am-ET')` to localize month and weekday names.
 * - Reuses `en-US` implementations for `formatLong`, `formatDistance`,
 *   `formatRelative`, and `match` to keep the footprint small.
 * - Ordinals are returned as plain numeric strings.
 */
// Map date-fns widths to Intl widths
function mapWidth(width) {
    switch (width) {
        case "narrow":
            return "narrow";
        case "short":
        case "abbreviated":
            return "short";
        default:
            return "long";
    }
}
function buildMonthNames(width) {
    const intlWidth = mapWidth(width);
    const fmt = new Intl.DateTimeFormat("am-ET", {
        month: intlWidth,
        timeZone: "UTC",
    });
    const names = [];
    for (let i = 0; i < 12; i++) {
        // Use a fixed UTC date to avoid locale-specific DST artifacts
        names.push(fmt.format(new Date(Date.UTC(2017, i, 1))));
    }
    return names;
}
function buildDayNames(width) {
    const intlWidth = mapWidth(width);
    const fmt = new Intl.DateTimeFormat("am-ET", {
        weekday: intlWidth,
        timeZone: "UTC",
    });
    const names = [];
    // 2017-01-01 was a Sunday; iterate 0..6
    const base = Date.UTC(2017, 0, 1);
    for (let i = 0; i < 7; i++) {
        names.push(fmt.format(new Date(base + i * 24 * 60 * 60 * 1000)));
    }
    return names;
}
function getDayPeriod(value, width) {
    if (value === "am" || value === "pm") {
        const sampleHour = value === "am" ? 1 : 13;
        const parts = new Intl.DateTimeFormat("am-ET", {
            hour: "numeric",
            hour12: true,
            timeZone: "UTC",
        })
            .formatToParts(new Date(Date.UTC(2017, 0, 1, sampleHour)))
            .find((p) => p.type === "dayPeriod");
        if (parts?.value)
            return parts.value;
    }
    // Fallback: delegate to en-US for anything else
    return en_US_1.enUS.localize.dayPeriod(value, { width: width });
}
const localize = {
    ...en_US_1.enUS.localize,
    // Ordinals in Amharic are commonly written as cardinals; keep simple numeric output
    ordinalNumber: (n) => String(n),
    month: (value, options) => {
        const names = buildMonthNames(options?.width);
        // value is 0..11 in date-fns v4
        return names[value];
    },
    day: (value, options) => {
        const names = buildDayNames(options?.width);
        // value is 0..6, where 0 = Sunday
        return names[value];
    },
    dayPeriod: (value, options) => getDayPeriod(value, options?.width),
};
const options = {
    weekStartsOn: 1,
    firstWeekContainsDate: 1,
};
/** Amharic (Ethiopia) locale backed by Intl for core names. */
exports.amET = {
    code: "am-ET",
    // Reuse en-US for distance/relative formatting and formatLong skeletons
    formatDistance: en_US_1.enUS.formatDistance,
    formatRelative: en_US_1.enUS.formatRelative,
    formatLong: en_US_1.enUS.formatLong,
    localize,
    match: en_US_1.enUS.match,
    options,
};
exports.default = exports.amET;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\daysInMonth.d.ts

~~~ts
/**
 * Returns the number of days in the specified month of the Ethiopic calendar.
 *
 * In the Ethiopic calendar:
 *
 * - Months 1-12 have 30 days each
 * - Month 13 (Pagume) has 5 days in regular years, 6 days in leap years
 *
 * @param month - The month number (1-13)
 * @param year - The Ethiopic year
 * @returns The number of days in the specified month
 */
export declare function daysInMonth(month: number, year: number): number;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\daysInMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.daysInMonth = daysInMonth;
const isEthiopicLeapYear_js_1 = require("./isEthiopicLeapYear.js");
/**
 * Returns the number of days in the specified month of the Ethiopic calendar.
 *
 * In the Ethiopic calendar:
 *
 * - Months 1-12 have 30 days each
 * - Month 13 (Pagume) has 5 days in regular years, 6 days in leap years
 *
 * @param month - The month number (1-13)
 * @param year - The Ethiopic year
 * @returns The number of days in the specified month
 */
function daysInMonth(month, year) {
    if (month === 13) {
        return (0, isEthiopicLeapYear_js_1.isEthiopicLeapYear)(year) ? 6 : 5;
    }
    return 30;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\EthiopicDate.d.ts

~~~ts
/**
 * Represents a date in the Ethiopic calendar system.
 *
 * The Ethiopic calendar has:
 *
 * - 13 months
 * - 12 months of 30 days each
 * - A 13th month (Pagume) of 5 or 6 days
 */
export interface EthiopicDate {
    /** The Ethiopic year */
    year: number;
    /** The month number (1-13) */
    month: number;
    /** The day of the month (1-30, or 1-5/6 for month 13) */
    day: number;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\EthiopicDate.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\index.d.ts

~~~ts
export * from "./daysInMonth.js";
export * from "./EthiopicDate.js";
export * from "./isEthiopicLeapYear.js";
export * from "./toEthiopicDate.js";
export * from "./toGeezNumerals.js";
export * from "./toGregorianDate.js";

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./daysInMonth.js"), exports);
__exportStar(require("./EthiopicDate.js"), exports);
__exportStar(require("./isEthiopicLeapYear.js"), exports);
__exportStar(require("./toEthiopicDate.js"), exports);
__exportStar(require("./toGeezNumerals.js"), exports);
__exportStar(require("./toGregorianDate.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\isEthiopicDateValid.d.ts

~~~ts
import type { EthiopicDate } from "./EthiopicDate.js";
export declare function isEthiopicDateValid(date: EthiopicDate): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\isEthiopicDateValid.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEthiopicDateValid = isEthiopicDateValid;
const daysInMonth_js_1 = require("./daysInMonth.js");
function isEthiopicDateValid(date) {
    if (date.month < 1)
        return false;
    if (date.day < 1)
        return false;
    if (date.month > 13)
        return false;
    if (date.day > (0, daysInMonth_js_1.daysInMonth)(date.month, date.year))
        return false;
    return true;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\isEthiopicLeapYear.d.ts

~~~ts
/**
 * Checks if a given Ethiopic year is a leap year.
 *
 * @param year - The Ethiopic year.
 * @returns True if the year is a leap year; otherwise, false.
 */
export declare function isEthiopicLeapYear(year: number): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\isEthiopicLeapYear.js

~~~js
"use strict";
/**
 * Checks if a given Ethiopic year is a leap year.
 *
 * @param year - The Ethiopic year.
 * @returns True if the year is a leap year; otherwise, false.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEthiopicLeapYear = isEthiopicLeapYear;
function isEthiopicLeapYear(year) {
    return year % 4 === 3;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\toEthiopicDate.d.ts

~~~ts
import type { EthiopicDate } from "./EthiopicDate.js";
/**
 * Calculates the number of days between January 1, 0001 and the given date.
 *
 * @param date - A JavaScript Date object to calculate days from
 * @returns The number of days since January 1, 0001. Returns 0 if the input is
 *   not a valid Date.
 */
export declare function getDayNoGregorian(date: Date): number;
/**
 * Converts a Gregorian date to an Ethiopic date.
 *
 * @param gregorianDate - A JavaScript Date object representing the Gregorian
 *   date.
 * @returns An EthiopicDate object.
 */
export declare function toEthiopicDate(gregorianDate: Date): EthiopicDate;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\toEthiopicDate.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDayNoGregorian = getDayNoGregorian;
exports.toEthiopicDate = toEthiopicDate;
const date_fns_1 = require("date-fns");
/**
 * Calculates the number of days between January 1, 0001 and the given date.
 *
 * @param date - A JavaScript Date object to calculate days from
 * @returns The number of days since January 1, 0001. Returns 0 if the input is
 *   not a valid Date.
 */
function getDayNoGregorian(date) {
    if (!(date instanceof Date)) {
        return 0;
    }
    // Create the start date as January 1, 0001 in the LOCAL timezone.
    const adStart = new Date(0);
    adStart.setFullYear(1, 0, 1);
    adStart.setHours(0, 0, 0, 0);
    // Calculate the number of days between the two dates, then add 1.
    const dayNumber = (0, date_fns_1.differenceInCalendarDays)(date, adStart) + 1;
    return dayNumber;
}
function createEthiopicDate(dn) {
    const num = Math.floor(dn / 1461);
    const num2 = dn % 1461;
    const num3 = Math.floor(num2 / 365);
    const num4 = num2 % 365;
    if (num2 !== 1460) {
        return {
            year: num * 4 + num3,
            month: Math.floor(num4 / 30) + 1,
            day: (num4 % 30) + 1,
        };
    }
    else {
        return {
            year: num * 4 + num3 - 1,
            month: 13,
            day: 6,
        };
    }
}
/**
 * Converts a Gregorian date to an Ethiopic date.
 *
 * @param gregorianDate - A JavaScript Date object representing the Gregorian
 *   date.
 * @returns An EthiopicDate object.
 */
function toEthiopicDate(gregorianDate) {
    return createEthiopicDate(getDayNoGregorian(gregorianDate) - 2431);
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\toGeezNumerals.d.ts

~~~ts
/**
 * Converts a number to Geez (Ethiopic) numerals.
 *
 * @param num - The number to convert
 * @returns The number in Geez numerals
 * @throws {Error} When input is 0 (Geez has no zero representation)
 */
export declare function toGeezNumerals(num: number): string;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\toGeezNumerals.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toGeezNumerals = toGeezNumerals;
/**
 * Converts a number to Geez (Ethiopic) numerals.
 *
 * @param num - The number to convert
 * @returns The number in Geez numerals
 * @throws {Error} When input is 0 (Geez has no zero representation)
 */
function toGeezNumerals(num) {
    const geezDigits = ["??, "??, "??, "??, "??, "??, "??, "??, "??];
    const geezTens = ["??, "??, "??, "??, "??, "??, "??, "??, "??];
    const geezHundreds = "??;
    const geezThousands = "??;
    if (num === 0)
        return "-";
    if (num < 0)
        return `-${toGeezNumerals(-num)}`;
    let result = "";
    let remaining = num;
    // Handle thousands (10,000 and above)
    if (remaining >= 10000) {
        const thousandsValue = Math.floor(remaining / 10000);
        result +=
            thousandsValue === 1
                ? geezThousands
                : toGeezNumerals(thousandsValue) + geezThousands;
        remaining %= 10000;
    }
    // Handle hundreds (100 - 9,900)
    if (remaining >= 100) {
        const hundredsValue = Math.floor(remaining / 100);
        result +=
            hundredsValue === 1
                ? geezHundreds
                : toGeezNumerals(hundredsValue) + geezHundreds;
        remaining %= 100;
    }
    // Handle tens (10 - 90)
    if (remaining >= 10) {
        const tensValue = Math.floor(remaining / 10);
        result += geezTens[tensValue - 1];
        remaining %= 10;
    }
    // Handle ones (1 - 9)
    if (remaining > 0) {
        result += geezDigits[remaining - 1];
    }
    return result;
}

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\toGregorianDate.d.ts

~~~ts
import type { EthiopicDate } from "./EthiopicDate.js";
export declare function getDayNoEthiopian(etDate: EthiopicDate): number;
/**
 * Converts an Ethiopic date to a Gregorian date.
 *
 * @param ethiopicDate - An EthiopicDate object.
 * @returns A JavaScript Date object representing the Gregorian date.
 */
export declare function toGregorianDate(ethiopicDate: EthiopicDate): Date;

~~~

## node_modules\react-day-picker\dist\cjs\ethiopic\utils\toGregorianDate.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDayNoEthiopian = getDayNoEthiopian;
exports.toGregorianDate = toGregorianDate;
const date_fns_1 = require("date-fns");
const isEthiopicDateValid_js_1 = require("./isEthiopicDateValid.js");
function getDayNoEthiopian(etDate) {
    const num = Math.floor(etDate.year / 4);
    const num2 = etDate.year % 4;
    return num * 1461 + num2 * 365 + (etDate.month - 1) * 30 + etDate.day - 1;
}
function gregorianDateFromDayNo(dayNum) {
    let year = 1, month = 1, day;
    const num400 = Math.floor(dayNum / 146097); // number of full 400-year periods
    dayNum %= 146097;
    if (dayNum === 0) {
        return new Date(400 * num400, 12 - 1, 31);
    }
    const num100 = Math.min(Math.floor(dayNum / 36524), 3); // number of full 100-year periods, but not more than 3
    dayNum -= num100 * 36524;
    if (dayNum === 0) {
        return new Date(400 * num400 + 100 * num100, 12 - 1, 31);
    }
    const num4 = Math.floor(dayNum / 1461); // number of full 4-year periods
    dayNum %= 1461;
    if (dayNum === 0) {
        return new Date(400 * num400 + 100 * num100 + 4 * num4, 12 - 1, 31);
    }
    const num1 = Math.min(Math.floor(dayNum / 365), 3); // number of full years, but not more than 3
    dayNum -= num1 * 365;
    if (dayNum === 0) {
        return new Date(400 * num400 + 100 * num100 + 4 * num4 + num1, 12 - 1, 31);
    }
    year += 400 * num400 + 100 * num100 + 4 * num4 + num1;
    while (dayNum > 0) {
        const tempDate = new Date(year, month - 1);
        const daysInMonth = (0, date_fns_1.getDaysInMonth)(tempDate);
        if (dayNum <= daysInMonth) {
            day = dayNum;
            break;
        }
        dayNum -= daysInMonth;
        month++;
    }
    // Remember in JavaScript Date object, months are 0-based.
    return new Date(year, month - 1, day);
}
/**
 * Converts an Ethiopic date to a Gregorian date.
 *
 * @param ethiopicDate - An EthiopicDate object.
 * @returns A JavaScript Date object representing the Gregorian date.
 */
function toGregorianDate(ethiopicDate) {
    if (!(0, isEthiopicDateValid_js_1.isEthiopicDateValid)(ethiopicDate)) {
        throw new Error("Invalid Ethiopic date");
    }
    return gregorianDateFromDayNo(getDayNoEthiopian(ethiopicDate) + 2431);
}

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatCaption.d.ts

~~~ts
import { DateLib, type DateLibOptions } from "../classes/DateLib.js";
/**
 * Formats the caption of the month.
 *
 * @defaultValue Locale-specific month/year order (e.g., "November 2022").
 * @param month The date representing the month.
 * @param options Configuration options for the date library.
 * @param dateLib The date library to use for formatting. If not provided, a new
 *   instance is created.
 * @returns The formatted caption as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
export declare function formatCaption(month: Date, options?: DateLibOptions, dateLib?: DateLib): string;
/**
 * @private
 * @deprecated Use {@link formatCaption} instead.
 * @group Formatters
 */
export declare const formatMonthCaption: typeof formatCaption;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatCaption.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatMonthCaption = void 0;
exports.formatCaption = formatCaption;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Formats the caption of the month.
 *
 * @defaultValue Locale-specific month/year order (e.g., "November 2022").
 * @param month The date representing the month.
 * @param options Configuration options for the date library.
 * @param dateLib The date library to use for formatting. If not provided, a new
 *   instance is created.
 * @returns The formatted caption as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
function formatCaption(month, options, dateLib) {
    const lib = dateLib ?? new DateLib_js_1.DateLib(options);
    return lib.formatMonthYear(month);
}
/**
 * @private
 * @deprecated Use {@link formatCaption} instead.
 * @group Formatters
 */
exports.formatMonthCaption = formatCaption;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatDay.d.ts

~~~ts
import { DateLib, type DateLibOptions } from "../classes/DateLib.js";
/**
 * Formats the day date shown in the day cell.
 *
 * @defaultValue `d` (e.g., "1").
 * @param date The date to format.
 * @param options Configuration options for the date library.
 * @param dateLib The date library to use for formatting. If not provided, a new
 *   instance is created.
 * @returns The formatted day as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
export declare function formatDay(date: Date, options?: DateLibOptions, dateLib?: DateLib): string;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatDay.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatDay = formatDay;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Formats the day date shown in the day cell.
 *
 * @defaultValue `d` (e.g., "1").
 * @param date The date to format.
 * @param options Configuration options for the date library.
 * @param dateLib The date library to use for formatting. If not provided, a new
 *   instance is created.
 * @returns The formatted day as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
function formatDay(date, options, dateLib) {
    return (dateLib ?? new DateLib_js_1.DateLib(options)).format(date, "d");
}

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatMonthDropdown.d.ts

~~~ts
import { type DateLib } from "../classes/DateLib.js";
/**
 * Formats the month for the dropdown option label.
 *
 * @defaultValue The localized full month name.
 * @param month The date representing the month.
 * @param dateLib The date library to use for formatting. Defaults to
 *   `defaultDateLib`.
 * @returns The formatted month name as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
export declare function formatMonthDropdown(month: Date, dateLib?: DateLib): string;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatMonthDropdown.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatMonthDropdown = formatMonthDropdown;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Formats the month for the dropdown option label.
 *
 * @defaultValue The localized full month name.
 * @param month The date representing the month.
 * @param dateLib The date library to use for formatting. Defaults to
 *   `defaultDateLib`.
 * @returns The formatted month name as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
function formatMonthDropdown(month, dateLib = DateLib_js_1.defaultDateLib) {
    return dateLib.format(month, "LLLL");
}

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatWeekdayName.d.ts

~~~ts
import { DateLib, type DateLibOptions } from "../classes/DateLib.js";
/**
 * Formats the name of a weekday to be displayed in the weekdays header.
 *
 * @defaultValue `cccccc` (e.g., "Mo" for Monday).
 * @param weekday The date representing the weekday.
 * @param options Configuration options for the date library.
 * @param dateLib The date library to use for formatting. If not provided, a new
 *   instance is created.
 * @returns The formatted weekday name as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
export declare function formatWeekdayName(weekday: Date, options?: DateLibOptions, dateLib?: DateLib): string;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatWeekdayName.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatWeekdayName = formatWeekdayName;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Formats the name of a weekday to be displayed in the weekdays header.
 *
 * @defaultValue `cccccc` (e.g., "Mo" for Monday).
 * @param weekday The date representing the weekday.
 * @param options Configuration options for the date library.
 * @param dateLib The date library to use for formatting. If not provided, a new
 *   instance is created.
 * @returns The formatted weekday name as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
function formatWeekdayName(weekday, options, dateLib) {
    return (dateLib ?? new DateLib_js_1.DateLib(options)).format(weekday, "cccccc");
}

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatWeekNumber.d.ts

~~~ts
/**
 * Formats the week number.
 *
 * @defaultValue The week number as a string, with a leading zero for single-digit numbers.
 * @param weekNumber The week number to format.
 * @param dateLib The date library to use for formatting. Defaults to
 *   `defaultDateLib`.
 * @returns The formatted week number as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
export declare function formatWeekNumber(weekNumber: number, dateLib?: import("../classes/DateLib.js").DateLib): string;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatWeekNumber.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatWeekNumber = formatWeekNumber;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Formats the week number.
 *
 * @defaultValue The week number as a string, with a leading zero for single-digit numbers.
 * @param weekNumber The week number to format.
 * @param dateLib The date library to use for formatting. Defaults to
 *   `defaultDateLib`.
 * @returns The formatted week number as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
function formatWeekNumber(weekNumber, dateLib = DateLib_js_1.defaultDateLib) {
    if (weekNumber < 10) {
        return dateLib.formatNumber(`0${weekNumber.toLocaleString()}`);
    }
    return dateLib.formatNumber(`${weekNumber.toLocaleString()}`);
}

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatWeekNumberHeader.d.ts

~~~ts
/**
 * Formats the header for the week number column.
 *
 * @defaultValue An empty string `""`.
 * @returns The formatted week number header as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
export declare function formatWeekNumberHeader(): string;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatWeekNumberHeader.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatWeekNumberHeader = formatWeekNumberHeader;
/**
 * Formats the header for the week number column.
 *
 * @defaultValue An empty string `""`.
 * @returns The formatted week number header as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
function formatWeekNumberHeader() {
    return ``;
}

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatYearDropdown.d.ts

~~~ts
import { type DateLib } from "../classes/DateLib.js";
/**
 * Formats the year for the dropdown option label.
 *
 * @param year The year to format.
 * @param dateLib The date library to use for formatting. Defaults to
 *   `defaultDateLib`.
 * @returns The formatted year as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
export declare function formatYearDropdown(year: Date, dateLib?: DateLib): string;
/**
 * @private
 * @deprecated Use `formatYearDropdown` instead.
 * @group Formatters
 */
export declare const formatYearCaption: typeof formatYearDropdown;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\formatYearDropdown.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatYearCaption = void 0;
exports.formatYearDropdown = formatYearDropdown;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Formats the year for the dropdown option label.
 *
 * @param year The year to format.
 * @param dateLib The date library to use for formatting. Defaults to
 *   `defaultDateLib`.
 * @returns The formatted year as a string.
 * @group Formatters
 * @see https://daypicker.dev/docs/translation#custom-formatters
 */
function formatYearDropdown(year, dateLib = DateLib_js_1.defaultDateLib) {
    return dateLib.format(year, "yyyy");
}
/**
 * @private
 * @deprecated Use `formatYearDropdown` instead.
 * @group Formatters
 */
exports.formatYearCaption = formatYearDropdown;

~~~

## node_modules\react-day-picker\dist\cjs\formatters\index.d.ts

~~~ts
export * from "./formatCaption.js";
export * from "./formatDay.js";
export * from "./formatMonthDropdown.js";
export * from "./formatWeekdayName.js";
export * from "./formatWeekNumber.js";
export * from "./formatWeekNumberHeader.js";
export * from "./formatYearDropdown.js";

~~~

## node_modules\react-day-picker\dist\cjs\formatters\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./formatCaption.js"), exports);
__exportStar(require("./formatDay.js"), exports);
__exportStar(require("./formatMonthDropdown.js"), exports);
__exportStar(require("./formatWeekdayName.js"), exports);
__exportStar(require("./formatWeekNumber.js"), exports);
__exportStar(require("./formatWeekNumberHeader.js"), exports);
__exportStar(require("./formatYearDropdown.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\index.d.ts

~~~ts
import type { Locale } from "date-fns";
import React from "react";
import { DateLib, type DateLibOptions } from "../index.js";
import type { DayPickerProps } from "../types/props.js";
export declare const he: Locale;
export declare const enUS: Locale;
/**
 * Render the Hebrew (lunisolar) calendar.
 *
 * Months follow the Hebrew lunisolar cycle with leap years containing Adar I
 * and Adar II. Weeks remain Sunday?밪aturday.
 *
 * Defaults:
 *
 * - `locale`: `he`
 * - `dir`: `rtl`
 * - `numerals`: `latn`
 */
export declare function DayPicker(props: DayPickerProps & {
    locale?: Locale;
    dir?: DayPickerProps["dir"];
    numerals?: DayPickerProps["numerals"];
    dateLib?: DayPickerProps["dateLib"];
}): React.JSX.Element;
/** Returns the date library used in the Hebrew calendar. */
export declare const getDateLib: (options?: DateLibOptions) => DateLib;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDateLib = exports.enUS = exports.he = void 0;
exports.DayPicker = DayPicker;
const locales = __importStar(require("date-fns/locale"));
const react_1 = __importDefault(require("react"));
const index_js_1 = require("../index.js");
const hebrewDateLib = __importStar(require("./lib/index.js"));
exports.he = locales.he;
exports.enUS = locales.enUS;
/**
 * Render the Hebrew (lunisolar) calendar.
 *
 * Months follow the Hebrew lunisolar cycle with leap years containing Adar I
 * and Adar II. Weeks remain Sunday?밪aturday.
 *
 * Defaults:
 *
 * - `locale`: `he`
 * - `dir`: `rtl`
 * - `numerals`: `latn`
 */
function DayPicker(props) {
    const dateLib = (0, exports.getDateLib)({
        locale: props.locale,
        weekStartsOn: props.broadcastCalendar ? 1 : props.weekStartsOn,
        firstWeekContainsDate: props.firstWeekContainsDate,
        useAdditionalWeekYearTokens: props.useAdditionalWeekYearTokens,
        useAdditionalDayOfYearTokens: props.useAdditionalDayOfYearTokens,
        timeZone: props.timeZone,
    });
    return (react_1.default.createElement(index_js_1.DayPicker, { ...props, locale: props.locale ?? exports.he, numerals: props.numerals ?? "latn", dir: props.dir ?? "rtl", dateLib: dateLib }));
}
/** Returns the date library used in the Hebrew calendar. */
const getDateLib = (options) => {
    return new index_js_1.DateLib(options, hebrewDateLib);
};
exports.getDateLib = getDateLib;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\addMonths.d.ts

~~~ts
export declare function addMonths(date: Date, amount: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\addMonths.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addMonths = addMonths;
const dateConversion_js_1 = require("../utils/dateConversion.js");
const serial_js_1 = require("../utils/serial.js");
function addMonths(date, amount) {
    if (amount === 0) {
        return new Date(date.getTime());
    }
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    const targetIndex = (0, serial_js_1.monthsSinceEpoch)(hebrew) + amount;
    const target = (0, serial_js_1.monthIndexToHebrewDate)(targetIndex, hebrew.day);
    const day = (0, serial_js_1.clampHebrewDay)(target.year, target.monthIndex, target.day);
    return (0, dateConversion_js_1.toGregorianDate)({ ...target, day });
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\addYears.d.ts

~~~ts
export declare function addYears(date: Date, amount: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\addYears.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addYears = addYears;
const dateConversion_js_1 = require("../utils/dateConversion.js");
const setYear_js_1 = require("./setYear.js");
function addYears(date, amount) {
    if (amount === 0) {
        return new Date(date.getTime());
    }
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    return (0, setYear_js_1.setYear)(date, hebrew.year + amount);
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\differenceInCalendarMonths.d.ts

~~~ts
export declare function differenceInCalendarMonths(dateLeft: Date, dateRight: Date): number;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\differenceInCalendarMonths.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.differenceInCalendarMonths = differenceInCalendarMonths;
const dateConversion_js_1 = require("../utils/dateConversion.js");
const serial_js_1 = require("../utils/serial.js");
function differenceInCalendarMonths(dateLeft, dateRight) {
    const left = (0, dateConversion_js_1.toHebrewDate)(dateLeft);
    const right = (0, dateConversion_js_1.toHebrewDate)(dateRight);
    return (0, serial_js_1.monthsSinceEpoch)(left) - (0, serial_js_1.monthsSinceEpoch)(right);
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\eachMonthOfInterval.d.ts

~~~ts
import { type Interval } from "date-fns";
export declare function eachMonthOfInterval(interval: Interval): Date[];

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\eachMonthOfInterval.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachMonthOfInterval = eachMonthOfInterval;
const date_fns_1 = require("date-fns");
const dateConversion_js_1 = require("../utils/dateConversion.js");
const serial_js_1 = require("../utils/serial.js");
function eachMonthOfInterval(interval) {
    const startDate = (0, date_fns_1.toDate)(interval.start);
    const endDate = (0, date_fns_1.toDate)(interval.end);
    if (endDate.getTime() < startDate.getTime()) {
        return [];
    }
    const startHebrew = (0, dateConversion_js_1.toHebrewDate)(startDate);
    const endHebrew = (0, dateConversion_js_1.toHebrewDate)(endDate);
    const startIndex = (0, serial_js_1.monthsSinceEpoch)(startHebrew);
    const endIndex = (0, serial_js_1.monthsSinceEpoch)(endHebrew);
    const months = [];
    for (let index = startIndex; index <= endIndex; index += 1) {
        const hebrew = (0, serial_js_1.monthIndexToHebrewDate)(index, 1);
        months.push((0, dateConversion_js_1.toGregorianDate)(hebrew));
    }
    return months;
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\eachYearOfInterval.d.ts

~~~ts
import { type Interval } from "date-fns";
export declare function eachYearOfInterval(interval: Interval): Date[];

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\eachYearOfInterval.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eachYearOfInterval = eachYearOfInterval;
const date_fns_1 = require("date-fns");
const dateConversion_js_1 = require("../utils/dateConversion.js");
function eachYearOfInterval(interval) {
    const start = (0, date_fns_1.toDate)(interval.start);
    const end = (0, date_fns_1.toDate)(interval.end);
    if (end.getTime() < start.getTime()) {
        return [];
    }
    const startYear = (0, dateConversion_js_1.toHebrewDate)(start).year;
    const endYear = (0, dateConversion_js_1.toHebrewDate)(end).year;
    const years = [];
    for (let year = startYear; year <= endYear; year += 1) {
        years.push((0, dateConversion_js_1.toGregorianDate)({ year, monthIndex: 0, day: 1 }));
    }
    return years;
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\endOfMonth.d.ts

~~~ts
export declare function endOfMonth(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\endOfMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.endOfMonth = endOfMonth;
const calendarMath_js_1 = require("../utils/calendarMath.js");
const dateConversion_js_1 = require("../utils/dateConversion.js");
function endOfMonth(date) {
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    const day = (0, calendarMath_js_1.daysInHebrewMonth)(hebrew.year, hebrew.monthIndex);
    return (0, dateConversion_js_1.toGregorianDate)({ ...hebrew, day });
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\endOfYear.d.ts

~~~ts
export declare function endOfYear(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\endOfYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.endOfYear = endOfYear;
const calendarMath_js_1 = require("../utils/calendarMath.js");
const dateConversion_js_1 = require("../utils/dateConversion.js");
function endOfYear(date) {
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    const lastMonth = (0, calendarMath_js_1.monthsInHebrewYear)(hebrew.year) - 1;
    const day = (0, calendarMath_js_1.daysInHebrewMonth)(hebrew.year, lastMonth);
    return (0, dateConversion_js_1.toGregorianDate)({ year: hebrew.year, monthIndex: lastMonth, day });
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\findMonthIndexByCode.d.ts

~~~ts
export declare function findMonthIndexByCode(year: number, preferredCode: string): number;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\findMonthIndexByCode.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findMonthIndexByCode = findMonthIndexByCode;
const calendarMath_js_1 = require("../utils/calendarMath.js");
function findMonthIndexByCode(year, preferredCode) {
    const monthsCount = (0, calendarMath_js_1.monthsInHebrewYear)(year);
    for (let index = 0; index < monthsCount; index += 1) {
        if ((0, calendarMath_js_1.getMonthCode)(year, index) === preferredCode) {
            return index;
        }
    }
    return -1;
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\format.d.ts

~~~ts
import type { FormatOptions as DateFnsFormatOptions } from "date-fns";
/** Hebrew calendar formatting override. */
export declare function format(date: Date, formatStr: string, options?: DateFnsFormatOptions): string;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\format.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.format = format;
const calendarMath_js_1 = require("../utils/calendarMath.js");
const dateConversion_js_1 = require("../utils/dateConversion.js");
const serial_js_1 = require("../utils/serial.js");
const fallbackMonthNames = {
    tishrei: { en: "Tishrei", he: "瘻漏淚?" },
    cheshvan: { en: "Cheshvan", he: "?漏???" },
    kislev: { en: "Kislev", he: "?遼??" },
    tevet: { en: "Tevet", he: "??瘻" },
    shevat: { en: "Shevat", he: "漏??" },
    adarI: { en: "Adar I", he: "??淚 ?柳" },
    adar: { en: "Adar", he: "??淚" },
    nisan: { en: "Nisan", he: "??遼?" },
    iyar: { en: "Iyar", he: "???淚" },
    sivan: { en: "Sivan", he: "遼????" },
    tamuz: { en: "Tammuz", he: "瘻???" },
    av: { en: "Av", he: "??" },
    elul: { en: "Elul", he: "????" },
};
const fallbackWeekdayNames = {
    long: {
        en: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
        ],
        he: [
            "??? 淚?漏??",
            "??? 漏??",
            "??? 漏??漏?",
            "??? 淚??鬧?",
            "??? ???漏?",
            "??? 漏?漏?",
            "漏?瘻",
        ],
    },
    narrow: {
        en: ["S", "M", "T", "W", "T", "F", "S"],
        he: ["?", "?", "?", "?", "?", "?", "漏"],
    },
};
const getLocaleCode = (options) => {
    return options?.locale?.code ?? "he";
};
const getMonthCodeForDate = (date) => {
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    return (0, calendarMath_js_1.getMonthCode)(hebrew.year, hebrew.monthIndex);
};
const formatMonthName = (date, localeCode) => {
    try {
        return new Intl.DateTimeFormat(localeCode, {
            month: "long",
            calendar: "hebrew",
        }).format(date);
    }
    catch {
        const code = getMonthCodeForDate(date);
        const isHebrew = localeCode.startsWith("he");
        return isHebrew ? fallbackMonthNames[code].he : fallbackMonthNames[code].en;
    }
};
const formatWeekdayName = (date, localeCode, width) => {
    try {
        return new Intl.DateTimeFormat(localeCode, {
            weekday: width,
            calendar: "hebrew",
        }).format(date);
    }
    catch {
        const index = date.getDay();
        const isHebrew = localeCode.startsWith("he");
        return isHebrew
            ? fallbackWeekdayNames[width].he[index]
            : fallbackWeekdayNames[width].en[index];
    }
};
const formatDateStyle = (date, localeCode, style) => {
    try {
        return new Intl.DateTimeFormat(localeCode, {
            dateStyle: style,
            calendar: "hebrew",
        }).format(date);
    }
    catch {
        const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
        const month = formatMonthName(date, localeCode);
        if (style === "full") {
            const weekday = formatWeekdayName(date, localeCode, "long");
            return `${weekday}, ${month} ${hebrew.day}, ${hebrew.year}`;
        }
        return `${month} ${hebrew.day}, ${hebrew.year}`;
    }
};
const formatNumber = (value) => {
    return value.toString();
};
const buildTimeFormat = (date, localeCode, formatStr) => {
    const hour12 = formatStr.includes("a");
    return new Intl.DateTimeFormat(localeCode, {
        hour: "numeric",
        minute: "numeric",
        hour12,
    }).format(date);
};
/** Hebrew calendar formatting override. */
function format(date, formatStr, options) {
    const extendedOptions = options;
    const localeCode = getLocaleCode(extendedOptions);
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    const monthNumber = (0, serial_js_1.hebrewMonthNumber)(hebrew.monthIndex);
    switch (formatStr) {
        case "LLLL y":
        case "LLLL yyyy":
            return `${formatMonthName(date, localeCode)} ${formatNumber(hebrew.year)}`;
        case "LLLL":
            return formatMonthName(date, localeCode);
        case "PPP":
            return formatDateStyle(date, localeCode, "long");
        case "PPPP":
            return formatDateStyle(date, localeCode, "full");
        case "cccc":
            return formatWeekdayName(date, localeCode, "long");
        case "cccccc":
            return formatWeekdayName(date, localeCode, "narrow");
        case "yyyy":
        case "y":
            return formatNumber(hebrew.year);
        case "yyyy-MM":
            return `${formatNumber(hebrew.year)}-${formatNumber(monthNumber).padStart(2, "0")}`;
        case "yyyy-MM-dd":
            return `${formatNumber(hebrew.year)}-${formatNumber(monthNumber).padStart(2, "0")}-${formatNumber(hebrew.day).padStart(2, "0")}`;
        case "MM":
            return formatNumber(monthNumber).padStart(2, "0");
        case "M":
            return formatNumber(monthNumber);
        case "dd":
            return formatNumber(hebrew.day).padStart(2, "0");
        case "d":
            return formatNumber(hebrew.day);
        default:
            if (/[Hh]/.test(formatStr) && /m/.test(formatStr)) {
                return buildTimeFormat(date, localeCode, formatStr);
            }
            return `${formatNumber(hebrew.day)}/${formatNumber(monthNumber)}/${formatNumber(hebrew.year)}`;
    }
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\getMonth.d.ts

~~~ts
export declare function getMonth(date: Date): number;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\getMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMonth = getMonth;
const dateConversion_js_1 = require("../utils/dateConversion.js");
function getMonth(date) {
    return (0, dateConversion_js_1.toHebrewDate)(date).monthIndex;
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\getYear.d.ts

~~~ts
export declare function getYear(date: Date): number;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\getYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getYear = getYear;
const dateConversion_js_1 = require("../utils/dateConversion.js");
function getYear(date) {
    return (0, dateConversion_js_1.toHebrewDate)(date).year;
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\index.d.ts

~~~ts
export * from "./addMonths.js";
export * from "./addYears.js";
export * from "./differenceInCalendarMonths.js";
export * from "./eachMonthOfInterval.js";
export * from "./eachYearOfInterval.js";
export * from "./endOfMonth.js";
export * from "./endOfYear.js";
export * from "./format.js";
export * from "./getMonth.js";
export * from "./getYear.js";
export * from "./isSameMonth.js";
export * from "./isSameYear.js";
export * from "./newDate.js";
export * from "./setMonth.js";
export * from "./setYear.js";
export * from "./startOfMonth.js";
export * from "./startOfYear.js";

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./addMonths.js"), exports);
__exportStar(require("./addYears.js"), exports);
__exportStar(require("./differenceInCalendarMonths.js"), exports);
__exportStar(require("./eachMonthOfInterval.js"), exports);
__exportStar(require("./eachYearOfInterval.js"), exports);
__exportStar(require("./endOfMonth.js"), exports);
__exportStar(require("./endOfYear.js"), exports);
__exportStar(require("./format.js"), exports);
__exportStar(require("./getMonth.js"), exports);
__exportStar(require("./getYear.js"), exports);
__exportStar(require("./isSameMonth.js"), exports);
__exportStar(require("./isSameYear.js"), exports);
__exportStar(require("./newDate.js"), exports);
__exportStar(require("./setMonth.js"), exports);
__exportStar(require("./setYear.js"), exports);
__exportStar(require("./startOfMonth.js"), exports);
__exportStar(require("./startOfYear.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\isSameMonth.d.ts

~~~ts
export declare function isSameMonth(dateLeft: Date, dateRight: Date): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\isSameMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameMonth = isSameMonth;
const dateConversion_js_1 = require("../utils/dateConversion.js");
function isSameMonth(dateLeft, dateRight) {
    const left = (0, dateConversion_js_1.toHebrewDate)(dateLeft);
    const right = (0, dateConversion_js_1.toHebrewDate)(dateRight);
    return left.year === right.year && left.monthIndex === right.monthIndex;
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\isSameYear.d.ts

~~~ts
export declare function isSameYear(dateLeft: Date, dateRight: Date): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\isSameYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSameYear = isSameYear;
const dateConversion_js_1 = require("../utils/dateConversion.js");
function isSameYear(dateLeft, dateRight) {
    return (0, dateConversion_js_1.toHebrewDate)(dateLeft).year === (0, dateConversion_js_1.toHebrewDate)(dateRight).year;
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\newDate.d.ts

~~~ts
export declare function newDate(year: number, monthIndex: number, day: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\newDate.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newDate = newDate;
const dateConversion_js_1 = require("../utils/dateConversion.js");
function newDate(year, monthIndex, day) {
    return (0, dateConversion_js_1.toGregorianDate)({ year, monthIndex, day });
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\setMonth.d.ts

~~~ts
export declare function setMonth(date: Date, month: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\setMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMonth = setMonth;
const dateConversion_js_1 = require("../utils/dateConversion.js");
const serial_js_1 = require("../utils/serial.js");
function setMonth(date, month) {
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    const baseIndex = (0, serial_js_1.monthsSinceEpoch)({ year: hebrew.year, monthIndex: 0 });
    const targetIndex = baseIndex + month;
    const target = (0, serial_js_1.monthIndexToHebrewDate)(targetIndex, hebrew.day);
    return (0, dateConversion_js_1.toGregorianDate)(target);
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\setYear.d.ts

~~~ts
export declare function setYear(date: Date, year: number): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\setYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setYear = setYear;
const calendarMath_js_1 = require("../utils/calendarMath.js");
const dateConversion_js_1 = require("../utils/dateConversion.js");
const serial_js_1 = require("../utils/serial.js");
const findMonthIndexByCode_js_1 = require("./findMonthIndexByCode.js");
function setYear(date, year) {
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    const targetYear = year;
    const originalCode = (0, calendarMath_js_1.getMonthCode)(hebrew.year, hebrew.monthIndex);
    let targetMonthIndex = (0, findMonthIndexByCode_js_1.findMonthIndexByCode)(targetYear, originalCode);
    if (targetMonthIndex === -1) {
        if (originalCode === "adarI") {
            targetMonthIndex = (0, findMonthIndexByCode_js_1.findMonthIndexByCode)(targetYear, "adar");
        }
        else if (originalCode === "adar" && !(0, calendarMath_js_1.isHebrewLeapYear)(targetYear)) {
            targetMonthIndex = (0, findMonthIndexByCode_js_1.findMonthIndexByCode)(targetYear, "adar");
        }
        else {
            const monthsCount = (0, calendarMath_js_1.monthsInHebrewYear)(targetYear);
            targetMonthIndex = Math.min(hebrew.monthIndex, monthsCount - 1);
        }
    }
    const day = (0, serial_js_1.clampHebrewDay)(targetYear, targetMonthIndex, hebrew.day);
    return (0, dateConversion_js_1.toGregorianDate)({
        year: targetYear,
        monthIndex: targetMonthIndex,
        day,
    });
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\startOfMonth.d.ts

~~~ts
export declare function startOfMonth(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\startOfMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startOfMonth = startOfMonth;
const dateConversion_js_1 = require("../utils/dateConversion.js");
function startOfMonth(date) {
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    return (0, dateConversion_js_1.toGregorianDate)({ ...hebrew, day: 1 });
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\startOfYear.d.ts

~~~ts
export declare function startOfYear(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\lib\startOfYear.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startOfYear = startOfYear;
const dateConversion_js_1 = require("../utils/dateConversion.js");
function startOfYear(date) {
    const hebrew = (0, dateConversion_js_1.toHebrewDate)(date);
    return (0, dateConversion_js_1.toGregorianDate)({ year: hebrew.year, monthIndex: 0, day: 1 });
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\utils\calendarMath.d.ts

~~~ts
import { type HebrewMonthCode } from "./constants.js";
/**
 * Calculate the modulus that always returns a positive remainder. Useful when
 * applying 19-year leap cycles.
 */
export declare function mod(value: number, divisor: number): number;
/** Determine whether a Hebrew year includes the extra Adar I month. */
export declare function isHebrewLeapYear(year: number): boolean;
/** Return the absolute day for Rosh Hashanah (cached for reuse). */
export declare function roshHashanah(year: number): number;
/** Total days in a Hebrew year, accounting for leap and year type. */
export declare function daysInHebrewYear(year: number): number;
/** Returns the number of months in the specified year (12 or 13). */
export declare function monthsInHebrewYear(year: number): number;
/** Number of days in a given Hebrew month (by index). */
export declare function daysInHebrewMonth(year: number, monthIndex: number): number;
export declare function getMonthCode(year: number, monthIndex: number): HebrewMonthCode;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\utils\calendarMath.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mod = mod;
exports.isHebrewLeapYear = isHebrewLeapYear;
exports.roshHashanah = roshHashanah;
exports.daysInHebrewYear = daysInHebrewYear;
exports.monthsInHebrewYear = monthsInHebrewYear;
exports.daysInHebrewMonth = daysInHebrewMonth;
exports.getMonthCode = getMonthCode;
const constants_js_1 = require("./constants.js");
const roshHashanahCache = new Map();
const yearLengthCache = new Map();
/**
 * Calculate the modulus that always returns a positive remainder. Useful when
 * applying 19-year leap cycles.
 */
function mod(value, divisor) {
    return ((value % divisor) + divisor) % divisor;
}
/** Determine whether a Hebrew year includes the extra Adar I month. */
function isHebrewLeapYear(year) {
    return mod(7 * year + 1, 19) < 7;
}
/** Count lunar months elapsed since the epoch up to the start of a year. */
function monthsElapsed(year) {
    return Math.floor((235 * year - 234) / 19);
}
/** Compute the absolute day (relative to epoch) for the new year. */
function hebrewCalendarElapsedDays(year) {
    const months = monthsElapsed(year);
    const parts = 204 + 793 * mod(months, 1080);
    const hours = 5 + 12 * months + 793 * Math.floor(months / 1080);
    const day = 1 + 29 * months + Math.floor(hours / 24);
    const partsRemain = mod(hours, 24) * 1080 + parts;
    let roshHashanah = day;
    const leapYear = isHebrewLeapYear(year);
    const lastYearLeap = isHebrewLeapYear(year - 1);
    if (partsRemain >= 19440 ||
        (mod(roshHashanah, 7) === 2 && partsRemain >= 9924 && !leapYear) ||
        (mod(roshHashanah, 7) === 1 && partsRemain >= 16789 && lastYearLeap)) {
        roshHashanah += 1;
    }
    const weekday = mod(roshHashanah, 7);
    if (weekday === 0 || weekday === 3 || weekday === 5) {
        roshHashanah += 1;
    }
    return roshHashanah;
}
/** Return the absolute day for Rosh Hashanah (cached for reuse). */
function roshHashanah(year) {
    const cached = roshHashanahCache.get(year);
    if (cached !== undefined) {
        return cached;
    }
    const value = constants_js_1.HEBREW_EPOCH + hebrewCalendarElapsedDays(year);
    roshHashanahCache.set(year, value);
    return value;
}
/** Total days in a Hebrew year, accounting for leap and year type. */
function daysInHebrewYear(year) {
    const cached = yearLengthCache.get(year);
    if (cached !== undefined) {
        return cached;
    }
    const days = roshHashanah(year + 1) - roshHashanah(year);
    yearLengthCache.set(year, days);
    return days;
}
/** Classify a year as deficient, regular, or complete. */
function yearType(year) {
    const days = daysInHebrewYear(year);
    const leap = isHebrewLeapYear(year);
    if (leap) {
        if (days === 383)
            return "deficient";
        if (days === 384)
            return "regular";
        return "complete";
    }
    if (days === 353)
        return "deficient";
    if (days === 354)
        return "regular";
    return "complete";
}
/** Get the sequence of month codes for a year, inserting Adar I as needed. */
function monthSequence(year) {
    return isHebrewLeapYear(year) ? constants_js_1.MONTH_SEQUENCE_LEAP : constants_js_1.MONTH_SEQUENCE_COMMON;
}
/** Retrieve the canonical month code for a year and month index. */
function monthCode(year, monthIndex) {
    const sequence = monthSequence(year);
    if (monthIndex < 0 || monthIndex >= sequence.length) {
        throw new RangeError(`Invalid month index ${monthIndex} for year ${year}`);
    }
    return sequence[monthIndex];
}
/** Returns the number of months in the specified year (12 or 13). */
function monthsInHebrewYear(year) {
    return monthSequence(year).length;
}
/** Number of days in a given Hebrew month (by index). */
function daysInHebrewMonth(year, monthIndex) {
    const code = monthCode(year, monthIndex);
    const type = yearType(year);
    switch (code) {
        case "tishrei":
            return 30;
        case "cheshvan":
            return type === "complete" ? 30 : 29;
        case "kislev":
            return type === "deficient" ? 29 : 30;
        case "tevet":
            return 29;
        case "shevat":
            return 30;
        case "adarI":
            return 30;
        case "adar":
            return 29;
        case "nisan":
            return 30;
        case "iyar":
            return 29;
        case "sivan":
            return 30;
        case "tamuz":
            return 29;
        case "av":
            return 30;
        case "elul":
            return 29;
        default:
            return 0;
    }
}
function getMonthCode(year, monthIndex) {
    return monthCode(year, monthIndex);
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\utils\constants.d.ts

~~~ts
export declare const MS_PER_DAY: number;
export declare const GREGORIAN_EPOCH: number;
export declare const HEBREW_EPOCH = -2067381;
export declare const MONTH_SEQUENCE_COMMON: readonly ["tishrei", "cheshvan", "kislev", "tevet", "shevat", "adar", "nisan", "iyar", "sivan", "tamuz", "av", "elul"];
export declare const MONTH_SEQUENCE_LEAP: readonly ["tishrei", "cheshvan", "kislev", "tevet", "shevat", "adarI", "adar", "nisan", "iyar", "sivan", "tamuz", "av", "elul"];
export declare const MONTHS_PER_CYCLE = 235;
export type HebrewMonthCode = (typeof MONTH_SEQUENCE_LEAP)[number];
export type HebrewDate = {
    year: number;
    monthIndex: number;
    day: number;
};
export type YearType = "deficient" | "regular" | "complete";

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\utils\constants.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MONTHS_PER_CYCLE = exports.MONTH_SEQUENCE_LEAP = exports.MONTH_SEQUENCE_COMMON = exports.HEBREW_EPOCH = exports.GREGORIAN_EPOCH = exports.MS_PER_DAY = void 0;
exports.MS_PER_DAY = 24 * 60 * 60 * 1000;
exports.GREGORIAN_EPOCH = Date.UTC(1, 0, 1);
exports.HEBREW_EPOCH = -2067381;
exports.MONTH_SEQUENCE_COMMON = [
    "tishrei",
    "cheshvan",
    "kislev",
    "tevet",
    "shevat",
    "adar",
    "nisan",
    "iyar",
    "sivan",
    "tamuz",
    "av",
    "elul",
];
exports.MONTH_SEQUENCE_LEAP = [
    "tishrei",
    "cheshvan",
    "kislev",
    "tevet",
    "shevat",
    "adarI",
    "adar",
    "nisan",
    "iyar",
    "sivan",
    "tamuz",
    "av",
    "elul",
];
exports.MONTHS_PER_CYCLE = 235;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\utils\dateConversion.d.ts

~~~ts
import { type HebrewDate } from "./constants.js";
/** Converts a Gregorian date to the corresponding Hebrew date. */
export declare function toHebrewDate(date: Date): HebrewDate;
/** Converts a Hebrew date back to the Gregorian calendar. */
export declare function toGregorianDate(hebrew: HebrewDate): Date;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\utils\dateConversion.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toHebrewDate = toHebrewDate;
exports.toGregorianDate = toGregorianDate;
const calendarMath_js_1 = require("./calendarMath.js");
const constants_js_1 = require("./constants.js");
/** Convert a Gregorian date to an absolute day number from the epoch. */
function dateToAbsolute(date) {
    const normalized = new Date(0);
    normalized.setUTCFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    normalized.setUTCHours(0, 0, 0, 0);
    return Math.floor((normalized.getTime() - constants_js_1.GREGORIAN_EPOCH) / constants_js_1.MS_PER_DAY) + 1;
}
/** Convert an absolute day number back to a Gregorian date. */
function absoluteToDate(absolute) {
    const utc = new Date(constants_js_1.GREGORIAN_EPOCH + (absolute - 1) * constants_js_1.MS_PER_DAY);
    const result = new Date(0);
    result.setFullYear(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate());
    result.setHours(0, 0, 0, 0);
    return result;
}
/** Convert a Hebrew date to an absolute day number so it can be compared. */
function absoluteFromHebrew({ year, monthIndex, day }) {
    let days = day - 1;
    for (let index = 0; index < monthIndex; index += 1) {
        days += (0, calendarMath_js_1.daysInHebrewMonth)(year, index);
    }
    return (0, calendarMath_js_1.roshHashanah)(year) + days;
}
/** Convert an absolute day number to the equivalent Hebrew date. */
function hebrewFromAbsolute(absolute) {
    const date = new Date(constants_js_1.GREGORIAN_EPOCH + (absolute - 1) * constants_js_1.MS_PER_DAY);
    let year = date.getUTCFullYear() + 3760;
    if (date.getUTCMonth() >= 8) {
        year += 1;
    }
    while (absolute >= (0, calendarMath_js_1.roshHashanah)(year + 1)) {
        year += 1;
    }
    while (absolute < (0, calendarMath_js_1.roshHashanah)(year)) {
        year -= 1;
    }
    let dayOfYear = absolute - (0, calendarMath_js_1.roshHashanah)(year);
    const monthCount = (0, calendarMath_js_1.monthsInHebrewYear)(year);
    let monthIndex = 0;
    while (monthIndex < monthCount) {
        const monthDays = (0, calendarMath_js_1.daysInHebrewMonth)(year, monthIndex);
        if (dayOfYear < monthDays) {
            break;
        }
        dayOfYear -= monthDays;
        monthIndex += 1;
    }
    return {
        year,
        monthIndex,
        day: dayOfYear + 1,
    };
}
/** Converts a Gregorian date to the corresponding Hebrew date. */
function toHebrewDate(date) {
    return hebrewFromAbsolute(dateToAbsolute(date));
}
/** Converts a Hebrew date back to the Gregorian calendar. */
function toGregorianDate(hebrew) {
    return absoluteToDate(absoluteFromHebrew(hebrew));
}

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\utils\serial.d.ts

~~~ts
import { type HebrewDate } from "./constants.js";
/** Serial index for Hebrew months since the epoch (Tishrei of year 1). */
export declare function monthsSinceEpoch({ year, monthIndex, }: Pick<HebrewDate, "year" | "monthIndex">): number;
/** Clamp a day number to the valid number of days in a month. */
export declare function clampHebrewDay(year: number, monthIndex: number, day: number): number;
/** Convert serial month index to a Hebrew date, clamping the day if needed. */
export declare function monthIndexToHebrewDate(monthIndex: number, day: number): HebrewDate;
/** Convert zero-based month index to the user-facing 1..13 number. */
export declare function hebrewMonthNumber(monthIndex: number): number;

~~~

## node_modules\react-day-picker\dist\cjs\hebrew\utils\serial.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.monthsSinceEpoch = monthsSinceEpoch;
exports.clampHebrewDay = clampHebrewDay;
exports.monthIndexToHebrewDate = monthIndexToHebrewDate;
exports.hebrewMonthNumber = hebrewMonthNumber;
const calendarMath_js_1 = require("./calendarMath.js");
const constants_js_1 = require("./constants.js");
/**
 * Count how many months have elapsed before the given Hebrew year. Needed to
 * compute serial month offsets across leap/non-leap cycles.
 */
function monthsBeforeYear(year) {
    if (year <= 1) {
        return 0;
    }
    const cycles = Math.floor((year - 1) / 19);
    let months = cycles * constants_js_1.MONTHS_PER_CYCLE;
    let currentYear = cycles * 19 + 1;
    while (currentYear < year) {
        months += (0, calendarMath_js_1.monthsInHebrewYear)(currentYear);
        currentYear += 1;
    }
    return months;
}
/** Serial index for Hebrew months since the epoch (Tishrei of year 1). */
function monthsSinceEpoch({ year, monthIndex, }) {
    return monthsBeforeYear(year) + monthIndex;
}
/**
 * Convert a serial month index back into Hebrew year/month. Supports negative
 * indices for pre-epoch dates.
 */
function hebrewFromMonthIndex(monthIndex) {
    let index = monthIndex;
    let year = 1;
    if (index >= 0) {
        const cycles = Math.floor(index / constants_js_1.MONTHS_PER_CYCLE);
        year += cycles * 19;
        index -= cycles * constants_js_1.MONTHS_PER_CYCLE;
        while (true) {
            const months = (0, calendarMath_js_1.monthsInHebrewYear)(year);
            if (index < months) {
                break;
            }
            index -= months;
            year += 1;
        }
        return { year, month: index };
    }
    // Handle negative month indices (dates before the epoch)
    while (index < 0) {
        year -= 1;
        const months = (0, calendarMath_js_1.monthsInHebrewYear)(year);
        index += months;
    }
    return { year, month: index };
}
/** Clamp a day number to the valid number of days in a month. */
function clampHebrewDay(year, monthIndex, day) {
    const maxDay = (0, calendarMath_js_1.daysInHebrewMonth)(year, monthIndex);
    return Math.min(day, maxDay);
}
/** Convert serial month index to a Hebrew date, clamping the day if needed. */
function monthIndexToHebrewDate(monthIndex, day) {
    const { year, month } = hebrewFromMonthIndex(monthIndex);
    return {
        year,
        monthIndex: month,
        day: clampHebrewDay(year, month, day),
    };
}
/** Convert zero-based month index to the user-facing 1..13 number. */
function hebrewMonthNumber(monthIndex) {
    return monthIndex + 1;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\calculateFocusTarget.d.ts

~~~ts
import type { CalendarDay } from "../classes/index.js";
import type { Modifiers } from "../types/index.js";
/**
 * Calculates the focus target day based on priority.
 *
 * This function determines the day that should receive focus in the calendar,
 * prioritizing days with specific modifiers (e.g., "focused", "today") or
 * selection states.
 *
 * @param days The array of `CalendarDay` objects to evaluate.
 * @param getModifiers A function to retrieve the modifiers for a given day.
 * @param isSelected A function to determine if a day is selected.
 * @param lastFocused The last focused day, if any.
 * @returns The `CalendarDay` that should receive focus, or `undefined` if no
 *   focusable day is found.
 */
export declare function calculateFocusTarget(days: CalendarDay[], getModifiers: (day: CalendarDay) => Modifiers, isSelected: (date: Date) => boolean, lastFocused: CalendarDay | undefined): CalendarDay | undefined;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\calculateFocusTarget.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateFocusTarget = calculateFocusTarget;
const UI_js_1 = require("../UI.js");
var FocusTargetPriority;
(function (FocusTargetPriority) {
    FocusTargetPriority[FocusTargetPriority["Today"] = 0] = "Today";
    FocusTargetPriority[FocusTargetPriority["Selected"] = 1] = "Selected";
    FocusTargetPriority[FocusTargetPriority["LastFocused"] = 2] = "LastFocused";
    FocusTargetPriority[FocusTargetPriority["FocusedModifier"] = 3] = "FocusedModifier";
})(FocusTargetPriority || (FocusTargetPriority = {}));
/**
 * Determines if a day is focusable based on its modifiers.
 *
 * A day is considered focusable if it is not disabled, hidden, or outside the
 * displayed month.
 *
 * @param modifiers The modifiers applied to the day.
 * @returns `true` if the day is focusable, otherwise `false`.
 */
function isFocusableDay(modifiers) {
    return (!modifiers[UI_js_1.DayFlag.disabled] &&
        !modifiers[UI_js_1.DayFlag.hidden] &&
        !modifiers[UI_js_1.DayFlag.outside]);
}
/**
 * Calculates the focus target day based on priority.
 *
 * This function determines the day that should receive focus in the calendar,
 * prioritizing days with specific modifiers (e.g., "focused", "today") or
 * selection states.
 *
 * @param days The array of `CalendarDay` objects to evaluate.
 * @param getModifiers A function to retrieve the modifiers for a given day.
 * @param isSelected A function to determine if a day is selected.
 * @param lastFocused The last focused day, if any.
 * @returns The `CalendarDay` that should receive focus, or `undefined` if no
 *   focusable day is found.
 */
function calculateFocusTarget(days, getModifiers, isSelected, lastFocused) {
    let focusTarget;
    let foundFocusTargetPriority = -1;
    for (const day of days) {
        const modifiers = getModifiers(day);
        if (isFocusableDay(modifiers)) {
            if (modifiers[UI_js_1.DayFlag.focused] &&
                foundFocusTargetPriority < FocusTargetPriority.FocusedModifier) {
                focusTarget = day;
                foundFocusTargetPriority = FocusTargetPriority.FocusedModifier;
            }
            else if (lastFocused?.isEqualTo(day) &&
                foundFocusTargetPriority < FocusTargetPriority.LastFocused) {
                focusTarget = day;
                foundFocusTargetPriority = FocusTargetPriority.LastFocused;
            }
            else if (isSelected(day.date) &&
                foundFocusTargetPriority < FocusTargetPriority.Selected) {
                focusTarget = day;
                foundFocusTargetPriority = FocusTargetPriority.Selected;
            }
            else if (modifiers[UI_js_1.DayFlag.today] &&
                foundFocusTargetPriority < FocusTargetPriority.Today) {
                focusTarget = day;
                foundFocusTargetPriority = FocusTargetPriority.Today;
            }
        }
    }
    if (!focusTarget) {
        // Return the first day that is focusable
        focusTarget = days.find((day) => isFocusableDay(getModifiers(day)));
    }
    return focusTarget;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\createGetModifiers.d.ts

~~~ts
import type { CalendarDay, DateLib } from "../classes/index.js";
import type { DayPickerProps, Modifiers } from "../types/index.js";
/**
 * Creates a function to retrieve the modifiers for a given day.
 *
 * This function calculates both internal and custom modifiers for each day
 * based on the provided calendar days and DayPicker props.
 *
 * @private
 * @param days The array of `CalendarDay` objects to process.
 * @param props The DayPicker props, including modifiers and configuration
 *   options.
 * @param dateLib The date library to use for date manipulation.
 * @returns A function that retrieves the modifiers for a given `CalendarDay`.
 */
export declare function createGetModifiers(days: CalendarDay[], props: DayPickerProps, navStart: Date | undefined, navEnd: Date | undefined, dateLib: DateLib): (day: CalendarDay) => Modifiers;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\createGetModifiers.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGetModifiers = createGetModifiers;
const UI_js_1 = require("../UI.js");
const dateMatchModifiers_js_1 = require("../utils/dateMatchModifiers.js");
/**
 * Creates a function to retrieve the modifiers for a given day.
 *
 * This function calculates both internal and custom modifiers for each day
 * based on the provided calendar days and DayPicker props.
 *
 * @private
 * @param days The array of `CalendarDay` objects to process.
 * @param props The DayPicker props, including modifiers and configuration
 *   options.
 * @param dateLib The date library to use for date manipulation.
 * @returns A function that retrieves the modifiers for a given `CalendarDay`.
 */
function createGetModifiers(days, props, navStart, navEnd, dateLib) {
    const { disabled, hidden, modifiers, showOutsideDays, broadcastCalendar, today, } = props;
    const { isSameDay, isSameMonth, startOfMonth, isBefore, endOfMonth, isAfter, } = dateLib;
    const computedNavStart = navStart && startOfMonth(navStart);
    const computedNavEnd = navEnd && endOfMonth(navEnd);
    const internalModifiersMap = {
        [UI_js_1.DayFlag.focused]: [],
        [UI_js_1.DayFlag.outside]: [],
        [UI_js_1.DayFlag.disabled]: [],
        [UI_js_1.DayFlag.hidden]: [],
        [UI_js_1.DayFlag.today]: [],
    };
    const customModifiersMap = {};
    for (const day of days) {
        const { date, displayMonth } = day;
        const isOutside = Boolean(displayMonth && !isSameMonth(date, displayMonth));
        const isBeforeNavStart = Boolean(computedNavStart && isBefore(date, computedNavStart));
        const isAfterNavEnd = Boolean(computedNavEnd && isAfter(date, computedNavEnd));
        const isDisabled = Boolean(disabled && (0, dateMatchModifiers_js_1.dateMatchModifiers)(date, disabled, dateLib));
        const isHidden = Boolean(hidden && (0, dateMatchModifiers_js_1.dateMatchModifiers)(date, hidden, dateLib)) ||
            isBeforeNavStart ||
            isAfterNavEnd ||
            // Broadcast calendar will show outside days as default
            (!broadcastCalendar && !showOutsideDays && isOutside) ||
            (broadcastCalendar && showOutsideDays === false && isOutside);
        const isToday = isSameDay(date, today ?? dateLib.today());
        if (isOutside)
            internalModifiersMap.outside.push(day);
        if (isDisabled)
            internalModifiersMap.disabled.push(day);
        if (isHidden)
            internalModifiersMap.hidden.push(day);
        if (isToday)
            internalModifiersMap.today.push(day);
        // Add custom modifiers
        if (modifiers) {
            Object.keys(modifiers).forEach((name) => {
                const modifierValue = modifiers?.[name];
                const isMatch = modifierValue
                    ? (0, dateMatchModifiers_js_1.dateMatchModifiers)(date, modifierValue, dateLib)
                    : false;
                if (!isMatch)
                    return;
                if (customModifiersMap[name]) {
                    customModifiersMap[name].push(day);
                }
                else {
                    customModifiersMap[name] = [day];
                }
            });
        }
    }
    return (day) => {
        // Initialize all the modifiers to false
        const dayFlags = {
            [UI_js_1.DayFlag.focused]: false,
            [UI_js_1.DayFlag.disabled]: false,
            [UI_js_1.DayFlag.hidden]: false,
            [UI_js_1.DayFlag.outside]: false,
            [UI_js_1.DayFlag.today]: false,
        };
        const customModifiers = {};
        // Find the modifiers for the given day
        for (const name in internalModifiersMap) {
            const days = internalModifiersMap[name];
            dayFlags[name] = days.some((d) => d === day);
        }
        for (const name in customModifiersMap) {
            customModifiers[name] = customModifiersMap[name].some((d) => d === day);
        }
        return {
            ...dayFlags,
            // custom modifiers should override all the previous ones
            ...customModifiers,
        };
    };
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\endOfBroadcastWeek.d.ts

~~~ts
import type { DateLib } from "../classes/index.js";
/**
 * Returns the end date of the week in the broadcast calendar.
 *
 * The broadcast week ends on the last day of the last broadcast week for the
 * given date.
 *
 * @since 9.4.0
 * @param date The date for which to calculate the end of the broadcast week.
 * @param dateLib The date library to use for date manipulation.
 * @returns The end date of the broadcast week.
 */
export declare function endOfBroadcastWeek(date: Date, dateLib: DateLib): Date;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\endOfBroadcastWeek.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.endOfBroadcastWeek = endOfBroadcastWeek;
const getBroadcastWeeksInMonth_js_1 = require("./getBroadcastWeeksInMonth.js");
const startOfBroadcastWeek_js_1 = require("./startOfBroadcastWeek.js");
/**
 * Returns the end date of the week in the broadcast calendar.
 *
 * The broadcast week ends on the last day of the last broadcast week for the
 * given date.
 *
 * @since 9.4.0
 * @param date The date for which to calculate the end of the broadcast week.
 * @param dateLib The date library to use for date manipulation.
 * @returns The end date of the broadcast week.
 */
function endOfBroadcastWeek(date, dateLib) {
    const startDate = (0, startOfBroadcastWeek_js_1.startOfBroadcastWeek)(date, dateLib);
    const numberOfWeeks = (0, getBroadcastWeeksInMonth_js_1.getBroadcastWeeksInMonth)(date, dateLib);
    const endDate = dateLib.addDays(startDate, numberOfWeeks * 7 - 1);
    return endDate;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getBroadcastWeeksInMonth.d.ts

~~~ts
import type { DateLib } from "../classes/index.js";
/**
 * Returns the number of weeks to display in the broadcast calendar for a given
 * month.
 *
 * The broadcast calendar may have either 4 or 5 weeks in a month, depending on
 * the start and end dates of the broadcast weeks.
 *
 * @since 9.4.0
 * @param month The month for which to calculate the number of weeks.
 * @param dateLib The date library to use for date manipulation.
 * @returns The number of weeks in the broadcast calendar (4 or 5).
 */
export declare function getBroadcastWeeksInMonth(month: Date, dateLib: DateLib): 4 | 5;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getBroadcastWeeksInMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBroadcastWeeksInMonth = getBroadcastWeeksInMonth;
const FIVE_WEEKS = 5;
const FOUR_WEEKS = 4;
/**
 * Returns the number of weeks to display in the broadcast calendar for a given
 * month.
 *
 * The broadcast calendar may have either 4 or 5 weeks in a month, depending on
 * the start and end dates of the broadcast weeks.
 *
 * @since 9.4.0
 * @param month The month for which to calculate the number of weeks.
 * @param dateLib The date library to use for date manipulation.
 * @returns The number of weeks in the broadcast calendar (4 or 5).
 */
function getBroadcastWeeksInMonth(month, dateLib) {
    // Get the first day of the month
    const firstDayOfMonth = dateLib.startOfMonth(month);
    // Get the day of the week for the first day of the month (1-7, where 1 is Monday)
    const firstDayOfWeek = firstDayOfMonth.getDay() > 0 ? firstDayOfMonth.getDay() : 7;
    const broadcastStartDate = dateLib.addDays(month, -firstDayOfWeek + 1);
    const lastDateOfLastWeek = dateLib.addDays(broadcastStartDate, FIVE_WEEKS * 7 - 1);
    const numberOfWeeks = dateLib.getMonth(month) === dateLib.getMonth(lastDateOfLastWeek)
        ? FIVE_WEEKS
        : FOUR_WEEKS;
    return numberOfWeeks;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getClassNamesForModifiers.d.ts

~~~ts
import type { ClassNames, ModifiersClassNames } from "../types/index.js";
/**
 * Returns the class names for a day based on its modifiers.
 *
 * This function combines the base class name for the day with any class names
 * associated with active modifiers.
 *
 * @param modifiers The modifiers applied to the day.
 * @param classNames The base class names for the calendar elements.
 * @param modifiersClassNames The class names associated with specific
 *   modifiers.
 * @returns An array of class names for the day.
 */
export declare function getClassNamesForModifiers(modifiers: Record<string, boolean>, classNames: ClassNames, modifiersClassNames?: ModifiersClassNames): string[];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getClassNamesForModifiers.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClassNamesForModifiers = getClassNamesForModifiers;
const UI_js_1 = require("../UI.js");
/**
 * Returns the class names for a day based on its modifiers.
 *
 * This function combines the base class name for the day with any class names
 * associated with active modifiers.
 *
 * @param modifiers The modifiers applied to the day.
 * @param classNames The base class names for the calendar elements.
 * @param modifiersClassNames The class names associated with specific
 *   modifiers.
 * @returns An array of class names for the day.
 */
function getClassNamesForModifiers(modifiers, classNames, modifiersClassNames = {}) {
    const modifierClassNames = Object.entries(modifiers)
        .filter(([, active]) => active === true)
        .reduce((previousValue, [key]) => {
        if (modifiersClassNames[key]) {
            previousValue.push(modifiersClassNames[key]);
        }
        else if (classNames[UI_js_1.DayFlag[key]]) {
            previousValue.push(classNames[UI_js_1.DayFlag[key]]);
        }
        else if (classNames[UI_js_1.SelectionState[key]]) {
            previousValue.push(classNames[UI_js_1.SelectionState[key]]);
        }
        return previousValue;
    }, [classNames[UI_js_1.UI.Day]]);
    return modifierClassNames;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getComponents.d.ts

~~~ts
import type { CustomComponents, DayPickerProps } from "../types/index.js";
/**
 * Merges custom components from the props with the default components.
 *
 * This function ensures that any custom components provided in the props
 * override the default components.
 *
 * @param customComponents The custom components provided in the DayPicker
 *   props.
 * @returns An object containing the merged components.
 */
export declare function getComponents(customComponents: DayPickerProps["components"]): CustomComponents;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getComponents.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getComponents = getComponents;
const components = __importStar(require("../components/custom-components.js"));
/**
 * Merges custom components from the props with the default components.
 *
 * This function ensures that any custom components provided in the props
 * override the default components.
 *
 * @param customComponents The custom components provided in the DayPicker
 *   props.
 * @returns An object containing the merged components.
 */
function getComponents(customComponents) {
    return {
        ...components,
        ...customComponents,
    };
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDataAttributes.d.ts

~~~ts
import type { DayPickerProps } from "../types/index.js";
/**
 * Extracts `data-` attributes from the DayPicker props.
 *
 * This function collects all `data-` attributes from the props and adds
 * additional attributes based on the DayPicker configuration.
 *
 * @param props The DayPicker props.
 * @returns An object containing the `data-` attributes.
 */
export declare function getDataAttributes(props: DayPickerProps): Record<string, unknown>;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDataAttributes.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDataAttributes = getDataAttributes;
/**
 * Extracts `data-` attributes from the DayPicker props.
 *
 * This function collects all `data-` attributes from the props and adds
 * additional attributes based on the DayPicker configuration.
 *
 * @param props The DayPicker props.
 * @returns An object containing the `data-` attributes.
 */
function getDataAttributes(props) {
    const dataAttributes = {
        "data-mode": props.mode ?? undefined,
        "data-required": "required" in props ? props.required : undefined,
        "data-multiple-months": (props.numberOfMonths && props.numberOfMonths > 1) || undefined,
        "data-week-numbers": props.showWeekNumber || undefined,
        "data-broadcast-calendar": props.broadcastCalendar || undefined,
        "data-nav-layout": props.navLayout || undefined,
    };
    Object.entries(props).forEach(([key, val]) => {
        if (key.startsWith("data-")) {
            dataAttributes[key] = val;
        }
    });
    return dataAttributes;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDates.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps } from "../types/props.js";
/**
 * Returns all the dates to display in the calendar.
 *
 * This function calculates the range of dates to display based on the provided
 * display months, constraints, and calendar configuration.
 *
 * @param displayMonths The months to display in the calendar.
 * @param maxDate The maximum date to include in the range.
 * @param props The DayPicker props, including calendar configuration options.
 * @param dateLib The date library to use for date manipulation.
 * @returns An array of dates to display in the calendar.
 */
export declare function getDates(displayMonths: Date[], maxDate: Date | undefined, props: Pick<DayPickerProps, "ISOWeek" | "fixedWeeks" | "broadcastCalendar">, dateLib: DateLib): Date[];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDates.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDates = getDates;
/**
 * Returns all the dates to display in the calendar.
 *
 * This function calculates the range of dates to display based on the provided
 * display months, constraints, and calendar configuration.
 *
 * @param displayMonths The months to display in the calendar.
 * @param maxDate The maximum date to include in the range.
 * @param props The DayPicker props, including calendar configuration options.
 * @param dateLib The date library to use for date manipulation.
 * @returns An array of dates to display in the calendar.
 */
function getDates(displayMonths, maxDate, props, dateLib) {
    const firstMonth = displayMonths[0];
    const lastMonth = displayMonths[displayMonths.length - 1];
    const { ISOWeek, fixedWeeks, broadcastCalendar } = props ?? {};
    const { addDays, differenceInCalendarDays, differenceInCalendarMonths, endOfBroadcastWeek, endOfISOWeek, endOfMonth, endOfWeek, isAfter, startOfBroadcastWeek, startOfISOWeek, startOfWeek, } = dateLib;
    const startWeekFirstDate = broadcastCalendar
        ? startOfBroadcastWeek(firstMonth, dateLib)
        : ISOWeek
            ? startOfISOWeek(firstMonth)
            : startOfWeek(firstMonth);
    const endWeekLastDate = broadcastCalendar
        ? endOfBroadcastWeek(lastMonth)
        : ISOWeek
            ? endOfISOWeek(endOfMonth(lastMonth))
            : endOfWeek(endOfMonth(lastMonth));
    const nOfDays = differenceInCalendarDays(endWeekLastDate, startWeekFirstDate);
    const nOfMonths = differenceInCalendarMonths(lastMonth, firstMonth) + 1;
    const dates = [];
    for (let i = 0; i <= nOfDays; i++) {
        const date = addDays(startWeekFirstDate, i);
        if (maxDate && isAfter(date, maxDate)) {
            break;
        }
        dates.push(date);
    }
    // If fixed weeks is enabled, add the extra dates to the array
    const nrOfDaysWithFixedWeeks = broadcastCalendar ? 35 : 42;
    const extraDates = nrOfDaysWithFixedWeeks * nOfMonths;
    if (fixedWeeks && dates.length < extraDates) {
        const daysToAdd = extraDates - dates.length;
        for (let i = 0; i < daysToAdd; i++) {
            const date = addDays(dates[dates.length - 1], 1);
            dates.push(date);
        }
    }
    return dates;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDays.d.ts

~~~ts
import type { CalendarDay, CalendarMonth } from "../classes/index.js";
/**
 * Returns all the days belonging to the calendar by merging the days in the
 * weeks for each month.
 *
 * @param calendarMonths The array of calendar months.
 * @returns An array of `CalendarDay` objects representing all the days in the
 *   calendar.
 */
export declare function getDays(calendarMonths: CalendarMonth[]): CalendarDay[];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDays.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDays = getDays;
/**
 * Returns all the days belonging to the calendar by merging the days in the
 * weeks for each month.
 *
 * @param calendarMonths The array of calendar months.
 * @returns An array of `CalendarDay` objects representing all the days in the
 *   calendar.
 */
function getDays(calendarMonths) {
    const initialDays = [];
    return calendarMonths.reduce((days, month) => {
        const weekDays = month.weeks.reduce((weekDays, week) => {
            return weekDays.concat(week.days.slice());
        }, initialDays.slice());
        return days.concat(weekDays.slice());
    }, initialDays.slice());
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDefaultClassNames.d.ts

~~~ts
import type { ClassNames } from "../types/index.js";
/**
 * Returns the default class names for the UI elements.
 *
 * This function generates a mapping of default class names for various UI
 * elements, day flags, selection states, and animations.
 *
 * @returns An object containing the default class names.
 * @group Utilities
 */
export declare function getDefaultClassNames(): ClassNames;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDefaultClassNames.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDefaultClassNames = getDefaultClassNames;
const UI_js_1 = require("../UI.js");
/**
 * Returns the default class names for the UI elements.
 *
 * This function generates a mapping of default class names for various UI
 * elements, day flags, selection states, and animations.
 *
 * @returns An object containing the default class names.
 * @group Utilities
 */
function getDefaultClassNames() {
    const classNames = {};
    for (const key in UI_js_1.UI) {
        classNames[UI_js_1.UI[key]] =
            `rdp-${UI_js_1.UI[key]}`;
    }
    for (const key in UI_js_1.DayFlag) {
        classNames[UI_js_1.DayFlag[key]] =
            `rdp-${UI_js_1.DayFlag[key]}`;
    }
    for (const key in UI_js_1.SelectionState) {
        classNames[UI_js_1.SelectionState[key]] =
            `rdp-${UI_js_1.SelectionState[key]}`;
    }
    for (const key in UI_js_1.Animation) {
        classNames[UI_js_1.Animation[key]] =
            `rdp-${UI_js_1.Animation[key]}`;
    }
    return classNames;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDisplayMonths.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps } from "../types/index.js";
/**
 * Returns the months to display in the calendar.
 *
 * @param firstDisplayedMonth The first month currently displayed in the
 *   calendar.
 * @param calendarEndMonth The latest month the user can navigate to.
 * @param props The DayPicker props, including `numberOfMonths`.
 * @param dateLib The date library to use for date manipulation.
 * @returns An array of dates representing the months to display.
 */
export declare function getDisplayMonths(firstDisplayedMonth: Date, calendarEndMonth: Date | undefined, props: Pick<DayPickerProps, "numberOfMonths">, dateLib: DateLib): Date[];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getDisplayMonths.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDisplayMonths = getDisplayMonths;
/**
 * Returns the months to display in the calendar.
 *
 * @param firstDisplayedMonth The first month currently displayed in the
 *   calendar.
 * @param calendarEndMonth The latest month the user can navigate to.
 * @param props The DayPicker props, including `numberOfMonths`.
 * @param dateLib The date library to use for date manipulation.
 * @returns An array of dates representing the months to display.
 */
function getDisplayMonths(firstDisplayedMonth, calendarEndMonth, props, dateLib) {
    const { numberOfMonths = 1 } = props;
    const months = [];
    for (let i = 0; i < numberOfMonths; i++) {
        const month = dateLib.addMonths(firstDisplayedMonth, i);
        if (calendarEndMonth && month > calendarEndMonth) {
            break;
        }
        months.push(month);
    }
    return months;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getFocusableDate.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps, MoveFocusBy, MoveFocusDir } from "../types/index.js";
/**
 * Calculates the next date that should be focused in the calendar.
 *
 * This function determines the next focusable date based on the movement
 * direction, constraints, and calendar configuration.
 *
 * @param moveBy The unit of movement (e.g., "day", "week").
 * @param moveDir The direction of movement ("before" or "after").
 * @param refDate The reference date from which to calculate the next focusable
 *   date.
 * @param navStart The earliest date the user can navigate to.
 * @param navEnd The latest date the user can navigate to.
 * @param props The DayPicker props, including calendar configuration options.
 * @param dateLib The date library to use for date manipulation.
 * @returns The next focusable date.
 */
export declare function getFocusableDate(moveBy: MoveFocusBy, moveDir: MoveFocusDir, refDate: Date, navStart: Date | undefined, navEnd: Date | undefined, props: Pick<DayPickerProps, "ISOWeek" | "broadcastCalendar">, dateLib: DateLib): Date;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getFocusableDate.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFocusableDate = getFocusableDate;
/**
 * Calculates the next date that should be focused in the calendar.
 *
 * This function determines the next focusable date based on the movement
 * direction, constraints, and calendar configuration.
 *
 * @param moveBy The unit of movement (e.g., "day", "week").
 * @param moveDir The direction of movement ("before" or "after").
 * @param refDate The reference date from which to calculate the next focusable
 *   date.
 * @param navStart The earliest date the user can navigate to.
 * @param navEnd The latest date the user can navigate to.
 * @param props The DayPicker props, including calendar configuration options.
 * @param dateLib The date library to use for date manipulation.
 * @returns The next focusable date.
 */
function getFocusableDate(moveBy, moveDir, refDate, navStart, navEnd, props, dateLib) {
    const { ISOWeek, broadcastCalendar } = props;
    const { addDays, addMonths, addWeeks, addYears, endOfBroadcastWeek, endOfISOWeek, endOfWeek, max, min, startOfBroadcastWeek, startOfISOWeek, startOfWeek, } = dateLib;
    const moveFns = {
        day: addDays,
        week: addWeeks,
        month: addMonths,
        year: addYears,
        startOfWeek: (date) => broadcastCalendar
            ? startOfBroadcastWeek(date, dateLib)
            : ISOWeek
                ? startOfISOWeek(date)
                : startOfWeek(date),
        endOfWeek: (date) => broadcastCalendar
            ? endOfBroadcastWeek(date)
            : ISOWeek
                ? endOfISOWeek(date)
                : endOfWeek(date),
    };
    let focusableDate = moveFns[moveBy](refDate, moveDir === "after" ? 1 : -1);
    if (moveDir === "before" && navStart) {
        focusableDate = max([navStart, focusableDate]);
    }
    else if (moveDir === "after" && navEnd) {
        focusableDate = min([navEnd, focusableDate]);
    }
    return focusableDate;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getFormatters.d.ts

~~~ts
import * as defaultFormatters from "../formatters/index.js";
import type { DayPickerProps } from "../types/index.js";
/**
 * Merges custom formatters from the props with the default formatters.
 *
 * @param customFormatters The custom formatters provided in the DayPicker
 *   props.
 * @returns The merged formatters object.
 */
export declare function getFormatters(customFormatters: DayPickerProps["formatters"]): {
    formatCaption: typeof defaultFormatters.formatCaption;
    formatDay: typeof defaultFormatters.formatDay;
    formatMonthDropdown: typeof defaultFormatters.formatMonthDropdown;
    formatMonthCaption: typeof defaultFormatters.formatMonthCaption;
    formatWeekNumber: typeof defaultFormatters.formatWeekNumber;
    formatWeekNumberHeader: typeof defaultFormatters.formatWeekNumberHeader;
    formatWeekdayName: typeof defaultFormatters.formatWeekdayName;
    formatYearDropdown: typeof defaultFormatters.formatYearDropdown;
    formatYearCaption: typeof defaultFormatters.formatYearCaption;
};

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getFormatters.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFormatters = getFormatters;
const defaultFormatters = __importStar(require("../formatters/index.js"));
/**
 * Merges custom formatters from the props with the default formatters.
 *
 * @param customFormatters The custom formatters provided in the DayPicker
 *   props.
 * @returns The merged formatters object.
 */
function getFormatters(customFormatters) {
    if (customFormatters?.formatMonthCaption && !customFormatters.formatCaption) {
        customFormatters.formatCaption = customFormatters.formatMonthCaption;
    }
    if (customFormatters?.formatYearCaption &&
        !customFormatters.formatYearDropdown) {
        customFormatters.formatYearDropdown = customFormatters.formatYearCaption;
    }
    return {
        ...defaultFormatters,
        ...customFormatters,
    };
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getInitialMonth.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps } from "../types/props.js";
/**
 * Determines the initial month to display in the calendar based on the provided
 * props.
 *
 * This function calculates the starting month, considering constraints such as
 * `startMonth`, `endMonth`, and the number of months to display.
 *
 * @param props The DayPicker props, including navigation and date constraints.
 * @param dateLib The date library to use for date manipulation.
 * @returns The initial month to display.
 */
export declare function getInitialMonth(props: Pick<DayPickerProps, "fromYear" | "toYear" | "month" | "defaultMonth" | "today" | "numberOfMonths" | "timeZone">, navStart: Date | undefined, navEnd: Date | undefined, dateLib: DateLib): Date;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getInitialMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInitialMonth = getInitialMonth;
/**
 * Determines the initial month to display in the calendar based on the provided
 * props.
 *
 * This function calculates the starting month, considering constraints such as
 * `startMonth`, `endMonth`, and the number of months to display.
 *
 * @param props The DayPicker props, including navigation and date constraints.
 * @param dateLib The date library to use for date manipulation.
 * @returns The initial month to display.
 */
function getInitialMonth(props, navStart, navEnd, dateLib) {
    const { month, defaultMonth, today = dateLib.today(), numberOfMonths = 1, } = props;
    let initialMonth = month || defaultMonth || today;
    const { differenceInCalendarMonths, addMonths, startOfMonth } = dateLib;
    if (navEnd &&
        differenceInCalendarMonths(navEnd, initialMonth) < numberOfMonths - 1) {
        const offset = -1 * (numberOfMonths - 1);
        initialMonth = addMonths(navEnd, offset);
    }
    if (navStart && differenceInCalendarMonths(initialMonth, navStart) < 0) {
        initialMonth = navStart;
    }
    return startOfMonth(initialMonth);
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getLabels.d.ts

~~~ts
import type { DayPickerProps, Labels } from "../types/index.js";
/**
 * Merges custom labels from the props with the default labels.
 *
 * @param customLabels The custom labels provided in the DayPicker props.
 * @returns The merged labels object.
 */
export declare function getLabels(customLabels: DayPickerProps["labels"]): Labels;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getLabels.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLabels = getLabels;
const defaultLabels = __importStar(require("../labels/index.js"));
/**
 * Merges custom labels from the props with the default labels.
 *
 * @param customLabels The custom labels provided in the DayPicker props.
 * @returns The merged labels object.
 */
function getLabels(customLabels) {
    return {
        ...defaultLabels,
        ...customLabels,
    };
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getMonthOptions.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DropdownOption } from "../components/Dropdown.js";
import type { Formatters } from "../types/index.js";
/**
 * Returns the months to show in the dropdown.
 *
 * This function generates a list of months for the current year, formatted
 * using the provided formatter, and determines whether each month should be
 * disabled based on the navigation range.
 *
 * @param displayMonth The currently displayed month.
 * @param navStart The start date for navigation.
 * @param navEnd The end date for navigation.
 * @param formatters The formatters to use for formatting the month labels.
 * @param dateLib The date library to use for date manipulation.
 * @returns An array of dropdown options representing the months, or `undefined`
 *   if no months are available.
 */
export declare function getMonthOptions(displayMonth: Date, navStart: Date | undefined, navEnd: Date | undefined, formatters: Pick<Formatters, "formatMonthDropdown">, dateLib: DateLib): DropdownOption[] | undefined;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getMonthOptions.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMonthOptions = getMonthOptions;
/**
 * Returns the months to show in the dropdown.
 *
 * This function generates a list of months for the current year, formatted
 * using the provided formatter, and determines whether each month should be
 * disabled based on the navigation range.
 *
 * @param displayMonth The currently displayed month.
 * @param navStart The start date for navigation.
 * @param navEnd The end date for navigation.
 * @param formatters The formatters to use for formatting the month labels.
 * @param dateLib The date library to use for date manipulation.
 * @returns An array of dropdown options representing the months, or `undefined`
 *   if no months are available.
 */
function getMonthOptions(displayMonth, navStart, navEnd, formatters, dateLib) {
    const { startOfMonth, startOfYear, endOfYear, eachMonthOfInterval, getMonth, } = dateLib;
    const months = eachMonthOfInterval({
        start: startOfYear(displayMonth),
        end: endOfYear(displayMonth),
    });
    const options = months.map((month) => {
        const label = formatters.formatMonthDropdown(month, dateLib);
        const value = getMonth(month);
        const disabled = (navStart && month < startOfMonth(navStart)) ||
            (navEnd && month > startOfMonth(navEnd)) ||
            false;
        return { value, label, disabled };
    });
    return options;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getMonths.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import { CalendarMonth } from "../classes/index.js";
import type { DayPickerProps } from "../types/index.js";
/**
 * Returns the months to display in the calendar.
 *
 * This function generates `CalendarMonth` objects for each month to be
 * displayed, including their weeks and days, based on the provided display
 * months and dates.
 *
 * @param displayMonths The months (as dates) to display in the calendar.
 * @param dates The dates to display in the calendar.
 * @param props Options from the DayPicker props context.
 * @param dateLib The date library to use for date manipulation.
 * @returns An array of `CalendarMonth` objects representing the months to
 *   display.
 */
export declare function getMonths(displayMonths: Date[], dates: Date[], props: Pick<DayPickerProps, "broadcastCalendar" | "fixedWeeks" | "ISOWeek" | "reverseMonths">, dateLib: DateLib): CalendarMonth[];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getMonths.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMonths = getMonths;
const index_js_1 = require("../classes/index.js");
/**
 * Returns the months to display in the calendar.
 *
 * This function generates `CalendarMonth` objects for each month to be
 * displayed, including their weeks and days, based on the provided display
 * months and dates.
 *
 * @param displayMonths The months (as dates) to display in the calendar.
 * @param dates The dates to display in the calendar.
 * @param props Options from the DayPicker props context.
 * @param dateLib The date library to use for date manipulation.
 * @returns An array of `CalendarMonth` objects representing the months to
 *   display.
 */
function getMonths(displayMonths, dates, props, dateLib) {
    const { addDays, endOfBroadcastWeek, endOfISOWeek, endOfMonth, endOfWeek, getISOWeek, getWeek, startOfBroadcastWeek, startOfISOWeek, startOfWeek, } = dateLib;
    const dayPickerMonths = displayMonths.reduce((months, month) => {
        const firstDateOfFirstWeek = props.broadcastCalendar
            ? startOfBroadcastWeek(month, dateLib)
            : props.ISOWeek
                ? startOfISOWeek(month)
                : startOfWeek(month);
        const lastDateOfLastWeek = props.broadcastCalendar
            ? endOfBroadcastWeek(month)
            : props.ISOWeek
                ? endOfISOWeek(endOfMonth(month))
                : endOfWeek(endOfMonth(month));
        /** The dates to display in the month. */
        const monthDates = dates.filter((date) => {
            return date >= firstDateOfFirstWeek && date <= lastDateOfLastWeek;
        });
        const nrOfDaysWithFixedWeeks = props.broadcastCalendar ? 35 : 42;
        if (props.fixedWeeks && monthDates.length < nrOfDaysWithFixedWeeks) {
            const extraDates = dates.filter((date) => {
                const daysToAdd = nrOfDaysWithFixedWeeks - monthDates.length;
                return (date > lastDateOfLastWeek &&
                    date <= addDays(lastDateOfLastWeek, daysToAdd));
            });
            monthDates.push(...extraDates);
        }
        const weeks = monthDates.reduce((weeks, date) => {
            const weekNumber = props.ISOWeek ? getISOWeek(date) : getWeek(date);
            const week = weeks.find((week) => week.weekNumber === weekNumber);
            const day = new index_js_1.CalendarDay(date, month, dateLib);
            if (!week) {
                weeks.push(new index_js_1.CalendarWeek(weekNumber, [day]));
            }
            else {
                week.days.push(day);
            }
            return weeks;
        }, []);
        const dayPickerMonth = new index_js_1.CalendarMonth(month, weeks);
        months.push(dayPickerMonth);
        return months;
    }, []);
    if (!props.reverseMonths) {
        return dayPickerMonths;
    }
    else {
        return dayPickerMonths.reverse();
    }
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getNavMonth.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps } from "../types/index.js";
/**
 * Returns the start and end months for calendar navigation.
 *
 * @param props The DayPicker props, including navigation and layout options.
 * @param dateLib The date library to use for date manipulation.
 * @returns A tuple containing the start and end months for navigation.
 */
export declare function getNavMonths(props: Pick<DayPickerProps, "captionLayout" | "endMonth" | "startMonth" | "today" | "timeZone" | "fromMonth" | "fromYear" | "toMonth" | "toYear">, dateLib: DateLib): [start: Date | undefined, end: Date | undefined];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getNavMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNavMonths = getNavMonths;
/**
 * Returns the start and end months for calendar navigation.
 *
 * @param props The DayPicker props, including navigation and layout options.
 * @param dateLib The date library to use for date manipulation.
 * @returns A tuple containing the start and end months for navigation.
 */
function getNavMonths(props, dateLib) {
    let { startMonth, endMonth } = props;
    const { startOfYear, startOfDay, startOfMonth, endOfMonth, addYears, endOfYear, newDate, today, } = dateLib;
    // Handle deprecated code
    const { fromYear, toYear, fromMonth, toMonth } = props;
    if (!startMonth && fromMonth) {
        startMonth = fromMonth;
    }
    if (!startMonth && fromYear) {
        startMonth = dateLib.newDate(fromYear, 0, 1);
    }
    if (!endMonth && toMonth) {
        endMonth = toMonth;
    }
    if (!endMonth && toYear) {
        endMonth = newDate(toYear, 11, 31);
    }
    const hasYearDropdown = props.captionLayout === "dropdown" ||
        props.captionLayout === "dropdown-years";
    if (startMonth) {
        startMonth = startOfMonth(startMonth);
    }
    else if (fromYear) {
        startMonth = newDate(fromYear, 0, 1);
    }
    else if (!startMonth && hasYearDropdown) {
        startMonth = startOfYear(addYears(props.today ?? today(), -100));
    }
    if (endMonth) {
        endMonth = endOfMonth(endMonth);
    }
    else if (toYear) {
        endMonth = newDate(toYear, 11, 31);
    }
    else if (!endMonth && hasYearDropdown) {
        endMonth = endOfYear(props.today ?? today());
    }
    return [
        startMonth ? startOfDay(startMonth) : startMonth,
        endMonth ? startOfDay(endMonth) : endMonth,
    ];
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getNextFocus.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import { CalendarDay } from "../classes/index.js";
import type { DayPickerProps, MoveFocusBy, MoveFocusDir } from "../types/index.js";
/**
 * Determines the next focusable day in the calendar.
 *
 * This function recursively calculates the next focusable day based on the
 * movement direction and modifiers applied to the days.
 *
 * @param moveBy The unit of movement (e.g., "day", "week").
 * @param moveDir The direction of movement ("before" or "after").
 * @param refDay The currently focused day.
 * @param calendarStartMonth The earliest month the user can navigate to.
 * @param calendarEndMonth The latest month the user can navigate to.
 * @param props The DayPicker props, including modifiers and configuration
 *   options.
 * @param dateLib The date library to use for date manipulation.
 * @param attempt The current recursion attempt (used to limit recursion depth).
 * @returns The next focusable day, or `undefined` if no focusable day is found.
 */
export declare function getNextFocus(moveBy: MoveFocusBy, moveDir: MoveFocusDir, refDay: CalendarDay, calendarStartMonth: Date | undefined, calendarEndMonth: Date | undefined, props: Pick<DayPickerProps, "disabled" | "hidden" | "modifiers" | "ISOWeek" | "timeZone">, dateLib: DateLib, attempt?: number): CalendarDay | undefined;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getNextFocus.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextFocus = getNextFocus;
const index_js_1 = require("../classes/index.js");
const dateMatchModifiers_js_1 = require("../utils/dateMatchModifiers.js");
const getFocusableDate_js_1 = require("./getFocusableDate.js");
/**
 * Determines the next focusable day in the calendar.
 *
 * This function recursively calculates the next focusable day based on the
 * movement direction and modifiers applied to the days.
 *
 * @param moveBy The unit of movement (e.g., "day", "week").
 * @param moveDir The direction of movement ("before" or "after").
 * @param refDay The currently focused day.
 * @param calendarStartMonth The earliest month the user can navigate to.
 * @param calendarEndMonth The latest month the user can navigate to.
 * @param props The DayPicker props, including modifiers and configuration
 *   options.
 * @param dateLib The date library to use for date manipulation.
 * @param attempt The current recursion attempt (used to limit recursion depth).
 * @returns The next focusable day, or `undefined` if no focusable day is found.
 */
function getNextFocus(moveBy, moveDir, refDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt = 0) {
    if (attempt > 365) {
        // Limit the recursion to 365 attempts
        return undefined;
    }
    const focusableDate = (0, getFocusableDate_js_1.getFocusableDate)(moveBy, moveDir, refDay.date, calendarStartMonth, calendarEndMonth, props, dateLib);
    const isDisabled = Boolean(props.disabled &&
        (0, dateMatchModifiers_js_1.dateMatchModifiers)(focusableDate, props.disabled, dateLib));
    const isHidden = Boolean(props.hidden && (0, dateMatchModifiers_js_1.dateMatchModifiers)(focusableDate, props.hidden, dateLib));
    const targetMonth = focusableDate;
    const focusDay = new index_js_1.CalendarDay(focusableDate, targetMonth, dateLib);
    if (!isDisabled && !isHidden) {
        return focusDay;
    }
    // Recursively attempt to find the next focusable date
    return getNextFocus(moveBy, moveDir, focusDay, calendarStartMonth, calendarEndMonth, props, dateLib, attempt + 1);
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getNextMonth.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps } from "../types/index.js";
/**
 * Returns the next month the user can navigate to, based on the given options.
 *
 * The next month is not always the next calendar month:
 *
 * - If it is after the `calendarEndMonth`, it returns `undefined`.
 * - If paged navigation is enabled, it skips forward by the number of displayed
 *   months.
 *
 * @param firstDisplayedMonth The first month currently displayed in the
 *   calendar.
 * @param calendarEndMonth The latest month the user can navigate to.
 * @param options Navigation options, including `numberOfMonths` and
 *   `pagedNavigation`.
 * @param dateLib The date library to use for date manipulation.
 * @returns The next month, or `undefined` if navigation is not possible.
 */
export declare function getNextMonth(firstDisplayedMonth: Date, calendarEndMonth: Date | undefined, options: Pick<DayPickerProps, "numberOfMonths" | "pagedNavigation" | "disableNavigation">, dateLib: DateLib): Date | undefined;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getNextMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNextMonth = getNextMonth;
/**
 * Returns the next month the user can navigate to, based on the given options.
 *
 * The next month is not always the next calendar month:
 *
 * - If it is after the `calendarEndMonth`, it returns `undefined`.
 * - If paged navigation is enabled, it skips forward by the number of displayed
 *   months.
 *
 * @param firstDisplayedMonth The first month currently displayed in the
 *   calendar.
 * @param calendarEndMonth The latest month the user can navigate to.
 * @param options Navigation options, including `numberOfMonths` and
 *   `pagedNavigation`.
 * @param dateLib The date library to use for date manipulation.
 * @returns The next month, or `undefined` if navigation is not possible.
 */
function getNextMonth(firstDisplayedMonth, calendarEndMonth, options, dateLib) {
    if (options.disableNavigation) {
        return undefined;
    }
    const { pagedNavigation, numberOfMonths = 1 } = options;
    const { startOfMonth, addMonths, differenceInCalendarMonths } = dateLib;
    const offset = pagedNavigation ? numberOfMonths : 1;
    const month = startOfMonth(firstDisplayedMonth);
    if (!calendarEndMonth) {
        return addMonths(month, offset);
    }
    const monthsDiff = differenceInCalendarMonths(calendarEndMonth, firstDisplayedMonth);
    if (monthsDiff < numberOfMonths) {
        return undefined;
    }
    return addMonths(month, offset);
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getPreviousMonth.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps } from "../types/index.js";
/**
 * Returns the previous month the user can navigate to, based on the given
 * options.
 *
 * The previous month is not always the previous calendar month:
 *
 * - If it is before the `calendarStartMonth`, it returns `undefined`.
 * - If paged navigation is enabled, it skips back by the number of displayed
 *   months.
 *
 * @param firstDisplayedMonth The first month currently displayed in the
 *   calendar.
 * @param calendarStartMonth The earliest month the user can navigate to.
 * @param options Navigation options, including `numberOfMonths` and
 *   `pagedNavigation`.
 * @param dateLib The date library to use for date manipulation.
 * @returns The previous month, or `undefined` if navigation is not possible.
 */
export declare function getPreviousMonth(firstDisplayedMonth: Date, calendarStartMonth: Date | undefined, options: Pick<DayPickerProps, "numberOfMonths" | "pagedNavigation" | "disableNavigation">, dateLib: DateLib): Date | undefined;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getPreviousMonth.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPreviousMonth = getPreviousMonth;
/**
 * Returns the previous month the user can navigate to, based on the given
 * options.
 *
 * The previous month is not always the previous calendar month:
 *
 * - If it is before the `calendarStartMonth`, it returns `undefined`.
 * - If paged navigation is enabled, it skips back by the number of displayed
 *   months.
 *
 * @param firstDisplayedMonth The first month currently displayed in the
 *   calendar.
 * @param calendarStartMonth The earliest month the user can navigate to.
 * @param options Navigation options, including `numberOfMonths` and
 *   `pagedNavigation`.
 * @param dateLib The date library to use for date manipulation.
 * @returns The previous month, or `undefined` if navigation is not possible.
 */
function getPreviousMonth(firstDisplayedMonth, calendarStartMonth, options, dateLib) {
    if (options.disableNavigation) {
        return undefined;
    }
    const { pagedNavigation, numberOfMonths } = options;
    const { startOfMonth, addMonths, differenceInCalendarMonths } = dateLib;
    const offset = pagedNavigation ? (numberOfMonths ?? 1) : 1;
    const month = startOfMonth(firstDisplayedMonth);
    if (!calendarStartMonth) {
        return addMonths(month, -offset);
    }
    const monthsDiff = differenceInCalendarMonths(month, calendarStartMonth);
    if (monthsDiff <= 0) {
        return undefined;
    }
    return addMonths(month, -offset);
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getStyleForModifiers.d.ts

~~~ts
import type { CSSProperties } from "react";
import type { Modifiers, ModifiersStyles, Styles } from "../types/index.js";
/**
 * Returns the computed style for a day based on its modifiers.
 *
 * This function merges the base styles for the day with any styles associated
 * with active modifiers.
 *
 * @param dayModifiers The modifiers applied to the day.
 * @param styles The base styles for the calendar elements.
 * @param modifiersStyles The styles associated with specific modifiers.
 * @returns The computed style for the day.
 */
export declare function getStyleForModifiers(dayModifiers: Modifiers, styles?: Partial<Styles>, modifiersStyles?: Partial<ModifiersStyles>): CSSProperties;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getStyleForModifiers.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStyleForModifiers = getStyleForModifiers;
const UI_js_1 = require("../UI.js");
/**
 * Returns the computed style for a day based on its modifiers.
 *
 * This function merges the base styles for the day with any styles associated
 * with active modifiers.
 *
 * @param dayModifiers The modifiers applied to the day.
 * @param styles The base styles for the calendar elements.
 * @param modifiersStyles The styles associated with specific modifiers.
 * @returns The computed style for the day.
 */
function getStyleForModifiers(dayModifiers, styles = {}, modifiersStyles = {}) {
    let style = { ...styles?.[UI_js_1.UI.Day] };
    Object.entries(dayModifiers)
        .filter(([, active]) => active === true)
        .forEach(([modifier]) => {
        style = {
            ...style,
            ...modifiersStyles?.[modifier],
        };
    });
    return style;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getWeekdays.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
/**
 * Generates a series of 7 days, starting from the beginning of the week, to use
 * for formatting weekday names (e.g., Monday, Tuesday, etc.).
 *
 * @param dateLib The date library to use for date manipulation.
 * @param ISOWeek Whether to use ISO week numbering (weeks start on Monday).
 * @param broadcastCalendar Whether to use the broadcast calendar (weeks start
 *   on Monday, but may include adjustments for broadcast-specific rules).
 * @returns An array of 7 dates representing the weekdays.
 */
export declare function getWeekdays(dateLib: DateLib, ISOWeek?: boolean | undefined, broadcastCalendar?: boolean | undefined): Date[];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getWeekdays.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWeekdays = getWeekdays;
/**
 * Generates a series of 7 days, starting from the beginning of the week, to use
 * for formatting weekday names (e.g., Monday, Tuesday, etc.).
 *
 * @param dateLib The date library to use for date manipulation.
 * @param ISOWeek Whether to use ISO week numbering (weeks start on Monday).
 * @param broadcastCalendar Whether to use the broadcast calendar (weeks start
 *   on Monday, but may include adjustments for broadcast-specific rules).
 * @returns An array of 7 dates representing the weekdays.
 */
function getWeekdays(dateLib, ISOWeek, broadcastCalendar) {
    const today = dateLib.today();
    const start = broadcastCalendar
        ? dateLib.startOfBroadcastWeek(today, dateLib)
        : ISOWeek
            ? dateLib.startOfISOWeek(today)
            : dateLib.startOfWeek(today);
    const days = [];
    for (let i = 0; i < 7; i++) {
        const day = dateLib.addDays(start, i);
        days.push(day);
    }
    return days;
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getWeeks.d.ts

~~~ts
import type { CalendarMonth, CalendarWeek } from "../classes/index.js";
/**
 * Returns an array of calendar weeks from an array of calendar months.
 *
 * @param months The array of calendar months.
 * @returns An array of calendar weeks.
 */
export declare function getWeeks(months: CalendarMonth[]): CalendarWeek[];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getWeeks.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWeeks = getWeeks;
/**
 * Returns an array of calendar weeks from an array of calendar months.
 *
 * @param months The array of calendar months.
 * @returns An array of calendar weeks.
 */
function getWeeks(months) {
    const initialWeeks = [];
    return months.reduce((weeks, month) => {
        return weeks.concat(month.weeks.slice());
    }, initialWeeks.slice());
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getYearOptions.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DropdownOption } from "../components/Dropdown.js";
import type { Formatters } from "../types/index.js";
/**
 * Returns the years to display in the dropdown.
 *
 * This function generates a list of years between the navigation start and end
 * dates, formatted using the provided formatter.
 *
 * @param navStart The start date for navigation.
 * @param navEnd The end date for navigation.
 * @param formatters The formatters to use for formatting the year labels.
 * @param dateLib The date library to use for date manipulation.
 * @param reverse If true, reverses the order of the years (descending).
 * @returns An array of dropdown options representing the years, or `undefined`
 *   if `navStart` or `navEnd` is not provided.
 */
export declare function getYearOptions(navStart: Date | undefined, navEnd: Date | undefined, formatters: Pick<Formatters, "formatYearDropdown">, dateLib: DateLib, reverse?: boolean): DropdownOption[] | undefined;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\getYearOptions.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getYearOptions = getYearOptions;
/**
 * Returns the years to display in the dropdown.
 *
 * This function generates a list of years between the navigation start and end
 * dates, formatted using the provided formatter.
 *
 * @param navStart The start date for navigation.
 * @param navEnd The end date for navigation.
 * @param formatters The formatters to use for formatting the year labels.
 * @param dateLib The date library to use for date manipulation.
 * @param reverse If true, reverses the order of the years (descending).
 * @returns An array of dropdown options representing the years, or `undefined`
 *   if `navStart` or `navEnd` is not provided.
 */
function getYearOptions(navStart, navEnd, formatters, dateLib, reverse = false) {
    if (!navStart)
        return undefined;
    if (!navEnd)
        return undefined;
    const { startOfYear, endOfYear, eachYearOfInterval, getYear } = dateLib;
    const firstNavYear = startOfYear(navStart);
    const lastNavYear = endOfYear(navEnd);
    const years = eachYearOfInterval({ start: firstNavYear, end: lastNavYear });
    if (reverse)
        years.reverse();
    return years.map((year) => {
        const label = formatters.formatYearDropdown(year, dateLib);
        return {
            value: getYear(year),
            label,
            disabled: false,
        };
    });
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\index.d.ts

~~~ts
export * from "./getDefaultClassNames.js";

~~~

## node_modules\react-day-picker\dist\cjs\helpers\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
// Only export helpers that can be useful to other developers.
__exportStar(require("./getDefaultClassNames.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\helpers\startOfBroadcastWeek.d.ts

~~~ts
import type { DateLib } from "../classes/index.js";
/**
 * Returns the start date of the week in the broadcast calendar.
 *
 * The broadcast week starts on Monday. If the first day of the month is not a
 * Monday, this function calculates the previous Monday as the start of the
 * broadcast week.
 *
 * @since 9.4.0
 * @param date The date for which to calculate the start of the broadcast week.
 * @param dateLib The date library to use for date manipulation.
 * @returns The start date of the broadcast week.
 */
export declare function startOfBroadcastWeek(date: Date, dateLib: DateLib): Date;

~~~

## node_modules\react-day-picker\dist\cjs\helpers\startOfBroadcastWeek.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startOfBroadcastWeek = startOfBroadcastWeek;
/**
 * Returns the start date of the week in the broadcast calendar.
 *
 * The broadcast week starts on Monday. If the first day of the month is not a
 * Monday, this function calculates the previous Monday as the start of the
 * broadcast week.
 *
 * @since 9.4.0
 * @param date The date for which to calculate the start of the broadcast week.
 * @param dateLib The date library to use for date manipulation.
 * @returns The start date of the broadcast week.
 */
function startOfBroadcastWeek(date, dateLib) {
    const firstOfMonth = dateLib.startOfMonth(date);
    const dayOfWeek = firstOfMonth.getDay();
    if (dayOfWeek === 1) {
        return firstOfMonth;
    }
    else if (dayOfWeek === 0) {
        return dateLib.addDays(firstOfMonth, -1 * 6);
    }
    else {
        return dateLib.addDays(firstOfMonth, -1 * (dayOfWeek - 1));
    }
}

~~~

## node_modules\react-day-picker\dist\cjs\helpers\useControlledValue.d.ts

~~~ts
export type DispatchStateAction<T> = React.Dispatch<React.SetStateAction<T>>;
/**
 * A custom hook for managing both controlled and uncontrolled component states.
 *
 * This hook allows a component to support both controlled and uncontrolled
 * states by determining whether the `controlledValue` is provided. If it is
 * undefined, the hook falls back to using the internal state.
 *
 * @example
 *   // Uncontrolled usage
 *   const [value, setValue] = useControlledValue(0, undefined);
 *
 *   // Controlled usage
 *   const [value, setValue] = useControlledValue(0, props.value);
 *
 * @template T - The type of the value.
 * @param defaultValue The initial value for the uncontrolled state.
 * @param controlledValue The value for the controlled state. If undefined, the
 *   component will use the uncontrolled state.
 * @returns A tuple where the first element is the current value (either
 *   controlled or uncontrolled) and the second element is a setter function to
 *   update the value.
 */
export declare function useControlledValue<T>(defaultValue: T, controlledValue: T | undefined): [T, DispatchStateAction<T>];

~~~

## node_modules\react-day-picker\dist\cjs\helpers\useControlledValue.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useControlledValue = useControlledValue;
const react_1 = require("react");
/**
 * A custom hook for managing both controlled and uncontrolled component states.
 *
 * This hook allows a component to support both controlled and uncontrolled
 * states by determining whether the `controlledValue` is provided. If it is
 * undefined, the hook falls back to using the internal state.
 *
 * @example
 *   // Uncontrolled usage
 *   const [value, setValue] = useControlledValue(0, undefined);
 *
 *   // Controlled usage
 *   const [value, setValue] = useControlledValue(0, props.value);
 *
 * @template T - The type of the value.
 * @param defaultValue The initial value for the uncontrolled state.
 * @param controlledValue The value for the controlled state. If undefined, the
 *   component will use the uncontrolled state.
 * @returns A tuple where the first element is the current value (either
 *   controlled or uncontrolled) and the second element is a setter function to
 *   update the value.
 */
function useControlledValue(defaultValue, controlledValue) {
    const [uncontrolledValue, setValue] = (0, react_1.useState)(defaultValue);
    const value = controlledValue === undefined ? uncontrolledValue : controlledValue;
    return [value, setValue];
}

~~~

## node_modules\react-day-picker\dist\cjs\index.d.ts

~~~ts
export { TZDate } from "@date-fns/tz";
export * from "./classes/index.js";
export * from "./components/custom-components.js";
export * from "./DayPicker.js";
export * from "./formatters/index.js";
export * from "./helpers/index.js";
export * from "./labels/index.js";
export * from "./types/index.js";
export * from "./UI.js";
export * from "./useDayPicker.js";
export * from "./utils/index.js";

~~~

## node_modules\react-day-picker\dist\cjs\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TZDate = void 0;
var tz_1 = require("@date-fns/tz");
Object.defineProperty(exports, "TZDate", { enumerable: true, get: function () { return tz_1.TZDate; } });
__exportStar(require("./classes/index.js"), exports);
__exportStar(require("./components/custom-components.js"), exports);
__exportStar(require("./DayPicker.js"), exports);
__exportStar(require("./formatters/index.js"), exports);
__exportStar(require("./helpers/index.js"), exports);
__exportStar(require("./labels/index.js"), exports);
__exportStar(require("./types/index.js"), exports);
__exportStar(require("./UI.js"), exports);
__exportStar(require("./useDayPicker.js"), exports);
__exportStar(require("./utils/index.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\jalali.d.ts

~~~ts
/** @deprecated Import from `react-day-picker/persian` instead. */
export * from "./persian.js";

~~~

## node_modules\react-day-picker\dist\cjs\jalali.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
/** @deprecated Import from `react-day-picker/persian` instead. */
__exportStar(require("./persian.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\labels\index.d.ts

~~~ts
export * from "./labelDayButton.js";
export * from "./labelGrid.js";
export * from "./labelGrid.js";
export * from "./labelGridcell.js";
export * from "./labelMonthDropdown.js";
export * from "./labelNav.js";
export * from "./labelNext.js";
export * from "./labelPrevious.js";
export * from "./labelWeekday.js";
export * from "./labelWeekNumber.js";
export * from "./labelWeekNumberHeader.js";
export * from "./labelYearDropdown.js";

~~~

## node_modules\react-day-picker\dist\cjs\labels\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./labelDayButton.js"), exports);
__exportStar(require("./labelGrid.js"), exports);
__exportStar(require("./labelGrid.js"), exports);
__exportStar(require("./labelGridcell.js"), exports);
__exportStar(require("./labelMonthDropdown.js"), exports);
__exportStar(require("./labelNav.js"), exports);
__exportStar(require("./labelNext.js"), exports);
__exportStar(require("./labelPrevious.js"), exports);
__exportStar(require("./labelWeekday.js"), exports);
__exportStar(require("./labelWeekNumber.js"), exports);
__exportStar(require("./labelWeekNumberHeader.js"), exports);
__exportStar(require("./labelYearDropdown.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelDayButton.d.ts

~~~ts
import { DateLib, type DateLibOptions } from "../classes/DateLib.js";
import type { Modifiers } from "../types/index.js";
/**
 * Generates the ARIA label for a day button.
 *
 * Use the `modifiers` argument to provide additional context for the label,
 * such as indicating if the day is "today" or "selected."
 *
 * @defaultValue The formatted date.
 * @param date - The date to format.
 * @param modifiers - The modifiers providing context for the day.
 * @param options - Optional configuration for the date formatting library.
 * @param dateLib - An optional instance of the date formatting library.
 * @returns The ARIA label for the day button.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelDayButton(date: Date, modifiers: Modifiers, options?: DateLibOptions, dateLib?: DateLib): string;
/**
 * @ignore
 * @deprecated Use `labelDayButton` instead.
 */
export declare const labelDay: typeof labelDayButton;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelDayButton.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelDay = void 0;
exports.labelDayButton = labelDayButton;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Generates the ARIA label for a day button.
 *
 * Use the `modifiers` argument to provide additional context for the label,
 * such as indicating if the day is "today" or "selected."
 *
 * @defaultValue The formatted date.
 * @param date - The date to format.
 * @param modifiers - The modifiers providing context for the day.
 * @param options - Optional configuration for the date formatting library.
 * @param dateLib - An optional instance of the date formatting library.
 * @returns The ARIA label for the day button.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelDayButton(date, modifiers, options, dateLib) {
    let label = (dateLib ?? new DateLib_js_1.DateLib(options)).format(date, "PPPP");
    if (modifiers.today)
        label = `Today, ${label}`;
    if (modifiers.selected)
        label = `${label}, selected`;
    return label;
}
/**
 * @ignore
 * @deprecated Use `labelDayButton` instead.
 */
exports.labelDay = labelDayButton;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelGrid.d.ts

~~~ts
import { DateLib, type DateLibOptions } from "../classes/DateLib.js";
/**
 * Generates the ARIA label for the month grid, which is announced when entering
 * the grid.
 *
 * @defaultValue Locale-specific month/year order (e.g., "November 2022").
 * @param date - The date representing the month.
 * @param options - Optional configuration for the date formatting library.
 * @param dateLib - An optional instance of the date formatting library.
 * @returns The ARIA label for the month grid.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelGrid(date: Date, options?: DateLibOptions, dateLib?: DateLib): string;
/**
 * @ignore
 * @deprecated Use {@link labelGrid} instead.
 */
export declare const labelCaption: typeof labelGrid;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelGrid.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelCaption = void 0;
exports.labelGrid = labelGrid;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Generates the ARIA label for the month grid, which is announced when entering
 * the grid.
 *
 * @defaultValue Locale-specific month/year order (e.g., "November 2022").
 * @param date - The date representing the month.
 * @param options - Optional configuration for the date formatting library.
 * @param dateLib - An optional instance of the date formatting library.
 * @returns The ARIA label for the month grid.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelGrid(date, options, dateLib) {
    const lib = dateLib ?? new DateLib_js_1.DateLib(options);
    return lib.formatMonthYear(date);
}
/**
 * @ignore
 * @deprecated Use {@link labelGrid} instead.
 */
exports.labelCaption = labelGrid;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelGridcell.d.ts

~~~ts
import { DateLib, type DateLibOptions } from "../classes/DateLib.js";
import type { Modifiers } from "../types/index.js";
/**
 * Generates the label for a day grid cell when the calendar is not interactive.
 *
 * @param date - The date to format.
 * @param modifiers - Optional modifiers providing context for the day.
 * @param options - Optional configuration for the date formatting library.
 * @param dateLib - An optional instance of the date formatting library.
 * @returns The label for the day grid cell.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelGridcell(date: Date, modifiers?: Modifiers, options?: DateLibOptions, dateLib?: DateLib): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelGridcell.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelGridcell = labelGridcell;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Generates the label for a day grid cell when the calendar is not interactive.
 *
 * @param date - The date to format.
 * @param modifiers - Optional modifiers providing context for the day.
 * @param options - Optional configuration for the date formatting library.
 * @param dateLib - An optional instance of the date formatting library.
 * @returns The label for the day grid cell.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelGridcell(date, modifiers, options, dateLib) {
    let label = (dateLib ?? new DateLib_js_1.DateLib(options)).format(date, "PPPP");
    if (modifiers?.today) {
        label = `Today, ${label}`;
    }
    return label;
}

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelMonthDropdown.d.ts

~~~ts
import type { DateLibOptions } from "../classes/DateLib.js";
/**
 * Generates the ARIA label for the months dropdown.
 *
 * @defaultValue `"Choose the Month"`
 * @param options - Optional configuration for the date formatting library.
 * @returns The ARIA label for the months dropdown.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelMonthDropdown(_options?: DateLibOptions): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelMonthDropdown.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelMonthDropdown = labelMonthDropdown;
/**
 * Generates the ARIA label for the months dropdown.
 *
 * @defaultValue `"Choose the Month"`
 * @param options - Optional configuration for the date formatting library.
 * @returns The ARIA label for the months dropdown.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelMonthDropdown(_options) {
    return "Choose the Month";
}

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelNav.d.ts

~~~ts
/**
 * Generates the ARIA label for the navigation toolbar.
 *
 * @defaultValue `""`
 * @returns The ARIA label for the navigation toolbar.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelNav(): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelNav.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelNav = labelNav;
/**
 * Generates the ARIA label for the navigation toolbar.
 *
 * @defaultValue `""`
 * @returns The ARIA label for the navigation toolbar.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelNav() {
    return "";
}

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelNext.d.ts

~~~ts
/**
 * Generates the ARIA label for the "next month" button.
 *
 * @defaultValue `"Go to the Next Month"`
 * @param month - The date representing the next month, or `undefined` if there
 *   is no next month.
 * @returns The ARIA label for the "next month" button.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelNext(_month: Date | undefined): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelNext.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelNext = labelNext;
/**
 * Generates the ARIA label for the "next month" button.
 *
 * @defaultValue `"Go to the Next Month"`
 * @param month - The date representing the next month, or `undefined` if there
 *   is no next month.
 * @returns The ARIA label for the "next month" button.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelNext(_month) {
    return "Go to the Next Month";
}

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelPrevious.d.ts

~~~ts
/**
 * Generates the ARIA label for the "previous month" button.
 *
 * @defaultValue `"Go to the Previous Month"`
 * @param month - The date representing the previous month, or `undefined` if
 *   there is no previous month.
 * @returns The ARIA label for the "previous month" button.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelPrevious(_month: Date | undefined): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelPrevious.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelPrevious = labelPrevious;
/**
 * Generates the ARIA label for the "previous month" button.
 *
 * @defaultValue `"Go to the Previous Month"`
 * @param month - The date representing the previous month, or `undefined` if
 *   there is no previous month.
 * @returns The ARIA label for the "previous month" button.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelPrevious(_month) {
    return "Go to the Previous Month";
}

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelWeekday.d.ts

~~~ts
import { DateLib, type DateLibOptions } from "../classes/DateLib.js";
/**
 * Generates the ARIA label for a weekday column header.
 *
 * @defaultValue `"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"`
 * @param date - The date representing the weekday.
 * @param options - Optional configuration for the date formatting library.
 * @param dateLib - An optional instance of the date formatting library.
 * @returns The ARIA label for the weekday column header.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelWeekday(date: Date, options?: DateLibOptions, dateLib?: DateLib): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelWeekday.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelWeekday = labelWeekday;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Generates the ARIA label for a weekday column header.
 *
 * @defaultValue `"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"`
 * @param date - The date representing the weekday.
 * @param options - Optional configuration for the date formatting library.
 * @param dateLib - An optional instance of the date formatting library.
 * @returns The ARIA label for the weekday column header.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelWeekday(date, options, dateLib) {
    return (dateLib ?? new DateLib_js_1.DateLib(options)).format(date, "cccc");
}

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelWeekNumber.d.ts

~~~ts
import type { DateLibOptions } from "../classes/DateLib.js";
/**
 * Generates the ARIA label for the week number cell (the first cell in a row).
 *
 * @defaultValue `Week ${weekNumber}`
 * @param weekNumber - The number of the week.
 * @param options - Optional configuration for the date formatting library.
 * @returns The ARIA label for the week number cell.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelWeekNumber(weekNumber: number, _options?: DateLibOptions): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelWeekNumber.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelWeekNumber = labelWeekNumber;
/**
 * Generates the ARIA label for the week number cell (the first cell in a row).
 *
 * @defaultValue `Week ${weekNumber}`
 * @param weekNumber - The number of the week.
 * @param options - Optional configuration for the date formatting library.
 * @returns The ARIA label for the week number cell.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelWeekNumber(weekNumber, _options) {
    return `Week ${weekNumber}`;
}

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelWeekNumberHeader.d.ts

~~~ts
import type { DateLibOptions } from "../classes/DateLib.js";
/**
 * Generates the ARIA label for the week number header element.
 *
 * @defaultValue `"Week Number"`
 * @param options - Optional configuration for the date formatting library.
 * @returns The ARIA label for the week number header.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelWeekNumberHeader(_options?: DateLibOptions): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelWeekNumberHeader.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelWeekNumberHeader = labelWeekNumberHeader;
/**
 * Generates the ARIA label for the week number header element.
 *
 * @defaultValue `"Week Number"`
 * @param options - Optional configuration for the date formatting library.
 * @returns The ARIA label for the week number header.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelWeekNumberHeader(_options) {
    return "Week Number";
}

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelYearDropdown.d.ts

~~~ts
import type { DateLibOptions } from "../classes/DateLib.js";
/**
 * Generates the ARIA label for the years dropdown.
 *
 * @defaultValue `"Choose the Year"`
 * @param options - Optional configuration for the date formatting library.
 * @returns The ARIA label for the years dropdown.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
export declare function labelYearDropdown(_options?: DateLibOptions): string;

~~~

## node_modules\react-day-picker\dist\cjs\labels\labelYearDropdown.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.labelYearDropdown = labelYearDropdown;
/**
 * Generates the ARIA label for the years dropdown.
 *
 * @defaultValue `"Choose the Year"`
 * @param options - Optional configuration for the date formatting library.
 * @returns The ARIA label for the years dropdown.
 * @group Labels
 * @see https://daypicker.dev/docs/translation#aria-labels
 */
function labelYearDropdown(_options) {
    return "Choose the Year";
}

~~~

## node_modules\react-day-picker\dist\cjs\locale.d.ts

~~~ts
export * from "date-fns/locale";

~~~

## node_modules\react-day-picker\dist\cjs\locale.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("date-fns/locale"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\package.json

~~~json
{ "type": "commonjs" }

~~~

## node_modules\react-day-picker\dist\cjs\persian.d.ts

~~~ts
import type { Locale } from "date-fns-jalali";
import React from "react";
import { DateLib, type DateLibOptions } from "./index.js";
import type { DayPickerProps } from "./types/props.js";
export declare const faIR: Locale;
export declare const enUS: Locale;
/**
 * Renders the Persian calendar using the DayPicker component.
 *
 * @defaultValue
 * - `locale`: `faIR`
 * - `dir`: `rtl`
 * - `dateLib`: `jalaliDateLib` from `date-fns-jalali`
 * - `numerals`: `arabext` (Eastern Arabic-Indic)
 * @param props - The props for the Persian calendar, including locale, text
 *   direction, date library, and numeral system.
 * @returns The Persian calendar component.
 * @see https://daypicker.dev/docs/localization#persian-calendar
 */
export declare function DayPicker(props: DayPickerProps & {
    /**
     * The locale to use in the calendar.
     *
     * @default `faIR`
     */
    locale?: Locale;
    /**
     * The direction of the text in the calendar.
     *
     * @default `rtl`
     */
    dir?: DayPickerProps["dir"];
    /**
     * The date library to use in the calendar.
     *
     * @default `jalaliDateLib` from `date-fns-jalali`
     */
    dateLib?: DayPickerProps["dateLib"];
    /**
     * The numeral system to use when formatting dates.
     *
     * - `latn`: Latin (Western Arabic)
     * - `arab`: Arabic-Indic
     * - `arabext`: Eastern Arabic-Indic (Persian)
     * - `deva`: Devanagari
     * - `beng`: Bengali
     * - `guru`: Gurmukhi
     * - `gujr`: Gujarati
     * - `orya`: Oriya
     * - `tamldec`: Tamil
     * - `telu`: Telugu
     * - `knda`: Kannada
     * - `mlym`: Malayalam
     *
     * @defaultValue `arabext` Eastern Arabic-Indic (Persian)
     * @see https://daypicker.dev/docs/translation#numeral-systems
     */
    numerals?: DayPickerProps["numerals"];
}): React.JSX.Element;
/**
 * Returns the date library used in the Persian calendar.
 *
 * @param options - Optional configuration for the date library.
 * @returns The date library instance.
 */
export declare const getDateLib: (options?: DateLibOptions) => DateLib;

~~~

## node_modules\react-day-picker\dist\cjs\persian.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDateLib = exports.enUS = exports.faIR = void 0;
exports.DayPicker = DayPicker;
const dateFnsJalali = __importStar(require("date-fns-jalali"));
const locales = __importStar(require("date-fns-jalali/locale"));
const react_1 = __importDefault(require("react"));
const index_js_1 = require("./index.js");
exports.faIR = locales.faIR;
exports.enUS = locales.enUS;
/**
 * Renders the Persian calendar using the DayPicker component.
 *
 * @defaultValue
 * - `locale`: `faIR`
 * - `dir`: `rtl`
 * - `dateLib`: `jalaliDateLib` from `date-fns-jalali`
 * - `numerals`: `arabext` (Eastern Arabic-Indic)
 * @param props - The props for the Persian calendar, including locale, text
 *   direction, date library, and numeral system.
 * @returns The Persian calendar component.
 * @see https://daypicker.dev/docs/localization#persian-calendar
 */
function DayPicker(props) {
    const dateLib = (0, exports.getDateLib)({
        locale: props.locale,
        weekStartsOn: props.broadcastCalendar ? 1 : props.weekStartsOn,
        firstWeekContainsDate: props.firstWeekContainsDate,
        useAdditionalWeekYearTokens: props.useAdditionalWeekYearTokens,
        useAdditionalDayOfYearTokens: props.useAdditionalDayOfYearTokens,
        timeZone: props.timeZone,
    });
    return (react_1.default.createElement(index_js_1.DayPicker, { ...props, locale: props.locale ?? exports.faIR, numerals: props.numerals ?? "arabext", dir: props.dir ?? "rtl", dateLib: dateLib }));
}
/**
 * Returns the date library used in the Persian calendar.
 *
 * @param options - Optional configuration for the date library.
 * @returns The date library instance.
 */
const getDateLib = (options) => {
    return new index_js_1.DateLib(options, dateFnsJalali);
};
exports.getDateLib = getDateLib;

~~~

## node_modules\react-day-picker\dist\cjs\selection\useMulti.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps, Selection } from "../types/index.js";
/**
 * Hook to manage multiple-date selection in the DayPicker component.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns An object containing the selected dates, a function to select dates,
 *   and a function to check if a date is selected.
 */
export declare function useMulti<T extends DayPickerProps>(props: T, dateLib: DateLib): Selection<T>;

~~~

## node_modules\react-day-picker\dist\cjs\selection\useMulti.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMulti = useMulti;
const useControlledValue_js_1 = require("../helpers/useControlledValue.js");
/**
 * Hook to manage multiple-date selection in the DayPicker component.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns An object containing the selected dates, a function to select dates,
 *   and a function to check if a date is selected.
 */
function useMulti(props, dateLib) {
    const { selected: initiallySelected, required, onSelect, } = props;
    const [internallySelected, setSelected] = (0, useControlledValue_js_1.useControlledValue)(initiallySelected, onSelect ? initiallySelected : undefined);
    const selected = !onSelect ? internallySelected : initiallySelected;
    const { isSameDay } = dateLib;
    const isSelected = (date) => {
        return selected?.some((d) => isSameDay(d, date)) ?? false;
    };
    const { min, max } = props;
    const select = (triggerDate, modifiers, e) => {
        let newDates = [...(selected ?? [])];
        if (isSelected(triggerDate)) {
            if (selected?.length === min) {
                // Min value reached, do nothing
                return;
            }
            if (required && selected?.length === 1) {
                // Required value already selected do nothing
                return;
            }
            newDates = selected?.filter((d) => !isSameDay(d, triggerDate));
        }
        else {
            if (selected?.length === max) {
                // Max value reached, reset the selection to date
                newDates = [triggerDate];
            }
            else {
                // Add the date to the selection
                newDates = [...newDates, triggerDate];
            }
        }
        if (!onSelect) {
            setSelected(newDates);
        }
        onSelect?.(newDates, triggerDate, modifiers, e);
        return newDates;
    };
    return {
        selected,
        select,
        isSelected,
    };
}

~~~

## node_modules\react-day-picker\dist\cjs\selection\useRange.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps, Selection } from "../types/index.js";
/**
 * Hook to manage range selection in the DayPicker component.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns An object containing the selected range, a function to select a
 *   range, and a function to check if a date is within the range.
 */
export declare function useRange<T extends DayPickerProps>(props: T, dateLib: DateLib): Selection<T>;

~~~

## node_modules\react-day-picker\dist\cjs\selection\useRange.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRange = useRange;
const useControlledValue_js_1 = require("../helpers/useControlledValue.js");
const index_js_1 = require("../utils/index.js");
const rangeIncludesDate_js_1 = require("../utils/rangeIncludesDate.js");
/**
 * Hook to manage range selection in the DayPicker component.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns An object containing the selected range, a function to select a
 *   range, and a function to check if a date is within the range.
 */
function useRange(props, dateLib) {
    const { disabled, excludeDisabled, selected: initiallySelected, required, onSelect, } = props;
    const [internallySelected, setSelected] = (0, useControlledValue_js_1.useControlledValue)(initiallySelected, onSelect ? initiallySelected : undefined);
    const selected = !onSelect ? internallySelected : initiallySelected;
    const isSelected = (date) => selected && (0, rangeIncludesDate_js_1.rangeIncludesDate)(selected, date, false, dateLib);
    const select = (triggerDate, modifiers, e) => {
        const { min, max } = props;
        const newRange = triggerDate
            ? (0, index_js_1.addToRange)(triggerDate, selected, min, max, required, dateLib)
            : undefined;
        if (excludeDisabled && disabled && newRange?.from && newRange.to) {
            if ((0, index_js_1.rangeContainsModifiers)({ from: newRange.from, to: newRange.to }, disabled, dateLib)) {
                // if a disabled days is found, the range is reset
                newRange.from = triggerDate;
                newRange.to = undefined;
            }
        }
        if (!onSelect) {
            setSelected(newRange);
        }
        onSelect?.(newRange, triggerDate, modifiers, e);
        return newRange;
    };
    return {
        selected,
        select,
        isSelected,
    };
}

~~~

## node_modules\react-day-picker\dist\cjs\selection\useSingle.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DayPickerProps, SelectedValue, SelectHandler, Selection } from "../types/index.js";
export type UseSingle<T extends DayPickerProps> = {
    select: SelectHandler<T>;
    isSelected: (date: Date) => boolean;
    selected: SelectedValue<T>;
};
/**
 * Hook to manage single-date selection in the DayPicker component.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns An object containing the selected date, a function to select a date,
 *   and a function to check if a date is selected.
 */
export declare function useSingle<T extends DayPickerProps>(props: DayPickerProps, dateLib: DateLib): Selection<T>;

~~~

## node_modules\react-day-picker\dist\cjs\selection\useSingle.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSingle = useSingle;
const useControlledValue_js_1 = require("../helpers/useControlledValue.js");
/**
 * Hook to manage single-date selection in the DayPicker component.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns An object containing the selected date, a function to select a date,
 *   and a function to check if a date is selected.
 */
function useSingle(props, dateLib) {
    const { selected: initiallySelected, required, onSelect, } = props;
    const [internallySelected, setSelected] = (0, useControlledValue_js_1.useControlledValue)(initiallySelected, onSelect ? initiallySelected : undefined);
    const selected = !onSelect ? internallySelected : initiallySelected;
    const { isSameDay } = dateLib;
    const isSelected = (compareDate) => {
        return selected ? isSameDay(selected, compareDate) : false;
    };
    const select = (triggerDate, modifiers, e) => {
        let newDate = triggerDate;
        if (!required && selected && selected && isSameDay(triggerDate, selected)) {
            // If the date is the same, clear the selection.
            newDate = undefined;
        }
        if (!onSelect) {
            setSelected(newDate);
        }
        if (required) {
            onSelect?.(newDate, triggerDate, modifiers, e);
        }
        else {
            onSelect?.(newDate, triggerDate, modifiers, e);
        }
        return newDate;
    };
    return {
        selected,
        select,
        isSelected,
    };
}

~~~

## node_modules\react-day-picker\dist\cjs\types\deprecated.d.ts

~~~ts
import { MonthCaption, type MonthCaptionProps } from "../components/MonthCaption.js";
import { Week, type WeekProps } from "../components/Week.js";
import type { labelDayButton, labelNext, labelWeekday, labelWeekNumber } from "../labels/index.js";
import type { DayFlag, SelectionState } from "../UI.js";
import { useDayPicker } from "../useDayPicker.js";
import type { PropsMulti, PropsRange, PropsSingle } from "./props.js";
import type { DayEventHandler, Mode } from "./shared.js";
/**
 * @ignore
 * @deprecated This type will be removed.
 */
export type RootProvider = any;
/**
 * @ignore
 * @deprecated This type will be removed.
 */
export type RootProviderProps = any;
/**
 * @ignore
 * @deprecated This component has been renamed. Use `MonthCaption` instead.
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare const Caption: typeof MonthCaption;
/**
 * @ignore
 * @deprecated This type has been renamed. Use `MonthCaptionProps` instead.
 */
export type CaptionProps = MonthCaptionProps;
/**
 * @ignore
 * @deprecated This component has been removed.
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export type HeadRow = any;
/**
 * @ignore
 * @deprecated This component has been renamed. Use `Week` instead.
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare const Row: typeof Week;
/**
 * @ignore
 * @deprecated This type has been removed. Use `WeekProps` instead.
 */
export type RowProps = WeekProps;
/**
 * @ignore
 * @deprecated This type has been renamed. Use `PropsSingle` instead.
 */
export type DayPickerSingleProps = PropsSingle;
/**
 * @ignore
 * @deprecated This type has been renamed. Use `PropsMulti` instead.
 */
export type DayPickerMultipleProps = PropsMulti;
/**
 * @ignore
 * @deprecated This type has been renamed. Use `PropsRange` instead.
 */
export type DayPickerRangeProps = PropsRange;
/**
 * @ignore
 * @deprecated This type will be removed. Use `NonNullable<unknown>` instead.
 */
export type DayPickerDefaultProps = NonNullable<unknown>;
/**
 * @ignore
 * @deprecated This type has been renamed. Use `Mode` instead.
 */
export type DaySelectionMode = Mode;
/**
 * @ignore
 * @deprecated This type will be removed. Use `string` instead.
 */
export type Modifier = string;
/**
 * @ignore
 * @deprecated This type will be removed. Use {@link DayFlag} or
 *   {@link SelectionState} instead.
 */
export type InternalModifier = DayFlag.disabled | DayFlag.hidden | DayFlag.focused | SelectionState.range_end | SelectionState.range_middle | SelectionState.range_start | SelectionState.selected;
/**
 * @ignore
 * @deprecated This type will be removed. Use `SelectHandler<{ mode: "single"
 *   }>` instead.
 */
export type SelectSingleEventHandler = PropsSingle["onSelect"];
/**
 * @ignore
 * @deprecated This type will be removed. Use `SelectHandler<{ mode: "multiple"
 *   }>` instead.
 */
export type SelectMultipleEventHandler = PropsMulti["onSelect"];
/**
 * @ignore
 * @deprecated This type will be removed. Use `SelectHandler<{ mode: "range" }>`
 *   instead.
 */
export type SelectRangeEventHandler = PropsRange["onSelect"];
/**
 * @ignore
 * @deprecated This type is not used anymore.
 */
export type DayPickerProviderProps = any;
/**
 * @ignore
 * @deprecated This type has been moved to `useDayPicker`.
 * @group Hooks
 */
export declare const useNavigation: typeof useDayPicker;
/**
 * @ignore
 * @deprecated This hook has been removed. Use a custom `Day` component instead.
 * @group Hooks
 * @see https://daypicker.dev/guides/custom-components
 */
export type useDayRender = any;
/**
 * @ignore
 * @deprecated This type is not used anymore.
 */
export type ContextProvidersProps = any;
/**
 * @ignore
 * @deprecated Use `typeof labelDayButton` instead.
 */
export type DayLabel = typeof labelDayButton;
/**
 * @ignore
 * @deprecated Use `typeof labelNext` or `typeof labelPrevious` instead.
 */
export type NavButtonLabel = typeof labelNext;
/**
 * @ignore
 * @deprecated Use `typeof labelWeekday` instead.
 */
export type WeekdayLabel = typeof labelWeekday;
/**
 * @ignore
 * @deprecated Use `typeof labelWeekNumber` instead.
 */
export type WeekNumberLabel = typeof labelWeekNumber;
/**
 * @ignore
 * @deprecated Use {@link DayMouseEventHandler} instead.
 */
export type DayClickEventHandler = DayEventHandler<React.MouseEvent>;
/**
 * @ignore
 * @deprecated This type will be removed. Use `DayEventHandler<React.FocusEvent
 *   | React.KeyboardEvent>` instead.
 */
export type DayFocusEventHandler = DayEventHandler<React.FocusEvent | React.KeyboardEvent>;
/**
 * @ignore
 * @deprecated This type will be removed. Use
 *   `DayEventHandler<React.KeyboardEvent>` instead.
 */
export type DayKeyboardEventHandler = DayEventHandler<React.KeyboardEvent>;
/**
 * @ignore
 * @deprecated This type will be removed. Use
 *   `DayEventHandler<React.MouseEvent>` instead.
 */
export type DayMouseEventHandler = DayEventHandler<React.MouseEvent>;
/**
 * @ignore
 * @deprecated This type will be removed. Use
 *   `DayEventHandler<React.PointerEvent>` instead.
 */
export type DayPointerEventHandler = DayEventHandler<React.PointerEvent>;
/**
 * @ignore
 * @deprecated This type will be removed. Use
 *   `DayEventHandler<React.TouchEvent>` instead.
 */
export type DayTouchEventHandler = DayEventHandler<React.TouchEvent>;

~~~

## node_modules\react-day-picker\dist\cjs\types\deprecated.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNavigation = exports.Row = exports.Caption = void 0;
const MonthCaption_js_1 = require("../components/MonthCaption.js");
const Week_js_1 = require("../components/Week.js");
const useDayPicker_js_1 = require("../useDayPicker.js");
/**
 * @ignore
 * @deprecated This component has been renamed. Use `MonthCaption` instead.
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
exports.Caption = MonthCaption_js_1.MonthCaption;
/**
 * @ignore
 * @deprecated This component has been renamed. Use `Week` instead.
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
exports.Row = Week_js_1.Week;
/**
 * @ignore
 * @deprecated This type has been moved to `useDayPicker`.
 * @group Hooks
 */
exports.useNavigation = useDayPicker_js_1.useDayPicker;

~~~

## node_modules\react-day-picker\dist\cjs\types\index.d.ts

~~~ts
export * from "./deprecated.js";
export * from "./props.js";
export * from "./selection.js";
export * from "./shared.js";

~~~

## node_modules\react-day-picker\dist\cjs\types\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./deprecated.js"), exports);
__exportStar(require("./props.js"), exports);
__exportStar(require("./selection.js"), exports);
__exportStar(require("./shared.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\types\props.d.ts

~~~ts
import type React from "react";
import type { DateLib, Locale } from "../classes/DateLib.js";
import type { DeprecatedUI } from "../UI.js";
import type { ClassNames, CustomComponents, DateRange, DayEventHandler, Formatters, Labels, Matcher, Mode, Modifiers, ModifiersClassNames, ModifiersStyles, MonthChangeEventHandler, Numerals, Styles } from "./shared.js";
/**
 * The props for the `<DayPicker />` component.
 *
 * @group DayPicker
 */
export type DayPickerProps = PropsBase & (PropsSingle | PropsSingleRequired | PropsMulti | PropsMultiRequired | PropsRange | PropsRangeRequired | {
    mode?: undefined;
    required?: undefined;
});
/**
 * Props for customizing the calendar, handling localization, and managing
 * events. These exclude the selection mode props.
 *
 * @group DayPicker
 * @see https://daypicker.dev/api/interfaces/PropsBase
 */
export interface PropsBase {
    /**
     * Enable the selection of a single day, multiple days, or a range of days.
     *
     * @see https://daypicker.dev/docs/selection-modes
     */
    mode?: Mode | undefined;
    /**
     * Whether the selection is required.
     *
     * @see https://daypicker.dev/docs/selection-modes
     */
    required?: boolean | undefined;
    /** Class name to add to the root element. */
    className?: string;
    /**
     * Change the class names used by DayPicker.
     *
     * Use this prop when you need to change the default class names ??for
     * example, when importing the style via CSS modules or when using a CSS
     * framework.
     *
     * @see https://daypicker.dev/docs/styling
     */
    classNames?: Partial<ClassNames> & Partial<DeprecatedUI<string>>;
    /**
     * Change the class name for the day matching the `modifiers`.
     *
     * @see https://daypicker.dev/guides/custom-modifiers
     */
    modifiersClassNames?: ModifiersClassNames;
    /** Style to apply to the root element. */
    style?: React.CSSProperties;
    /**
     * Change the inline styles of the HTML elements.
     *
     * @see https://daypicker.dev/docs/styling
     */
    styles?: Partial<Styles> & Partial<DeprecatedUI<React.CSSProperties>>;
    /**
     * Change the class name for the day matching the {@link modifiers}.
     *
     * @see https://daypicker.dev/guides/custom-modifiers
     */
    modifiersStyles?: ModifiersStyles;
    /** A unique id to add to the root element. */
    id?: string;
    /**
     * The initial month to show in the calendar.
     *
     * Use this prop to let DayPicker control the current month. If you need to
     * set the month programmatically, use {@link month} and {@link onMonthChange}.
     *
     * @defaultValue The current month
     * @see https://daypicker.dev/docs/navigation
     */
    defaultMonth?: Date;
    /**
     * The month displayed in the calendar.
     *
     * As opposed to `defaultMonth`, use this prop with `onMonthChange` to change
     * the month programmatically.
     *
     * @see https://daypicker.dev/docs/navigation
     */
    month?: Date;
    /**
     * The number of displayed months.
     *
     * @defaultValue 1
     * @see https://daypicker.dev/docs/customization#multiplemonths
     */
    numberOfMonths?: number;
    /**
     * The earliest month to start the month navigation.
     *
     * @since 9.0.0
     * @see https://daypicker.dev/docs/navigation#start-and-end-dates
     */
    startMonth?: Date | undefined;
    /**
     * @private
     * @deprecated This prop has been removed. Use `hidden={{ before: date }}`
     *   instead.
     * @see https://daypicker.dev/docs/navigation#start-and-end-dates
     */
    fromDate?: Date | undefined;
    /**
     * @private
     * @deprecated This prop has been renamed to `startMonth`.
     * @see https://daypicker.dev/docs/navigation#start-and-end-dates
     */
    fromMonth?: Date | undefined;
    /**
     * @private
     * @deprecated Use `startMonth` instead. E.g. `startMonth={new Date(year,
     *   0)}`.
     * @see https://daypicker.dev/docs/navigation#start-and-end-dates
     */
    fromYear?: number | undefined;
    /**
     * The latest month to end the month navigation.
     *
     * @since 9.0.0
     * @see https://daypicker.dev/docs/navigation#start-and-end-dates
     */
    endMonth?: Date;
    /**
     * @private
     * @deprecated This prop has been removed. Use `hidden={{ after: date }}`
     *   instead.
     * @see https://daypicker.dev/docs/navigation#start-and-end-dates
     */
    toDate?: Date;
    /**
     * @private
     * @deprecated This prop has been renamed to `endMonth`.
     * @see https://daypicker.dev/docs/navigation#start-and-end-dates
     */
    toMonth?: Date;
    /**
     * @private
     * @deprecated Use `endMonth` instead. E.g. `endMonth={new Date(year, 0)}`.
     * @see https://daypicker.dev/docs/navigation#start-and-end-dates
     */
    toYear?: number;
    /**
     * Paginate the month navigation displaying the `numberOfMonths` at a time.
     *
     * @see https://daypicker.dev/docs/customization#multiplemonths
     */
    pagedNavigation?: boolean;
    /**
     * Render the months in reversed order (when {@link numberOfMonths} is set) to
     * display the most recent month first.
     *
     * @see https://daypicker.dev/docs/customization#multiplemonths
     */
    reverseMonths?: boolean;
    /**
     * Hide the navigation buttons. This prop won't disable the navigation: to
     * disable the navigation, use {@link disableNavigation}.
     *
     * @since 9.0.0
     * @see https://daypicker.dev/docs/navigation#hidenavigation
     */
    hideNavigation?: boolean;
    /**
     * Disable the navigation between months. This prop won't hide the navigation:
     * to hide the navigation, use {@link hideNavigation}.
     *
     * @see https://daypicker.dev/docs/navigation#disablenavigation
     */
    disableNavigation?: boolean;
    /**
     * Show dropdowns to navigate between months or years.
     *
     * - `label`: Displays the month and year as a label. Default value.
     * - `dropdown`: Displays dropdowns for both month and year navigation.
     * - `dropdown-months`: Displays a dropdown only for the month navigation.
     * - `dropdown-years`: Displays a dropdown only for the year navigation.
     *
     * **Note:** By default, showing the dropdown will set the {@link startMonth}
     * to 100 years ago and {@link endMonth} to the end of the current year. You
     * can override this behavior by explicitly setting `startMonth` and
     * `endMonth`.
     *
     * @see https://daypicker.dev/docs/customization#caption-layouts
     */
    captionLayout?: "label" | "dropdown" | "dropdown-months" | "dropdown-years";
    /**
     * Reverse the order of years in the dropdown when using
     * `captionLayout="dropdown"` or `captionLayout="dropdown-years"`.
     *
     * @since 9.9.0
     * @see https://daypicker.dev/docs/customization#caption-layouts
     */
    reverseYears?: boolean;
    /**
     * Adjust the positioning of the navigation buttons.
     *
     * - `around`: Displays the buttons on either side of the caption.
     * - `after`: Displays the buttons after the caption. This ensures the tab order
     *   matches the visual order.
     *
     * If not set, the buttons default to being displayed after the caption, but
     * the tab order may not align with the visual order.
     *
     * @since 9.7.0
     * @see https://daypicker.dev/docs/customization#navigation-layouts
     */
    navLayout?: "around" | "after" | undefined;
    /**
     * Display always 6 weeks per each month, regardless of the month?셲 number of
     * weeks. Weeks will be filled with the days from the next month.
     *
     * @see https://daypicker.dev/docs/customization#fixed-weeks
     */
    fixedWeeks?: boolean;
    /**
     * Hide the row displaying the weekday row header.
     *
     * @since 9.0.0
     */
    hideWeekdays?: boolean;
    /**
     * Show the outside days (days falling in the next or the previous month).
     *
     * **Note:** when a {@link broadcastCalendar} is set, this prop defaults to
     * true.
     *
     * @see https://daypicker.dev/docs/customization#outside-days
     */
    showOutsideDays?: boolean;
    /**
     * Show the week numbers column. Weeks are numbered according to the local
     * week index.
     *
     * @see https://daypicker.dev/docs/customization#showweeknumber
     */
    showWeekNumber?: boolean;
    /**
     * Animate navigating between months.
     *
     * @since 9.6.0
     * @see https://daypicker.dev/docs/navigation#animate
     */
    animate?: boolean;
    /**
     * Display the weeks in the month following the broadcast calendar. Setting
     * this prop will ignore {@link weekStartsOn} (always Monday) and
     * {@link showOutsideDays} will default to true.
     *
     * @since 9.4.0
     * @see https://daypicker.dev/docs/localization#broadcast-calendar
     * @see https://en.wikipedia.org/wiki/Broadcast_calendar
     */
    broadcastCalendar?: boolean;
    /**
     * Use ISO week dates instead of the locale setting. Setting this prop will
     * ignore `weekStartsOn` and `firstWeekContainsDate`.
     *
     * @see https://daypicker.dev/docs/localization#iso-week-dates
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     */
    ISOWeek?: boolean;
    /**
     * The time zone (IANA or UTC offset) to use in the calendar (experimental).
     *
     * See
     * [Wikipedia](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
     * for the possible values.
     *
     * @since 9.1.1
     * @see https://daypicker.dev/docs/time-zone
     */
    timeZone?: string | undefined;
    /**
     * Change the components used for rendering the calendar elements.
     *
     * @see https://daypicker.dev/guides/custom-components
     */
    components?: Partial<CustomComponents>;
    /**
     * Add a footer to the calendar, acting as a live region.
     *
     * Use this prop to communicate the calendar's status to screen readers.
     * Prefer strings over complex UI elements.
     *
     * @see https://daypicker.dev/guides/accessibility#footer
     */
    footer?: React.ReactNode | string;
    /**
     * When a selection mode is set, DayPicker will focus the first selected day
     * (if set) or today's date (if not disabled).
     *
     * Use this prop when you need to focus DayPicker after a user action, for
     * improved accessibility.
     *
     * @see https://daypicker.dev/guides/accessibility#autofocus
     */
    autoFocus?: boolean;
    /**
     * @private
     * @deprecated This prop will be removed. Use {@link autoFocus} instead.
     */
    initialFocus?: boolean;
    /**
     * Apply the `disabled` modifier to the matching days. Disabled days cannot be
     * selected when in a selection mode is set.
     *
     * @see https://daypicker.dev/docs/selection-modes#disabled
     */
    disabled?: Matcher | Matcher[] | undefined;
    /**
     * Apply the `hidden` modifier to the matching days. Will hide them from the
     * calendar.
     *
     * @see https://daypicker.dev/guides/custom-modifiers#hidden-modifier
     */
    hidden?: Matcher | Matcher[] | undefined;
    /**
     * The today?셲 date. Default is the current date. This date will get the
     * `today` modifier to style the day.
     *
     * @see https://daypicker.dev/guides/custom-modifiers#today-modifier
     */
    today?: Date;
    /**
     * Add modifiers to the matching days.
     *
     * @example
     *   const modifiers = {
     *   weekend: { dayOfWeek: [0, 6] }, // Match weekends
     *   holiday: [new Date(2023, 11, 25)] // Match Christmas
     *   };
     *   <DayPicker modifiers={modifiers} />
     *
     * @see https://daypicker.dev/guides/custom-modifiers
     */
    modifiers?: Record<string, Matcher | Matcher[] | undefined> | undefined;
    /**
     * Labels creators to override the defaults. Use this prop to customize the
     * aria-label attributes in DayPicker.
     *
     * @see https://daypicker.dev/docs/translation#aria-labels
     */
    labels?: Partial<Labels>;
    /**
     * Formatters used to format dates to strings. Use this prop to override the
     * default functions.
     *
     * @see https://daypicker.dev/docs/translation#custom-formatters
     */
    formatters?: Partial<Formatters>;
    /**
     * The text direction of the calendar. Use `ltr` for left-to-right (default)
     * or `rtl` for right-to-left.
     *
     * @see https://daypicker.dev/docs/translation#rtl-text-direction
     */
    dir?: HTMLDivElement["dir"];
    /**
     * The aria-label attribute to add to the container element.
     *
     * @since 9.4.1
     * @see https://daypicker.dev/guides/accessibility
     */
    "aria-label"?: string;
    /**
     * The aria-labelledby attribute to add to the container element.
     *
     * @since 9.11.0
     * @see https://daypicker.dev/guides/accessibility
     */
    "aria-labelledby"?: string;
    /**
     * The role attribute to add to the container element.
     *
     * @since 9.4.1
     * @see https://daypicker.dev/guides/accessibility
     */
    role?: "application" | "dialog" | undefined;
    /**
     * A cryptographic nonce ("number used once") which can be used by Content
     * Security Policy for the inline `style` attributes.
     */
    nonce?: HTMLDivElement["nonce"];
    /** Add a `title` attribute to the container element. */
    title?: HTMLDivElement["title"];
    /** Add the language tag to the container element. */
    lang?: HTMLDivElement["lang"];
    /**
     * The locale object used to localize dates. Pass a locale from
     * `react-day-picker/locale` to localize the calendar.
     *
     * @example
     *   import { es } from "react-day-picker/locale";
     *   <DayPicker locale={es} />
     *
     * @defaultValue enUS - The English locale default of `date-fns`.
     * @see https://daypicker.dev/docs/localization
     * @see https://github.com/date-fns/date-fns/tree/main/src/locale for a list of the supported locales
     */
    locale?: Partial<Locale> | undefined;
    /**
     * The numeral system to use when formatting dates.
     *
     * - `latn`: Latin (Western Arabic)
     * - `arab`: Arabic-Indic
     * - `arabext`: Eastern Arabic-Indic (Persian)
     * - `deva`: Devanagari
     * - `beng`: Bengali
     * - `guru`: Gurmukhi
     * - `gujr`: Gujarati
     * - `orya`: Oriya
     * - `tamldec`: Tamil
     * - `telu`: Telugu
     * - `knda`: Kannada
     * - `mlym`: Malayalam
     *
     * @defaultValue `latn` Latin (Western Arabic)
     * @see https://daypicker.dev/docs/translation#numeral-systems
     */
    numerals?: Numerals | undefined;
    /**
     * The index of the first day of the week (0 - Sunday). Overrides the locale's
     * default.
     *
     * @see https://daypicker.dev/docs/localization#first-date-of-the-week
     */
    weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined;
    /**
     * The day of January that is always in the first week of the year.
     *
     * @see https://daypicker.dev/docs/localization#first-week-contains-date
     */
    firstWeekContainsDate?: 1 | 4;
    /**
     * Enable `DD` and `DDDD` for week year tokens when formatting or parsing
     * dates.
     *
     * @see https://date-fns.org/docs/Unicode-Tokens
     */
    useAdditionalWeekYearTokens?: boolean | undefined;
    /**
     * Enable `YY` and `YYYY` for day of year tokens when formatting or parsing
     * dates.
     *
     * @see https://date-fns.org/docs/Unicode-Tokens
     */
    useAdditionalDayOfYearTokens?: boolean | undefined;
    /**
     * Event fired when the user navigates between months.
     *
     * @see https://daypicker.dev/docs/navigation#onmonthchange
     */
    onMonthChange?: MonthChangeEventHandler;
    /**
     * Event handler when the next month button is clicked.
     *
     * @see https://daypicker.dev/docs/navigation
     */
    onNextClick?: MonthChangeEventHandler;
    /**
     * Event handler when the previous month button is clicked.
     *
     * @see https://daypicker.dev/docs/navigation
     */
    onPrevClick?: MonthChangeEventHandler;
    /**
     * Event handler when a week number is clicked.
     *
     * @private
     * @deprecated Use a custom `WeekNumber` component instead.
     * @see https://daypicker.dev/docs/customization#showweeknumber
     */
    onWeekNumberClick?: any;
    /** Event handler when a day is clicked. */
    onDayClick?: DayEventHandler<React.MouseEvent>;
    /** Event handler when a day is focused. */
    onDayFocus?: DayEventHandler<React.FocusEvent>;
    /** Event handler when a day is blurred. */
    onDayBlur?: DayEventHandler<React.FocusEvent>;
    /** Event handler when a key is pressed on a day. */
    onDayKeyDown?: DayEventHandler<React.KeyboardEvent>;
    /** Event handler when the mouse enters a day. */
    onDayMouseEnter?: DayEventHandler<React.MouseEvent>;
    /** Event handler when the mouse leaves a day. */
    onDayMouseLeave?: DayEventHandler<React.MouseEvent>;
    /**
     * Replace the default date library with a custom one. Experimental: not
     * guaranteed to be stable (may not respect semver).
     *
     * @since 9.0.0
     * @experimental
     */
    dateLib?: Partial<typeof DateLib.prototype> | undefined;
    /**
     * @private
     * @deprecated Use a custom `DayButton` component instead.
     */
    onDayKeyUp?: DayEventHandler<React.KeyboardEvent>;
    /**
     * @private
     * @deprecated Use a custom `DayButton` component instead.
     */
    onDayKeyPress?: DayEventHandler<React.KeyboardEvent>;
    /**
     * @private
     * @deprecated Use a custom `DayButton` component instead.
     */
    onDayPointerEnter?: DayEventHandler<React.PointerEvent>;
    /**
     * @private
     * @deprecated Use a custom `DayButton` component instead.
     */
    onDayPointerLeave?: DayEventHandler<React.PointerEvent>;
    /**
     * @private
     * @deprecated Use a custom `DayButton` component instead.
     */
    onDayTouchCancel?: DayEventHandler<React.TouchEvent>;
    /**
     * @private
     * @deprecated Use a custom `DayButton` component instead.
     */
    onDayTouchEnd?: DayEventHandler<React.TouchEvent>;
    /**
     * @private
     * @deprecated Use a custom `DayButton` component instead.
     */
    onDayTouchMove?: DayEventHandler<React.TouchEvent>;
    /**
     * @private
     * @deprecated Use a custom `DayButton` component instead.
     */
    onDayTouchStart?: DayEventHandler<React.TouchEvent>;
}
/**
 * Shared handler type for `onSelect` callback when a selection mode is set.
 *
 * @example
 *   const handleSelect: OnSelectHandler<Date> = (
 *     selected,
 *     triggerDate,
 *     modifiers,
 *     e,
 *   ) => {
 *     console.log("Selected:", selected);
 *     console.log("Triggered by:", triggerDate);
 *   };
 *
 * @template T - The type of the selected item.
 * @callback OnSelectHandler
 * @param {T} selected - The selected item after the event.
 * @param {Date} triggerDate - The date when the event was triggered. This is
 *   typically the day clicked or interacted with.
 * @param {Modifiers} modifiers - The modifiers associated with the event.
 * @param {React.MouseEvent | React.KeyboardEvent} e - The event object.
 */
export type OnSelectHandler<T> = (selected: T, triggerDate: Date, modifiers: Modifiers, e: React.MouseEvent | React.KeyboardEvent) => void;
/**
 * The props when the single selection is required.
 *
 * @group DayPicker
 * @see https://daypicker.dev/docs/selection-modes#single-mode
 */
export interface PropsSingleRequired {
    mode: "single";
    required: true;
    /** The selected date. */
    selected: Date | undefined;
    /** Event handler when a day is selected. */
    onSelect?: OnSelectHandler<Date>;
}
/**
 * The props when the single selection is optional.
 *
 * @group DayPicker
 * @see https://daypicker.dev/docs/selection-modes#single-mode
 */
export interface PropsSingle {
    mode: "single";
    required?: false | undefined;
    /** The selected date. */
    selected?: Date | undefined;
    /** Event handler when a day is selected. */
    onSelect?: OnSelectHandler<Date | undefined>;
}
/**
 * The props when the multiple selection is required.
 *
 * @group DayPicker
 * @see https://daypicker.dev/docs/selection-modes#multiple-mode
 */
export interface PropsMultiRequired {
    mode: "multiple";
    required: true;
    /** The selected dates. */
    selected: Date[] | undefined;
    /** Event handler when days are selected. */
    onSelect?: OnSelectHandler<Date[]>;
    /** The minimum number of selectable days. */
    min?: number;
    /** The maximum number of selectable days. */
    max?: number;
}
/**
 * The props when the multiple selection is optional.
 *
 * @group DayPicker
 * @see https://daypicker.dev/docs/selection-modes#multiple-mode
 */
export interface PropsMulti {
    mode: "multiple";
    required?: false | undefined;
    /** The selected dates. */
    selected?: Date[] | undefined;
    /** Event handler when days are selected. */
    onSelect?: OnSelectHandler<Date[] | undefined>;
    /** The minimum number of selectable days. */
    min?: number;
    /** The maximum number of selectable days. */
    max?: number;
}
/**
 * The props when the range selection is required.
 *
 * @group DayPicker
 * @see https://daypicker.dev/docs/selection-modes#range-mode
 */
export interface PropsRangeRequired {
    mode: "range";
    required: true;
    /**
     * Apply the `disabled` modifier to the matching days. Disabled days cannot be
     * selected when in a selection mode is set.
     *
     * @see https://daypicker.dev/docs/selection-modes#disabled
     */
    disabled?: Matcher | Matcher[] | undefined;
    /**
     * When `true`, the range will reset when including a disabled day.
     *
     * @since V9.0.2
     */
    excludeDisabled?: boolean | undefined;
    /** The selected range. */
    selected: DateRange | undefined;
    /** Event handler when a range is selected. */
    onSelect?: OnSelectHandler<DateRange>;
    /** The minimum number of days to include in the range. */
    min?: number;
    /** The maximum number of days to include in the range. */
    max?: number;
}
/**
 * The props when the range selection is optional.
 *
 * @group DayPicker
 * @see https://daypicker.dev/docs/selection-modes#range-mode
 */
export interface PropsRange {
    mode: "range";
    required?: false | undefined;
    /**
     * Apply the `disabled` modifier to the matching days. Disabled days cannot be
     * selected when in a selection mode is set.
     *
     * @see https://daypicker.dev/docs/selection-modes#disabled
     */
    disabled?: Matcher | Matcher[] | undefined;
    /**
     * When `true`, the range will reset when including a disabled day.
     *
     * @since V9.0.2
     * @see https://daypicker.dev/docs/selection-modes#exclude-disabled
     */
    excludeDisabled?: boolean | undefined;
    /** The selected range. */
    selected?: DateRange | undefined;
    /** Event handler when the selection changes. */
    onSelect?: OnSelectHandler<DateRange | undefined>;
    /** The minimum number of days to include in the range. */
    min?: number;
    /** The maximum number of days to include in the range. */
    max?: number;
}

~~~

## node_modules\react-day-picker\dist\cjs\types\props.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

~~~

## node_modules\react-day-picker\dist\cjs\types\selection.d.ts

~~~ts
import type { DayPickerProps } from "./props.js";
import type { DateRange, Mode, Modifiers } from "./shared.js";
export type Selection<T extends DayPickerProps> = {
    /** The selected date(s). */
    selected: SelectedValue<T> | undefined;
    /** Set a selection. */
    select: SelectHandler<T> | undefined;
    /** Whether the given date is selected. */
    isSelected: (date: Date) => boolean;
};
export type SelectedSingle<T extends {
    required?: boolean;
}> = T["required"] extends true ? Date : Date | undefined;
export type SelectedMulti<T extends {
    required?: boolean;
}> = T["required"] extends true ? Date[] : Date[] | undefined;
export type SelectedRange<T extends {
    required?: boolean;
}> = T["required"] extends true ? DateRange : DateRange | undefined;
/**
 * Represents the selected value based on the selection mode.
 *
 * @example
 *   // Single selection mode
 *   const selected: SelectedValue<{ mode: "single" }> = new Date();
 *
 *   // Multiple selection mode
 *   const selected: SelectedValue<{ mode: "multiple" }> = [
 *     new Date(),
 *     new Date(),
 *   ];
 *
 *   // Range selection mode
 *   const selected: SelectedValue<{ mode: "range" }> = {
 *     from: new Date(),
 *     to: new Date(),
 *   };
 */
export type SelectedValue<T> = T extends {
    mode: "single";
    required?: boolean;
} ? SelectedSingle<T> : T extends {
    mode: "multiple";
    required?: boolean;
} ? SelectedMulti<T> : T extends {
    mode: "range";
    required?: boolean;
} ? SelectedRange<T> : undefined;
export type SelectHandlerSingle<T extends {
    required?: boolean | undefined;
}> = (triggerDate: Date, modifiers: Modifiers, e: React.MouseEvent | React.KeyboardEvent) => T["required"] extends true ? Date : Date | undefined;
export type SelectHandlerMulti<T extends {
    required?: boolean | undefined;
}> = (triggerDate: Date, modifiers: Modifiers, e: React.MouseEvent | React.KeyboardEvent) => T["required"] extends true ? Date[] : Date[] | undefined;
export type SelectHandlerRange<T extends {
    required?: boolean | undefined;
}> = (triggerDate: Date, modifiers: Modifiers, e: React.MouseEvent | React.KeyboardEvent) => T["required"] extends true ? DateRange : DateRange | undefined;
/**
 * The handler to set a selection based on the mode.
 *
 * @example
 *   const handleSelect: SelectHandler<{ mode: "single" }> = (
 *     triggerDate,
 *     modifiers,
 *     e,
 *   ) => {
 *     console.log("Selected date:", triggerDate);
 *   };
 */
export type SelectHandler<T extends {
    mode?: Mode | undefined;
    required?: boolean | undefined;
}> = T extends {
    mode: "single";
} ? SelectHandlerSingle<T> : T extends {
    mode: "multiple";
} ? SelectHandlerMulti<T> : T extends {
    mode: "range";
} ? SelectHandlerRange<T> : undefined;

~~~

## node_modules\react-day-picker\dist\cjs\types\selection.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

~~~

## node_modules\react-day-picker\dist\cjs\types\shared.d.ts

~~~ts
import type { CSSProperties } from "react";
import type * as components from "../components/custom-components.js";
import type { formatCaption, formatDay, formatMonthCaption, formatMonthDropdown, formatWeekdayName, formatWeekNumber, formatWeekNumberHeader, formatYearCaption, formatYearDropdown } from "../formatters/index.js";
import type { labelDayButton, labelGrid, labelGridcell, labelMonthDropdown, labelNav, labelNext, labelPrevious, labelWeekday, labelWeekNumber, labelWeekNumberHeader, labelYearDropdown } from "../labels/index.js";
import type { Animation, DayFlag, SelectionState, UI } from "../UI.js";
/**
 * Selection modes supported by DayPicker.
 *
 * - `single`: Select a single day.
 * - `multiple`: Select multiple days.
 * - `range`: Select a range of days.
 *
 * @see https://daypicker.dev/docs/selection-modes
 */
export type Mode = "single" | "multiple" | "range";
/**
 * The components that can be customized using the `components` prop.
 *
 * @see https://daypicker.dev/guides/custom-components
 */
export type CustomComponents = {
    /**
     * Render any button element in DayPicker.
     *
     * @deprecated Use {@link CustomComponents.NextMonthButton} or
     *   {@link CustomComponents.PreviousMonthButton} instead.
     */
    Button: typeof components.Button;
    /** Render the chevron icon used in the navigation buttons and dropdowns. */
    Chevron: typeof components.Chevron;
    /** Render the caption label of the month grid. */
    CaptionLabel: typeof components.CaptionLabel;
    /** Render the day cell in the month grid. */
    Day: typeof components.Day;
    /** Render the button containing the day in the day cell. */
    DayButton: typeof components.DayButton;
    /** Render the dropdown element to select years and months. */
    Dropdown: typeof components.Dropdown;
    /** Render the container of the dropdowns. */
    DropdownNav: typeof components.DropdownNav;
    /** Render the footer element announced by screen readers. */
    Footer: typeof components.Footer;
    /** Render the container of the MonthGrid. */
    Month: typeof components.Month;
    /** Render the caption of the month grid. */
    MonthCaption: typeof components.MonthCaption;
    /** Render the grid of days in a month. */
    MonthGrid: typeof components.MonthGrid;
    /** Wrapper of the month grids. */
    Months: typeof components.Months;
    /** Render the navigation element with the next and previous buttons. */
    Nav: typeof components.Nav;
    /** Render the `<option>` HTML element in the dropdown. */
    Option: typeof components.Option;
    /** Render the previous month button element in the navigation. */
    PreviousMonthButton: typeof components.PreviousMonthButton;
    /** Render the next month button element in the navigation. */
    NextMonthButton: typeof components.NextMonthButton;
    /** Render the root element of the calendar. */
    Root: typeof components.Root;
    /** Render the select element in the dropdowns. */
    Select: typeof components.Select;
    /** Render the weeks section in the month grid. */
    Weeks: typeof components.Weeks;
    /** Render the week rows. */
    Week: typeof components.Week;
    /** Render the weekday name in the header. */
    Weekday: typeof components.Weekday;
    /** Render the row containing the week days. */
    Weekdays: typeof components.Weekdays;
    /** Render the cell with the number of the week. */
    WeekNumber: typeof components.WeekNumber;
    /** Render the header of the week number column. */
    WeekNumberHeader: typeof components.WeekNumberHeader;
    /** Render the dropdown for selecting months. */
    MonthsDropdown: typeof components.MonthsDropdown;
    /** Render the dropdown for selecting years. */
    YearsDropdown: typeof components.YearsDropdown;
};
/** Represents a map of formatters used to render localized content. */
export type Formatters = {
    /** Format the caption of a month grid. */
    formatCaption: typeof formatCaption;
    /** Format the day in the day cell. */
    formatDay: typeof formatDay;
    /** Format the label in the month dropdown. */
    formatMonthDropdown: typeof formatMonthDropdown;
    /**
     * @ignore
     * @deprecated Use {@link Formatters.formatCaption} instead.
     *
     *   **Note:** This formatter will be removed in version 10.0.0.
     */
    formatMonthCaption: typeof formatMonthCaption;
    /** Format the week number. */
    formatWeekNumber: typeof formatWeekNumber;
    /** Format the header of the week number column. */
    formatWeekNumberHeader: typeof formatWeekNumberHeader;
    /** Format the week day name in the header. */
    formatWeekdayName: typeof formatWeekdayName;
    /** Format the label in the year dropdown. */
    formatYearDropdown: typeof formatYearDropdown;
    /**
     * @ignore
     * @deprecated Use {@link Formatters.formatYearDropdown} instead.
     */
    formatYearCaption: typeof formatYearCaption;
};
/** A map of functions to translate ARIA labels for various elements. */
export type Labels = {
    /** The label for the navigation toolbar. */
    labelNav: typeof labelNav;
    /** The label for the month grid. */
    labelGrid: typeof labelGrid;
    /** The label for the gridcell, when the calendar is not interactive. */
    labelGridcell: typeof labelGridcell;
    /** The label for the month dropdown. */
    labelMonthDropdown: typeof labelMonthDropdown;
    /** The label for the year dropdown. */
    labelYearDropdown: typeof labelYearDropdown;
    /** The label for the "next month" button. */
    labelNext: typeof labelNext;
    /** The label for the "previous month" button. */
    labelPrevious: typeof labelPrevious;
    /** The label for the day button. */
    labelDayButton: typeof labelDayButton;
    /**
     * @ignore
     * @deprecated Use {@link labelDayButton} instead.
     */
    labelDay: typeof labelDayButton;
    /** The label for the weekday. */
    labelWeekday: typeof labelWeekday;
    /** The label for the week number. */
    labelWeekNumber: typeof labelWeekNumber;
    /** The label for the column of week numbers. */
    labelWeekNumberHeader: typeof labelWeekNumberHeader;
};
/**
 * A value or a function that matches specific days.
 *
 * @example
 *   // Match weekends and specific holidays
 *   const matcher: Matcher = [
 *     { dayOfWeek: [0, 6] }, // Weekends
 *     { from: new Date(2023, 11, 24), to: new Date(2023, 11, 26) }, // Christmas
 *   ];
 */
export type Matcher = boolean | ((date: Date) => boolean) | Date | Date[] | DateRange | DateBefore | DateAfter | DateInterval | DayOfWeek;
/**
 * Match a day falling after the specified date (exclusive).
 *
 * @example
 *   // Match days after February 2, 2019
 *   const matcher: DateAfter = { after: new Date(2019, 1, 2) };
 */
export type DateAfter = {
    after: Date;
};
/**
 * Match a day falling before the specified date (exclusive).
 *
 * @example
 *   // Match days before February 2, 2019
 *   const matcher: DateBefore = { before: new Date(2019, 1, 2) };
 */
export type DateBefore = {
    before: Date;
};
/**
 * An interval of dates. Unlike {@link DateRange}, the range ends are not
 * included.
 *
 * @example
 *   // Match days between February 2 and February 5, 2019
 *   const matcher: DateInterval = {
 *     after: new Date(2019, 1, 2),
 *     before: new Date(2019, 1, 5),
 *   };
 */
export type DateInterval = {
    before: Date;
    after: Date;
};
/**
 * A range of dates. Unlike {@link DateInterval}, the range ends are included.
 *
 * @example
 *   // Match days between February 2 and February 5, 2019
 *   const matcher: DateRange = {
 *     from: new Date(2019, 1, 2),
 *     to: new Date(2019, 1, 5),
 *   };
 */
export type DateRange = {
    from: Date | undefined;
    to?: Date | undefined;
};
/**
 * Match days of the week (`0-6`, where `0` is Sunday).
 *
 * @example
 *   // Match Sundays
 *   const matcher: DayOfWeek = { dayOfWeek: 0 };
 *   // Match weekends
 *   const matcher: DayOfWeek = { dayOfWeek: [0, 6] };
 */
export type DayOfWeek = {
    dayOfWeek: number | number[];
};
/**
 * The event handler triggered when clicking or interacting with a day.
 *
 * @template EventType - The event type that triggered the event (e.g.
 *   `React.MouseEvent`, `React.KeyboardEvent`, etc.).
 * @param date - The date that has triggered the event.
 * @param modifiers - The modifiers belonging to the date.
 * @param e - The DOM event that triggered the event.
 */
export type DayEventHandler<EventType> = (date: Date, modifiers: Modifiers, e: EventType) => void;
/**
 * The event handler when a month is changed in the calendar.
 *
 * ```tsx
 * <DayPicker onMonthChange={(month) => console.log(month)} />
 * ```
 *
 * @see https://daypicker.dev/docs/navigation
 */
export type MonthChangeEventHandler = (month: Date) => void;
/**
 * The CSS classnames to use for the {@link UI} elements, the
 * {@link SelectionState} and the {@link DayFlag}.
 *
 * @example
 *   const classNames: ClassNames = {
 *     [UI.Root]: "root",
 *     [UI.Outside]: "outside",
 *     [UI.Nav]: "nav",
 *     // etc.
 *   };
 */
export type ClassNames = {
    [key in UI | SelectionState | DayFlag | Animation]: string;
};
/**
 * The CSS styles to use for the {@link UI} elements, the {@link SelectionState}
 * and the {@link DayFlag}.
 */
export type Styles = {
    [key in UI | SelectionState | DayFlag]: CSSProperties | undefined;
};
/**
 * Represents the modifiers that match a specific day in the calendar.
 *
 * @example
 *   const modifiers: Modifiers = {
 *     today: true, // The day is today
 *     selected: false, // The day is not selected
 *     weekend: true, // Custom modifier for weekends
 *   };
 *
 * @see https://daypicker.dev/guides/custom-modifiers
 */
export type Modifiers = Record<string, boolean>;
/**
 * The style to apply to each day element matching a modifier.
 *
 * @example
 *   const modifiersStyles: ModifiersStyles = {
 *     today: { color: "red" },
 *     selected: { backgroundColor: "blue" },
 *     weekend: { color: "green" },
 *   };
 */
export type ModifiersStyles = Record<string, CSSProperties>;
/**
 * The classnames to assign to each day element matching a modifier.
 *
 * @example
 *   const modifiersClassNames: ModifiersClassNames = {
 *     today: "today", // Use the "today" class for the today's day
 *     selected: "highlight", // Use the "highlight" class for the selected day
 *     weekend: "weekend", // Use the "weekend" class for the weekend days
 *   };
 */
export type ModifiersClassNames = Record<string, string>;
/**
 * The props that have been deprecated since version 9.0.0.
 *
 * @private
 * @since 9.0.0
 * @see https://daypicker.dev/upgrading
 */
export type V9DeprecatedProps = 
/** Use `hidden` prop instead. */
"fromDate"
/** Use `hidden` prop instead. */
 | "toDate"
/** Use `startMonth` instead. */
 | "fromMonth"
/** Use `endMonth` instead. */
 | "toMonth"
/** Use `startMonth` instead. */
 | "fromYear"
/** Use `endMonth` instead. */
 | "toYear";
/** The direction to move the focus relative to the current focused date. */
export type MoveFocusDir = "after" | "before";
/** The temporal unit to move the focus by. */
export type MoveFocusBy = "day" | "week" | "startOfWeek" | "endOfWeek" | "month" | "year";
/**
 * The numbering system supported by DayPicker.
 *
 * - `latn`: Latin (Western Arabic)
 * - `arab`: Arabic-Indic
 * - `arabext`: Eastern Arabic-Indic (Persian)
 * - `deva`: Devanagari
 * - `beng`: Bengali
 * - `guru`: Gurmukhi
 * - `gujr`: Gujarati
 * - `orya`: Oriya
 * - `tamldec`: Tamil
 * - `telu`: Telugu
 * - `knda`: Kannada
 * - `mlym`: Malayalam
 * - `thai`: Thai
 * - `mymr`: Myanmar
 * - `khmr`: Khmer
 * - `laoo`: Lao
 * - `tibt`: Tibetan
 *
 * @see https://daypicker.dev/docs/translation#numeral-systems
 */
export type Numerals = "latn" | "arab" | "arabext" | "deva" | "geez" | "beng" | "guru" | "gujr" | "orya" | "tamldec" | "telu" | "knda" | "mlym" | "thai" | "mymr" | "khmr" | "laoo" | "tibt";

~~~

## node_modules\react-day-picker\dist\cjs\types\shared.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

~~~

## node_modules\react-day-picker\dist\cjs\UI.d.ts

~~~ts
import type { CSSProperties } from "react";
/**
 * Enum representing the UI elements composing DayPicker. These elements are
 * mapped to {@link CustomComponents}, {@link ClassNames}, and {@link Styles}.
 *
 * Some elements are extended by flags and modifiers.
 */
export declare enum UI {
    /** The root component displaying the months and the navigation bar. */
    Root = "root",
    /** The Chevron SVG element used by navigation buttons and dropdowns. */
    Chevron = "chevron",
    /**
     * The grid cell with the day's date. Extended by {@link DayFlag} and
     * {@link SelectionState}.
     */
    Day = "day",
    /** The button containing the formatted day's date, inside the grid cell. */
    DayButton = "day_button",
    /** The caption label of the month (when not showing the dropdown navigation). */
    CaptionLabel = "caption_label",
    /** The container of the dropdown navigation (when enabled). */
    Dropdowns = "dropdowns",
    /** The dropdown element to select for years and months. */
    Dropdown = "dropdown",
    /** The container element of the dropdown. */
    DropdownRoot = "dropdown_root",
    /** The root element of the footer. */
    Footer = "footer",
    /** The month grid. */
    MonthGrid = "month_grid",
    /** Contains the dropdown navigation or the caption label. */
    MonthCaption = "month_caption",
    /** The dropdown with the months. */
    MonthsDropdown = "months_dropdown",
    /** Wrapper of the month grid. */
    Month = "month",
    /** The container of the displayed months. */
    Months = "months",
    /** The navigation bar with the previous and next buttons. */
    Nav = "nav",
    /**
     * The next month button in the navigation. *
     *
     * @since 9.1.0
     */
    NextMonthButton = "button_next",
    /**
     * The previous month button in the navigation.
     *
     * @since 9.1.0
     */
    PreviousMonthButton = "button_previous",
    /** The row containing the week. */
    Week = "week",
    /** The group of row weeks in a month (`tbody`). */
    Weeks = "weeks",
    /** The column header with the weekday. */
    Weekday = "weekday",
    /** The row grouping the weekdays in the column headers. */
    Weekdays = "weekdays",
    /** The cell containing the week number. */
    WeekNumber = "week_number",
    /** The cell header of the week numbers column. */
    WeekNumberHeader = "week_number_header",
    /** The dropdown with the years. */
    YearsDropdown = "years_dropdown"
}
/** Enum representing flags for the {@link UI.Day} element. */
export declare enum DayFlag {
    /** The day is disabled. */
    disabled = "disabled",
    /** The day is hidden. */
    hidden = "hidden",
    /** The day is outside the current month. */
    outside = "outside",
    /** The day is focused. */
    focused = "focused",
    /** The day is today. */
    today = "today"
}
/**
 * Enum representing selection states that can be applied to the {@link UI.Day}
 * element in selection mode.
 */
export declare enum SelectionState {
    /** The day is at the end of a selected range. */
    range_end = "range_end",
    /** The day is at the middle of a selected range. */
    range_middle = "range_middle",
    /** The day is at the start of a selected range. */
    range_start = "range_start",
    /** The day is selected. */
    selected = "selected"
}
/**
 * Enum representing different animation states for transitioning between
 * months.
 */
export declare enum Animation {
    /** The entering weeks when they appear before the exiting month. */
    weeks_before_enter = "weeks_before_enter",
    /** The exiting weeks when they disappear before the entering month. */
    weeks_before_exit = "weeks_before_exit",
    /** The entering weeks when they appear after the exiting month. */
    weeks_after_enter = "weeks_after_enter",
    /** The exiting weeks when they disappear after the entering month. */
    weeks_after_exit = "weeks_after_exit",
    /** The entering caption when it appears after the exiting month. */
    caption_after_enter = "caption_after_enter",
    /** The exiting caption when it disappears after the entering month. */
    caption_after_exit = "caption_after_exit",
    /** The entering caption when it appears before the exiting month. */
    caption_before_enter = "caption_before_enter",
    /** The exiting caption when it disappears before the entering month. */
    caption_before_exit = "caption_before_exit"
}
/**
 * Deprecated UI elements and flags from previous versions of DayPicker.
 *
 * These elements are kept for backward compatibility and to assist in
 * transitioning to the new {@link UI} elements.
 *
 * @deprecated
 * @since 9.0.1
 * @template T - The type of the deprecated UI element (e.g., CSS class or
 *   style).
 * @see https://daypicker.dev/upgrading
 * @see https://daypicker.dev/docs/styling
 */
export type DeprecatedUI<T extends CSSProperties | string> = {
    /**
     * This element was applied to the style of any button in DayPicker and it is
     * replaced by {@link UI.PreviousMonthButton} and {@link UI.NextMonthButton}.
     *
     * @deprecated
     */
    button: T;
    /**
     * This element was resetting the style of any button in DayPicker and it is
     * replaced by {@link UI.PreviousMonthButton} and {@link UI.NextMonthButton}.
     *
     * @deprecated
     */
    button_reset: T;
    /**
     * This element has been renamed to {@link UI.MonthCaption}.
     *
     * @deprecated
     */
    caption: T;
    /**
     * This element has been removed. Captions are styled via
     * {@link UI.MonthCaption}.
     *
     * @deprecated
     */
    caption_between: T;
    /**
     * This element has been renamed to {@link UI.Dropdowns}.
     *
     * @deprecated
     */
    caption_dropdowns: T;
    /**
     * This element has been removed. Captions are styled via
     * {@link UI.MonthCaption}.
     *
     * @deprecated
     */
    caption_end: T;
    /**
     * This element has been removed.
     *
     * @deprecated
     */
    caption_start: T;
    /**
     * This element has been renamed to {@link UI.Day}.
     *
     * @deprecated
     */
    cell: T;
    /**
     * This element has been renamed to {@link DayFlag.disabled}.
     *
     * @deprecated
     */
    day_disabled: T;
    /**
     * This element has been renamed to {@link DayFlag.hidden}.
     *
     * @deprecated
     */
    day_hidden: T;
    /**
     * This element has been renamed to {@link DayFlag.outside}.
     *
     * @deprecated
     */
    day_outside: T;
    /**
     * This element has been renamed to {@link SelectionState.range_end}.
     *
     * @deprecated
     */
    day_range_end: T;
    /**
     * This element has been renamed to {@link SelectionState.range_middle}.
     *
     * @deprecated
     */
    day_range_middle: T;
    /**
     * This element has been renamed to {@link SelectionState.range_start}.
     *
     * @deprecated
     */
    day_range_start: T;
    /**
     * This element has been renamed to {@link SelectionState.selected}.
     *
     * @deprecated
     */
    day_selected: T;
    /**
     * This element has been renamed to {@link DayFlag.today}.
     *
     * @deprecated
     */
    day_today: T;
    /**
     * This element has been removed. The dropdown icon is now {@link UI.Chevron}
     * inside a {@link UI.CaptionLabel}.
     *
     * @deprecated
     */
    dropdown_icon: T;
    /**
     * This element has been renamed to {@link UI.MonthsDropdown}.
     *
     * @deprecated
     */
    dropdown_month: T;
    /**
     * This element has been renamed to {@link UI.YearsDropdown}.
     *
     * @deprecated
     */
    dropdown_year: T;
    /**
     * This element has been removed.
     *
     * @deprecated
     */
    head: T;
    /**
     * This element has been renamed to {@link UI.Weekday}.
     *
     * @deprecated
     */
    head_cell: T;
    /**
     * This element has been renamed to {@link UI.Weekdays}.
     *
     * @deprecated
     */
    head_row: T;
    /**
     * This flag has been removed. Use `data-multiple-months` in your CSS
     * selectors.
     *
     * @deprecated
     */
    multiple_months: T;
    /**
     * This element has been removed. To style the navigation buttons, use
     * {@link UI.PreviousMonthButton} and {@link UI.NextMonthButton}.
     *
     * @deprecated
     */
    nav_button: T;
    /**
     * This element has been renamed to {@link UI.NextMonthButton}.
     *
     * @deprecated
     */
    nav_button_next: T;
    /**
     * This element has been renamed to {@link UI.PreviousMonthButton}.
     *
     * @deprecated
     */
    nav_button_previous: T;
    /**
     * This element has been removed. The dropdown icon is now {@link UI.Chevron}
     * inside a {@link UI.NextMonthButton} or a {@link UI.PreviousMonthButton}.
     *
     * @deprecated
     */
    nav_icon: T;
    /**
     * This element has been renamed to {@link UI.Week}.
     *
     * @deprecated
     */
    row: T;
    /**
     * This element has been renamed to {@link UI.MonthGrid}.
     *
     * @deprecated
     */
    table: T;
    /**
     * This element has been renamed to {@link UI.Weeks}.
     *
     * @deprecated
     */
    tbody: T;
    /**
     * This element has been removed. The {@link UI.Footer} is now a single element
     * below the months.
     *
     * @deprecated
     */
    tfoot: T;
    /**
     * This flag has been removed. There are no "visually hidden" elements in
     * DayPicker 9.
     *
     * @deprecated
     */
    vhidden: T;
    /**
     * This element has been renamed. Use {@link UI.WeekNumber} instead.
     *
     * @deprecated
     */
    weeknumber: T;
    /**
     * This flag has been removed. Use `data-week-numbers` in your CSS.
     *
     * @deprecated
     */
    with_weeknumber: T;
};

~~~

## node_modules\react-day-picker\dist\cjs\UI.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Animation = exports.SelectionState = exports.DayFlag = exports.UI = void 0;
/**
 * Enum representing the UI elements composing DayPicker. These elements are
 * mapped to {@link CustomComponents}, {@link ClassNames}, and {@link Styles}.
 *
 * Some elements are extended by flags and modifiers.
 */
var UI;
(function (UI) {
    /** The root component displaying the months and the navigation bar. */
    UI["Root"] = "root";
    /** The Chevron SVG element used by navigation buttons and dropdowns. */
    UI["Chevron"] = "chevron";
    /**
     * The grid cell with the day's date. Extended by {@link DayFlag} and
     * {@link SelectionState}.
     */
    UI["Day"] = "day";
    /** The button containing the formatted day's date, inside the grid cell. */
    UI["DayButton"] = "day_button";
    /** The caption label of the month (when not showing the dropdown navigation). */
    UI["CaptionLabel"] = "caption_label";
    /** The container of the dropdown navigation (when enabled). */
    UI["Dropdowns"] = "dropdowns";
    /** The dropdown element to select for years and months. */
    UI["Dropdown"] = "dropdown";
    /** The container element of the dropdown. */
    UI["DropdownRoot"] = "dropdown_root";
    /** The root element of the footer. */
    UI["Footer"] = "footer";
    /** The month grid. */
    UI["MonthGrid"] = "month_grid";
    /** Contains the dropdown navigation or the caption label. */
    UI["MonthCaption"] = "month_caption";
    /** The dropdown with the months. */
    UI["MonthsDropdown"] = "months_dropdown";
    /** Wrapper of the month grid. */
    UI["Month"] = "month";
    /** The container of the displayed months. */
    UI["Months"] = "months";
    /** The navigation bar with the previous and next buttons. */
    UI["Nav"] = "nav";
    /**
     * The next month button in the navigation. *
     *
     * @since 9.1.0
     */
    UI["NextMonthButton"] = "button_next";
    /**
     * The previous month button in the navigation.
     *
     * @since 9.1.0
     */
    UI["PreviousMonthButton"] = "button_previous";
    /** The row containing the week. */
    UI["Week"] = "week";
    /** The group of row weeks in a month (`tbody`). */
    UI["Weeks"] = "weeks";
    /** The column header with the weekday. */
    UI["Weekday"] = "weekday";
    /** The row grouping the weekdays in the column headers. */
    UI["Weekdays"] = "weekdays";
    /** The cell containing the week number. */
    UI["WeekNumber"] = "week_number";
    /** The cell header of the week numbers column. */
    UI["WeekNumberHeader"] = "week_number_header";
    /** The dropdown with the years. */
    UI["YearsDropdown"] = "years_dropdown";
})(UI || (exports.UI = UI = {}));
/** Enum representing flags for the {@link UI.Day} element. */
var DayFlag;
(function (DayFlag) {
    /** The day is disabled. */
    DayFlag["disabled"] = "disabled";
    /** The day is hidden. */
    DayFlag["hidden"] = "hidden";
    /** The day is outside the current month. */
    DayFlag["outside"] = "outside";
    /** The day is focused. */
    DayFlag["focused"] = "focused";
    /** The day is today. */
    DayFlag["today"] = "today";
})(DayFlag || (exports.DayFlag = DayFlag = {}));
/**
 * Enum representing selection states that can be applied to the {@link UI.Day}
 * element in selection mode.
 */
var SelectionState;
(function (SelectionState) {
    /** The day is at the end of a selected range. */
    SelectionState["range_end"] = "range_end";
    /** The day is at the middle of a selected range. */
    SelectionState["range_middle"] = "range_middle";
    /** The day is at the start of a selected range. */
    SelectionState["range_start"] = "range_start";
    /** The day is selected. */
    SelectionState["selected"] = "selected";
})(SelectionState || (exports.SelectionState = SelectionState = {}));
/**
 * Enum representing different animation states for transitioning between
 * months.
 */
var Animation;
(function (Animation) {
    /** The entering weeks when they appear before the exiting month. */
    Animation["weeks_before_enter"] = "weeks_before_enter";
    /** The exiting weeks when they disappear before the entering month. */
    Animation["weeks_before_exit"] = "weeks_before_exit";
    /** The entering weeks when they appear after the exiting month. */
    Animation["weeks_after_enter"] = "weeks_after_enter";
    /** The exiting weeks when they disappear after the entering month. */
    Animation["weeks_after_exit"] = "weeks_after_exit";
    /** The entering caption when it appears after the exiting month. */
    Animation["caption_after_enter"] = "caption_after_enter";
    /** The exiting caption when it disappears after the entering month. */
    Animation["caption_after_exit"] = "caption_after_exit";
    /** The entering caption when it appears before the exiting month. */
    Animation["caption_before_enter"] = "caption_before_enter";
    /** The exiting caption when it disappears before the entering month. */
    Animation["caption_before_exit"] = "caption_before_exit";
})(Animation || (exports.Animation = Animation = {}));

~~~

## node_modules\react-day-picker\dist\cjs\useAnimation.d.ts

~~~ts
import type React from "react";
import type { CalendarDay } from "./classes/CalendarDay.js";
import type { CalendarMonth } from "./classes/CalendarMonth.js";
import type { DateLib } from "./classes/DateLib.js";
import type { ClassNames } from "./types/shared.js";
/**
 * Handles animations for transitioning between months in the DayPicker
 * component.
 *
 * @private
 * @param rootElRef - A reference to the root element of the DayPicker
 *   component.
 * @param enabled - Whether animations are enabled.
 * @param options - Configuration options for the animation, including class
 *   names, months, focused day, and the date utility library.
 */
export declare function useAnimation(rootElRef: React.RefObject<HTMLDivElement | null>, enabled: boolean, { classNames, months, focused, dateLib, }: {
    classNames: ClassNames;
    months: CalendarMonth[];
    focused: CalendarDay | undefined;
    dateLib: DateLib;
}): void;

~~~

## node_modules\react-day-picker\dist\cjs\useAnimation.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useAnimation = useAnimation;
const react_1 = require("react");
const UI_js_1 = require("./UI.js");
const asHtmlElement = (element) => {
    if (element instanceof HTMLElement)
        return element;
    return null;
};
const queryMonthEls = (element) => [
    ...(element.querySelectorAll("[data-animated-month]") ?? []),
];
const queryMonthEl = (element) => asHtmlElement(element.querySelector("[data-animated-month]"));
const queryCaptionEl = (element) => asHtmlElement(element.querySelector("[data-animated-caption]"));
const queryWeeksEl = (element) => asHtmlElement(element.querySelector("[data-animated-weeks]"));
const queryNavEl = (element) => asHtmlElement(element.querySelector("[data-animated-nav]"));
const queryWeekdaysEl = (element) => asHtmlElement(element.querySelector("[data-animated-weekdays]"));
/**
 * Handles animations for transitioning between months in the DayPicker
 * component.
 *
 * @private
 * @param rootElRef - A reference to the root element of the DayPicker
 *   component.
 * @param enabled - Whether animations are enabled.
 * @param options - Configuration options for the animation, including class
 *   names, months, focused day, and the date utility library.
 */
function useAnimation(rootElRef, enabled, { classNames, months, focused, dateLib, }) {
    const previousRootElSnapshotRef = (0, react_1.useRef)(null);
    const previousMonthsRef = (0, react_1.useRef)(months);
    const animatingRef = (0, react_1.useRef)(false);
    (0, react_1.useLayoutEffect)(() => {
        // get previous months before updating the previous months ref
        const previousMonths = previousMonthsRef.current;
        // update previous months ref for next effect trigger
        previousMonthsRef.current = months;
        if (!enabled ||
            !rootElRef.current ||
            // safety check because the ref can be set to anything by consumers
            !(rootElRef.current instanceof HTMLElement) ||
            // validation required for the animation to work as expected
            months.length === 0 ||
            previousMonths.length === 0 ||
            months.length !== previousMonths.length) {
            return;
        }
        const isSameMonth = dateLib.isSameMonth(months[0].date, previousMonths[0].date);
        const isAfterPreviousMonth = dateLib.isAfter(months[0].date, previousMonths[0].date);
        const captionAnimationClass = isAfterPreviousMonth
            ? classNames[UI_js_1.Animation.caption_after_enter]
            : classNames[UI_js_1.Animation.caption_before_enter];
        const weeksAnimationClass = isAfterPreviousMonth
            ? classNames[UI_js_1.Animation.weeks_after_enter]
            : classNames[UI_js_1.Animation.weeks_before_enter];
        // get previous root element snapshot before updating the snapshot ref
        const previousRootElSnapshot = previousRootElSnapshotRef.current;
        // update snapshot for next effect trigger
        const rootElSnapshot = rootElRef.current.cloneNode(true);
        if (rootElSnapshot instanceof HTMLElement) {
            // if this effect is triggered while animating, we need to clean up the new root snapshot
            // to put it in the same state as when not animating, to correctly animate the next month change
            const currentMonthElsSnapshot = queryMonthEls(rootElSnapshot);
            currentMonthElsSnapshot.forEach((currentMonthElSnapshot) => {
                if (!(currentMonthElSnapshot instanceof HTMLElement))
                    return;
                // remove the old month snapshots from the new root snapshot
                const previousMonthElSnapshot = queryMonthEl(currentMonthElSnapshot);
                if (previousMonthElSnapshot &&
                    currentMonthElSnapshot.contains(previousMonthElSnapshot)) {
                    currentMonthElSnapshot.removeChild(previousMonthElSnapshot);
                }
                // remove animation classes from the new month snapshots
                const captionEl = queryCaptionEl(currentMonthElSnapshot);
                if (captionEl) {
                    captionEl.classList.remove(captionAnimationClass);
                }
                const weeksEl = queryWeeksEl(currentMonthElSnapshot);
                if (weeksEl) {
                    weeksEl.classList.remove(weeksAnimationClass);
                }
            });
            previousRootElSnapshotRef.current = rootElSnapshot;
        }
        else {
            previousRootElSnapshotRef.current = null;
        }
        if (animatingRef.current ||
            isSameMonth ||
            // skip animation if a day is focused because it can cause issues to the animation and is better for a11y
            focused) {
            return;
        }
        const previousMonthEls = previousRootElSnapshot instanceof HTMLElement
            ? queryMonthEls(previousRootElSnapshot)
            : [];
        const currentMonthEls = queryMonthEls(rootElRef.current);
        if (currentMonthEls?.every((el) => el instanceof HTMLElement) &&
            previousMonthEls &&
            previousMonthEls.every((el) => el instanceof HTMLElement)) {
            animatingRef.current = true;
            const cleanUpFunctions = [];
            // set isolation to isolate to isolate the stacking context during animation
            rootElRef.current.style.isolation = "isolate";
            // set z-index to 1 to ensure the nav is clickable over the other elements being animated
            const navEl = queryNavEl(rootElRef.current);
            if (navEl) {
                navEl.style.zIndex = "1";
            }
            currentMonthEls.forEach((currentMonthEl, index) => {
                const previousMonthEl = previousMonthEls[index];
                if (!previousMonthEl) {
                    return;
                }
                // animate new displayed month
                currentMonthEl.style.position = "relative";
                currentMonthEl.style.overflow = "hidden";
                const captionEl = queryCaptionEl(currentMonthEl);
                if (captionEl) {
                    captionEl.classList.add(captionAnimationClass);
                }
                const weeksEl = queryWeeksEl(currentMonthEl);
                if (weeksEl) {
                    weeksEl.classList.add(weeksAnimationClass);
                }
                // animate new displayed month end
                const cleanUp = () => {
                    animatingRef.current = false;
                    if (rootElRef.current) {
                        rootElRef.current.style.isolation = "";
                    }
                    if (navEl) {
                        navEl.style.zIndex = "";
                    }
                    if (captionEl) {
                        captionEl.classList.remove(captionAnimationClass);
                    }
                    if (weeksEl) {
                        weeksEl.classList.remove(weeksAnimationClass);
                    }
                    currentMonthEl.style.position = "";
                    currentMonthEl.style.overflow = "";
                    if (currentMonthEl.contains(previousMonthEl)) {
                        currentMonthEl.removeChild(previousMonthEl);
                    }
                };
                cleanUpFunctions.push(cleanUp);
                // animate old displayed month
                previousMonthEl.style.pointerEvents = "none";
                previousMonthEl.style.position = "absolute";
                previousMonthEl.style.overflow = "hidden";
                previousMonthEl.setAttribute("aria-hidden", "true");
                // hide the weekdays container of the old month and only the new one
                const previousWeekdaysEl = queryWeekdaysEl(previousMonthEl);
                if (previousWeekdaysEl) {
                    previousWeekdaysEl.style.opacity = "0";
                }
                const previousCaptionEl = queryCaptionEl(previousMonthEl);
                if (previousCaptionEl) {
                    previousCaptionEl.classList.add(isAfterPreviousMonth
                        ? classNames[UI_js_1.Animation.caption_before_exit]
                        : classNames[UI_js_1.Animation.caption_after_exit]);
                    previousCaptionEl.addEventListener("animationend", cleanUp);
                }
                const previousWeeksEl = queryWeeksEl(previousMonthEl);
                if (previousWeeksEl) {
                    previousWeeksEl.classList.add(isAfterPreviousMonth
                        ? classNames[UI_js_1.Animation.weeks_before_exit]
                        : classNames[UI_js_1.Animation.weeks_after_exit]);
                }
                currentMonthEl.insertBefore(previousMonthEl, currentMonthEl.firstChild);
            });
        }
    });
}

~~~

## node_modules\react-day-picker\dist\cjs\useCalendar.d.ts

~~~ts
import type { CalendarDay, CalendarMonth, CalendarWeek, DateLib } from "./classes/index.js";
import type { DayPickerProps } from "./types/props.js";
/**
 * Return the calendar object to work with the calendar in custom components.
 *
 * @see https://daypicker.dev/guides/custom-components
 */
export interface Calendar {
    /**
     * All the days displayed in the calendar. As opposite from
     * {@link CalendarContext.dates}, it may return duplicated dates when shown
     * outside the month.
     */
    days: CalendarDay[];
    /** The months displayed in the calendar. */
    weeks: CalendarWeek[];
    /** The months displayed in the calendar. */
    months: CalendarMonth[];
    /** The next month to display. */
    nextMonth: Date | undefined;
    /** The previous month to display. */
    previousMonth: Date | undefined;
    /**
     * The month where the navigation starts. `undefined` if the calendar can be
     * navigated indefinitely to the past.
     */
    navStart: Date | undefined;
    /**
     * The month where the navigation ends. `undefined` if the calendar can be
     * navigated indefinitely to the past.
     */
    navEnd: Date | undefined;
    /** Navigate to the specified month. Will fire the `onMonthChange` callback. */
    goToMonth: (month: Date) => void;
    /**
     * Navigate to the specified date. If the second parameter (refDate) is
     * provided and the date is before the refDate, then the month is set to one
     * month before the date.
     *
     * @param day - The date to navigate to.
     * @param dateToCompare - Optional. If `date` is before `dateToCompare`, the
     *   month is set to one month before the date.
     */
    goToDay: (day: CalendarDay) => void;
}
/**
 * Provides the calendar object to work with the calendar in custom components.
 *
 * @private
 * @param props - The DayPicker props related to calendar configuration.
 * @param dateLib - The date utility library instance.
 * @returns The calendar object containing displayed days, weeks, months, and
 *   navigation methods.
 */
export declare function useCalendar(props: Pick<DayPickerProps, "captionLayout" | "endMonth" | "startMonth" | "today" | "fixedWeeks" | "ISOWeek" | "numberOfMonths" | "disableNavigation" | "onMonthChange" | "month" | "defaultMonth" | "timeZone" | "broadcastCalendar" | "fromMonth" | "fromYear" | "toMonth" | "toYear">, dateLib: DateLib): Calendar;

~~~

## node_modules\react-day-picker\dist\cjs\useCalendar.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCalendar = useCalendar;
const react_1 = require("react");
const getDates_js_1 = require("./helpers/getDates.js");
const getDays_js_1 = require("./helpers/getDays.js");
const getDisplayMonths_js_1 = require("./helpers/getDisplayMonths.js");
const getInitialMonth_js_1 = require("./helpers/getInitialMonth.js");
const getMonths_js_1 = require("./helpers/getMonths.js");
const getNavMonth_js_1 = require("./helpers/getNavMonth.js");
const getNextMonth_js_1 = require("./helpers/getNextMonth.js");
const getPreviousMonth_js_1 = require("./helpers/getPreviousMonth.js");
const getWeeks_js_1 = require("./helpers/getWeeks.js");
const useControlledValue_js_1 = require("./helpers/useControlledValue.js");
/**
 * Provides the calendar object to work with the calendar in custom components.
 *
 * @private
 * @param props - The DayPicker props related to calendar configuration.
 * @param dateLib - The date utility library instance.
 * @returns The calendar object containing displayed days, weeks, months, and
 *   navigation methods.
 */
function useCalendar(props, dateLib) {
    const [navStart, navEnd] = (0, getNavMonth_js_1.getNavMonths)(props, dateLib);
    const { startOfMonth, endOfMonth } = dateLib;
    const initialMonth = (0, getInitialMonth_js_1.getInitialMonth)(props, navStart, navEnd, dateLib);
    const [firstMonth, setFirstMonth] = (0, useControlledValue_js_1.useControlledValue)(initialMonth, 
    // initialMonth is always computed from props.month if provided
    props.month ? initialMonth : undefined);
    // biome-ignore lint/correctness/useExhaustiveDependencies: change the initial month when the time zone changes.
    (0, react_1.useEffect)(() => {
        const newInitialMonth = (0, getInitialMonth_js_1.getInitialMonth)(props, navStart, navEnd, dateLib);
        setFirstMonth(newInitialMonth);
    }, [props.timeZone]);
    /** The months displayed in the calendar. */
    const displayMonths = (0, getDisplayMonths_js_1.getDisplayMonths)(firstMonth, navEnd, props, dateLib);
    /** The dates displayed in the calendar. */
    const dates = (0, getDates_js_1.getDates)(displayMonths, props.endMonth ? endOfMonth(props.endMonth) : undefined, props, dateLib);
    /** The Months displayed in the calendar. */
    const months = (0, getMonths_js_1.getMonths)(displayMonths, dates, props, dateLib);
    /** The Weeks displayed in the calendar. */
    const weeks = (0, getWeeks_js_1.getWeeks)(months);
    /** The Days displayed in the calendar. */
    const days = (0, getDays_js_1.getDays)(months);
    const previousMonth = (0, getPreviousMonth_js_1.getPreviousMonth)(firstMonth, navStart, props, dateLib);
    const nextMonth = (0, getNextMonth_js_1.getNextMonth)(firstMonth, navEnd, props, dateLib);
    const { disableNavigation, onMonthChange } = props;
    const isDayInCalendar = (day) => weeks.some((week) => week.days.some((d) => d.isEqualTo(day)));
    const goToMonth = (date) => {
        if (disableNavigation) {
            return;
        }
        let newMonth = startOfMonth(date);
        // if month is before start, use the first month instead
        if (navStart && newMonth < startOfMonth(navStart)) {
            newMonth = startOfMonth(navStart);
        }
        // if month is after endMonth, use the last month instead
        if (navEnd && newMonth > startOfMonth(navEnd)) {
            newMonth = startOfMonth(navEnd);
        }
        setFirstMonth(newMonth);
        onMonthChange?.(newMonth);
    };
    const goToDay = (day) => {
        // is this check necessary?
        if (isDayInCalendar(day)) {
            return;
        }
        goToMonth(day.date);
    };
    const calendar = {
        months,
        weeks,
        days,
        navStart,
        navEnd,
        previousMonth,
        nextMonth,
        goToMonth,
        goToDay,
    };
    return calendar;
}

~~~

## node_modules\react-day-picker\dist\cjs\useDayPicker.d.ts

~~~ts
import type { CalendarDay } from "./classes/CalendarDay.js";
import type { CalendarMonth } from "./classes/CalendarMonth.js";
import type { DayPickerProps } from "./types/props.js";
import type { SelectedValue, SelectHandler } from "./types/selection.js";
import type { ClassNames, CustomComponents, Formatters, Labels, Mode, Modifiers, Styles } from "./types/shared.js";
/** @ignore */
export declare const dayPickerContext: import("react").Context<DayPickerContext<{
    mode?: Mode | undefined;
    required?: boolean | undefined;
}> | undefined>;
/**
 * Represents the context for the DayPicker component, providing various
 * properties and methods to interact with the calendar.
 *
 * @template T - The type of the DayPicker props, which must optionally include
 *   `mode` and `required` properties. This type can be used to refine the type
 *   returned by the hook.
 */
export type DayPickerContext<T extends {
    mode?: Mode | undefined;
    required?: boolean | undefined;
}> = {
    /** The months displayed in the calendar. */
    months: CalendarMonth[];
    /** The next month to display. */
    nextMonth: Date | undefined;
    /** The previous month to display. */
    previousMonth: Date | undefined;
    /** Navigate to the specified month. Will fire the `onMonthChange` callback. */
    goToMonth: (month: Date) => void;
    /** Returns the modifiers for the given day. */
    getModifiers: (day: CalendarDay) => Modifiers;
    /** The selected date(s). */
    selected: SelectedValue<T> | undefined;
    /** Set a selection. */
    select: SelectHandler<T> | undefined;
    /** Whether the given date is selected. */
    isSelected: ((date: Date) => boolean) | undefined;
    /** The components used internally by DayPicker. */
    components: CustomComponents;
    /** The class names for the UI elements. */
    classNames: ClassNames;
    /** The styles for the UI elements. */
    styles: Partial<Styles> | undefined;
    /** The labels used in the user interface. */
    labels: Labels;
    /** The formatters used to format the UI elements. */
    formatters: Formatters;
    /**
     * The props as passed to the DayPicker component.
     *
     * @since 9.3.0
     */
    dayPickerProps: DayPickerProps;
};
/**
 * Provides access to the DayPicker context, which includes properties and
 * methods to interact with the DayPicker component. This hook must be used
 * within a custom component.
 *
 * @template T - Use this type to refine the returned context type with a
 *   specific selection mode.
 * @returns The context to work with DayPicker.
 * @throws {Error} If the hook is used outside of a DayPicker provider.
 * @group Hooks
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function useDayPicker<T extends {
    mode?: Mode | undefined;
    required?: boolean | undefined;
}>(): DayPickerContext<T>;

~~~

## node_modules\react-day-picker\dist\cjs\useDayPicker.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dayPickerContext = void 0;
exports.useDayPicker = useDayPicker;
const react_1 = require("react");
/** @ignore */
exports.dayPickerContext = (0, react_1.createContext)(undefined);
/**
 * Provides access to the DayPicker context, which includes properties and
 * methods to interact with the DayPicker component. This hook must be used
 * within a custom component.
 *
 * @template T - Use this type to refine the returned context type with a
 *   specific selection mode.
 * @returns The context to work with DayPicker.
 * @throws {Error} If the hook is used outside of a DayPicker provider.
 * @group Hooks
 * @see https://daypicker.dev/guides/custom-components
 */
function useDayPicker() {
    const context = (0, react_1.useContext)(exports.dayPickerContext);
    if (context === undefined) {
        throw new Error("useDayPicker() must be used within a custom component.");
    }
    return context;
}

~~~

## node_modules\react-day-picker\dist\cjs\useFocus.d.ts

~~~ts
import type { CalendarDay, DateLib } from "./classes/index.js";
import type { DayPickerProps, Modifiers, MoveFocusBy, MoveFocusDir } from "./types/index.js";
import type { Calendar } from "./useCalendar.js";
export type UseFocus = {
    /** The date that is currently focused. */
    focused: CalendarDay | undefined;
    /** Check if the given day is the focus target when entering the calendar. */
    isFocusTarget: (day: CalendarDay) => boolean;
    /** Focus the given day. */
    setFocused: (day: CalendarDay | undefined) => void;
    /** Blur the focused day. */
    blur: () => void;
    /** Move the current focus to the next day according to the given direction. */
    moveFocus: (moveBy: MoveFocusBy, moveDir: MoveFocusDir) => void;
};
/**
 * Manages focus behavior for the DayPicker component, including setting,
 * moving, and blurring focus on calendar days.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param calendar - The calendar object containing the displayed days and
 *   months.
 * @param getModifiers - A function to retrieve modifiers for a given day.
 * @param isSelected - A function to check if a date is selected.
 * @param dateLib - The date utility library instance.
 * @returns An object containing focus-related methods and the currently focused
 *   day.
 */
export declare function useFocus<T extends DayPickerProps>(props: T, calendar: Calendar, getModifiers: (day: CalendarDay) => Modifiers, isSelected: (date: Date) => boolean, dateLib: DateLib): UseFocus;

~~~

## node_modules\react-day-picker\dist\cjs\useFocus.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFocus = useFocus;
const react_1 = require("react");
const calculateFocusTarget_js_1 = require("./helpers/calculateFocusTarget.js");
const getNextFocus_js_1 = require("./helpers/getNextFocus.js");
/**
 * Manages focus behavior for the DayPicker component, including setting,
 * moving, and blurring focus on calendar days.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param calendar - The calendar object containing the displayed days and
 *   months.
 * @param getModifiers - A function to retrieve modifiers for a given day.
 * @param isSelected - A function to check if a date is selected.
 * @param dateLib - The date utility library instance.
 * @returns An object containing focus-related methods and the currently focused
 *   day.
 */
function useFocus(props, calendar, getModifiers, isSelected, dateLib) {
    const { autoFocus } = props;
    const [lastFocused, setLastFocused] = (0, react_1.useState)();
    const focusTarget = (0, calculateFocusTarget_js_1.calculateFocusTarget)(calendar.days, getModifiers, isSelected || (() => false), lastFocused);
    const [focusedDay, setFocused] = (0, react_1.useState)(autoFocus ? focusTarget : undefined);
    const blur = () => {
        setLastFocused(focusedDay);
        setFocused(undefined);
    };
    const moveFocus = (moveBy, moveDir) => {
        if (!focusedDay)
            return;
        const nextFocus = (0, getNextFocus_js_1.getNextFocus)(moveBy, moveDir, focusedDay, calendar.navStart, calendar.navEnd, props, dateLib);
        if (!nextFocus)
            return;
        if (props.disableNavigation) {
            const isNextInCalendar = calendar.days.some((day) => day.isEqualTo(nextFocus));
            if (!isNextInCalendar) {
                return;
            }
        }
        calendar.goToDay(nextFocus);
        setFocused(nextFocus);
    };
    const isFocusTarget = (day) => {
        return Boolean(focusTarget?.isEqualTo(day));
    };
    const useFocus = {
        isFocusTarget,
        setFocused,
        focused: focusedDay,
        blur,
        moveFocus,
    };
    return useFocus;
}

~~~

## node_modules\react-day-picker\dist\cjs\useSelection.d.ts

~~~ts
import type { DateLib } from "./classes/DateLib.js";
import type { DayPickerProps } from "./types/index.js";
import type { Selection } from "./types/selection.js";
/**
 * Determines the appropriate selection hook to use based on the selection mode
 * and returns the corresponding selection object.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns The selection object for the specified mode, or `undefined` if no
 *   mode is set.
 */
export declare function useSelection<T extends DayPickerProps>(props: T, dateLib: DateLib): Selection<T> | undefined;

~~~

## node_modules\react-day-picker\dist\cjs\useSelection.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useSelection = useSelection;
const useMulti_js_1 = require("./selection/useMulti.js");
const useRange_js_1 = require("./selection/useRange.js");
const useSingle_js_1 = require("./selection/useSingle.js");
/**
 * Determines the appropriate selection hook to use based on the selection mode
 * and returns the corresponding selection object.
 *
 * @template T - The type of DayPicker props.
 * @param props - The DayPicker props.
 * @param dateLib - The date utility library instance.
 * @returns The selection object for the specified mode, or `undefined` if no
 *   mode is set.
 */
function useSelection(props, dateLib) {
    const single = (0, useSingle_js_1.useSingle)(props, dateLib);
    const multi = (0, useMulti_js_1.useMulti)(props, dateLib);
    const range = (0, useRange_js_1.useRange)(props, dateLib);
    switch (props.mode) {
        case "single":
            return single;
        case "multiple":
            return multi;
        case "range":
            return range;
        default:
            return undefined;
    }
}

~~~

## node_modules\react-day-picker\dist\cjs\utc.d.ts

~~~ts
import React from "react";
import { type DayPickerProps } from "./index.js";
/**
 * @deprecated Use the `timeZone` prop instead of this function. This function
 *   wraps the DayPicker component and sets the `timeZone` to "utc".
 * @param props - The props to pass to the DayPicker component.
 * @returns The DayPicker component with the `timeZone` set to "utc".
 */
export declare function DayPicker(props: DayPickerProps): React.JSX.Element;

~~~

## node_modules\react-day-picker\dist\cjs\utc.js

~~~js
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DayPicker = DayPicker;
const react_1 = __importDefault(require("react"));
const index_js_1 = require("./index.js");
/**
 * @deprecated Use the `timeZone` prop instead of this function. This function
 *   wraps the DayPicker component and sets the `timeZone` to "utc".
 * @param props - The props to pass to the DayPicker component.
 * @returns The DayPicker component with the `timeZone` set to "utc".
 */
function DayPicker(props) {
    return react_1.default.createElement(index_js_1.DayPicker, { timeZone: "utc", ...props });
}

~~~

## node_modules\react-day-picker\dist\cjs\utils\addToRange.d.ts

~~~ts
import { type DateLib } from "../classes/DateLib.js";
import type { DateRange } from "../types/index.js";
/**
 * Adds a date to an existing range, considering constraints like minimum and
 * maximum range size.
 *
 * @param date - The date to add to the range.
 * @param initialRange - The initial range to which the date will be added.
 * @param min - The minimum number of days in the range.
 * @param max - The maximum number of days in the range.
 * @param required - Whether the range must always include at least one date.
 * @param dateLib - The date utility library instance.
 * @returns The updated date range, or `undefined` if the range is cleared.
 * @group Utilities
 */
export declare function addToRange(date: Date, initialRange: DateRange | undefined, min?: number, max?: number, required?: boolean, dateLib?: DateLib): DateRange | undefined;

~~~

## node_modules\react-day-picker\dist\cjs\utils\addToRange.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addToRange = addToRange;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Adds a date to an existing range, considering constraints like minimum and
 * maximum range size.
 *
 * @param date - The date to add to the range.
 * @param initialRange - The initial range to which the date will be added.
 * @param min - The minimum number of days in the range.
 * @param max - The maximum number of days in the range.
 * @param required - Whether the range must always include at least one date.
 * @param dateLib - The date utility library instance.
 * @returns The updated date range, or `undefined` if the range is cleared.
 * @group Utilities
 */
function addToRange(date, initialRange, min = 0, max = 0, required = false, dateLib = DateLib_js_1.defaultDateLib) {
    const { from, to } = initialRange || {};
    const { isSameDay, isAfter, isBefore } = dateLib;
    let range;
    if (!from && !to) {
        // the range is empty, add the date
        range = { from: date, to: min > 0 ? undefined : date };
    }
    else if (from && !to) {
        // adding date to an incomplete range
        if (isSameDay(from, date)) {
            // adding a date equal to the start of the range
            if (min === 0) {
                range = { from, to: date };
            }
            else if (required) {
                range = { from, to: undefined };
            }
            else {
                range = undefined;
            }
        }
        else if (isBefore(date, from)) {
            // adding a date before the start of the range
            range = { from: date, to: from };
        }
        else {
            // adding a date after the start of the range
            range = { from, to: date };
        }
    }
    else if (from && to) {
        // adding date to a complete range
        if (isSameDay(from, date) && isSameDay(to, date)) {
            // adding a date that is equal to both start and end of the range
            if (required) {
                range = { from, to };
            }
            else {
                range = undefined;
            }
        }
        else if (isSameDay(from, date)) {
            // adding a date equal to the the start of the range
            range = { from, to: min > 0 ? undefined : date };
        }
        else if (isSameDay(to, date)) {
            // adding a dare equal to the end of the range
            range = { from: date, to: min > 0 ? undefined : date };
        }
        else if (isBefore(date, from)) {
            // adding a date before the start of the range
            range = { from: date, to: to };
        }
        else if (isAfter(date, from)) {
            // adding a date after the start of the range
            range = { from, to: date };
        }
        else if (isAfter(date, to)) {
            // adding a date after the end of the range
            range = { from, to: date };
        }
        else {
            throw new Error("Invalid range");
        }
    }
    // check for min / max
    if (range?.from && range?.to) {
        const diff = dateLib.differenceInCalendarDays(range.to, range.from);
        if (max > 0 && diff > max) {
            range = { from: date, to: undefined };
        }
        else if (min > 1 && diff < min) {
            range = { from: date, to: undefined };
        }
    }
    return range;
}

~~~

## node_modules\react-day-picker\dist\cjs\utils\dateMatchModifiers.d.ts

~~~ts
import { type DateLib } from "../classes/DateLib.js";
import type { Matcher } from "../types/index.js";
/**
 * Checks if a given date matches at least one of the specified {@link Matcher}.
 *
 * @param date - The date to check.
 * @param matchers - The matchers to check against.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the date matches any of the matchers, otherwise `false`.
 * @group Utilities
 */
export declare function dateMatchModifiers(date: Date, matchers: Matcher | Matcher[], dateLib?: DateLib): boolean;
/**
 * @private
 * @deprecated Use {@link dateMatchModifiers} instead.
 */
export declare const isMatch: typeof dateMatchModifiers;

~~~

## node_modules\react-day-picker\dist\cjs\utils\dateMatchModifiers.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isMatch = void 0;
exports.dateMatchModifiers = dateMatchModifiers;
const DateLib_js_1 = require("../classes/DateLib.js");
const rangeIncludesDate_js_1 = require("./rangeIncludesDate.js");
const typeguards_js_1 = require("./typeguards.js");
/**
 * Checks if a given date matches at least one of the specified {@link Matcher}.
 *
 * @param date - The date to check.
 * @param matchers - The matchers to check against.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the date matches any of the matchers, otherwise `false`.
 * @group Utilities
 */
function dateMatchModifiers(date, matchers, dateLib = DateLib_js_1.defaultDateLib) {
    const matchersArr = !Array.isArray(matchers) ? [matchers] : matchers;
    const { isSameDay, differenceInCalendarDays, isAfter } = dateLib;
    return matchersArr.some((matcher) => {
        if (typeof matcher === "boolean") {
            return matcher;
        }
        if (dateLib.isDate(matcher)) {
            return isSameDay(date, matcher);
        }
        if ((0, typeguards_js_1.isDatesArray)(matcher, dateLib)) {
            return matcher.includes(date);
        }
        if ((0, typeguards_js_1.isDateRange)(matcher)) {
            return (0, rangeIncludesDate_js_1.rangeIncludesDate)(matcher, date, false, dateLib);
        }
        if ((0, typeguards_js_1.isDayOfWeekType)(matcher)) {
            if (!Array.isArray(matcher.dayOfWeek)) {
                return matcher.dayOfWeek === date.getDay();
            }
            return matcher.dayOfWeek.includes(date.getDay());
        }
        if ((0, typeguards_js_1.isDateInterval)(matcher)) {
            const diffBefore = differenceInCalendarDays(matcher.before, date);
            const diffAfter = differenceInCalendarDays(matcher.after, date);
            const isDayBefore = diffBefore > 0;
            const isDayAfter = diffAfter < 0;
            const isClosedInterval = isAfter(matcher.before, matcher.after);
            if (isClosedInterval) {
                return isDayAfter && isDayBefore;
            }
            else {
                return isDayBefore || isDayAfter;
            }
        }
        if ((0, typeguards_js_1.isDateAfterType)(matcher)) {
            return differenceInCalendarDays(date, matcher.after) > 0;
        }
        if ((0, typeguards_js_1.isDateBeforeType)(matcher)) {
            return differenceInCalendarDays(matcher.before, date) > 0;
        }
        if (typeof matcher === "function") {
            return matcher(date);
        }
        return false;
    });
}
/**
 * @private
 * @deprecated Use {@link dateMatchModifiers} instead.
 */
exports.isMatch = dateMatchModifiers;

~~~

## node_modules\react-day-picker\dist\cjs\utils\index.d.ts

~~~ts
export * from "./addToRange.js";
export * from "./dateMatchModifiers.js";
export * from "./rangeContainsDayOfWeek.js";
export * from "./rangeContainsModifiers.js";
export * from "./rangeIncludesDate.js";
export * from "./rangeOverlaps.js";
export * from "./typeguards.js";

~~~

## node_modules\react-day-picker\dist\cjs\utils\index.js

~~~js
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./addToRange.js"), exports);
__exportStar(require("./dateMatchModifiers.js"), exports);
__exportStar(require("./rangeContainsDayOfWeek.js"), exports);
__exportStar(require("./rangeContainsModifiers.js"), exports);
__exportStar(require("./rangeIncludesDate.js"), exports);
__exportStar(require("./rangeOverlaps.js"), exports);
__exportStar(require("./typeguards.js"), exports);

~~~

## node_modules\react-day-picker\dist\cjs\utils\rangeContainsDayOfWeek.d.ts

~~~ts
import { type DateLib } from "../classes/DateLib.js";
/**
 * Checks if a date range contains one or more specified days of the week.
 *
 * @since 9.2.2
 * @param range - The date range to check.
 * @param dayOfWeek - The day(s) of the week to check for (`0-6`, where `0` is
 *   Sunday).
 * @param dateLib - The date utility library instance.
 * @returns `true` if the range contains the specified day(s) of the week,
 *   otherwise `false`.
 * @group Utilities
 */
export declare function rangeContainsDayOfWeek(range: {
    from: Date;
    to: Date;
}, dayOfWeek: number | number[], dateLib?: DateLib): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\utils\rangeContainsDayOfWeek.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rangeContainsDayOfWeek = rangeContainsDayOfWeek;
const DateLib_js_1 = require("../classes/DateLib.js");
/**
 * Checks if a date range contains one or more specified days of the week.
 *
 * @since 9.2.2
 * @param range - The date range to check.
 * @param dayOfWeek - The day(s) of the week to check for (`0-6`, where `0` is
 *   Sunday).
 * @param dateLib - The date utility library instance.
 * @returns `true` if the range contains the specified day(s) of the week,
 *   otherwise `false`.
 * @group Utilities
 */
function rangeContainsDayOfWeek(range, dayOfWeek, dateLib = DateLib_js_1.defaultDateLib) {
    const dayOfWeekArr = !Array.isArray(dayOfWeek) ? [dayOfWeek] : dayOfWeek;
    let date = range.from;
    const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);
    // iterate at maximum one week or the total days if the range is shorter than one week
    const totalDaysLimit = Math.min(totalDays, 6);
    for (let i = 0; i <= totalDaysLimit; i++) {
        if (dayOfWeekArr.includes(date.getDay())) {
            return true;
        }
        date = dateLib.addDays(date, 1);
    }
    return false;
}

~~~

## node_modules\react-day-picker\dist\cjs\utils\rangeContainsModifiers.d.ts

~~~ts
import { type DateLib } from "../classes/DateLib.js";
import type { Matcher } from "../types/index.js";
/**
 * Checks if a date range contains dates that match the given modifiers.
 *
 * @since 9.2.2
 * @param range - The date range to check.
 * @param modifiers - The modifiers to match against.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the range contains matching dates, otherwise `false`.
 * @group Utilities
 */
export declare function rangeContainsModifiers(range: {
    from: Date;
    to: Date;
}, modifiers: Matcher | Matcher[], dateLib?: DateLib): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\utils\rangeContainsModifiers.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rangeContainsModifiers = rangeContainsModifiers;
const DateLib_js_1 = require("../classes/DateLib.js");
const dateMatchModifiers_js_1 = require("./dateMatchModifiers.js");
const rangeContainsDayOfWeek_js_1 = require("./rangeContainsDayOfWeek.js");
const rangeIncludesDate_js_1 = require("./rangeIncludesDate.js");
const rangeOverlaps_js_1 = require("./rangeOverlaps.js");
const typeguards_js_1 = require("./typeguards.js");
/**
 * Checks if a date range contains dates that match the given modifiers.
 *
 * @since 9.2.2
 * @param range - The date range to check.
 * @param modifiers - The modifiers to match against.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the range contains matching dates, otherwise `false`.
 * @group Utilities
 */
function rangeContainsModifiers(range, modifiers, dateLib = DateLib_js_1.defaultDateLib) {
    const matchers = Array.isArray(modifiers) ? modifiers : [modifiers];
    // Defer function matchers evaluation as they are the least performant.
    const nonFunctionMatchers = matchers.filter((matcher) => typeof matcher !== "function");
    const nonFunctionMatchersResult = nonFunctionMatchers.some((matcher) => {
        if (typeof matcher === "boolean")
            return matcher;
        if (dateLib.isDate(matcher)) {
            return (0, rangeIncludesDate_js_1.rangeIncludesDate)(range, matcher, false, dateLib);
        }
        if ((0, typeguards_js_1.isDatesArray)(matcher, dateLib)) {
            return matcher.some((date) => (0, rangeIncludesDate_js_1.rangeIncludesDate)(range, date, false, dateLib));
        }
        if ((0, typeguards_js_1.isDateRange)(matcher)) {
            if (matcher.from && matcher.to) {
                return (0, rangeOverlaps_js_1.rangeOverlaps)(range, { from: matcher.from, to: matcher.to }, dateLib);
            }
            return false;
        }
        if ((0, typeguards_js_1.isDayOfWeekType)(matcher)) {
            return (0, rangeContainsDayOfWeek_js_1.rangeContainsDayOfWeek)(range, matcher.dayOfWeek, dateLib);
        }
        if ((0, typeguards_js_1.isDateInterval)(matcher)) {
            const isClosedInterval = dateLib.isAfter(matcher.before, matcher.after);
            if (isClosedInterval) {
                return (0, rangeOverlaps_js_1.rangeOverlaps)(range, {
                    from: dateLib.addDays(matcher.after, 1),
                    to: dateLib.addDays(matcher.before, -1),
                }, dateLib);
            }
            return ((0, dateMatchModifiers_js_1.dateMatchModifiers)(range.from, matcher, dateLib) ||
                (0, dateMatchModifiers_js_1.dateMatchModifiers)(range.to, matcher, dateLib));
        }
        if ((0, typeguards_js_1.isDateAfterType)(matcher) || (0, typeguards_js_1.isDateBeforeType)(matcher)) {
            return ((0, dateMatchModifiers_js_1.dateMatchModifiers)(range.from, matcher, dateLib) ||
                (0, dateMatchModifiers_js_1.dateMatchModifiers)(range.to, matcher, dateLib));
        }
        return false;
    });
    if (nonFunctionMatchersResult) {
        return true;
    }
    const functionMatchers = matchers.filter((matcher) => typeof matcher === "function");
    if (functionMatchers.length) {
        let date = range.from;
        const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);
        for (let i = 0; i <= totalDays; i++) {
            if (functionMatchers.some((matcher) => matcher(date))) {
                return true;
            }
            date = dateLib.addDays(date, 1);
        }
    }
    return false;
}

~~~

## node_modules\react-day-picker\dist\cjs\utils\rangeIncludesDate.d.ts

~~~ts
import type { DateRange } from "../types/index.js";
/**
 * Checks if a given date is within a specified date range.
 *
 * @since 9.0.0
 * @param range - The date range to check against.
 * @param date - The date to check.
 * @param excludeEnds - If `true`, the range's start and end dates are excluded.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the date is within the range, otherwise `false`.
 * @group Utilities
 */
export declare function rangeIncludesDate(range: DateRange, date: Date, excludeEnds?: boolean, dateLib?: import("../classes/DateLib.js").DateLib): boolean;
/**
 * @private
 * @deprecated Use {@link rangeIncludesDate} instead.
 */
export declare const isDateInRange: (range: DateRange, date: Date) => boolean;

~~~

## node_modules\react-day-picker\dist\cjs\utils\rangeIncludesDate.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDateInRange = void 0;
exports.rangeIncludesDate = rangeIncludesDate;
const index_js_1 = require("../classes/index.js");
/**
 * Checks if a given date is within a specified date range.
 *
 * @since 9.0.0
 * @param range - The date range to check against.
 * @param date - The date to check.
 * @param excludeEnds - If `true`, the range's start and end dates are excluded.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the date is within the range, otherwise `false`.
 * @group Utilities
 */
function rangeIncludesDate(range, date, excludeEnds = false, dateLib = index_js_1.defaultDateLib) {
    let { from, to } = range;
    const { differenceInCalendarDays, isSameDay } = dateLib;
    if (from && to) {
        const isRangeInverted = differenceInCalendarDays(to, from) < 0;
        if (isRangeInverted) {
            [from, to] = [to, from];
        }
        const isInRange = differenceInCalendarDays(date, from) >= (excludeEnds ? 1 : 0) &&
            differenceInCalendarDays(to, date) >= (excludeEnds ? 1 : 0);
        return isInRange;
    }
    if (!excludeEnds && to) {
        return isSameDay(to, date);
    }
    if (!excludeEnds && from) {
        return isSameDay(from, date);
    }
    return false;
}
/**
 * @private
 * @deprecated Use {@link rangeIncludesDate} instead.
 */
const isDateInRange = (range, date) => rangeIncludesDate(range, date, false, index_js_1.defaultDateLib);
exports.isDateInRange = isDateInRange;

~~~

## node_modules\react-day-picker\dist\cjs\utils\rangeOverlaps.d.ts

~~~ts
/**
 * Determines if two date ranges overlap.
 *
 * @since 9.2.2
 * @param rangeLeft - The first date range.
 * @param rangeRight - The second date range.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the ranges overlap, otherwise `false`.
 * @group Utilities
 */
export declare function rangeOverlaps(rangeLeft: {
    from: Date;
    to: Date;
}, rangeRight: {
    from: Date;
    to: Date;
}, dateLib?: import("../classes/DateLib.js").DateLib): boolean;

~~~

## node_modules\react-day-picker\dist\cjs\utils\rangeOverlaps.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rangeOverlaps = rangeOverlaps;
const index_js_1 = require("../classes/index.js");
const rangeIncludesDate_js_1 = require("./rangeIncludesDate.js");
/**
 * Determines if two date ranges overlap.
 *
 * @since 9.2.2
 * @param rangeLeft - The first date range.
 * @param rangeRight - The second date range.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the ranges overlap, otherwise `false`.
 * @group Utilities
 */
function rangeOverlaps(rangeLeft, rangeRight, dateLib = index_js_1.defaultDateLib) {
    return ((0, rangeIncludesDate_js_1.rangeIncludesDate)(rangeLeft, rangeRight.from, false, dateLib) ||
        (0, rangeIncludesDate_js_1.rangeIncludesDate)(rangeLeft, rangeRight.to, false, dateLib) ||
        (0, rangeIncludesDate_js_1.rangeIncludesDate)(rangeRight, rangeLeft.from, false, dateLib) ||
        (0, rangeIncludesDate_js_1.rangeIncludesDate)(rangeRight, rangeLeft.to, false, dateLib));
}

~~~

## node_modules\react-day-picker\dist\cjs\utils\typeguards.d.ts

~~~ts
import type { DateLib } from "../classes/DateLib.js";
import type { DateAfter, DateBefore, DateInterval, DateRange, DayOfWeek } from "../types/index.js";
/**
 * Checks if the given value is of type {@link DateInterval}.
 *
 * @param matcher - The value to check.
 * @returns `true` if the value is a {@link DateInterval}, otherwise `false`.
 * @group Utilities
 */
export declare function isDateInterval(matcher: unknown): matcher is DateInterval;
/**
 * Checks if the given value is of type {@link DateRange}.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a {@link DateRange}, otherwise `false`.
 * @group Utilities
 */
export declare function isDateRange(value: unknown): value is DateRange;
/**
 * Checks if the given value is of type {@link DateAfter}.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a {@link DateAfter}, otherwise `false`.
 * @group Utilities
 */
export declare function isDateAfterType(value: unknown): value is DateAfter;
/**
 * Checks if the given value is of type {@link DateBefore}.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a {@link DateBefore}, otherwise `false`.
 * @group Utilities
 */
export declare function isDateBeforeType(value: unknown): value is DateBefore;
/**
 * Checks if the given value is of type {@link DayOfWeek}.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a {@link DayOfWeek}, otherwise `false`.
 * @group Utilities
 */
export declare function isDayOfWeekType(value: unknown): value is DayOfWeek;
/**
 * Checks if the given value is an array of valid dates.
 *
 * @private
 * @param value - The value to check.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the value is an array of valid dates, otherwise `false`.
 */
export declare function isDatesArray(value: unknown, dateLib: DateLib): value is Date[];

~~~

## node_modules\react-day-picker\dist\cjs\utils\typeguards.js

~~~js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDateInterval = isDateInterval;
exports.isDateRange = isDateRange;
exports.isDateAfterType = isDateAfterType;
exports.isDateBeforeType = isDateBeforeType;
exports.isDayOfWeekType = isDayOfWeekType;
exports.isDatesArray = isDatesArray;
/**
 * Checks if the given value is of type {@link DateInterval}.
 *
 * @param matcher - The value to check.
 * @returns `true` if the value is a {@link DateInterval}, otherwise `false`.
 * @group Utilities
 */
function isDateInterval(matcher) {
    return Boolean(matcher &&
        typeof matcher === "object" &&
        "before" in matcher &&
        "after" in matcher);
}
/**
 * Checks if the given value is of type {@link DateRange}.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a {@link DateRange}, otherwise `false`.
 * @group Utilities
 */
function isDateRange(value) {
    return Boolean(value && typeof value === "object" && "from" in value);
}
/**
 * Checks if the given value is of type {@link DateAfter}.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a {@link DateAfter}, otherwise `false`.
 * @group Utilities
 */
function isDateAfterType(value) {
    return Boolean(value && typeof value === "object" && "after" in value);
}
/**
 * Checks if the given value is of type {@link DateBefore}.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a {@link DateBefore}, otherwise `false`.
 * @group Utilities
 */
function isDateBeforeType(value) {
    return Boolean(value && typeof value === "object" && "before" in value);
}
/**
 * Checks if the given value is of type {@link DayOfWeek}.
 *
 * @param value - The value to check.
 * @returns `true` if the value is a {@link DayOfWeek}, otherwise `false`.
 * @group Utilities
 */
function isDayOfWeekType(value) {
    return Boolean(value && typeof value === "object" && "dayOfWeek" in value);
}
/**
 * Checks if the given value is an array of valid dates.
 *
 * @private
 * @param value - The value to check.
 * @param dateLib - The date utility library instance.
 * @returns `true` if the value is an array of valid dates, otherwise `false`.
 */
function isDatesArray(value, dateLib) {
    return Array.isArray(value) && value.every(dateLib.isDate);
}

~~~

## node_modules\react-day-picker\dist\esm\buddhist\index.d.ts

~~~ts
import type { Locale } from "date-fns";
import React from "react";
import { DateLib, type DateLibOptions } from "../index.js";
import type { DayPickerProps } from "../types/props.js";
export declare const th: Locale;
export declare const enUS: Locale;
/**
 * Render the Buddhist (Thai) calendar.
 *
 * Months/weeks are Gregorian; displayed year is Buddhist Era (BE = CE + 543).
 * Thai digits are used by default.
 *
 * Defaults:
 *
 * - `locale`: `th`
 * - `dir`: `ltr`
 * - `numerals`: `thai`
 */
export declare function DayPicker(props: DayPickerProps & {
    locale?: Locale;
    dir?: DayPickerProps["dir"];
    numerals?: DayPickerProps["numerals"];
    dateLib?: DayPickerProps["dateLib"];
}): React.JSX.Element;
/** Returns the date library used in the Buddhist calendar. */
export declare const getDateLib: (options?: DateLibOptions) => DateLib;

~~~

## node_modules\react-day-picker\dist\esm\buddhist\index.js

~~~js
import * as locales from "date-fns/locale";
import React from "react";
import { DateLib, DayPicker as DayPickerComponent, } from "../index.js";
import { format as originalBuddhistFormat } from "./lib/format.js";
// Adapter to match DateLib's format signature without using `any`.
const buddhistFormat = (date, formatStr, options) => {
    return originalBuddhistFormat(date, formatStr, options);
};
export const th = locales.th;
export const enUS = locales.enUS;
/**
 * Render the Buddhist (Thai) calendar.
 *
 * Months/weeks are Gregorian; displayed year is Buddhist Era (BE = CE + 543).
 * Thai digits are used by default.
 *
 * Defaults:
 *
 * - `locale`: `th`
 * - `dir`: `ltr`
 * - `numerals`: `thai`
 */
export function DayPicker(props) {
    const dateLib = getDateLib({
        locale: props.locale ?? th,
        weekStartsOn: props.broadcastCalendar ? 1 : props.weekStartsOn,
        firstWeekContainsDate: props.firstWeekContainsDate,
        useAdditionalWeekYearTokens: props.useAdditionalWeekYearTokens,
        useAdditionalDayOfYearTokens: props.useAdditionalDayOfYearTokens,
        timeZone: props.timeZone,
    });
    return (React.createElement(DayPickerComponent, { ...props, locale: props.locale ?? th, numerals: props.numerals ?? "thai", dir: props.dir ?? "ltr", dateLib: dateLib }));
}
/** Returns the date library used in the Buddhist calendar. */
export const getDateLib = (options) => {
    return new DateLib(options, {
        format: buddhistFormat,
    });
};

~~~

## node_modules\react-day-picker\dist\esm\buddhist\lib\format.d.ts

~~~ts
import type { DateLibOptions } from "../../classes/DateLib.js";
/** Format override adding +543 to year tokens for Buddhist Era (BE). */
export declare function format(date: Date, formatStr: string, options?: DateLibOptions): string;

~~~

## node_modules\react-day-picker\dist\esm\buddhist\lib\format.js

~~~js
import { format as dfFormat } from "date-fns";
/** Format override adding +543 to year tokens for Buddhist Era (BE). */
export function format(date, formatStr, options) {
    const beYear = date.getFullYear() + 543;
    switch (formatStr) {
        case "LLLL y":
        case "LLLL yyyy":
            return `${dfFormat(date, "LLLL", options)} ${beYear}`;
        case "LLLL":
            return dfFormat(date, "LLLL", options);
        case "yyyy":
            return String(beYear).padStart(4, "0");
        case "y":
            return String(beYear);
        case "yyyy-MM":
            return `${beYear}-${dfFormat(date, "MM", options)}`;
        case "yyyy-MM-dd":
            return `${beYear}-${dfFormat(date, "MM", options)}-${dfFormat(date, "dd", options)}`;
        case "PPP":
        case "PPPP": {
            const raw = dfFormat(date, formatStr, options);
            return raw.replace(/(.*)(\d{4})(?!.*\d)/, (_m, pre) => `${pre}${beYear}`);
        }
        default:
            return dfFormat(date, formatStr, options);
    }
}

~~~

## node_modules\react-day-picker\dist\esm\classes\CalendarDay.d.ts

~~~ts
import { type DateLib } from "./DateLib.js";
/**
 * Represents a day displayed in the calendar.
 *
 * In DayPicker, a `CalendarDay` is a wrapper around a `Date` object that
 * provides additional information about the day, such as whether it belongs to
 * the displayed month.
 */
export declare class CalendarDay {
    constructor(date: Date, displayMonth: Date, dateLib?: DateLib);
    /**
     * Utility functions for manipulating dates.
     *
     * @private
     */
    readonly dateLib: DateLib;
    /**
     * Indicates whether the day does not belong to the displayed month.
     *
     * If `outside` is `true`, use `displayMonth` to determine the month to which
     * the day belongs.
     */
    readonly outside: boolean;
    /**
     * The month that is currently displayed in the calendar.
     *
     * This property is useful for determining if the day belongs to the same
     * month as the displayed month, especially when `showOutsideDays` is
     * enabled.
     */
    readonly displayMonth: Date;
    /** The date represented by this day. */
    readonly date: Date;
    /**
     * Checks if this day is equal to another `CalendarDay`, considering both the
     * date and the displayed month.
     *
     * @param day The `CalendarDay` to compare with.
     * @returns `true` if the days are equal, otherwise `false`.
     */
    isEqualTo(day: CalendarDay): boolean;
}

~~~

## node_modules\react-day-picker\dist\esm\classes\CalendarDay.js

~~~js
import { defaultDateLib } from "./DateLib.js";
/**
 * Represents a day displayed in the calendar.
 *
 * In DayPicker, a `CalendarDay` is a wrapper around a `Date` object that
 * provides additional information about the day, such as whether it belongs to
 * the displayed month.
 */
export class CalendarDay {
    constructor(date, displayMonth, dateLib = defaultDateLib) {
        this.date = date;
        this.displayMonth = displayMonth;
        this.outside = Boolean(displayMonth && !dateLib.isSameMonth(date, displayMonth));
        this.dateLib = dateLib;
    }
    /**
     * Checks if this day is equal to another `CalendarDay`, considering both the
     * date and the displayed month.
     *
     * @param day The `CalendarDay` to compare with.
     * @returns `true` if the days are equal, otherwise `false`.
     */
    isEqualTo(day) {
        return (this.dateLib.isSameDay(day.date, this.date) &&
            this.dateLib.isSameMonth(day.displayMonth, this.displayMonth));
    }
}

~~~

## node_modules\react-day-picker\dist\esm\classes\CalendarMonth.d.ts

~~~ts
import type { CalendarWeek } from "./CalendarWeek.js";
/**
 * Represents a month in a calendar year.
 *
 * A `CalendarMonth` contains the weeks within the month and the date of the
 * month.
 */
export declare class CalendarMonth {
    constructor(month: Date, weeks: CalendarWeek[]);
    /** The date representing the first day of the month. */
    date: Date;
    /** The weeks that belong to this month. */
    weeks: CalendarWeek[];
}

~~~

## node_modules\react-day-picker\dist\esm\classes\CalendarMonth.js

~~~js
/**
 * Represents a month in a calendar year.
 *
 * A `CalendarMonth` contains the weeks within the month and the date of the
 * month.
 */
export class CalendarMonth {
    constructor(month, weeks) {
        this.date = month;
        this.weeks = weeks;
    }
}

~~~

## node_modules\react-day-picker\dist\esm\classes\CalendarWeek.d.ts

~~~ts
import type { CalendarDay } from "./CalendarDay.js";
/**
 * Represents a week in a calendar month.
 *
 * A `CalendarWeek` contains the days within the week and the week number.
 */
export declare class CalendarWeek {
    constructor(weekNumber: number, days: CalendarDay[]);
    /** The number of the week within the year. */
    weekNumber: number;
    /** The days that belong to this week. */
    days: CalendarDay[];
}

~~~

## node_modules\react-day-picker\dist\esm\classes\CalendarWeek.js

~~~js
/**
 * Represents a week in a calendar month.
 *
 * A `CalendarWeek` contains the days within the week and the week number.
 */
export class CalendarWeek {
    constructor(weekNumber, days) {
        this.days = days;
        this.weekNumber = weekNumber;
    }
}

~~~

## node_modules\react-day-picker\dist\esm\classes\DateLib.d.ts

~~~ts
import type { FormatOptions as DateFnsFormatOptions, EndOfWeekOptions, GetMonthOptions, GetWeekOptions, GetYearOptions, Interval, StartOfWeekOptions } from "date-fns";
import type { Locale } from "date-fns/locale";
import type { Numerals } from "../types/shared.js";
export type { Month as DateFnsMonth } from "date-fns";
export type { Locale } from "date-fns/locale";
/**
 * @ignore
 * @deprecated Use {@link DateLibOptions} instead.
 */
export type FormatOptions = DateLibOptions;
/**
 * @ignore
 * @deprecated Use {@link DateLibOptions} instead.
 */
export type LabelOptions = DateLibOptions;
/** Indicates the preferred ordering of month and year for localized labels. */
export type MonthYearOrder = "month-first" | "year-first";
/**
 * The options for the `DateLib` class.
 *
 * Extends `date-fns` [format](https://date-fns.org/docs/format),
 * [startOfWeek](https://date-fns.org/docs/startOfWeek) and
 * [endOfWeek](https://date-fns.org/docs/endOfWeek) options.
 *
 * @since 9.2.0
 */
export interface DateLibOptions extends DateFnsFormatOptions, StartOfWeekOptions, EndOfWeekOptions {
    /** A constructor for the `Date` object. */
    Date?: typeof Date;
    /** A locale to use for formatting dates. */
    locale?: Locale;
    /**
     * A time zone to use for dates.
     *
     * @since 9.5.0
     */
    timeZone?: string;
    /**
     * The numbering system to use for formatting numbers.
     *
     * @since 9.5.0
     */
    numerals?: Numerals;
}
/**
 * A wrapper class around [date-fns](http://date-fns.org) that provides utility
 * methods for date manipulation and formatting.
 *
 * @since 9.2.0
 * @example
 *   const dateLib = new DateLib({ locale: es });
 *   const newDate = dateLib.addDays(new Date(), 5);
 */
export declare class DateLib {
    /** The options for configuring the date library. */
    readonly options: DateLibOptions;
    /** Overrides for the default date library functions. */
    readonly overrides?: Partial<typeof DateLib.prototype>;
    /**
     * Creates an instance of `DateLib`.
     *
     * @param options Configuration options for the date library.
     * @param overrides Custom overrides for the date library functions.
     */
    constructor(options?: DateLibOptions, overrides?: Partial<typeof DateLib.prototype>);
    /**
     * Generates a mapping of Arabic digits (0-9) to the target numbering system
     * digits.
     *
     * @since 9.5.0
     * @returns A record mapping Arabic digits to the target numerals.
     */
    private getDigitMap;
    /**
     * Replaces Arabic digits in a string with the target numbering system digits.
     *
     * @since 9.5.0
     * @param input The string containing Arabic digits.
     * @returns The string with digits replaced.
     */
    private replaceDigits;
    /**
     * Formats a number using the configured numbering system.
     *
     * @since 9.5.0
     * @param value The number to format.
     * @returns The formatted number as a string.
     */
    formatNumber(value: number | string): string;
    /**
     * Returns the preferred ordering for month and year labels for the current
     * locale.
     */
    getMonthYearOrder(): MonthYearOrder;
    /**
     * Formats the month/year pair respecting locale conventions.
     *
     * @since 9.11.0
     */
    formatMonthYear(date: Date): string;
    private static readonly yearFirstLocales;
    /**
     * Reference to the built-in Date constructor.
     *
     * @deprecated Use `newDate()` or `today()`.
     */
    Date: typeof Date;
    /**
     * Creates a new `Date` object representing today's date.
     *
     * @since 9.5.0
     * @returns A `Date` object for today's date.
     */
    today: () => Date;
    /**
     * Creates a new `Date` object with the specified year, month, and day.
     *
     * @since 9.5.0
     * @param year The year.
     * @param monthIndex The month (0-11).
     * @param date The day of the month.
     * @returns A new `Date` object.
     */
    newDate: (year: number, monthIndex: number, date: number) => Date;
    /**
     * Adds the specified number of days to the given date.
     *
     * @param date The date to add days to.
     * @param amount The number of days to add.
     * @returns The new date with the days added.
     */
    addDays: (date: Date, amount: number) => Date;
    /**
     * Adds the specified number of months to the given date.
     *
     * @param date The date to add months to.
     * @param amount The number of months to add.
     * @returns The new date with the months added.
     */
    addMonths: (date: Date, amount: number) => Date;
    /**
     * Adds the specified number of weeks to the given date.
     *
     * @param date The date to add weeks to.
     * @param amount The number of weeks to add.
     * @returns The new date with the weeks added.
     */
    addWeeks: (date: Date, amount: number) => Date;
    /**
     * Adds the specified number of years to the given date.
     *
     * @param date The date to add years to.
     * @param amount The number of years to add.
     * @returns The new date with the years added.
     */
    addYears: (date: Date, amount: number) => Date;
    /**
     * Returns the number of calendar days between the given dates.
     *
     * @param dateLeft The later date.
     * @param dateRight The earlier date.
     * @returns The number of calendar days between the dates.
     */
    differenceInCalendarDays: (dateLeft: Date, dateRight: Date) => number;
    /**
     * Returns the number of calendar months between the given dates.
     *
     * @param dateLeft The later date.
     * @param dateRight The earlier date.
     * @returns The number of calendar months between the dates.
     */
    differenceInCalendarMonths: (dateLeft: Date, dateRight: Date) => number;
    /**
     * Returns the months between the given dates.
     *
     * @param interval The interval to get the months for.
     */
    eachMonthOfInterval: (interval: Interval) => Date[];
    /**
     * Returns the years between the given dates.
     *
     * @since 9.11.1
     * @param interval The interval to get the years for.
     * @returns The array of years in the interval.
     */
    eachYearOfInterval: (interval: Interval) => Date[];
    /**
     * Returns the end of the broadcast week for the given date.
     *
     * @param date The original date.
     * @returns The end of the broadcast week.
     */
    endOfBroadcastWeek: (date: Date) => Date;
    /**
     * Returns the end of the ISO week for the given date.
     *
     * @param date The original date.
     * @returns The end of the ISO week.
     */
    endOfISOWeek: (date: Date) => Date;
    /**
     * Returns the end of the month for the given date.
     *
     * @param date The original date.
     * @returns The end of the month.
     */
    endOfMonth: (date: Date) => Date;
    /**
     * Returns the end of the week for the given date.
     *
     * @param date The original date.
     * @returns The end of the week.
     */
    endOfWeek: (date: Date, options?: EndOfWeekOptions<Date>) => Date;
    /**
     * Returns the end of the year for the given date.
     *
     * @param date The original date.
     * @returns The end of the year.
     */
    endOfYear: (date: Date) => Date;
    /**
     * Formats the given date using the specified format string.
     *
     * @param date The date to format.
     * @param formatStr The format string.
     * @returns The formatted date string.
     */
    format: (date: Date, formatStr: string, _options?: DateFnsFormatOptions) => string;
    /**
     * Returns the ISO week number for the given date.
     *
     * @param date The date to get the ISO week number for.
     * @returns The ISO week number.
     */
    getISOWeek: (date: Date) => number;
    /**
     * Returns the month of the given date.
     *
     * @param date The date to get the month for.
     * @returns The month.
     */
    getMonth: (date: Date, _options?: GetMonthOptions) => number;
    /**
     * Returns the year of the given date.
     *
     * @param date The date to get the year for.
     * @returns The year.
     */
    getYear: (date: Date, _options?: GetYearOptions) => number;
    /**
     * Returns the local week number for the given date.
     *
     * @param date The date to get the week number for.
     * @returns The week number.
     */
    getWeek: (date: Date, _options?: GetWeekOptions) => number;
    /**
     * Checks if the first date is after the second date.
     *
     * @param date The date to compare.
     * @param dateToCompare The date to compare with.
     * @returns True if the first date is after the second date.
     */
    isAfter: (date: Date, dateToCompare: Date) => boolean;
    /**
     * Checks if the first date is before the second date.
     *
     * @param date The date to compare.
     * @param dateToCompare The date to compare with.
     * @returns True if the first date is before the second date.
     */
    isBefore: (date: Date, dateToCompare: Date) => boolean;
    /**
     * Checks if the given value is a Date object.
     *
     * @param value The value to check.
     * @returns True if the value is a Date object.
     */
    isDate: (value: unknown) => value is Date;
    /**
     * Checks if the given dates are on the same day.
     *
     * @param dateLeft The first date to compare.
     * @param dateRight The second date to compare.
     * @returns True if the dates are on the same day.
     */
    isSameDay: (dateLeft: Date, dateRight: Date) => boolean;
    /**
     * Checks if the given dates are in the same month.
     *
     * @param dateLeft The first date to compare.
     * @param dateRight The second date to compare.
     * @returns True if the dates are in the same month.
     */
    isSameMonth: (dateLeft: Date, dateRight: Date) => boolean;
    /**
     * Checks if the given dates are in the same year.
     *
     * @param dateLeft The first date to compare.
     * @param dateRight The second date to compare.
     * @returns True if the dates are in the same year.
     */
    isSameYear: (dateLeft: Date, dateRight: Date) => boolean;
    /**
     * Returns the latest date in the given array of dates.
     *
     * @param dates The array of dates to compare.
     * @returns The latest date.
     */
    max: (dates: Date[]) => Date;
    /**
     * Returns the earliest date in the given array of dates.
     *
     * @param dates The array of dates to compare.
     * @returns The earliest date.
     */
    min: (dates: Date[]) => Date;
    /**
     * Sets the month of the given date.
     *
     * @param date The date to set the month on.
     * @param month The month to set (0-11).
     * @returns The new date with the month set.
     */
    setMonth: (date: Date, month: number) => Date;
    /**
     * Sets the year of the given date.
     *
     * @param date The date to set the year on.
     * @param year The year to set.
     * @returns The new date with the year set.
     */
    setYear: (date: Date, year: number) => Date;
    /**
     * Returns the start of the broadcast week for the given date.
     *
     * @param date The original date.
     * @returns The start of the broadcast week.
     */
    startOfBroadcastWeek: (date: Date, _dateLib: DateLib) => Date;
    /**
     * Returns the start of the day for the given date.
     *
     * @param date The original date.
     * @returns The start of the day.
     */
    startOfDay: (date: Date) => Date;
    /**
     * Returns the start of the ISO week for the given date.
     *
     * @param date The original date.
     * @returns The start of the ISO week.
     */
    startOfISOWeek: (date: Date) => Date;
    /**
     * Returns the start of the month for the given date.
     *
     * @param date The original date.
     * @returns The start of the month.
     */
    startOfMonth: (date: Date) => Date;
    /**
     * Returns the start of the week for the given date.
     *
     * @param date The original date.
     * @returns The start of the week.
     */
    startOfWeek: (date: Date, _options?: StartOfWeekOptions) => Date;
    /**
     * Returns the start of the year for the given date.
     *
     * @param date The original date.
     * @returns The start of the year.
     */
    startOfYear: (date: Date) => Date;
}
/** The default locale (English). */
export { enUS as defaultLocale } from "date-fns/locale/en-US";
/**
 * The default date library with English locale.
 *
 * @since 9.2.0
 */
export declare const defaultDateLib: DateLib;
/**
 * @ignore
 * @deprecated Use `defaultDateLib`.
 */
export declare const dateLib: DateLib;

~~~

## node_modules\react-day-picker\dist\esm\classes\DateLib.js

~~~js
import { TZDate } from "@date-fns/tz";
import { addDays, addMonths, addWeeks, addYears, differenceInCalendarDays, differenceInCalendarMonths, eachMonthOfInterval, eachYearOfInterval, endOfISOWeek, endOfMonth, endOfWeek, endOfYear, format, getISOWeek, getMonth, getWeek, getYear, isAfter, isBefore, isDate, isSameDay, isSameMonth, isSameYear, max, min, setMonth, setYear, startOfDay, startOfISOWeek, startOfMonth, startOfWeek, startOfYear, } from "date-fns";
import { enUS } from "date-fns/locale/en-US";
import { endOfBroadcastWeek } from "../helpers/endOfBroadcastWeek.js";
import { startOfBroadcastWeek } from "../helpers/startOfBroadcastWeek.js";
/**
 * A wrapper class around [date-fns](http://date-fns.org) that provides utility
 * methods for date manipulation and formatting.
 *
 * @since 9.2.0
 * @example
 *   const dateLib = new DateLib({ locale: es });
 *   const newDate = dateLib.addDays(new Date(), 5);
 */
export class DateLib {
    /**
     * Creates an instance of `DateLib`.
     *
     * @param options Configuration options for the date library.
     * @param overrides Custom overrides for the date library functions.
     */
    constructor(options, overrides) {
        /**
         * Reference to the built-in Date constructor.
         *
         * @deprecated Use `newDate()` or `today()`.
         */
        this.Date = Date;
        /**
         * Creates a new `Date` object representing today's date.
         *
         * @since 9.5.0
         * @returns A `Date` object for today's date.
         */
        this.today = () => {
            if (this.overrides?.today) {
                return this.overrides.today();
            }
            if (this.options.timeZone) {
                return TZDate.tz(this.options.timeZone);
            }
            return new this.Date();
        };
        /**
         * Creates a new `Date` object with the specified year, month, and day.
         *
         * @since 9.5.0
         * @param year The year.
         * @param monthIndex The month (0-11).
         * @param date The day of the month.
         * @returns A new `Date` object.
         */
        this.newDate = (year, monthIndex, date) => {
            if (this.overrides?.newDate) {
                return this.overrides.newDate(year, monthIndex, date);
            }
            if (this.options.timeZone) {
                return new TZDate(year, monthIndex, date, this.options.timeZone);
            }
            return new Date(year, monthIndex, date);
        };
        /**
         * Adds the specified number of days to the given date.
         *
         * @param date The date to add days to.
         * @param amount The number of days to add.
         * @returns The new date with the days added.
         */
        this.addDays = (date, amount) => {
            return this.overrides?.addDays
                ? this.overrides.addDays(date, amount)
                : addDays(date, amount);
        };
        /**
         * Adds the specified number of months to the given date.
         *
         * @param date The date to add months to.
         * @param amount The number of months to add.
         * @returns The new date with the months added.
         */
        this.addMonths = (date, amount) => {
            return this.overrides?.addMonths
                ? this.overrides.addMonths(date, amount)
                : addMonths(date, amount);
        };
        /**
         * Adds the specified number of weeks to the given date.
         *
         * @param date The date to add weeks to.
         * @param amount The number of weeks to add.
         * @returns The new date with the weeks added.
         */
        this.addWeeks = (date, amount) => {
            return this.overrides?.addWeeks
                ? this.overrides.addWeeks(date, amount)
                : addWeeks(date, amount);
        };
        /**
         * Adds the specified number of years to the given date.
         *
         * @param date The date to add years to.
         * @param amount The number of years to add.
         * @returns The new date with the years added.
         */
        this.addYears = (date, amount) => {
            return this.overrides?.addYears
                ? this.overrides.addYears(date, amount)
                : addYears(date, amount);
        };
        /**
         * Returns the number of calendar days between the given dates.
         *
         * @param dateLeft The later date.
         * @param dateRight The earlier date.
         * @returns The number of calendar days between the dates.
         */
        this.differenceInCalendarDays = (dateLeft, dateRight) => {
            return this.overrides?.differenceInCalendarDays
                ? this.overrides.differenceInCalendarDays(dateLeft, dateRight)
                : differenceInCalendarDays(dateLeft, dateRight);
        };
        /**
         * Returns the number of calendar months between the given dates.
         *
         * @param dateLeft The later date.
         * @param dateRight The earlier date.
         * @returns The number of calendar months between the dates.
         */
        this.differenceInCalendarMonths = (dateLeft, dateRight) => {
            return this.overrides?.differenceInCalendarMonths
                ? this.overrides.differenceInCalendarMonths(dateLeft, dateRight)
                : differenceInCalendarMonths(dateLeft, dateRight);
        };
        /**
         * Returns the months between the given dates.
         *
         * @param interval The interval to get the months for.
         */
        this.eachMonthOfInterval = (interval) => {
            return this.overrides?.eachMonthOfInterval
                ? this.overrides.eachMonthOfInterval(interval)
                : eachMonthOfInterval(interval);
        };
        /**
         * Returns the years between the given dates.
         *
         * @since 9.11.1
         * @param interval The interval to get the years for.
         * @returns The array of years in the interval.
         */
        this.eachYearOfInterval = (interval) => {
            const years = this.overrides?.eachYearOfInterval
                ? this.overrides.eachYearOfInterval(interval)
                : eachYearOfInterval(interval);
            // Remove duplicates that may happen across DST transitions (e.g., "America/Sao_Paulo")
            // See https://github.com/date-fns/tz/issues/72
            const uniqueYears = new Set(years.map((d) => this.getYear(d)));
            if (uniqueYears.size === years.length) {
                // No duplicates, return as is
                return years;
            }
            // Rebuild the array to ensure one date per year
            const yearsArray = [];
            uniqueYears.forEach((y) => {
                yearsArray.push(new Date(y, 0, 1));
            });
            return yearsArray;
        };
        /**
         * Returns the end of the broadcast week for the given date.
         *
         * @param date The original date.
         * @returns The end of the broadcast week.
         */
        this.endOfBroadcastWeek = (date) => {
            return this.overrides?.endOfBroadcastWeek
                ? this.overrides.endOfBroadcastWeek(date)
                : endOfBroadcastWeek(date, this);
        };
        /**
         * Returns the end of the ISO week for the given date.
         *
         * @param date The original date.
         * @returns The end of the ISO week.
         */
        this.endOfISOWeek = (date) => {
            return this.overrides?.endOfISOWeek
                ? this.overrides.endOfISOWeek(date)
                : endOfISOWeek(date);
        };
        /**
         * Returns the end of the month for the given date.
         *
         * @param date The original date.
         * @returns The end of the month.
         */
        this.endOfMonth = (date) => {
            return this.overrides?.endOfMonth
                ? this.overrides.endOfMonth(date)
                : endOfMonth(date);
        };
        /**
         * Returns the end of the week for the given date.
         *
         * @param date The original date.
         * @returns The end of the week.
         */
        this.endOfWeek = (date, options) => {
            return this.overrides?.endOfWeek
                ? this.overrides.endOfWeek(date, options)
                : endOfWeek(date, this.options);
        };
        /**
         * Returns the end of the year for the given date.
         *
         * @param date The original date.
         * @returns The end of the year.
         */
        this.endOfYear = (date) => {
            return this.overrides?.endOfYear
                ? this.overrides.endOfYear(date)
                : endOfYear(date);
        };
        /**
         * Formats the given date using the specified format string.
         *
         * @param date The date to format.
         * @param formatStr The format string.
         * @returns The formatted date string.
         */
        this.format = (date, formatStr, _options) => {
            const formatted = this.overrides?.format
                ? this.overrides.format(date, formatStr, this.options)
                : format(date, formatStr, this.options);
            if (this.options.numerals && this.options.numerals !== "latn") {
                return this.replaceDigits(formatted);
            }
            return formatted;
        };
        /**
         * Returns the ISO week number for the given date.
         *
         * @param date The date to get the ISO week number for.
         * @returns The ISO week number.
         */
        this.getISOWeek = (date) => {
            return this.overrides?.getISOWeek
                ? this.overrides.getISOWeek(date)
                : getISOWeek(date);
        };
        /**
         * Returns the month of the given date.
         *
         * @param date The date to get the month for.
         * @returns The month.
         */
        this.getMonth = (date, _options) => {
            return this.overrides?.getMonth
                ? this.overrides.getMonth(date, this.options)
                : getMonth(date, this.options);
        };
        /**
         * Returns the year of the given date.
         *
         * @param date The date to get the year for.
         * @returns The year.
         */
        this.getYear = (date, _options) => {
            return this.overrides?.getYear
                ? this.overrides.getYear(date, this.options)
                : getYear(date, this.options);
        };
        /**
         * Returns the local week number for the given date.
         *
         * @param date The date to get the week number for.
         * @returns The week number.
         */
        this.getWeek = (date, _options) => {
            return this.overrides?.getWeek
                ? this.overrides.getWeek(date, this.options)
                : getWeek(date, this.options);
        };
        /**
         * Checks if the first date is after the second date.
         *
         * @param date The date to compare.
         * @param dateToCompare The date to compare with.
         * @returns True if the first date is after the second date.
         */
        this.isAfter = (date, dateToCompare) => {
            return this.overrides?.isAfter
                ? this.overrides.isAfter(date, dateToCompare)
                : isAfter(date, dateToCompare);
        };
        /**
         * Checks if the first date is before the second date.
         *
         * @param date The date to compare.
         * @param dateToCompare The date to compare with.
         * @returns True if the first date is before the second date.
         */
        this.isBefore = (date, dateToCompare) => {
            return this.overrides?.isBefore
                ? this.overrides.isBefore(date, dateToCompare)
                : isBefore(date, dateToCompare);
        };
        /**
         * Checks if the given value is a Date object.
         *
         * @param value The value to check.
         * @returns True if the value is a Date object.
         */
        this.isDate = (value) => {
            return this.overrides?.isDate
                ? this.overrides.isDate(value)
                : isDate(value);
        };
        /**
         * Checks if the given dates are on the same day.
         *
         * @param dateLeft The first date to compare.
         * @param dateRight The second date to compare.
         * @returns True if the dates are on the same day.
         */
        this.isSameDay = (dateLeft, dateRight) => {
            return this.overrides?.isSameDay
                ? this.overrides.isSameDay(dateLeft, dateRight)
                : isSameDay(dateLeft, dateRight);
        };
        /**
         * Checks if the given dates are in the same month.
         *
         * @param dateLeft The first date to compare.
         * @param dateRight The second date to compare.
         * @returns True if the dates are in the same month.
         */
        this.isSameMonth = (dateLeft, dateRight) => {
            return this.overrides?.isSameMonth
                ? this.overrides.isSameMonth(dateLeft, dateRight)
                : isSameMonth(dateLeft, dateRight);
        };
        /**
         * Checks if the given dates are in the same year.
         *
         * @param dateLeft The first date to compare.
         * @param dateRight The second date to compare.
         * @returns True if the dates are in the same year.
         */
        this.isSameYear = (dateLeft, dateRight) => {
            return this.overrides?.isSameYear
                ? this.overrides.isSameYear(dateLeft, dateRight)
                : isSameYear(dateLeft, dateRight);
        };
        /**
         * Returns the latest date in the given array of dates.
         *
         * @param dates The array of dates to compare.
         * @returns The latest date.
         */
        this.max = (dates) => {
            return this.overrides?.max ? this.overrides.max(dates) : max(dates);
        };
        /**
         * Returns the earliest date in the given array of dates.
         *
         * @param dates The array of dates to compare.
         * @returns The earliest date.
         */
        this.min = (dates) => {
            return this.overrides?.min ? this.overrides.min(dates) : min(dates);
        };
        /**
         * Sets the month of the given date.
         *
         * @param date The date to set the month on.
         * @param month The month to set (0-11).
         * @returns The new date with the month set.
         */
        this.setMonth = (date, month) => {
            return this.overrides?.setMonth
                ? this.overrides.setMonth(date, month)
                : setMonth(date, month);
        };
        /**
         * Sets the year of the given date.
         *
         * @param date The date to set the year on.
         * @param year The year to set.
         * @returns The new date with the year set.
         */
        this.setYear = (date, year) => {
            return this.overrides?.setYear
                ? this.overrides.setYear(date, year)
                : setYear(date, year);
        };
        /**
         * Returns the start of the broadcast week for the given date.
         *
         * @param date The original date.
         * @returns The start of the broadcast week.
         */
        this.startOfBroadcastWeek = (date, _dateLib) => {
            return this.overrides?.startOfBroadcastWeek
                ? this.overrides.startOfBroadcastWeek(date, this)
                : startOfBroadcastWeek(date, this);
        };
        /**
         * Returns the start of the day for the given date.
         *
         * @param date The original date.
         * @returns The start of the day.
         */
        this.startOfDay = (date) => {
            return this.overrides?.startOfDay
                ? this.overrides.startOfDay(date)
                : startOfDay(date);
        };
        /**
         * Returns the start of the ISO week for the given date.
         *
         * @param date The original date.
         * @returns The start of the ISO week.
         */
        this.startOfISOWeek = (date) => {
            return this.overrides?.startOfISOWeek
                ? this.overrides.startOfISOWeek(date)
                : startOfISOWeek(date);
        };
        /**
         * Returns the start of the month for the given date.
         *
         * @param date The original date.
         * @returns The start of the month.
         */
        this.startOfMonth = (date) => {
            return this.overrides?.startOfMonth
                ? this.overrides.startOfMonth(date)
                : startOfMonth(date);
        };
        /**
         * Returns the start of the week for the given date.
         *
         * @param date The original date.
         * @returns The start of the week.
         */
        this.startOfWeek = (date, _options) => {
            return this.overrides?.startOfWeek
                ? this.overrides.startOfWeek(date, this.options)
                : startOfWeek(date, this.options);
        };
        /**
         * Returns the start of the year for the given date.
         *
         * @param date The original date.
         * @returns The start of the year.
         */
        this.startOfYear = (date) => {
            return this.overrides?.startOfYear
                ? this.overrides.startOfYear(date)
                : startOfYear(date);
        };
        this.options = { locale: enUS, ...options };
        this.overrides = overrides;
    }
    /**
     * Generates a mapping of Arabic digits (0-9) to the target numbering system
     * digits.
     *
     * @since 9.5.0
     * @returns A record mapping Arabic digits to the target numerals.
     */
    getDigitMap() {
        const { numerals = "latn" } = this.options;
        // Use Intl.NumberFormat to create a formatter with the specified numbering system
        const formatter = new Intl.NumberFormat("en-US", {
            numberingSystem: numerals,
        });
        // Map Arabic digits (0-9) to the target numerals
        const digitMap = {};
        for (let i = 0; i < 10; i++) {
            digitMap[i.toString()] = formatter.format(i);
        }
        return digitMap;
    }
    /**
     * Replaces Arabic digits in a string with the target numbering system digits.
     *
     * @since 9.5.0
     * @param input The string containing Arabic digits.
     * @returns The string with digits replaced.
     */
    replaceDigits(input) {
        const digitMap = this.getDigitMap();
        return input.replace(/\d/g, (digit) => digitMap[digit] || digit);
    }
    /**
     * Formats a number using the configured numbering system.
     *
     * @since 9.5.0
     * @param value The number to format.
     * @returns The formatted number as a string.
     */
    formatNumber(value) {
        return this.replaceDigits(value.toString());
    }
    /**
     * Returns the preferred ordering for month and year labels for the current
     * locale.
     */
    getMonthYearOrder() {
        const code = this.options.locale?.code;
        if (!code) {
            return "month-first";
        }
        return DateLib.yearFirstLocales.has(code) ? "year-first" : "month-first";
    }
    /**
     * Formats the month/year pair respecting locale conventions.
     *
     * @since 9.11.0
     */
    formatMonthYear(date) {
        const { locale, timeZone, numerals } = this.options;
        const localeCode = locale?.code;
        if (localeCode && DateLib.yearFirstLocales.has(localeCode)) {
            try {
                const intl = new Intl.DateTimeFormat(localeCode, {
                    month: "long",
                    year: "numeric",
                    timeZone,
                    numberingSystem: numerals,
                });
                const formatted = intl.format(date);
                return formatted;
            }
            catch {
                // Fallback to date-fns formatting below.
            }
        }
        const pattern = this.getMonthYearOrder() === "year-first" ? "y LLLL" : "LLLL y";
        return this.format(date, pattern);
    }
}
DateLib.yearFirstLocales = new Set([
    "eu",
    "hu",
    "ja",
    "ja-Hira",
    "ja-JP",
    "ko",
    "ko-KR",
    "lt",
    "lt-LT",
    "lv",
    "lv-LV",
    "mn",
    "mn-MN",
    "zh",
    "zh-CN",
    "zh-HK",
    "zh-TW",
]);
/** The default locale (English). */
export { enUS as defaultLocale } from "date-fns/locale/en-US";
/**
 * The default date library with English locale.
 *
 * @since 9.2.0
 */
export const defaultDateLib = new DateLib();
/**
 * @ignore
 * @deprecated Use `defaultDateLib`.
 */
export const dateLib = defaultDateLib;

~~~

## node_modules\react-day-picker\dist\esm\classes\index.d.ts

~~~ts
export * from "./CalendarDay.js";
export * from "./CalendarMonth.js";
export * from "./CalendarWeek.js";
export * from "./DateLib.js";

~~~

## node_modules\react-day-picker\dist\esm\classes\index.js

~~~js
export * from "./CalendarDay.js";
export * from "./CalendarMonth.js";
export * from "./CalendarWeek.js";
export * from "./DateLib.js";

~~~

## node_modules\react-day-picker\dist\esm\components\Button.d.ts

~~~ts
import React, { type ButtonHTMLAttributes } from "react";
/**
 * Render the button elements in the calendar.
 *
 * @private
 * @deprecated Use `PreviousMonthButton` or `@link NextMonthButton` instead.
 */
export declare function Button(props: ButtonHTMLAttributes<HTMLButtonElement>): React.JSX.Element;
export type ButtonProps = Parameters<typeof Button>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Button.js

~~~js
import React from "react";
/**
 * Render the button elements in the calendar.
 *
 * @private
 * @deprecated Use `PreviousMonthButton` or `@link NextMonthButton` instead.
 */
export function Button(props) {
    return React.createElement("button", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\CaptionLabel.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the label in the month caption.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function CaptionLabel(props: HTMLAttributes<HTMLSpanElement>): React.JSX.Element;
export type CaptionLabelProps = Parameters<typeof CaptionLabel>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\CaptionLabel.js

~~~js
import React from "react";
/**
 * Render the label in the month caption.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function CaptionLabel(props) {
    return React.createElement("span", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Chevron.d.ts

~~~ts
import React from "react";
/**
 * Render the chevron icon used in the navigation buttons and dropdowns.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Chevron(props: {
    className?: string;
    /**
     * The size of the chevron.
     *
     * @defaultValue 24
     */
    size?: number;
    /** Set to `true` to disable the chevron. */
    disabled?: boolean;
    /** The orientation of the chevron. */
    orientation?: "up" | "down" | "left" | "right";
}): React.JSX.Element;
export type ChevronProps = Parameters<typeof Chevron>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Chevron.js

~~~js
import React from "react";
/**
 * Render the chevron icon used in the navigation buttons and dropdowns.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Chevron(props) {
    const { size = 24, orientation = "left", className } = props;
    return (
    // biome-ignore lint/a11y/noSvgWithoutTitle: handled by the parent component
    React.createElement("svg", { className: className, width: size, height: size, viewBox: "0 0 24 24" },
        orientation === "up" && (React.createElement("polygon", { points: "6.77 17 12.5 11.43 18.24 17 20 15.28 12.5 8 5 15.28" })),
        orientation === "down" && (React.createElement("polygon", { points: "6.77 8 12.5 13.57 18.24 8 20 9.72 12.5 17 5 9.72" })),
        orientation === "left" && (React.createElement("polygon", { points: "16 18.112 9.81111111 12 16 5.87733333 14.0888889 4 6 12 14.0888889 20" })),
        orientation === "right" && (React.createElement("polygon", { points: "8 18.112 14.18888889 12 8 5.87733333 9.91111111 4 18 12 9.91111111 20" }))));
}

~~~

## node_modules\react-day-picker\dist\esm\components\custom-components.d.ts

~~~ts
export * from "./Button.js";
export * from "./CaptionLabel.js";
export * from "./Chevron.js";
export * from "./Day.js";
export * from "./DayButton.js";
export * from "./Dropdown.js";
export * from "./DropdownNav.js";
export * from "./Footer.js";
export * from "./Month.js";
export * from "./MonthCaption.js";
export * from "./MonthGrid.js";
export * from "./Months.js";
export * from "./MonthsDropdown.js";
export * from "./Nav.js";
export * from "./NextMonthButton.js";
export * from "./Option.js";
export * from "./PreviousMonthButton.js";
export * from "./Root.js";
export * from "./Select.js";
export * from "./Week.js";
export * from "./Weekday.js";
export * from "./Weekdays.js";
export * from "./WeekNumber.js";
export * from "./WeekNumberHeader.js";
export * from "./Weeks.js";
export * from "./YearsDropdown.js";

~~~

## node_modules\react-day-picker\dist\esm\components\custom-components.js

~~~js
export * from "./Button.js";
export * from "./CaptionLabel.js";
export * from "./Chevron.js";
export * from "./Day.js";
export * from "./DayButton.js";
export * from "./Dropdown.js";
export * from "./DropdownNav.js";
export * from "./Footer.js";
export * from "./Month.js";
export * from "./MonthCaption.js";
export * from "./MonthGrid.js";
export * from "./Months.js";
export * from "./MonthsDropdown.js";
export * from "./Nav.js";
export * from "./NextMonthButton.js";
export * from "./Option.js";
export * from "./PreviousMonthButton.js";
export * from "./Root.js";
export * from "./Select.js";
export * from "./Week.js";
export * from "./Weekday.js";
export * from "./Weekdays.js";
export * from "./WeekNumber.js";
export * from "./WeekNumberHeader.js";
export * from "./Weeks.js";
export * from "./YearsDropdown.js";

~~~

## node_modules\react-day-picker\dist\esm\components\Day.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
import type { CalendarDay } from "../classes/index.js";
import type { Modifiers } from "../types/index.js";
/**
 * Render a grid cell for a specific day in the calendar.
 *
 * Handles interaction and focus for the day. If you only need to change the
 * content of the day cell, consider swapping the `DayButton` component
 * instead.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Day(props: {
    /** The day to render. */
    day: CalendarDay;
    /** The modifiers to apply to the day. */
    modifiers: Modifiers;
} & HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type DayProps = Parameters<typeof Day>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Day.js

~~~js
import React from "react";
/**
 * Render a grid cell for a specific day in the calendar.
 *
 * Handles interaction and focus for the day. If you only need to change the
 * content of the day cell, consider swapping the `DayButton` component
 * instead.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Day(props) {
    const { day, modifiers, ...tdProps } = props;
    return React.createElement("td", { ...tdProps });
}

~~~

## node_modules\react-day-picker\dist\esm\components\DayButton.d.ts

~~~ts
import React, { type ButtonHTMLAttributes } from "react";
import type { CalendarDay } from "../classes/index.js";
import type { Modifiers } from "../types/index.js";
/**
 * Render a button for a specific day in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function DayButton(props: {
    /** The day to render. */
    day: CalendarDay;
    /** The modifiers to apply to the day. */
    modifiers: Modifiers;
} & ButtonHTMLAttributes<HTMLButtonElement>): React.JSX.Element;
export type DayButtonProps = Parameters<typeof DayButton>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\DayButton.js

~~~js
import React from "react";
/**
 * Render a button for a specific day in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function DayButton(props) {
    const { day, modifiers, ...buttonProps } = props;
    const ref = React.useRef(null);
    React.useEffect(() => {
        if (modifiers.focused)
            ref.current?.focus();
    }, [modifiers.focused]);
    return React.createElement("button", { ref: ref, ...buttonProps });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Dropdown.d.ts

~~~ts
import React, { type SelectHTMLAttributes } from "react";
import type { ClassNames, CustomComponents } from "../types/index.js";
/** An option to use in the dropdown. Maps to the `<option>` HTML element. */
export type DropdownOption = {
    /** The value of the option. */
    value: number;
    /** The label of the option. */
    label: string;
    /** Whether the dropdown option is disabled (e.g., out of the calendar range). */
    disabled: boolean;
};
/**
 * Render a dropdown component for navigation in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Dropdown(props: {
    /**
     * @deprecated Use {@link useDayPicker} hook to get the list of internal
     *   components.
     */
    components: CustomComponents;
    /**
     * @deprecated Use {@link useDayPicker} hook to get the list of internal
     *   class names.
     */
    classNames: ClassNames;
    /** The options to display in the dropdown. */
    options?: DropdownOption[] | undefined;
} & Omit<SelectHTMLAttributes<HTMLSelectElement>, "children">): React.JSX.Element;
export type DropdownProps = Parameters<typeof Dropdown>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Dropdown.js

~~~js
import React from "react";
import { UI } from "../UI.js";
/**
 * Render a dropdown component for navigation in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Dropdown(props) {
    const { options, className, components, classNames, ...selectProps } = props;
    const cssClassSelect = [classNames[UI.Dropdown], className].join(" ");
    const selectedOption = options?.find(({ value }) => value === selectProps.value);
    return (React.createElement("span", { "data-disabled": selectProps.disabled, className: classNames[UI.DropdownRoot] },
        React.createElement(components.Select, { className: cssClassSelect, ...selectProps }, options?.map(({ value, label, disabled }) => (React.createElement(components.Option, { key: value, value: value, disabled: disabled }, label)))),
        React.createElement("span", { className: classNames[UI.CaptionLabel], "aria-hidden": true },
            selectedOption?.label,
            React.createElement(components.Chevron, { orientation: "down", size: 18, className: classNames[UI.Chevron] }))));
}

~~~

## node_modules\react-day-picker\dist\esm\components\DropdownNav.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the navigation dropdowns for the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function DropdownNav(props: HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type DropdownNavProps = Parameters<typeof DropdownNav>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\DropdownNav.js

~~~js
import React from "react";
/**
 * Render the navigation dropdowns for the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function DropdownNav(props) {
    return React.createElement("div", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Footer.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the footer of the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Footer(props: HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type FooterProps = Parameters<typeof Footer>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Footer.js

~~~js
import React from "react";
/**
 * Render the footer of the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Footer(props) {
    return React.createElement("div", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Month.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
import type { CalendarMonth } from "../classes/CalendarMonth.js";
/**
 * Render the grid with the weekday header row and the weeks for a specific
 * month.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Month(props: {
    /** The month to display in the grid. */
    calendarMonth: CalendarMonth;
    /** The index of the month being displayed. */
    displayIndex: number;
} & HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type MonthProps = Parameters<typeof Month>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Month.js

~~~js
import React from "react";
/**
 * Render the grid with the weekday header row and the weeks for a specific
 * month.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Month(props) {
    const { calendarMonth, displayIndex, ...divProps } = props;
    return React.createElement("div", { ...divProps }, props.children);
}

~~~

## node_modules\react-day-picker\dist\esm\components\MonthCaption.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
import type { CalendarMonth } from "../classes/index.js";
/**
 * Render the caption for a month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function MonthCaption(props: {
    /** The month to display in the caption. */
    calendarMonth: CalendarMonth;
    /** The index of the month being displayed. */
    displayIndex: number;
} & HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type MonthCaptionProps = Parameters<typeof MonthCaption>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\MonthCaption.js

~~~js
import React from "react";
/**
 * Render the caption for a month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function MonthCaption(props) {
    const { calendarMonth, displayIndex, ...divProps } = props;
    return React.createElement("div", { ...divProps });
}

~~~

## node_modules\react-day-picker\dist\esm\components\MonthGrid.d.ts

~~~ts
import React, { type TableHTMLAttributes } from "react";
/**
 * Render the grid of days for a specific month.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function MonthGrid(props: TableHTMLAttributes<HTMLTableElement>): React.JSX.Element;
export type MonthGridProps = Parameters<typeof MonthGrid>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\MonthGrid.js

~~~js
import React from "react";
/**
 * Render the grid of days for a specific month.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function MonthGrid(props) {
    return React.createElement("table", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Months.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render a container wrapping the month grids.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Months(props: HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type MonthsProps = Parameters<typeof Months>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Months.js

~~~js
import React from "react";
/**
 * Render a container wrapping the month grids.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Months(props) {
    return React.createElement("div", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\MonthsDropdown.d.ts

~~~ts
import React from "react";
import type { DropdownProps } from "./Dropdown.js";
/**
 * Render a dropdown to navigate between months in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function MonthsDropdown(props: DropdownProps): React.JSX.Element;

~~~

## node_modules\react-day-picker\dist\esm\components\MonthsDropdown.js

~~~js
import React from "react";
import { useDayPicker } from "../useDayPicker.js";
/**
 * Render a dropdown to navigate between months in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function MonthsDropdown(props) {
    const { components } = useDayPicker();
    return React.createElement(components.Dropdown, { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Nav.d.ts

~~~ts
import React, { type HTMLAttributes, type MouseEventHandler } from "react";
/**
 * Render the navigation toolbar with buttons to navigate between months.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Nav(props: {
    /** Handler for the previous month button click. */
    onPreviousClick?: MouseEventHandler<HTMLButtonElement>;
    /** Handler for the next month button click. */
    onNextClick?: MouseEventHandler<HTMLButtonElement>;
    /** The date of the previous month, if available. */
    previousMonth?: Date | undefined;
    /** The date of the next month, if available. */
    nextMonth?: Date | undefined;
} & HTMLAttributes<HTMLElement>): React.JSX.Element;
export type NavProps = Parameters<typeof Nav>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Nav.js

~~~js
import React, { useCallback, } from "react";
import { UI } from "../UI.js";
import { useDayPicker } from "../useDayPicker.js";
/**
 * Render the navigation toolbar with buttons to navigate between months.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Nav(props) {
    const { onPreviousClick, onNextClick, previousMonth, nextMonth, ...navProps } = props;
    const { components, classNames, labels: { labelPrevious, labelNext }, } = useDayPicker();
    const handleNextClick = useCallback((e) => {
        if (nextMonth) {
            onNextClick?.(e);
        }
    }, [nextMonth, onNextClick]);
    const handlePreviousClick = useCallback((e) => {
        if (previousMonth) {
            onPreviousClick?.(e);
        }
    }, [previousMonth, onPreviousClick]);
    return (React.createElement("nav", { ...navProps },
        React.createElement(components.PreviousMonthButton, { type: "button", className: classNames[UI.PreviousMonthButton], tabIndex: previousMonth ? undefined : -1, "aria-disabled": previousMonth ? undefined : true, "aria-label": labelPrevious(previousMonth), onClick: handlePreviousClick },
            React.createElement(components.Chevron, { disabled: previousMonth ? undefined : true, className: classNames[UI.Chevron], orientation: "left" })),
        React.createElement(components.NextMonthButton, { type: "button", className: classNames[UI.NextMonthButton], tabIndex: nextMonth ? undefined : -1, "aria-disabled": nextMonth ? undefined : true, "aria-label": labelNext(nextMonth), onClick: handleNextClick },
            React.createElement(components.Chevron, { disabled: nextMonth ? undefined : true, orientation: "right", className: classNames[UI.Chevron] }))));
}

~~~

## node_modules\react-day-picker\dist\esm\components\NextMonthButton.d.ts

~~~ts
import React, { type ButtonHTMLAttributes } from "react";
/**
 * Render the button to navigate to the next month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function NextMonthButton(props: ButtonHTMLAttributes<HTMLButtonElement>): React.JSX.Element;
export type NextMonthButtonProps = Parameters<typeof NextMonthButton>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\NextMonthButton.js

~~~js
import React from "react";
import { useDayPicker } from "../useDayPicker.js";
/**
 * Render the button to navigate to the next month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function NextMonthButton(props) {
    const { components } = useDayPicker();
    return React.createElement(components.Button, { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Option.d.ts

~~~ts
import React, { type OptionHTMLAttributes } from "react";
/**
 * Render an `option` element.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Option(props: OptionHTMLAttributes<HTMLOptionElement>): React.JSX.Element;
export type OptionProps = Parameters<typeof Option>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Option.js

~~~js
import React from "react";
/**
 * Render an `option` element.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Option(props) {
    return React.createElement("option", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\PreviousMonthButton.d.ts

~~~ts
import React, { type ButtonHTMLAttributes } from "react";
/**
 * Render the button to navigate to the previous month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function PreviousMonthButton(props: ButtonHTMLAttributes<HTMLButtonElement>): React.JSX.Element;
export type PreviousMonthButtonProps = Parameters<typeof PreviousMonthButton>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\PreviousMonthButton.js

~~~js
import React from "react";
import { useDayPicker } from "../useDayPicker.js";
/**
 * Render the button to navigate to the previous month in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function PreviousMonthButton(props) {
    const { components } = useDayPicker();
    return React.createElement(components.Button, { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Root.d.ts

~~~ts
import React, { type HTMLAttributes, type Ref } from "react";
/**
 * Render the root element of the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Root(props: {
    /** Ref for the root element, used when `animate` is `true`. */
    rootRef?: Ref<HTMLDivElement>;
} & HTMLAttributes<HTMLDivElement>): React.JSX.Element;
export type RootProps = Parameters<typeof Root>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Root.js

~~~js
import React from "react";
/**
 * Render the root element of the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Root(props) {
    const { rootRef, ...rest } = props;
    return React.createElement("div", { ...rest, ref: rootRef });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Select.d.ts

~~~ts
import React, { type SelectHTMLAttributes } from "react";
/**
 * Render a `select` element.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Select(props: SelectHTMLAttributes<HTMLSelectElement>): React.JSX.Element;
export type SelectProps = Parameters<typeof Select>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Select.js

~~~js
import React from "react";
/**
 * Render a `select` element.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Select(props) {
    return React.createElement("select", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Week.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
import type { CalendarWeek } from "../classes/index.js";
/**
 * Render a table row representing a week in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Week(props: {
    /** The week to render. */
    week: CalendarWeek;
} & HTMLAttributes<HTMLTableRowElement>): React.JSX.Element;
export type WeekProps = Parameters<typeof Week>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Week.js

~~~js
import React from "react";
/**
 * Render a table row representing a week in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Week(props) {
    const { week, ...trProps } = props;
    return React.createElement("tr", { ...trProps });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Weekday.d.ts

~~~ts
import React, { type ThHTMLAttributes } from "react";
/**
 * Render a table header cell with the name of a weekday (e.g., "Mo", "Tu").
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Weekday(props: ThHTMLAttributes<HTMLTableCellElement>): React.JSX.Element;
export type WeekdayProps = Parameters<typeof Weekday>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Weekday.js

~~~js
import React from "react";
/**
 * Render a table header cell with the name of a weekday (e.g., "Mo", "Tu").
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Weekday(props) {
    return React.createElement("th", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Weekdays.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the table row containing the weekday names.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Weekdays(props: HTMLAttributes<HTMLTableRowElement>): React.JSX.Element;
export type WeekdaysProps = Parameters<typeof Weekdays>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Weekdays.js

~~~js
import React from "react";
/**
 * Render the table row containing the weekday names.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Weekdays(props) {
    return (React.createElement("thead", { "aria-hidden": true },
        React.createElement("tr", { ...props })));
}

~~~

## node_modules\react-day-picker\dist\esm\components\WeekNumber.d.ts

~~~ts
import React, { type ThHTMLAttributes } from "react";
import type { CalendarWeek } from "../classes/index.js";
/**
 * Render a table cell displaying the number of the week.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function WeekNumber(props: {
    /** The week to display. */
    week: CalendarWeek;
} & ThHTMLAttributes<HTMLTableCellElement>): React.JSX.Element;
export type WeekNumberProps = Parameters<typeof WeekNumber>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\WeekNumber.js

~~~js
import React from "react";
/**
 * Render a table cell displaying the number of the week.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function WeekNumber(props) {
    const { week, ...thProps } = props;
    return React.createElement("th", { ...thProps });
}

~~~

## node_modules\react-day-picker\dist\esm\components\WeekNumberHeader.d.ts

~~~ts
import React, { type ThHTMLAttributes } from "react";
/**
 * Render the header cell for the week numbers column.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function WeekNumberHeader(props: ThHTMLAttributes<HTMLTableCellElement>): React.JSX.Element;
export type WeekNumberHeaderProps = Parameters<typeof WeekNumberHeader>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\WeekNumberHeader.js

~~~js
import React from "react";
/**
 * Render the header cell for the week numbers column.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function WeekNumberHeader(props) {
    return React.createElement("th", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\Weeks.d.ts

~~~ts
import React, { type HTMLAttributes } from "react";
/**
 * Render the container for the weeks in the month grid.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function Weeks(props: HTMLAttributes<HTMLTableSectionElement>): React.JSX.Element;
export type WeeksProps = Parameters<typeof Weeks>[0];

~~~

## node_modules\react-day-picker\dist\esm\components\Weeks.js

~~~js
import React from "react";
/**
 * Render the container for the weeks in the month grid.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function Weeks(props) {
    return React.createElement("tbody", { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\components\YearsDropdown.d.ts

~~~ts
import React from "react";
import type { DropdownProps } from "./Dropdown.js";
/**
 * Render a dropdown to navigate between years in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export declare function YearsDropdown(props: DropdownProps): React.JSX.Element;

~~~

## node_modules\react-day-picker\dist\esm\components\YearsDropdown.js

~~~js
import React from "react";
import { useDayPicker } from "../useDayPicker.js";
/**
 * Render a dropdown to navigate between years in the calendar.
 *
 * @group Components
 * @see https://daypicker.dev/guides/custom-components
 */
export function YearsDropdown(props) {
    const { components } = useDayPicker();
    return React.createElement(components.Dropdown, { ...props });
}

~~~

## node_modules\react-day-picker\dist\esm\DayPicker.d.ts

~~~ts
import React from "react";
import type { DayPickerProps } from "./types/index.js";
/**
 * Renders the DayPicker calendar component.
 *
 * @param initialProps - The props for the DayPicker component.
 * @returns The rendered DayPicker component.
 * @group DayPicker
 * @see https://daypicker.dev
 */
export declare function DayPicker(initialProps: DayPickerProps): React.JSX.Element;

~~~

## node_modules\react-day-picker\dist\esm\DayPicker.js

~~~js
import { TZDate } from "@date-fns/tz";
import React, { useCallback, useMemo, useRef } from "react";
import { DateLib, defaultLocale } from "./classes/DateLib.js";
import { createGetModifiers } from "./helpers/createGetModifiers.js";
import { getClassNamesForModifiers } from "./helpers/getClassNamesForModifiers.js";
import { getComponents } from "./helpers/getComponents.js";
import { getDataAttributes } from "./helpers/getDataAttributes.js";
import { getDefaultClassNames } from "./helpers/getDefaultClassNames.js";
import { getFormatters } from "./helpers/getFormatters.js";
import { getMonthOptions } from "./helpers/getMonthOptions.js";
import { getStyleForModifiers } from "./helpers/getStyleForModifiers.js";
import { getWeekdays } from "./helpers/getWeekdays.js";
import { getYearOptions } from "./helpers/getYearOptions.js";
import * as defaultLabels from "./labels/index.js";
import { DayFlag, SelectionState, UI } from "./UI.js";
import { useAnimation } from "./useAnimation.js";
import { useCalendar } from "./useCalendar.js";
import { dayPickerContext } from "./useDayPicker.js";
import { useFocus } from "./useFocus.js";
import { useSelection } from "./useSelection.js";
import { rangeIncludesDate } from "./utils/rangeIncludesDate.js";
import { isDateRange } from "./utils/typeguards.js";
/**
 * Renders the DayPicker calendar component.
 *
 * @param initialProps - The props for the DayPicker component.
 * @returns The rendered DayPicker component.
 * @group DayPicker
 * @see https://daypicker.dev
 */
export function DayPicker(initialProps) {
    let props = initialProps;
    if (props.timeZone) {
        props = {
            ...initialProps,
        };
        if (props.today) {
            props.today = new TZDate(props.today, props.timeZone);
        }
        if (props.month) {
            props.month = new TZDate(props.month, props.timeZone);
        }
        if (props.defaultMonth) {
            props.defaultMonth = new TZDate(props.defaultMonth, props.timeZone);
        }
        if (props.startMonth) {
            props.startMonth = new TZDate(props.startMonth, props.timeZone);
        }
        if (props.endMonth) {
            props.endMonth = new TZDate(props.endMonth, props.timeZone);
        }
        if (props.mode === "single" && props.selected) {
            props.selected = new TZDate(props.selected, props.timeZone);
        }
        else if (props.mode === "multiple" && props.selected) {
            props.selected = props.selected?.map((date) => new TZDate(date, props.timeZone));
        }
        else if (props.mode === "range" && props.selected) {
            props.selected = {
                from: props.selected.from
                    ? new TZDate(props.selected.from, props.timeZone)
                    : undefined,
                to: props.selected.to
                    ? new TZDate(props.selected.to, props.timeZone)
                    : undefined,
            };
        }
    }
    const { components, formatters, labels, dateLib, locale, classNames } = useMemo(() => {
        const locale = { ...defaultLocale, ...props.locale };
        const dateLib = new DateLib({
            locale,
            weekStartsOn: props.broadcastCalendar ? 1 : props.weekStartsOn,
            firstWeekContainsDate: props.firstWeekContainsDate,
            useAdditionalWeekYearTokens: props.useAdditionalWeekYearTokens,
            useAdditionalDayOfYearTokens: props.useAdditionalDayOfYearTokens,
            timeZone: props.timeZone,
            numerals: props.numerals,
        }, props.dateLib);
        return {
            dateLib,
            components: getComponents(props.components),
            formatters: getFormatters(props.formatters),
            labels: { ...defaultLabels, ...props.labels },
            locale,
            classNames: { ...getDefaultClassNames(), ...props.classNames },
        };
    }, [
        props.locale,
        props.broadcastCalendar,
        props.weekStartsOn,
        props.firstWeekContainsDate,
        props.useAdditionalWeekYearTokens,
        props.useAdditionalDayOfYearTokens,
        props.timeZone,
        props.numerals,
        props.dateLib,
        props.components,
        props.formatters,
        props.labels,
        props.classNames,
    ]);
    const { captionLayout, mode, navLayout, numberOfMonths = 1, onDayBlur, onDayClick, onDayFocus, onDayKeyDown, onDayMouseEnter, onDayMouseLeave, onNextClick, onPrevClick, showWeekNumber, styles, } = props;
    const { formatCaption, formatDay, formatMonthDropdown, formatWeekNumber, formatWeekNumberHeader, formatWeekdayName, formatYearDropdown, } = formatters;
    const calendar = useCalendar(props, dateLib);
    const { days, months, navStart, navEnd, previousMonth, nextMonth, goToMonth, } = calendar;
    const getModifiers = createGetModifiers(days, props, navStart, navEnd, dateLib);
    const { isSelected, select, selected: selectedValue, } = useSelection(props, dateLib) ?? {};
    const { blur, focused, isFocusTarget, moveFocus, setFocused } = useFocus(props, calendar, getModifiers, isSelected ?? (() => false), dateLib);
    const { labelDayButton, labelGridcell, labelGrid, labelMonthDropdown, labelNav, labelPrevious, labelNext, labelWeekday, labelWeekNumber, labelWeekNumberHeader, labelYearDropdown, } = labels;
    const weekdays = useMemo(() => getWeekdays(dateLib, props.ISOWeek), [dateLib, props.ISOWeek]);
    const isInteractive = mode !== undefined || onDayClick !== undefined;
    const handlePreviousClick = useCallback(() => {
        if (!previousMonth)
            return;
        goToMonth(previousMonth);
        onPrevClick?.(previousMonth);
    }, [previousMonth, goToMonth, onPrevClick]);
    const handleNextClick = useCallback(() => {
        if (!nextMonth)
            return;
        goToMonth(nextMonth);
        onNextClick?.(nextMonth);
    }, [goToMonth, nextMonth, onNextClick]);
    const handleDayClick = useCallback((day, m) => (e) => {
        e.preventDefault();
        e.stopPropagation();
        setFocused(day);
        select?.(day.date, m, e);
        onDayClick?.(day.date, m, e);
    }, [select, onDayClick, setFocused]);
    const handleDayFocus = useCallback((day, m) => (e) => {
        setFocused(day);
        onDayFocus?.(day.date, m, e);
    }, [onDayFocus, setFocused]);
    const handleDayBlur = useCallback((day, m) => (e) => {
        blur();
        onDayBlur?.(day.date, m, e);
    }, [blur, onDayBlur]);
    const handleDayKeyDown = useCallback((day, modifiers) => (e) => {
        const keyMap = {
            ArrowLeft: [
                e.shiftKey ? "month" : "day",
                props.dir === "rtl" ? "after" : "before",
            ],
            ArrowRight: [
                e.shiftKey ? "month" : "day",
                props.dir === "rtl" ? "before" : "after",
            ],
            ArrowDown: [e.shiftKey ? "year" : "week", "after"],
            ArrowUp: [e.shiftKey ? "year" : "week", "before"],
            PageUp: [e.shiftKey ? "year" : "month", "before"],
            PageDown: [e.shiftKey ? "year" : "month", "after"],
            Home: ["startOfWeek", "before"],
            End: ["endOfWeek", "after"],
        };
        if (keyMap[e.key]) {
            e.preventDefault();
            e.stopPropagation();
            const [moveBy, moveDir] = keyMap[e.key];
            moveFocus(moveBy, moveDir);
        }
        onDayKeyDown?.(day.date, modifiers, e);
    }, [moveFocus, onDayKeyDown, props.dir]);
    const handleDayMouseEnter = useCallback((day, modifiers) => (e) => {
        onDayMouseEnter?.(day.date, modifiers, e);
    }, [onDayMouseEnter]);
    const handleDayMouseLeave = useCallback((day, modifiers) => (e) => {
        onDayMouseLeave?.(day.date, modifiers, e);
    }, [onDayMouseLeave]);
    const handleMonthChange = useCallback((date) => (e) => {
        const selectedMonth = Number(e.target.value);
        const month = dateLib.setMonth(dateLib.startOfMonth(date), selectedMonth);
        goToMonth(month);
    }, [dateLib, goToMonth]);
    const handleYearChange = useCallback((date) => (e) => {
        const selectedYear = Number(e.target.value);
        const month = dateLib.setYear(dateLib.startOfMonth(date), selectedYear);
        goToMonth(month);
    }, [dateLib, goToMonth]);
    const { className, style } = useMemo(() => ({
        className: [classNames[UI.Root], props.className]
            .filter(Boolean)
            .join(" "),
        style: { ...styles?.[UI.Root], ...props.style },
    }), [classNames, props.className, props.style, styles]);
    const dataAttributes = getDataAttributes(props);
    const rootElRef = useRef(null);
    useAnimation(rootElRef, Boolean(props.animate), {
        classNames,
        months,
        focused,
        dateLib,
    });
    const contextValue = {
        dayPickerProps: props,
        selected: selectedValue,
        select: select,
        isSelected,
        months,
        nextMonth,
        previousMonth,
        goToMonth,
        getModifiers,
        components,
        classNames,
        styles,
        labels,
        formatters,
    };
    return (React.createElement(dayPickerContext.Provider, { value: contextValue },
        React.createElement(components.Root, { rootRef: props.animate ? rootElRef : undefined, className: className, style: style, dir: props.dir, id: props.id, lang: props.lang, nonce: props.nonce, title: props.title, role: props.role, "aria-label": props["aria-label"], "aria-labelledby": props["aria-labelledby"], ...dataAttributes },
            React.createElement(components.Months, { className: classNames[UI.Months], style: styles?.[UI.Months] },
                !props.hideNavigation && !navLayout && (React.createElement(components.Nav, { "data-animated-nav": props.animate ? "true" : undefined, className: classNames[UI.Nav], style: styles?.[UI.Nav], "aria-label": labelNav(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth: previousMonth, nextMonth: nextMonth })),
                months.map((calendarMonth, displayIndex) => {
                    return (React.createElement(components.Month, { "data-animated-month": props.animate ? "true" : undefined, className: classNames[UI.Month], style: styles?.[UI.Month], 
                        // biome-ignore lint/suspicious/noArrayIndexKey: breaks animation
                        key: displayIndex, displayIndex: displayIndex, calendarMonth: calendarMonth },
                        navLayout === "around" &&
                            !props.hideNavigation &&
                            displayIndex === 0 && (React.createElement(components.PreviousMonthButton, { type: "button", className: classNames[UI.PreviousMonthButton], tabIndex: previousMonth ? undefined : -1, "aria-disabled": previousMonth ? undefined : true, "aria-label": labelPrevious(previousMonth), onClick: handlePreviousClick, "data-animated-button": props.animate ? "true" : undefined },
                            React.createElement(components.Chevron, { disabled: previousMonth ? undefined : true, className: classNames[UI.Chevron], orientation: props.dir === "rtl" ? "right" : "left" }))),
                        React.createElement(components.MonthCaption, { "data-animated-caption": props.animate ? "true" : undefined, className: classNames[UI.MonthCaption], style: styles?.[UI.MonthCaption], calendarMonth: calendarMonth, displayIndex: displayIndex }, captionLayout?.startsWith("dropdown") ? (React.createElement(components.DropdownNav, { className: classNames[UI.Dropdowns], style: styles?.[UI.Dropdowns] },
                            (() => {
                                const monthControl = captionLayout === "dropdown" ||
                                    captionLayout === "dropdown-months" ? (React.createElement(components.MonthsDropdown, { key: "month", className: classNames[UI.MonthsDropdown], "aria-label": labelMonthDropdown(), classNames: classNames, components: components, disabled: Boolean(props.disableNavigation), onChange: handleMonthChange(calendarMonth.date), options: getMonthOptions(calendarMonth.date, navStart, navEnd, formatters, dateLib), style: styles?.[UI.Dropdown], value: dateLib.getMonth(calendarMonth.date) })) : (React.createElement("span", { key: "month" }, formatMonthDropdown(calendarMonth.date, dateLib)));
                                const yearControl = captionLayout === "dropdown" ||
                                    captionLayout === "dropdown-years" ? (React.createElement(components.YearsDropdown, { key: "year", className: classNames[UI.YearsDropdown], "aria-label": labelYearDropdown(dateLib.options), classNames: classNames, components: components, disabled: Boolean(props.disableNavigation), onChange: handleYearChange(calendarMonth.date), options: getYearOptions(navStart, navEnd, formatters, dateLib, Boolean(props.reverseYears)), style: styles?.[UI.Dropdown], value: dateLib.getYear(calendarMonth.date) })) : (React.createElement("span", { key: "year" }, formatYearDropdown(calendarMonth.date, dateLib)));
                                const controls = dateLib.getMonthYearOrder() === "year-first"
                                    ? [yearControl, monthControl]
                                    : [monthControl, yearControl];
                                return controls;
                            })(),
                            React.createElement("span", { role: "status", "aria-live": "polite", style: {
                                    border: 0,
                                    clip: "rect(0 0 0 0)",
                                    height: "1px",
                                    margin: "-1px",
                                    overflow: "hidden",
                                    padding: 0,
                                    position: "absolute",
                                    width: "1px",
                                    whiteSpace: "nowrap",
                                    wordWrap: "normal",
                                } }, formatCaption(calendarMonth.date, dateLib.options, dateLib)))) : (
                        // biome-ignore lint/a11y/useSemanticElements: breaking change
                        React.createElement(components.CaptionLabel, { className: classNames[UI.CaptionLabel], role: "status", "aria-live": "polite" }, formatCaption(calendarMonth.date, dateLib.options, dateLib)))),
                        navLayout === "around" &&
                            !props.hideNavigation &&
                            displayIndex === numberOfMonths - 1 && (React.createElement(components.NextMonthButton, { type: "button", className: classNames[UI.NextMonthButton], tabIndex: nextMonth ? undefined : -1, "aria-disabled": nextMonth ? undefined : true, "aria-label": labelNext(nextMonth), onClick: handleNextClick, "data-animated-button": props.animate ? "true" : undefined },
                            React.createElement(components.Chevron, { disabled: nextMonth ? undefined : true, className: classNames[UI.Chevron], orientation: props.dir === "rtl" ? "left" : "right" }))),
                        displayIndex === numberOfMonths - 1 &&
                            navLayout === "after" &&
                            !props.hideNavigation && (React.createElement(components.Nav, { "data-animated-nav": props.animate ? "true" : undefined, className: classNames[UI.Nav], style: styles?.[UI.Nav], "aria-label": labelNav(), onPreviousClick: handlePreviousClick, onNextClick: handleNextClick, previousMonth: previousMonth, nextMonth: nextMonth })),
                        React.createElement(components.MonthGrid, { role: "grid", "aria-multiselectable": mode === "multiple" || mode === "range", "aria-label": labelGrid(calendarMonth.date, dateLib.options, dateLib) ||
                                undefined, className: classNames[UI.MonthGrid], style: styles?.[UI.MonthGrid] },
                            !props.hideWeekdays && (React.createElement(components.Weekdays, { "data-animated-weekdays": props.animate ? "true" : undefined, className: classNames[UI.Weekdays], style: styles?.[UI.Weekdays] },
                                showWeekNumber && (React.createElement(components.WeekNumberHeader, { "aria-label": labelWeekNumberHeader(dateLib.options), className: classNames[UI.WeekNumberHeader], style: styles?.[UI.WeekNumberHeader], scope: "col" }, formatWeekNumberHeader())),
                                weekdays.map((weekday) => (React.createElement(components.Weekday, { "aria-label": labelWeekday(weekday, dateLib.options, dateLib), className: classNames[UI.Weekday], key: String(weekday), style: styles?.[UI.Weekday], scope: "col" }, formatWeekdayName(weekday, dateLib.options, dateLib)))))),
                            React.createElement(components.Weeks, { "data-animated-weeks": props.animate ? "true" : undefined, className: classNames[UI.Weeks], style: styles?.[UI.Weeks] }, calendarMonth.weeks.map((week) => {
                                return (React.createElement(components.Week, { className: classNames[UI.Week], key: week.weekNumber, style: styles?.[UI.Week], week: week },
                                    showWeekNumber && (
                                    // biome-ignore lint/a11y/useSemanticElements: react component
                                    React.createElement(components.WeekNumber, { week: week, style: styles?.[UI.WeekNumber], "aria-label": labelWeekNumber(week.weekNumber, {
                                            locale,
                                        }), className: classNames[UI.WeekNumber], scope: "row", role: "rowheader" }, formatWeekNumber(week.weekNumber, dateLib))),
                                    week.days.map((day) => {
                                        const { date } = day;
                                        const modifiers = getModifiers(day);
                                        modifiers[DayFlag.focused] =
                                            !modifiers.hidden &&
                                                Boolean(focused?.isEqualTo(day));
                                        modifiers[SelectionState.selected] =
                                            isSelected?.(date) || modifiers.selected;
                                        if (isDateRange(selectedValue)) {
                                            // add range modifiers
                                            const { from, to } = selectedValue;
                                            modifiers[SelectionState.range_start] = Boolean(from && to && dateLib.isSameDay(date, from));
                                            modifiers[SelectionState.range_end] = Boolean(from && to && dateLib.isSameDay(date, to));
                                            modifiers[SelectionState.range_middle] =
                                                rangeIncludesDate(selectedValue, date, true, dateLib);
                                        }
                                        const style = getStyleForModifiers(modifiers, styles, props.modifiersStyles);
                                        const className = getClassNamesForModifiers(modifiers, classNames, props.modifiersClassNames);
                                        const ariaLabel = !isInteractive && !modifiers.hidden
                                            ? labelGridcell(date, modifiers, dateLib.options, dateLib)
                                            : undefined;
                                        return (
                                        // biome-ignore lint/a11y/useSemanticElements: react component
                                        React.createElement(components.Day, { key: `${dateLib.format(date, "yyyy-MM-dd")}_${dateLib.format(day.displayMonth, "yyyy-MM")}`, day: day, modifiers: modifiers, className: className.join(" "), style: style, role: "gridcell", "aria-selected": modifiers.selected || undefined, "aria-label": ariaLabel, "data-day": dateLib.format(date, "yyyy-MM-dd"), "data-month": day.outside
                                                ? dateLib.format(date, "yyyy-MM")
                                                : undefined, "data-selected": modifiers.selected || undefined, "data-disabled": modifiers.disabled || undefined, "data-hidden": modifiers.hidden || undefined, "data-outside": day.outside || undefined, "data-focused": modifiers.focused || undefined, "data-today": modifiers.today || undefined }, !modifiers.hidden && isInteractive ? (React.createElement(components.DayButton, { className: classNames[UI.DayButton], style: styles?.[UI.DayButton], type: "button", day: day, modifiers: modifiers, disabled: modifiers.disabled || undefined, tabIndex: isFocusTarget(day) ? 0 : -1, "aria-label": labelDayButton(date, modifiers, dateLib.options, dateLib), onClick: handleDayClick(day, modifiers), onBlur: handleDayBlur(day, modifiers), onFocus: handleDayFocus(day, modifiers), onKeyDown: handleDayKeyDown(day, modifiers), onMouseEnter: handleDayMouseEnter(day, modifiers), onMouseLeave: handleDayMouseLeave(day, modifiers) }, formatDay(date, dateLib.options, dateLib))) : (!modifiers.hidden &&
                                            formatDay(day.date, dateLib.options, dateLib))));
                                    })));
                            })))));
                })),
            props.footer && (
            // biome-ignore lint/a11y/useSemanticElements: react component
            React.createElement(components.Footer, { className: classNames[UI.Footer], style: styles?.[UI.Footer], role: "status", "aria-live": "polite" }, props.footer)))));
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\index.d.ts

~~~ts
import type { Locale } from "date-fns";
import React from "react";
import { DateLib, type DateLibOptions } from "../index.js";
import type { DayPickerProps } from "../types/props.js";
export { enUS } from "date-fns/locale/en-US";
/**
 * Render the Ethiopic calendar.
 *
 * Defaults:
 *
 * - `locale`: `am-ET` (Amharic) via an Intl-backed date-fns locale
 * - `numerals`: `geez` (Ethiopic digits)
 *
 * Notes:
 *
 * - Weekday names are taken from `Intl.DateTimeFormat(locale.code)`.
 * - Month names are Amharic by default; they switch to Latin transliteration when
 *   `locale.code` starts with `en` or when `numerals` is `latn`.
 * - Time tokens like `hh:mm a` are formatted via `Intl.DateTimeFormat` using the
 *   provided `locale`.
 *
 * @see https://daypicker.dev/docs/localization#ethiopic-calendar
 */
export declare function DayPicker(props: DayPickerProps & {
    /**
     * The locale to use in the calendar.
     *
     * @default `am-ET`
     */
    locale?: Locale;
    /**
     * The numeral system to use when formatting dates.
     *
     * - `latn`: Latin (Western Arabic)
     * - `geez`: Ge'ez (Ethiopic numerals)
     *
     * @defaultValue `geez` (Ethiopic numerals)
     * @see https://daypicker.dev/docs/translation#numeral-systems
     */
    numerals?: DayPickerProps["numerals"];
}): React.JSX.Element;
/** Returns the date library used in the calendar. */
export declare const getDateLib: (options?: DateLibOptions) => DateLib;
export { amET } from "./locale/am-ET.js";

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\index.js

~~~js
import React from "react";
import { DateLib, DayPicker as DayPickerComponent, } from "../index.js";
import * as ethiopicDateLib from "./lib/index.js";
import amET from "./locale/am-ET.js";
export { enUS } from "date-fns/locale/en-US";
/**
 * Render the Ethiopic calendar.
 *
 * Defaults:
 *
 * - `locale`: `am-ET` (Amharic) via an Intl-backed date-fns locale
 * - `numerals`: `geez` (Ethiopic digits)
 *
 * Notes:
 *
 * - Weekday names are taken from `Intl.DateTimeFormat(locale.code)`.
 * - Month names are Amharic by default; they switch to Latin transliteration when
 *   `locale.code` starts with `en` or when `numerals` is `latn`.
 * - Time tokens like `hh:mm a` are formatted via `Intl.DateTimeFormat` using the
 *   provided `locale`.
 *
 * @see https://daypicker.dev/docs/localization#ethiopic-calendar
 */
export function DayPicker(props) {
    return (React.createElement(DayPickerComponent, { ...props, locale: props.locale ?? amET, numerals: props.numerals ?? "geez", 
        // Pass overrides, not a DateLib instance
        dateLib: ethiopicDateLib }));
}
/** Returns the date library used in the calendar. */
export const getDateLib = (options) => {
    return new DateLib(options, ethiopicDateLib);
};
// Export a minimal Amharic (Ethiopia) date-fns locale that uses Intl
export { amET } from "./locale/am-ET.js";

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\addMonths.d.ts

~~~ts
/**
 * Adds the specified number of months to the given Ethiopian date. Handles
 * month overflow and year boundaries correctly.
 *
 * @param date - The starting gregorian date
 * @param amount - The number of months to add (can be negative)
 * @returns A new gregorian date with the months added
 */
export declare function addMonths(date: Date, amount: number): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\addMonths.js

~~~js
import { daysInMonth } from "../utils/daysInMonth.js";
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
/**
 * Adds the specified number of months to the given Ethiopian date. Handles
 * month overflow and year boundaries correctly.
 *
 * @param date - The starting gregorian date
 * @param amount - The number of months to add (can be negative)
 * @returns A new gregorian date with the months added
 */
export function addMonths(date, amount) {
    const { year, month, day } = toEthiopicDate(date);
    let newMonth = month + amount;
    const yearAdjustment = Math.floor((newMonth - 1) / 13);
    newMonth = ((newMonth - 1) % 13) + 1;
    if (newMonth < 1) {
        newMonth += 13;
    }
    const newYear = year + yearAdjustment;
    // Adjust day if it exceeds the month length
    const monthLength = daysInMonth(newMonth, newYear);
    const newDay = Math.min(day, monthLength);
    return toGregorianDate({ year: newYear, month: newMonth, day: newDay });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\addYears.d.ts

~~~ts
/**
 * Adds the specified number of years to the given Ethiopian date. Handles leap
 * year transitions for Pagume month.
 *
 * @param date - The starting gregorian date
 * @param amount - The number of years to add (can be negative)
 * @returns A new gregorian date with the years added
 */
export declare function addYears(date: Date, amount: number): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\addYears.js

~~~js
import { isEthiopicLeapYear, toEthiopicDate, toGregorianDate, } from "../utils/index.js";
/**
 * Adds the specified number of years to the given Ethiopian date. Handles leap
 * year transitions for Pagume month.
 *
 * @param date - The starting gregorian date
 * @param amount - The number of years to add (can be negative)
 * @returns A new gregorian date with the years added
 */
export function addYears(date, amount) {
    const etDate = toEthiopicDate(date);
    const day = isEthiopicLeapYear(etDate.year) &&
        etDate.month === 13 &&
        etDate.day === 6 &&
        amount % 4 !== 0
        ? 5
        : etDate.day;
    return toGregorianDate({
        month: etDate.month,
        day: day,
        year: etDate.year + amount,
    });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\differenceInCalendarMonths.d.ts

~~~ts
/**
 * Difference in calendar months
 *
 * @param {Date} dateLeft - The later date
 * @param {Date} dateRight - The earlier date
 * @returns {number} The number of calendar months between the two dates
 */
export declare function differenceInCalendarMonths(dateLeft: Date, dateRight: Date): number;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\differenceInCalendarMonths.js

~~~js
import { toEthiopicDate } from "../utils/index.js";
/**
 * Difference in calendar months
 *
 * @param {Date} dateLeft - The later date
 * @param {Date} dateRight - The earlier date
 * @returns {number} The number of calendar months between the two dates
 */
export function differenceInCalendarMonths(dateLeft, dateRight) {
    const ethiopicLeft = toEthiopicDate(dateLeft);
    const ethiopicRight = toEthiopicDate(dateRight);
    return ((ethiopicLeft.year - ethiopicRight.year) * 13 +
        (ethiopicLeft.month - ethiopicRight.month));
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\eachMonthOfInterval.d.ts

~~~ts
import type { Interval } from "date-fns";
/**
 * Each month of an interval
 *
 * @param {Object} interval - The interval object
 * @param {Date} interval.start - The start date of the interval
 * @param {Date} interval.end - The end date of the interval
 * @returns {Date[]} An array of dates representing the start of each month in
 *   the interval
 */
export declare function eachMonthOfInterval(interval: Interval): Date[];

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\eachMonthOfInterval.js

~~~js
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
/**
 * Each month of an interval
 *
 * @param {Object} interval - The interval object
 * @param {Date} interval.start - The start date of the interval
 * @param {Date} interval.end - The end date of the interval
 * @returns {Date[]} An array of dates representing the start of each month in
 *   the interval
 */
export function eachMonthOfInterval(interval) {
    const start = toEthiopicDate(new Date(interval.start));
    const end = toEthiopicDate(new Date(interval.end));
    const dates = [];
    let currentYear = start.year;
    let currentMonth = start.month;
    while (currentYear < end.year ||
        (currentYear === end.year && currentMonth <= end.month)) {
        dates.push(toGregorianDate({ year: currentYear, month: currentMonth, day: 1 }));
        currentMonth++;
        if (currentMonth > 13) {
            currentMonth = 1;
            currentYear++;
        }
    }
    return dates;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\eachYearOfInterval.d.ts

~~~ts
import type { Interval } from "date-fns";
/**
 * Returns the start of each Ethiopic year included in the given interval.
 *
 * @param interval The interval whose years should be returned.
 */
export declare function eachYearOfInterval(interval: Interval): Date[];

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\eachYearOfInterval.js

~~~js
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
/**
 * Returns the start of each Ethiopic year included in the given interval.
 *
 * @param interval The interval whose years should be returned.
 */
export function eachYearOfInterval(interval) {
    const start = toEthiopicDate(new Date(interval.start));
    const end = toEthiopicDate(new Date(interval.end));
    if (end.year < start.year) {
        return [];
    }
    const years = [];
    for (let year = start.year; year <= end.year; year += 1) {
        years.push(toGregorianDate({ year, month: 1, day: 1 }));
    }
    return years;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\endOfMonth.d.ts

~~~ts
/**
 * Returns the last day of the Ethiopian month for the given date.
 *
 * @param date - The gregorian date to get the end of month for
 * @returns A new gregorian date representing the last day of the Ethiopian
 *   month
 */
export declare function endOfMonth(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\endOfMonth.js

~~~js
import { daysInMonth } from "../utils/daysInMonth.js";
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
/**
 * Returns the last day of the Ethiopian month for the given date.
 *
 * @param date - The gregorian date to get the end of month for
 * @returns A new gregorian date representing the last day of the Ethiopian
 *   month
 */
export function endOfMonth(date) {
    const { year, month } = toEthiopicDate(date);
    const day = daysInMonth(month, year);
    return toGregorianDate({ year, month, day: day });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\endOfWeek.d.ts

~~~ts
import { type EndOfWeekOptions } from "date-fns";
/**
 * End of week
 *
 * @param {Date} date - The original date
 * @param {EndOfWeekOptions} [options] - The options object
 * @returns {Date} The end of the week
 */
export declare function endOfWeek(date: Date, options?: EndOfWeekOptions): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\endOfWeek.js

~~~js
import { endOfWeek as endOfWeekFns } from "date-fns";
/**
 * End of week
 *
 * @param {Date} date - The original date
 * @param {EndOfWeekOptions} [options] - The options object
 * @returns {Date} The end of the week
 */
export function endOfWeek(date, options) {
    const weekStartsOn = options?.weekStartsOn ?? 0; // Default to Monday (1)
    const endOfWeek = endOfWeekFns(date, { weekStartsOn });
    return endOfWeek;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\endOfYear.d.ts

~~~ts
/**
 * End of year
 *
 * @param {Date} date - The original date
 * @returns {Date} The end of the year
 */
export declare function endOfYear(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\endOfYear.js

~~~js
import { isEthiopicLeapYear, toEthiopicDate, toGregorianDate, } from "../utils/index.js";
/**
 * End of year
 *
 * @param {Date} date - The original date
 * @returns {Date} The end of the year
 */
export function endOfYear(date) {
    const { year } = toEthiopicDate(date);
    const day = isEthiopicLeapYear(year) ? 6 : 5;
    return toGregorianDate({ year, month: 13, day });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\format.d.ts

~~~ts
import type { FormatOptions as DateFnsFormatOptions } from "date-fns";
/** Options for formatting dates in the Ethiopian calendar */
export type FormatOptions = DateFnsFormatOptions;
/**
 * Format an Ethiopic calendar date using a subset of date-fns tokens.
 *
 * Behavior specifics for Ethiopic mode:
 *
 * - Weekday names ("cccc", "cccccc") come from `Intl.DateTimeFormat` using
 *   `options.locale?.code` (default: `am-ET`). Narrow form is a single letter.
 * - Month names ("LLLL") are Amharic by default and switch to Latin
 *   transliteration when the locale code starts with `en` or when
 *   `options.numerals === 'latn'`.
 * - Time parts such as `hh:mm a` are delegated to `Intl.DateTimeFormat` with the
 *   given locale.
 * - Digits are converted to Ethiopic (Geez) when `options.numerals === 'geez'`.
 */
export declare function format(date: Date, formatStr: string, options?: DateFnsFormatOptions): string;
export declare const ethMonths: string[];
export declare const ethMonthsLatin: string[];
export declare const shortDays: string[];
export declare const longDays: string[];

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\format.js

~~~js
import { toEthiopicDate } from "../utils/index.js";
import { formatNumber } from "./formatNumber.js";
function getEtDayName(day, short = true, localeCode = "am-ET") {
    try {
        const dtf = new Intl.DateTimeFormat(localeCode, {
            // Ethiopic calendar expects single-letter for "cccccc" -> use narrow
            weekday: short ? "narrow" : "long",
        });
        return dtf.format(day);
    }
    catch {
        const dayOfWeek = day.getDay();
        return short ? shortDays[dayOfWeek] : longDays[dayOfWeek];
    }
}
function getEtMonthName(m, latin = false) {
    if (m > 0 && m <= 13) {
        return latin ? ethMonthsLatin[m - 1] : ethMonths[m - 1];
    }
    return "";
}
function formatEthiopianDate(dateObj, formatStr, numerals, localeCode) {
    const etDate = dateObj ? toEthiopicDate(dateObj) : undefined;
    if (!etDate)
        return "";
    const useLatin = (localeCode?.startsWith("en") ?? false) || numerals === "latn";
    const yearTokenMatch = formatStr.match(/^(\s*)(y+)(\s*)$/);
    if (yearTokenMatch) {
        const [, leading = "", yearToken, trailing = ""] = yearTokenMatch;
        const year = etDate.year.toString();
        let formattedYear;
        if (yearToken.length === 1) {
            formattedYear = year;
        }
        else if (yearToken.length === 2) {
            formattedYear = year.slice(-2).padStart(2, "0");
        }
        else {
            formattedYear = year.padStart(yearToken.length, "0");
        }
        return `${leading}${formattedYear}${trailing}`;
    }
    switch (formatStr) {
        case "LLLL yyyy":
        case "LLLL y":
            return `${getEtMonthName(etDate.month, useLatin)} ${etDate.year}`;
        case "LLLL":
            return getEtMonthName(etDate.month, useLatin);
        case "yyyy-MM-dd":
            return `${etDate.year}-${etDate.month
                .toString()
                .padStart(2, "0")}-${etDate.day.toString().padStart(2, "0")}`;
        case "yyyy-MM":
            return `${etDate.year}-${etDate.month.toString().padStart(2, "0")}`;
        case "d":
            return etDate.day.toString();
        case "PPP":
            return ` ${getEtMonthName(etDate.month, useLatin)} ${etDate.day}, ${etDate.year}`;
        case "PPPP":
            if (!dateObj)
                return "";
            return `${getEtDayName(dateObj, false, localeCode)}, ${getEtMonthName(etDate.month, useLatin)} ${etDate.day}, ${etDate.year}`;
        case "cccc":
            return dateObj ? getEtDayName(dateObj, false, localeCode) : "";
        case "cccccc":
            return dateObj ? getEtDayName(dateObj, true, localeCode) : "";
        default:
            return `${etDate.day}/${etDate.month}/${etDate.year}`;
    }
}
/**
 * Format an Ethiopic calendar date using a subset of date-fns tokens.
 *
 * Behavior specifics for Ethiopic mode:
 *
 * - Weekday names ("cccc", "cccccc") come from `Intl.DateTimeFormat` using
 *   `options.locale?.code` (default: `am-ET`). Narrow form is a single letter.
 * - Month names ("LLLL") are Amharic by default and switch to Latin
 *   transliteration when the locale code starts with `en` or when
 *   `options.numerals === 'latn'`.
 * - Time parts such as `hh:mm a` are delegated to `Intl.DateTimeFormat` with the
 *   given locale.
 * - Digits are converted to Ethiopic (Geez) when `options.numerals === 'geez'`.
 */
export function format(date, formatStr, options) {
    const extendedOptions = options;
    if (formatStr.includes("hh:mm") || formatStr.includes("a")) {
        return new Intl.DateTimeFormat(extendedOptions?.locale?.code ?? "en-US", {
            hour: "numeric",
            minute: "numeric",
            hour12: formatStr.includes("a"),
        }).format(date);
    }
    const formatted = formatEthiopianDate(date, formatStr, extendedOptions?.numerals, extendedOptions?.locale?.code ?? "am-ET");
    if (extendedOptions?.numerals && extendedOptions.numerals === "geez") {
        return formatted.replace(/\d+/g, (match) => formatNumber(parseInt(match, 10), "geez"));
    }
    return formatted;
}
export const ethMonths = [
    "?섂댌?ⓤ닲??,
    "?α뎲?앩돲",
    "?끷떝??,
    "?녁늼?녁댌",
    "?α댂",
    "?ⓤ뒲?꿍돲",
    "?섂뙅?㏇돲",
    "?싡떕?싡떕",
    "?띮뒘?╇돲",
    "?결뒗",
    "?먤닜??,
    "?먤???,
    "?녁뙃??,
];
export const ethMonthsLatin = [
    "Meskerem",
    "Tikimt",
    "Hidar",
    "Tahsas",
    "Tir",
    "Yekatit",
    "Megabit",
    "Miyazya",
    "Ginbot",
    "Sene",
    "Hamle",
    "Nehase",
    "Pagumen",
];
export const shortDays = ["??, "??, "??, "??, "??, "??, "??];
export const longDays = ["?α늸??, "?결뒢", "?쎺뒴?결뒢", "?ⓤ돘??, "?먤닕??, "?볚댂??, "?끷떝??];

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\formatNumber.d.ts

~~~ts
/**
 * Formats a number using either Latin or Ethiopic (Geez) numerals
 *
 * @example
 *   ```ts
 *   formatNumber(123) // '123'
 *   formatNumber(123, 'geez') // '?삔뜵??
 *   formatNumber(2023, 'geez') // '?녁띀?녁뜪'
 *   ```;
 *
 * @param value - The number to format
 * @param numerals - The numeral system to use:
 *
 *   - 'latn': Latin numerals (1, 2, 3...)
 *   - 'geez': Ethiopic numerals (?? ?? ??..)
 *
 * @returns The formatted number string
 */
export declare function formatNumber(value: number, numerals?: string): string;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\formatNumber.js

~~~js
import { toGeezNumerals } from "../utils/toGeezNumerals.js";
/**
 * Formats a number using either Latin or Ethiopic (Geez) numerals
 *
 * @example
 *   ```ts
 *   formatNumber(123) // '123'
 *   formatNumber(123, 'geez') // '?삔뜵??
 *   formatNumber(2023, 'geez') // '?녁띀?녁뜪'
 *   ```;
 *
 * @param value - The number to format
 * @param numerals - The numeral system to use:
 *
 *   - 'latn': Latin numerals (1, 2, 3...)
 *   - 'geez': Ethiopic numerals (?? ?? ??..)
 *
 * @returns The formatted number string
 */
export function formatNumber(value, numerals = "latn") {
    if (numerals === "geez") {
        return toGeezNumerals(value);
    }
    // Use Intl.NumberFormat for other numeral systems
    const formatter = new Intl.NumberFormat("en-US", {
        numberingSystem: numerals,
    });
    return formatter.format(value);
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\getMonth.d.ts

~~~ts
/**
 * Get month
 *
 * @param {Date} date - The original date
 * @returns {number} The zero-based month index
 */
export declare function getMonth(date: Date): number;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\getMonth.js

~~~js
import { toEthiopicDate } from "../utils/index.js";
/**
 * Get month
 *
 * @param {Date} date - The original date
 * @returns {number} The zero-based month index
 */
export function getMonth(date) {
    const { month } = toEthiopicDate(date);
    return month - 1; // Return zero-based month index
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\getWeek.d.ts

~~~ts
import { type GetWeekOptions } from "date-fns";
/**
 * Get week number for Ethiopian calendar
 *
 * @param {Date} date - The original date
 * @param {GetWeekOptions} [options] - The options object
 * @returns {number} The week number
 */
export declare function getWeek(date: Date, options?: GetWeekOptions): number;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\getWeek.js

~~~js
import { differenceInDays, getWeek as getWeekFns, } from "date-fns";
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
import { startOfWeek } from "./startOfWeek.js";
/**
 * Get week number for Ethiopian calendar
 *
 * @param {Date} date - The original date
 * @param {GetWeekOptions} [options] - The options object
 * @returns {number} The week number
 */
export function getWeek(date, options) {
    const weekStartsOn = options?.weekStartsOn ?? 1; // Default to Monday (1)
    const etDate = toEthiopicDate(date);
    const currentWeekStart = startOfWeek(date, { weekStartsOn });
    // Get the first day of the current year
    const firstDayOfYear = toGregorianDate({
        year: etDate.year,
        month: 1,
        day: 1,
    });
    const firstWeekStart = startOfWeek(firstDayOfYear, { weekStartsOn });
    // If date is before the first week of its year
    if (date < firstWeekStart) {
        return getWeekFns(date, { weekStartsOn, firstWeekContainsDate: 1 });
    }
    // If date falls into the first week of the NEXT Ethiopic year, return 1
    const nextYearFirstDay = toGregorianDate({
        year: etDate.year + 1,
        month: 1,
        day: 1,
    });
    const nextYearFirstWeekStart = startOfWeek(nextYearFirstDay, {
        weekStartsOn,
    });
    if (date >= nextYearFirstWeekStart) {
        return 1;
    }
    // Calculate week number based on days since first week
    const daysSinceFirstWeek = differenceInDays(currentWeekStart, firstWeekStart);
    return Math.floor(daysSinceFirstWeek / 7) + 1;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\getYear.d.ts

~~~ts
/**
 * Get year
 *
 * @param {Date} date - The original date
 * @returns {number} The year
 */
export declare function getYear(date: Date): number;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\getYear.js

~~~js
import { toEthiopicDate } from "../utils/index.js";
/**
 * Get year
 *
 * @param {Date} date - The original date
 * @returns {number} The year
 */
export function getYear(date) {
    const { year } = toEthiopicDate(date);
    return year;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\index.d.ts

~~~ts
export * from "./addMonths.js";
export * from "./addYears.js";
export * from "./differenceInCalendarMonths.js";
export * from "./eachMonthOfInterval.js";
export * from "./eachYearOfInterval.js";
export * from "./endOfMonth.js";
export * from "./endOfWeek.js";
export * from "./endOfYear.js";
export * from "./format.js";
export * from "./formatNumber.js";
export * from "./getMonth.js";
export * from "./getWeek.js";
export * from "./getYear.js";
export * from "./isSameMonth.js";
export * from "./isSameYear.js";
export * from "./newDate.js";
export * from "./setMonth.js";
export * from "./setYear.js";
export * from "./startOfDay.js";
export * from "./startOfMonth.js";
export * from "./startOfWeek.js";
export * from "./startOfYear.js";

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\index.js

~~~js
export * from "./addMonths.js";
export * from "./addYears.js";
export * from "./differenceInCalendarMonths.js";
export * from "./eachMonthOfInterval.js";
export * from "./eachYearOfInterval.js";
export * from "./endOfMonth.js";
export * from "./endOfWeek.js";
export * from "./endOfYear.js";
export * from "./format.js";
export * from "./formatNumber.js";
export * from "./getMonth.js";
export * from "./getWeek.js";
export * from "./getYear.js";
export * from "./isSameMonth.js";
export * from "./isSameYear.js";
export * from "./newDate.js";
export * from "./setMonth.js";
export * from "./setYear.js";
export * from "./startOfDay.js";
export * from "./startOfMonth.js";
export * from "./startOfWeek.js";
export * from "./startOfYear.js";

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\isSameMonth.d.ts

~~~ts
/**
 * Is same month
 *
 * @param {Date} dateLeft - The first date
 * @param {Date} dateRight - The second date
 * @returns {boolean} True if the two dates are in the same month
 */
export declare function isSameMonth(dateLeft: Date, dateRight: Date): boolean;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\isSameMonth.js

~~~js
import { toEthiopicDate } from "../utils/index.js";
/**
 * Is same month
 *
 * @param {Date} dateLeft - The first date
 * @param {Date} dateRight - The second date
 * @returns {boolean} True if the two dates are in the same month
 */
export function isSameMonth(dateLeft, dateRight) {
    const left = toEthiopicDate(dateLeft);
    const right = toEthiopicDate(dateRight);
    return left.year === right.year && left.month === right.month;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\isSameYear.d.ts

~~~ts
/**
 * Checks if two dates fall in the same Ethiopian year.
 *
 * @param dateLeft - The first gregorian date to compare
 * @param dateRight - The second gregorian date to compare
 * @returns True if the dates are in the same Ethiopian year
 */
export declare function isSameYear(dateLeft: Date, dateRight: Date): boolean;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\isSameYear.js

~~~js
import { toEthiopicDate } from "../utils/index.js";
/**
 * Checks if two dates fall in the same Ethiopian year.
 *
 * @param dateLeft - The first gregorian date to compare
 * @param dateRight - The second gregorian date to compare
 * @returns True if the dates are in the same Ethiopian year
 */
export function isSameYear(dateLeft, dateRight) {
    const left = toEthiopicDate(dateLeft);
    const right = toEthiopicDate(dateRight);
    return left.year === right.year;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\newDate.d.ts

~~~ts
/**
 * Creates a new Ethiopic date
 *
 * @param {number} year - The year of the Ethiopic date
 * @param {number} monthIndex - The zero-based month index of the Ethiopic date
 * @param {number} date - The day of the month of the Ethiopic date
 * @returns {Date} The corresponding Gregorian date
 */
export declare function newDate(year: number, monthIndex: number, date: number): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\newDate.js

~~~js
import { toGregorianDate } from "../utils/index.js";
import { isEthiopicDateValid } from "../utils/isEthiopicDateValid.js";
/**
 * Creates a new Ethiopic date
 *
 * @param {number} year - The year of the Ethiopic date
 * @param {number} monthIndex - The zero-based month index of the Ethiopic date
 * @param {number} date - The day of the month of the Ethiopic date
 * @returns {Date} The corresponding Gregorian date
 */
export function newDate(year, monthIndex, date) {
    // Convert from 0-based month index to 1-based Ethiopic month
    const month = monthIndex + 1;
    if (!isEthiopicDateValid({ year, month, day: date })) {
        throw new Error("Invalid Ethiopic date");
    }
    return toGregorianDate({
        year: year,
        month: month,
        day: date,
    });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\setMonth.d.ts

~~~ts
/**
 * Set month
 *
 * @param {Date} date - The original date
 * @param {number} month - The zero-based month index
 * @returns {Date} The new date with the month set
 */
export declare function setMonth(date: Date, month: number): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\setMonth.js

~~~js
import { daysInMonth, toEthiopicDate, toGregorianDate, } from "../utils/index.js";
/**
 * Set month
 *
 * @param {Date} date - The original date
 * @param {number} month - The zero-based month index
 * @returns {Date} The new date with the month set
 */
export function setMonth(date, month) {
    const { year, day } = toEthiopicDate(date);
    const targetMonth = month + 1; // Convert from zero-based index
    const safeDay = Math.min(day, daysInMonth(targetMonth, year));
    return toGregorianDate({ year, month: targetMonth, day: safeDay });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\setYear.d.ts

~~~ts
/**
 * Set year
 *
 * @param {Date} date - The original date
 * @param {number} year - The year to set
 * @returns {Date} The new date with the year set
 */
export declare function setYear(date: Date, year: number): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\setYear.js

~~~js
import { daysInMonth } from "../utils/daysInMonth.js";
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
/**
 * Set year
 *
 * @param {Date} date - The original date
 * @param {number} year - The year to set
 * @returns {Date} The new date with the year set
 */
export function setYear(date, year) {
    const { month, day } = toEthiopicDate(date);
    // Check if the day is valid in the new year (handles leap year changes)
    const maxDays = daysInMonth(month, year);
    const newDay = Math.min(day, maxDays);
    return toGregorianDate({ year, month, day: newDay });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\startOfDay.d.ts

~~~ts
/**
 * Start of day
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the day
 */
export declare function startOfDay(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\startOfDay.js

~~~js
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
/**
 * Start of day
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the day
 */
export function startOfDay(date) {
    const { year, month, day } = toEthiopicDate(date);
    return toGregorianDate({ year, month, day });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\startOfMonth.d.ts

~~~ts
/**
 * Start of month
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the month
 */
export declare function startOfMonth(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\startOfMonth.js

~~~js
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
/**
 * Start of month
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the month
 */
export function startOfMonth(date) {
    const { year, month } = toEthiopicDate(date);
    return toGregorianDate({ year, month, day: 1 });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\startOfWeek.d.ts

~~~ts
import { type StartOfWeekOptions } from "date-fns";
/**
 * Start of week
 *
 * @param {Date} date - The original date
 * @param {StartOfWeekOptions} [options] - The options object
 * @returns {Date} The start of the week
 */
export declare function startOfWeek(date: Date, options?: StartOfWeekOptions): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\startOfWeek.js

~~~js
import { startOfWeek as startOfWeekFns, } from "date-fns";
/**
 * Start of week
 *
 * @param {Date} date - The original date
 * @param {StartOfWeekOptions} [options] - The options object
 * @returns {Date} The start of the week
 */
export function startOfWeek(date, options) {
    const weekStartsOn = options?.weekStartsOn ?? 1; // Default to Monday (1)
    return startOfWeekFns(date, { weekStartsOn: weekStartsOn });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\startOfYear.d.ts

~~~ts
/**
 * Start of year
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the year
 */
export declare function startOfYear(date: Date): Date;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\lib\startOfYear.js

~~~js
import { toEthiopicDate, toGregorianDate } from "../utils/index.js";
/**
 * Start of year
 *
 * @param {Date} date - The original date
 * @returns {Date} The start of the year
 */
export function startOfYear(date) {
    const { year } = toEthiopicDate(date);
    return toGregorianDate({ year, month: 1, day: 1 });
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\locale\am-ET.d.ts

~~~ts
import type { Locale } from "date-fns/locale";
/** Amharic (Ethiopia) locale backed by Intl for core names. */
export declare const amET: Locale;
export default amET;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\locale\am-ET.js

~~~js
import { enUS } from "date-fns/locale/en-US";
/**
 * Minimal Amharic (Ethiopia) locale for date-fns v4.
 *
 * - Uses `Intl.DateTimeFormat('am-ET')` to localize month and weekday names.
 * - Reuses `en-US` implementations for `formatLong`, `formatDistance`,
 *   `formatRelative`, and `match` to keep the footprint small.
 * - Ordinals are returned as plain numeric strings.
 */
// Map date-fns widths to Intl widths
function mapWidth(width) {
    switch (width) {
        case "narrow":
            return "narrow";
        case "short":
        case "abbreviated":
            return "short";
        default:
            return "long";
    }
}
function buildMonthNames(width) {
    const intlWidth = mapWidth(width);
    const fmt = new Intl.DateTimeFormat("am-ET", {
        month: intlWidth,
        timeZone: "UTC",
    });
    const names = [];
    for (let i = 0; i < 12; i++) {
        // Use a fixed UTC date to avoid locale-specific DST artifacts
        names.push(fmt.format(new Date(Date.UTC(2017, i, 1))));
    }
    return names;
}
function buildDayNames(width) {
    const intlWidth = mapWidth(width);
    const fmt = new Intl.DateTimeFormat("am-ET", {
        weekday: intlWidth,
        timeZone: "UTC",
    });
    const names = [];
    // 2017-01-01 was a Sunday; iterate 0..6
    const base = Date.UTC(2017, 0, 1);
    for (let i = 0; i < 7; i++) {
        names.push(fmt.format(new Date(base + i * 24 * 60 * 60 * 1000)));
    }
    return names;
}
function getDayPeriod(value, width) {
    if (value === "am" || value === "pm") {
        const sampleHour = value === "am" ? 1 : 13;
        const parts = new Intl.DateTimeFormat("am-ET", {
            hour: "numeric",
            hour12: true,
            timeZone: "UTC",
        })
            .formatToParts(new Date(Date.UTC(2017, 0, 1, sampleHour)))
            .find((p) => p.type === "dayPeriod");
        if (parts?.value)
            return parts.value;
    }
    // Fallback: delegate to en-US for anything else
    return enUS.localize.dayPeriod(value, { width: width });
}
const localize = {
    ...enUS.localize,
    // Ordinals in Amharic are commonly written as cardinals; keep simple numeric output
    ordinalNumber: (n) => String(n),
    month: (value, options) => {
        const names = buildMonthNames(options?.width);
        // value is 0..11 in date-fns v4
        return names[value];
    },
    day: (value, options) => {
        const names = buildDayNames(options?.width);
        // value is 0..6, where 0 = Sunday
        return names[value];
    },
    dayPeriod: (value, options) => getDayPeriod(value, options?.width),
};
const options = {
    weekStartsOn: 1,
    firstWeekContainsDate: 1,
};
/** Amharic (Ethiopia) locale backed by Intl for core names. */
export const amET = {
    code: "am-ET",
    // Reuse en-US for distance/relative formatting and formatLong skeletons
    formatDistance: enUS.formatDistance,
    formatRelative: enUS.formatRelative,
    formatLong: enUS.formatLong,
    localize,
    match: enUS.match,
    options,
};
export default amET;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\utils\daysInMonth.d.ts

~~~ts
/**
 * Returns the number of days in the specified month of the Ethiopic calendar.
 *
 * In the Ethiopic calendar:
 *
 * - Months 1-12 have 30 days each
 * - Month 13 (Pagume) has 5 days in regular years, 6 days in leap years
 *
 * @param month - The month number (1-13)
 * @param year - The Ethiopic year
 * @returns The number of days in the specified month
 */
export declare function daysInMonth(month: number, year: number): number;

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\utils\daysInMonth.js

~~~js
import { isEthiopicLeapYear } from "./isEthiopicLeapYear.js";
/**
 * Returns the number of days in the specified month of the Ethiopic calendar.
 *
 * In the Ethiopic calendar:
 *
 * - Months 1-12 have 30 days each
 * - Month 13 (Pagume) has 5 days in regular years, 6 days in leap years
 *
 * @param month - The month number (1-13)
 * @param year - The Ethiopic year
 * @returns The number of days in the specified month
 */
export function daysInMonth(month, year) {
    if (month === 13) {
        return isEthiopicLeapYear(year) ? 6 : 5;
    }
    return 30;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\utils\EthiopicDate.d.ts

~~~ts
/**
 * Represents a date in the Ethiopic calendar system.
 *
 * The Ethiopic calendar has:
 *
 * - 13 months
 * - 12 months of 30 days each
 * - A 13th month (Pagume) of 5 or 6 days
 */
export interface EthiopicDate {
    /** The Ethiopic year */
    year: number;
    /** The month number (1-13) */
    month: number;
    /** The day of the month (1-30, or 1-5/6 for month 13) */
    day: number;
}

~~~

## node_modules\react-day-picker\dist\esm\ethiopic\utils\EthiopicDate.js

~~~js
export {};

~~~